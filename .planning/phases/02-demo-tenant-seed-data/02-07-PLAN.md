---
phase: 02-demo-tenant-seed-data
plan: 07
type: execute
wave: 5
depends_on: ["02-05", "02-06"]
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/prisma/migrations/xxx_demo_user_session.sql
  - apps/backend/src/modules/demo/demo-session.service.ts
  - apps/backend/src/modules/demo/demo-reset.service.ts
  - apps/backend/src/modules/demo/demo-reset.controller.ts
  - apps/backend/src/modules/demo/demo.module.ts
  - apps/backend/prisma/reset-demo.ts
  - apps/backend/package.json
autonomous: true

must_haves:
  truths:
    - "Base demo data (3-year history) is marked immutable and never deleted by resets"
    - "Each demo user has an isolated DemoUserSession tracking their changes"
    - "Reset clears only the user's isolated changes, not shared base data"
    - "Reset completes in under 1 minute (under 5 minutes acceptable)"
    - "Confirmation required before reset executes"
    - "24-hour undo window allows restoring cleared changes"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "DemoUserSession and DemoArchivedChange models"
      contains: "DemoUserSession"
    - path: "apps/backend/src/modules/demo/demo-session.service.ts"
      provides: "Session management and copy-on-write tracking"
      min_lines: 100
    - path: "apps/backend/src/modules/demo/demo-reset.service.ts"
      provides: "Reset logic with undo support"
      min_lines: 150
    - path: "apps/backend/src/modules/demo/demo-reset.controller.ts"
      provides: "REST endpoints for reset and undo"
      min_lines: 50
    - path: "apps/backend/package.json"
      provides: "seed:reset and demo:cleanup scripts"
      contains: "seed:reset"
  key_links:
    - from: "apps/backend/src/modules/demo/demo-reset.service.ts"
      to: "DemoUserSession"
      via: "Session-scoped deletion"
      pattern: "demoUserSessionId"
---

<objective>
Implement the hybrid multi-user demo reset system that preserves shared base data while isolating and resetting individual user changes.

Purpose: Multiple sales reps and prospects can demo simultaneously without affecting each other. Resets are fast (under 1 minute) because they only clear user-specific changes, not the entire 3-year dataset. 24-hour undo window provides safety net for accidental resets.

Output: DemoUserSession tracking, copy-on-write isolation pattern, reset endpoint with confirmation, undo capability, and optional scheduled cleanup.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-demo-tenant-seed-data/02-CONTEXT.md
@.planning/phases/02-demo-tenant-seed-data/02-RESEARCH.md
@.planning/phases/02-demo-tenant-seed-data/02-05-PLAN.md (base data structure)
@apps/backend/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DemoUserSession and DemoArchivedChange schema models</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
Add Prisma models for tracking demo user sessions and archiving changes for undo.

**Add these models to schema.prisma:**
```prisma
/// Tracks a demo user's session and their isolated changes
model DemoUserSession {
  id              String   @id @default(uuid())
  organizationId  String
  userId          String

  /// When this session was created
  createdAt       DateTime @default(now())
  /// Last activity in this session
  lastActivityAt  DateTime @default(now())

  /// Foreign keys
  organization    Organization @relation(fields: [organizationId], references: [id])
  user            User         @relation(fields: [userId], references: [id])

  /// User's isolated changes (copy-on-write records)
  cases           Case[]       @relation("DemoSessionCases")
  investigations  Investigation[] @relation("DemoSessionInvestigations")
  rius            RiskIntelligenceUnit[] @relation("DemoSessionRius")

  /// Archived changes for undo
  archivedChanges DemoArchivedChange[]

  @@unique([organizationId, userId])
  @@index([organizationId])
  @@index([userId])
  @@index([lastActivityAt])
}

/// Archives user changes during reset for 24-hour undo window
model DemoArchivedChange {
  id                  String   @id @default(uuid())
  demoUserSessionId   String

  /// The type of entity archived
  entityType          String   // 'Case', 'Investigation', 'RIU', etc.
  /// The original entity ID
  entityId            String
  /// Complete JSON snapshot of the entity
  entityData          Json

  /// When the change was archived (for 24-hour expiry)
  archivedAt          DateTime @default(now())
  /// When this archive expires and can be cleaned up
  expiresAt           DateTime

  /// Whether this has been restored
  restoredAt          DateTime?

  demoUserSession     DemoUserSession @relation(fields: [demoUserSessionId], references: [id], onDelete: Cascade)

  @@index([demoUserSessionId])
  @@index([archivedAt])
  @@index([expiresAt])
  @@index([entityType, entityId])
}
```

**Add to existing Case, Investigation, RIU models:**
```prisma
// Add to Case model
demoUserSessionId   String?
demoUserSession     DemoUserSession? @relation("DemoSessionCases", fields: [demoUserSessionId], references: [id])
isBaseData          Boolean @default(false)  // true = immutable base data

// Add to Investigation model
demoUserSessionId   String?
demoUserSession     DemoUserSession? @relation("DemoSessionInvestigations", fields: [demoUserSessionId], references: [id])
isBaseData          Boolean @default(false)

// Add to RiskIntelligenceUnit model
demoUserSessionId   String?
demoUserSession     DemoUserSession? @relation("DemoSessionRius", fields: [demoUserSessionId], references: [id])
isBaseData          Boolean @default(false)
```

**Key design points:**
- `isBaseData: true` marks records as immutable base data (seeded once, never deleted)
- `demoUserSessionId` links user-created records to their session
- Base data has `demoUserSessionId: null` and `isBaseData: true`
- User changes have `demoUserSessionId: {id}` and `isBaseData: false`
- Reset deletes only records matching user's session ID
  </action>
  <verify>
Run: `cd apps/backend && npx prisma format && npx prisma validate`
  </verify>
  <done>
Schema includes DemoUserSession, DemoArchivedChange, and session linking fields on transactional entities.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create demo session service for tracking user changes</name>
  <files>apps/backend/src/modules/demo/demo-session.service.ts</files>
  <action>
Create service that manages demo user sessions and implements copy-on-write tracking.

**Create demo-session.service.ts:**
```typescript
import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { DemoUserSession } from '@prisma/client';

@Injectable()
export class DemoSessionService {
  private readonly logger = new Logger(DemoSessionService.name);

  constructor(private readonly prisma: PrismaService) {}

  /**
   * Get or create a demo session for a user.
   * Each user has exactly one session per organization.
   */
  async getOrCreateSession(
    organizationId: string,
    userId: string,
  ): Promise<DemoUserSession> {
    const existing = await this.prisma.demoUserSession.findUnique({
      where: {
        organizationId_userId: { organizationId, userId },
      },
    });

    if (existing) {
      // Update last activity
      return this.prisma.demoUserSession.update({
        where: { id: existing.id },
        data: { lastActivityAt: new Date() },
      });
    }

    this.logger.log(`Creating new demo session for user ${userId} in org ${organizationId}`);
    return this.prisma.demoUserSession.create({
      data: {
        organizationId,
        userId,
      },
    });
  }

  /**
   * Get session by ID with counts of user's changes.
   */
  async getSessionWithStats(sessionId: string): Promise<{
    session: DemoUserSession;
    changeCount: {
      cases: number;
      investigations: number;
      rius: number;
    };
  }> {
    const session = await this.prisma.demoUserSession.findUnique({
      where: { id: sessionId },
    });

    if (!session) {
      throw new Error(`Demo session ${sessionId} not found`);
    }

    const [cases, investigations, rius] = await Promise.all([
      this.prisma.case.count({ where: { demoUserSessionId: sessionId } }),
      this.prisma.investigation.count({ where: { demoUserSessionId: sessionId } }),
      this.prisma.riskIntelligenceUnit.count({ where: { demoUserSessionId: sessionId } }),
    ]);

    return {
      session,
      changeCount: { cases, investigations, rius },
    };
  }

  /**
   * Check if a record is base data (immutable) or user-created.
   */
  isBaseData(record: { isBaseData?: boolean; demoUserSessionId?: string | null }): boolean {
    return record.isBaseData === true || record.demoUserSessionId === null;
  }

  /**
   * Get all sessions with stale changes (for optional cleanup).
   * Returns sessions where lastActivityAt is older than the specified days.
   */
  async getStaleSessions(olderThanDays: number = 30): Promise<DemoUserSession[]> {
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - olderThanDays);

    return this.prisma.demoUserSession.findMany({
      where: {
        lastActivityAt: { lt: cutoff },
      },
      orderBy: { lastActivityAt: 'asc' },
    });
  }

  /**
   * Update last activity timestamp for a session.
   */
  async touchSession(sessionId: string): Promise<void> {
    await this.prisma.demoUserSession.update({
      where: { id: sessionId },
      data: { lastActivityAt: new Date() },
    });
  }
}
```

**Key design points:**
- One session per user per organization (upsert pattern)
- Tracks last activity for cleanup scheduling
- Provides stats on user's change count
- Helper to identify base data vs user changes
  </action>
  <verify>
TypeScript check: `cd apps/backend && npx tsc --noEmit`
  </verify>
  <done>
Demo session service manages user sessions with activity tracking and change counting.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create demo reset service with undo support</name>
  <files>apps/backend/src/modules/demo/demo-reset.service.ts</files>
  <action>
Create service that handles reset logic with archiving for 24-hour undo window.

**Create demo-reset.service.ts:**
```typescript
import { Injectable, Logger, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { DemoSessionService } from './demo-session.service';
import chalk from 'chalk';

const UNDO_WINDOW_HOURS = 24;

export interface ResetResult {
  success: boolean;
  deletedCounts: {
    cases: number;
    investigations: number;
    rius: number;
    auditLogs: number;
    messages: number;
  };
  archiveId: string;
  undoExpiresAt: Date;
  durationMs: number;
}

export interface UndoResult {
  success: boolean;
  restoredCounts: {
    cases: number;
    investigations: number;
    rius: number;
  };
}

@Injectable()
export class DemoResetService {
  private readonly logger = new Logger(DemoResetService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly sessionService: DemoSessionService,
  ) {}

  /**
   * Reset a user's demo changes.
   * Archives changes for 24-hour undo window, then deletes.
   * Base data (isBaseData: true) is NEVER touched.
   */
  async resetUserChanges(
    organizationId: string,
    userId: string,
    confirmationToken: string,
  ): Promise<ResetResult> {
    const startTime = Date.now();

    // Validate confirmation token (simple implementation)
    if (confirmationToken !== 'CONFIRM_RESET') {
      throw new BadRequestException(
        'Reset requires confirmation. Pass confirmationToken: "CONFIRM_RESET"'
      );
    }

    const session = await this.sessionService.getOrCreateSession(organizationId, userId);
    const sessionId = session.id;

    this.logger.log(`Starting reset for session ${sessionId} (user ${userId})`);

    // Calculate undo expiry time
    const undoExpiresAt = new Date();
    undoExpiresAt.setHours(undoExpiresAt.getHours() + UNDO_WINDOW_HOURS);

    // Archive user's changes before deletion
    const archiveId = await this.archiveUserChanges(sessionId, undoExpiresAt);

    // Delete user's changes (NOT base data)
    const deletedCounts = await this.deleteUserChanges(sessionId, organizationId);

    const durationMs = Date.now() - startTime;
    this.logger.log(
      `Reset complete in ${durationMs}ms. Deleted: ${JSON.stringify(deletedCounts)}`
    );

    return {
      success: true,
      deletedCounts,
      archiveId,
      undoExpiresAt,
      durationMs,
    };
  }

  /**
   * Archive user's changes to DemoArchivedChange for undo support.
   */
  private async archiveUserChanges(
    sessionId: string,
    expiresAt: Date,
  ): Promise<string> {
    const archiveId = `archive_${sessionId}_${Date.now()}`;

    // Fetch all user changes
    const [cases, investigations, rius] = await Promise.all([
      this.prisma.case.findMany({
        where: { demoUserSessionId: sessionId, isBaseData: false },
        include: { messages: true, subjects: true },
      }),
      this.prisma.investigation.findMany({
        where: { demoUserSessionId: sessionId, isBaseData: false },
        include: { notes: true, interviews: true },
      }),
      this.prisma.riskIntelligenceUnit.findMany({
        where: { demoUserSessionId: sessionId, isBaseData: false },
      }),
    ]);

    // Create archive records
    const archiveRecords = [
      ...cases.map((c) => ({
        demoUserSessionId: sessionId,
        entityType: 'Case',
        entityId: c.id,
        entityData: c as any,
        expiresAt,
      })),
      ...investigations.map((i) => ({
        demoUserSessionId: sessionId,
        entityType: 'Investigation',
        entityId: i.id,
        entityData: i as any,
        expiresAt,
      })),
      ...rius.map((r) => ({
        demoUserSessionId: sessionId,
        entityType: 'RIU',
        entityId: r.id,
        entityData: r as any,
        expiresAt,
      })),
    ];

    if (archiveRecords.length > 0) {
      await this.prisma.demoArchivedChange.createMany({
        data: archiveRecords,
      });
    }

    this.logger.log(`Archived ${archiveRecords.length} records for undo`);
    return archiveId;
  }

  /**
   * Delete user's changes (session-scoped only, never base data).
   */
  private async deleteUserChanges(
    sessionId: string,
    organizationId: string,
  ): Promise<ResetResult['deletedCounts']> {
    // Delete in FK-safe order (children first)
    const results = await this.prisma.$transaction([
      // Audit logs linked to user-created entities
      this.prisma.auditLog.deleteMany({
        where: {
          organizationId,
          OR: [
            { entityType: 'Case', entityId: { in: await this.getUserCaseIds(sessionId) } },
            { entityType: 'Investigation', entityId: { in: await this.getUserInvestigationIds(sessionId) } },
            { entityType: 'RIU', entityId: { in: await this.getUserRiuIds(sessionId) } },
          ],
        },
      }),
      // Messages on user-created cases
      this.prisma.caseMessage.deleteMany({
        where: { case: { demoUserSessionId: sessionId } },
      }),
      // Investigation children
      this.prisma.investigationNote.deleteMany({
        where: { investigation: { demoUserSessionId: sessionId } },
      }),
      this.prisma.interview.deleteMany({
        where: { investigation: { demoUserSessionId: sessionId } },
      }),
      // Subjects on user cases
      this.prisma.subject.deleteMany({
        where: { case: { demoUserSessionId: sessionId } },
      }),
      // Investigations
      this.prisma.investigation.deleteMany({
        where: { demoUserSessionId: sessionId, isBaseData: false },
      }),
      // RIU-Case associations for user RIUs
      this.prisma.riuCaseAssociation.deleteMany({
        where: { riu: { demoUserSessionId: sessionId } },
      }),
      // Cases
      this.prisma.case.deleteMany({
        where: { demoUserSessionId: sessionId, isBaseData: false },
      }),
      // RIUs
      this.prisma.riskIntelligenceUnit.deleteMany({
        where: { demoUserSessionId: sessionId, isBaseData: false },
      }),
    ]);

    return {
      auditLogs: results[0].count,
      messages: results[1].count,
      investigations: results[5].count,
      cases: results[7].count,
      rius: results[8].count,
    };
  }

  /**
   * Helper to get user's case IDs for audit log deletion.
   */
  private async getUserCaseIds(sessionId: string): Promise<string[]> {
    const cases = await this.prisma.case.findMany({
      where: { demoUserSessionId: sessionId },
      select: { id: true },
    });
    return cases.map((c) => c.id);
  }

  private async getUserInvestigationIds(sessionId: string): Promise<string[]> {
    const investigations = await this.prisma.investigation.findMany({
      where: { demoUserSessionId: sessionId },
      select: { id: true },
    });
    return investigations.map((i) => i.id);
  }

  private async getUserRiuIds(sessionId: string): Promise<string[]> {
    const rius = await this.prisma.riskIntelligenceUnit.findMany({
      where: { demoUserSessionId: sessionId },
      select: { id: true },
    });
    return rius.map((r) => r.id);
  }

  /**
   * Undo a recent reset (within 24-hour window).
   */
  async undoReset(
    organizationId: string,
    userId: string,
  ): Promise<UndoResult> {
    const session = await this.sessionService.getOrCreateSession(organizationId, userId);

    // Get archived changes that haven't expired or been restored
    const archived = await this.prisma.demoArchivedChange.findMany({
      where: {
        demoUserSessionId: session.id,
        expiresAt: { gt: new Date() },
        restoredAt: null,
      },
      orderBy: { archivedAt: 'desc' },
    });

    if (archived.length === 0) {
      throw new BadRequestException(
        'No changes available to restore. Undo window may have expired.'
      );
    }

    // Restore entities from archive
    const restoredCounts = { cases: 0, investigations: 0, rius: 0 };

    for (const archive of archived) {
      const data = archive.entityData as any;

      switch (archive.entityType) {
        case 'Case':
          // Restore case (simplified - full implementation would handle relations)
          await this.prisma.case.create({ data: this.cleanForRestore(data) });
          restoredCounts.cases++;
          break;
        case 'Investigation':
          await this.prisma.investigation.create({ data: this.cleanForRestore(data) });
          restoredCounts.investigations++;
          break;
        case 'RIU':
          await this.prisma.riskIntelligenceUnit.create({ data: this.cleanForRestore(data) });
          restoredCounts.rius++;
          break;
      }

      // Mark as restored
      await this.prisma.demoArchivedChange.update({
        where: { id: archive.id },
        data: { restoredAt: new Date() },
      });
    }

    this.logger.log(`Restored ${archived.length} entities from archive`);

    return {
      success: true,
      restoredCounts,
    };
  }

  /**
   * Clean entity data for restoration (remove relations, etc.).
   */
  private cleanForRestore(data: any): any {
    const { messages, subjects, notes, interviews, ...clean } = data;
    return clean;
  }

  /**
   * Cleanup expired archives (called by scheduled job).
   */
  async cleanupExpiredArchives(): Promise<number> {
    const result = await this.prisma.demoArchivedChange.deleteMany({
      where: {
        expiresAt: { lt: new Date() },
      },
    });

    this.logger.log(`Cleaned up ${result.count} expired archive records`);
    return result.count;
  }

  /**
   * Cleanup stale sessions (optional, for sessions inactive > 30 days).
   */
  async cleanupStaleSessions(olderThanDays: number = 30): Promise<number> {
    const staleSessions = await this.sessionService.getStaleSessions(olderThanDays);

    for (const session of staleSessions) {
      // Delete session's changes first
      await this.deleteUserChanges(session.id, session.organizationId);
      // Then delete the session
      await this.prisma.demoUserSession.delete({ where: { id: session.id } });
    }

    this.logger.log(`Cleaned up ${staleSessions.length} stale sessions`);
    return staleSessions.length;
  }
}
```

**Key design points:**
- `isBaseData: false` filter ensures base data is NEVER deleted
- Archives changes before deletion for 24-hour undo
- Confirmation token required to prevent accidental resets
- Deletes in FK-safe order (children before parents)
- Cleanup methods for expired archives and stale sessions
  </action>
  <verify>
TypeScript check: `cd apps/backend && npx tsc --noEmit`
  </verify>
  <done>
Demo reset service handles session-scoped deletion with archiving and undo support.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create demo reset controller with confirmation endpoint</name>
  <files>apps/backend/src/modules/demo/demo-reset.controller.ts</files>
  <action>
Create REST endpoints for reset and undo operations.

**Create demo-reset.controller.ts:**
```typescript
import {
  Controller,
  Post,
  Get,
  Body,
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { TenantGuard } from '../auth/guards/tenant.guard';
import { CurrentUser } from '../auth/decorators/current-user.decorator';
import { TenantId } from '../auth/decorators/tenant-id.decorator';
import { DemoResetService, ResetResult, UndoResult } from './demo-reset.service';
import { DemoSessionService } from './demo-session.service';
import { User } from '@prisma/client';

class ResetDemoDto {
  confirmationToken: string;
}

@Controller('api/v1/demo')
@UseGuards(JwtAuthGuard, TenantGuard)
export class DemoResetController {
  constructor(
    private readonly resetService: DemoResetService,
    private readonly sessionService: DemoSessionService,
  ) {}

  /**
   * Get current user's demo session stats.
   * Shows how many changes would be cleared by reset.
   */
  @Get('session')
  async getSessionStats(
    @CurrentUser() user: User,
    @TenantId() orgId: string,
  ) {
    const session = await this.sessionService.getOrCreateSession(orgId, user.id);
    const stats = await this.sessionService.getSessionWithStats(session.id);

    return {
      sessionId: session.id,
      createdAt: session.createdAt,
      lastActivityAt: session.lastActivityAt,
      changes: stats.changeCount,
      totalChanges:
        stats.changeCount.cases +
        stats.changeCount.investigations +
        stats.changeCount.rius,
    };
  }

  /**
   * Reset user's demo changes.
   * Requires confirmation token to prevent accidental resets.
   *
   * POST /api/v1/demo/reset
   * Body: { "confirmationToken": "CONFIRM_RESET" }
   */
  @Post('reset')
  @HttpCode(HttpStatus.OK)
  async resetDemo(
    @CurrentUser() user: User,
    @TenantId() orgId: string,
    @Body() dto: ResetDemoDto,
  ): Promise<ResetResult> {
    return this.resetService.resetUserChanges(
      orgId,
      user.id,
      dto.confirmationToken,
    );
  }

  /**
   * Undo a recent reset (within 24-hour window).
   *
   * POST /api/v1/demo/undo
   */
  @Post('undo')
  @HttpCode(HttpStatus.OK)
  async undoReset(
    @CurrentUser() user: User,
    @TenantId() orgId: string,
  ): Promise<UndoResult> {
    return this.resetService.undoReset(orgId, user.id);
  }

  /**
   * Preview what would be deleted by a reset.
   * Same as session stats but explicitly for reset preview.
   */
  @Get('reset/preview')
  async previewReset(
    @CurrentUser() user: User,
    @TenantId() orgId: string,
  ) {
    const session = await this.sessionService.getOrCreateSession(orgId, user.id);
    const stats = await this.sessionService.getSessionWithStats(session.id);

    return {
      message: 'Reset will delete the following user-created items:',
      willDelete: stats.changeCount,
      totalItems:
        stats.changeCount.cases +
        stats.changeCount.investigations +
        stats.changeCount.rius,
      baseDataPreserved: true,
      undoAvailable: true,
      undoWindowHours: 24,
      confirmationRequired: true,
      confirmationToken: 'CONFIRM_RESET',
    };
  }
}
```

**Endpoints:**
- `GET /api/v1/demo/session` - Get session stats
- `GET /api/v1/demo/reset/preview` - Preview what reset will delete
- `POST /api/v1/demo/reset` - Execute reset (requires confirmation)
- `POST /api/v1/demo/undo` - Undo recent reset
  </action>
  <verify>
TypeScript check: `cd apps/backend && npx tsc --noEmit`
  </verify>
  <done>
Demo reset controller exposes REST endpoints with confirmation requirement.
  </done>
</task>

<task type="auto">
  <name>Task 5: Create demo module</name>
  <files>apps/backend/src/modules/demo/demo.module.ts</files>
  <action>
Create NestJS module that wires up demo services and controller.

**Create demo.module.ts:**
```typescript
import { Module } from '@nestjs/common';
import { PrismaModule } from '../../prisma/prisma.module';
import { DemoSessionService } from './demo-session.service';
import { DemoResetService } from './demo-reset.service';
import { DemoResetController } from './demo-reset.controller';

@Module({
  imports: [PrismaModule],
  controllers: [DemoResetController],
  providers: [DemoSessionService, DemoResetService],
  exports: [DemoSessionService, DemoResetService],
})
export class DemoModule {}
```

**Also create index.ts for clean exports:**
```typescript
export * from './demo.module';
export * from './demo-session.service';
export * from './demo-reset.service';
```

**Register module in app.module.ts:**
```typescript
import { DemoModule } from './modules/demo';

@Module({
  imports: [
    // ... existing modules
    DemoModule,
  ],
})
export class AppModule {}
```
  </action>
  <verify>
TypeScript check: `cd apps/backend && npx tsc --noEmit`
  </verify>
  <done>
Demo module registered and exports services for use by other modules.
  </done>
</task>

<task type="auto">
  <name>Task 6: Update seeders to mark base data as immutable</name>
  <files>apps/backend/prisma/seeders/case.seeder.ts, apps/backend/prisma/seeders/riu.seeder.ts, apps/backend/prisma/seeders/investigation.seeder.ts</files>
  <action>
Update existing seeders to set `isBaseData: true` on all seeded records.

**In each seeder, add isBaseData flag:**
```typescript
// In case.seeder.ts - seedCases function
const caseData = {
  // ... existing fields
  isBaseData: true,           // Mark as immutable base data
  demoUserSessionId: null,    // Not owned by any user session
};

// In riu.seeder.ts - seedRius function
const riuData = {
  // ... existing fields
  isBaseData: true,
  demoUserSessionId: null,
};

// In investigation.seeder.ts - seedInvestigations function
const investigationData = {
  // ... existing fields
  isBaseData: true,
  demoUserSessionId: null,
};
```

**Key point:** All seeded demo data is marked as base data and will NEVER be deleted by user resets.
  </action>
  <verify>
Verify seeders include isBaseData flag in create calls.
  </verify>
  <done>
Seeders mark all demo data as immutable base data.
  </done>
</task>

<task type="auto">
  <name>Task 7: Create CLI reset script and npm commands</name>
  <files>apps/backend/prisma/reset-demo.ts, apps/backend/package.json</files>
  <action>
Create CLI script for manual reset (admin use) and add npm scripts.

**Create reset-demo.ts:**
```typescript
import { PrismaClient } from '@prisma/client';
import chalk from 'chalk';

const prisma = new PrismaClient();
const DEMO_ORG_SLUG = 'acme-corp';

async function resetDemo() {
  console.log(chalk.blue('Demo Reset CLI'));
  console.log(chalk.gray('This script is for admin use. Users should use the API endpoint.\n'));

  const args = process.argv.slice(2);
  const userId = args[0];

  if (!userId) {
    console.log(chalk.yellow('Usage: npm run seed:reset <userId>'));
    console.log(chalk.gray('  Resets demo changes for a specific user.\n'));
    console.log(chalk.yellow('Usage: npm run seed:reset --cleanup'));
    console.log(chalk.gray('  Cleans up expired archives and stale sessions.\n'));
    process.exit(1);
  }

  // Find demo organization
  const org = await prisma.organization.findUnique({
    where: { slug: DEMO_ORG_SLUG },
  });

  if (!org) {
    console.error(chalk.red(`Demo organization '${DEMO_ORG_SLUG}' not found!`));
    console.log(chalk.yellow('Run "npm run db:seed" first to create the demo tenant.'));
    process.exit(1);
  }

  if (userId === '--cleanup') {
    // Cleanup mode
    console.log(chalk.cyan('Running cleanup...'));

    const expiredArchives = await prisma.demoArchivedChange.deleteMany({
      where: { expiresAt: { lt: new Date() } },
    });
    console.log(chalk.green(`Deleted ${expiredArchives.count} expired archives`));

    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - 30);
    const staleSessions = await prisma.demoUserSession.findMany({
      where: { lastActivityAt: { lt: cutoff } },
    });
    console.log(chalk.green(`Found ${staleSessions.length} stale sessions (>30 days inactive)`));

    console.log(chalk.blue.bold('\nCleanup complete!'));
    return;
  }

  // Find user's session
  const session = await prisma.demoUserSession.findUnique({
    where: {
      organizationId_userId: { organizationId: org.id, userId },
    },
  });

  if (!session) {
    console.log(chalk.yellow(`No demo session found for user ${userId}.`));
    console.log(chalk.gray('User has no changes to reset.'));
    process.exit(0);
  }

  // Count what will be deleted
  const [cases, investigations, rius] = await Promise.all([
    prisma.case.count({ where: { demoUserSessionId: session.id, isBaseData: false } }),
    prisma.investigation.count({ where: { demoUserSessionId: session.id, isBaseData: false } }),
    prisma.riskIntelligenceUnit.count({ where: { demoUserSessionId: session.id, isBaseData: false } }),
  ]);

  console.log(chalk.cyan('Changes to delete:'));
  console.log(chalk.white(`  Cases:          ${cases}`));
  console.log(chalk.white(`  Investigations: ${investigations}`));
  console.log(chalk.white(`  RIUs:           ${rius}`));

  if (cases + investigations + rius === 0) {
    console.log(chalk.green('\nNo user changes to delete.'));
    process.exit(0);
  }

  // Delete user changes (skip archiving for CLI - this is admin tool)
  console.log(chalk.yellow('\nDeleting user changes...'));

  const startTime = Date.now();

  await prisma.$transaction([
    prisma.auditLog.deleteMany({
      where: {
        organizationId: org.id,
        entityId: {
          in: [
            ...(await prisma.case.findMany({
              where: { demoUserSessionId: session.id },
              select: { id: true },
            })).map(c => c.id),
          ],
        },
      },
    }),
    prisma.caseMessage.deleteMany({
      where: { case: { demoUserSessionId: session.id } },
    }),
    prisma.investigationNote.deleteMany({
      where: { investigation: { demoUserSessionId: session.id } },
    }),
    prisma.subject.deleteMany({
      where: { case: { demoUserSessionId: session.id } },
    }),
    prisma.investigation.deleteMany({
      where: { demoUserSessionId: session.id, isBaseData: false },
    }),
    prisma.riuCaseAssociation.deleteMany({
      where: { riu: { demoUserSessionId: session.id } },
    }),
    prisma.case.deleteMany({
      where: { demoUserSessionId: session.id, isBaseData: false },
    }),
    prisma.riskIntelligenceUnit.deleteMany({
      where: { demoUserSessionId: session.id, isBaseData: false },
    }),
  ]);

  const durationMs = Date.now() - startTime;

  console.log(chalk.blue.bold(`\nReset complete in ${durationMs}ms`));
  console.log(chalk.gray('Base data preserved. User can start fresh.'));
}

resetDemo()
  .catch((e) => {
    console.error(chalk.red('Reset failed:'), e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

**Add to package.json scripts:**
```json
{
  "scripts": {
    "seed:reset": "ts-node prisma/reset-demo.ts",
    "demo:cleanup": "ts-node prisma/reset-demo.ts --cleanup"
  }
}
```
  </action>
  <verify>
Verify scripts added: `cd apps/backend && npm run seed:reset --help`
  </verify>
  <done>
CLI script and npm commands available for admin reset and cleanup operations.
  </done>
</task>

<task type="auto">
  <name>Task 8: Add verification summary to reset operations</name>
  <files>apps/backend/src/modules/demo/demo-reset.service.ts</files>
  <action>
Add verification summary output to reset service.

**Add verification method to DemoResetService:**
```typescript
/**
 * Get verification summary after reset.
 */
async getVerificationSummary(
  organizationId: string,
  userId: string,
): Promise<{
  baseDataIntact: boolean;
  userChangesCleared: boolean;
  counts: {
    baseRius: number;
    baseCases: number;
    baseInvestigations: number;
    userRius: number;
    userCases: number;
    userInvestigations: number;
  };
}> {
  const session = await this.sessionService.getOrCreateSession(organizationId, userId);

  const [baseRius, baseCases, baseInvestigations, userRius, userCases, userInvestigations] =
    await Promise.all([
      this.prisma.riskIntelligenceUnit.count({
        where: { organizationId, isBaseData: true },
      }),
      this.prisma.case.count({
        where: { organizationId, isBaseData: true },
      }),
      this.prisma.investigation.count({
        where: { organizationId, isBaseData: true },
      }),
      this.prisma.riskIntelligenceUnit.count({
        where: { demoUserSessionId: session.id, isBaseData: false },
      }),
      this.prisma.case.count({
        where: { demoUserSessionId: session.id, isBaseData: false },
      }),
      this.prisma.investigation.count({
        where: { demoUserSessionId: session.id, isBaseData: false },
      }),
    ]);

  // Expected base data counts (from seeding)
  const expectedBaseRius = 5000;
  const expectedBaseCases = 4500;

  return {
    baseDataIntact: baseRius >= expectedBaseRius * 0.9 && baseCases >= expectedBaseCases * 0.9,
    userChangesCleared: userRius === 0 && userCases === 0 && userInvestigations === 0,
    counts: {
      baseRius,
      baseCases,
      baseInvestigations,
      userRius,
      userCases,
      userInvestigations,
    },
  };
}
```

**Update resetUserChanges to include verification:**
```typescript
// At end of resetUserChanges method, after deletion
const verification = await this.getVerificationSummary(organizationId, userId);

this.logger.log(`Verification: Base data intact: ${verification.baseDataIntact}, User changes cleared: ${verification.userChangesCleared}`);

return {
  success: true,
  deletedCounts,
  archiveId,
  undoExpiresAt,
  durationMs,
  verification, // Add to response
};
```

**Add verification endpoint to controller:**
```typescript
@Get('verify')
async verifyReset(
  @CurrentUser() user: User,
  @TenantId() orgId: string,
) {
  return this.resetService.getVerificationSummary(orgId, user.id);
}
```
  </action>
  <verify>
TypeScript check: `cd apps/backend && npx tsc --noEmit`
  </verify>
  <done>
Verification summary confirms base data preserved and user changes cleared.
  </done>
</task>

</tasks>

<verification>
1. Schema validates: `cd apps/backend && npx prisma validate`
2. TypeScript compiles: `cd apps/backend && npx tsc --noEmit`
3. DemoUserSession and DemoArchivedChange models exist
4. Base data marked with `isBaseData: true` in seeders
5. Reset only deletes records where `isBaseData: false` AND `demoUserSessionId` matches
6. Confirmation token required for reset
7. 24-hour undo window via DemoArchivedChange
8. Verification endpoint confirms base data intact
9. Reset completes in under 1 minute for typical user changes
</verification>

<success_criteria>
- Base demo data (3-year history) is NEVER deleted by resets
- Each user's changes isolated via DemoUserSession
- Reset requires confirmation before executing
- Reset completes in under 1 minute (under 5 minutes acceptable)
- 24-hour undo window available after reset
- Verification confirms base data intact and user changes cleared
- Optional cleanup for expired archives and stale sessions
- CLI script available for admin operations
</success_criteria>

<output>
After completion, create `.planning/phases/02-demo-tenant-seed-data/02-07-SUMMARY.md`
</output>
