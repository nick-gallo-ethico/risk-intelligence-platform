---
phase: 02-demo-tenant-seed-data
plan: 06
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/prisma/seeders/user.seeder.ts
  - apps/backend/prisma/seed.ts
  - apps/backend/src/modules/demo/demo.module.ts
  - apps/backend/src/modules/demo/demo.service.ts
  - apps/backend/src/modules/demo/demo.controller.ts
  - apps/backend/src/modules/demo/dto/provision-prospect.dto.ts
  - apps/backend/src/modules/demo/demo.scheduler.ts
autonomous: true

must_haves:
  truths:
    - "9 demo user accounts exist with distinct role presets (demo-cco@, demo-investigator@, demo-employee@, etc.)"
    - "All demo users have password 'Password123!' for testing"
    - "DemoAccount entity tracks prospect account provisioning with expiry and attribution"
    - "Sales reps can self-provision time-limited prospect accounts via API"
    - "Prospect accounts auto-expire based on configurable expiry date"
    - "All prospect access is attributed to the originating sales rep"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "DemoAccount entity for tracking demo sessions"
      exports: ["DemoAccount model"]
    - path: "apps/backend/prisma/seeders/user.seeder.ts"
      provides: "Demo user factory with role variety"
      exports: ["seedDemoUsers"]
    - path: "apps/backend/src/modules/demo/demo.service.ts"
      provides: "Demo account management service"
      exports: ["DemoService"]
    - path: "apps/backend/src/modules/demo/demo.controller.ts"
      provides: "Prospect provisioning API endpoint"
      exports: ["DemoController"]
  key_links:
    - from: "apps/backend/prisma/seeders/user.seeder.ts"
      to: "bcrypt"
      via: "password hashing"
      pattern: "bcrypt\\.hash"
    - from: "apps/backend/src/modules/demo/demo.scheduler.ts"
      to: "@nestjs/schedule"
      via: "cron job for expiry"
      pattern: "@Cron"
---

<objective>
Create the hybrid multi-user demo access system with sales rep accounts and prospect provisioning.

Purpose: Enable a scalable demo model where:
1. Sales reps have permanent demo accounts with multiple role presets
2. Sales reps can self-provision time-limited prospect accounts for customer demos
3. Prospect accounts are attributed to the originating sales rep for tracking
4. Expired prospect accounts are automatically deactivated

Output:
- 9 permanent demo user accounts with role presets
- DemoAccount entity for tracking prospect sessions
- Prospect provisioning API endpoint
- Automatic expiry scheduling
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-demo-tenant-seed-data/02-RESEARCH.md
@.planning/phases/02-demo-tenant-seed-data/02-CONTEXT.md
@apps/backend/prisma/schema.prisma (User model, UserRole enum)
@apps/backend/prisma/seed.ts (existing user creation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DemoAccount entity to Prisma schema</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
Add DemoAccount model to track prospect account provisioning.

**DemoAccount entity:**
```prisma
model DemoAccount {
  id                String    @id @default(uuid())
  organizationId    String

  // Prospect user details
  prospectUserId    String    @unique
  prospectUser      User      @relation("ProspectUser", fields: [prospectUserId], references: [id])
  prospectEmail     String
  prospectName      String?
  prospectCompany   String?

  // Attribution to sales rep
  salesRepUserId    String
  salesRepUser      User      @relation("SalesRepUser", fields: [salesRepUserId], references: [id])

  // Expiry configuration
  expiresAt         DateTime
  expiredAt         DateTime? // When actually expired (null if still active)

  // Status tracking
  status            DemoAccountStatus @default(ACTIVE)
  lastAccessAt      DateTime?
  accessCount       Int       @default(0)

  // Metadata
  notes             String?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  organization      Organization @relation(fields: [organizationId], references: [id])

  @@index([organizationId])
  @@index([salesRepUserId])
  @@index([status, expiresAt])
}

enum DemoAccountStatus {
  ACTIVE
  EXPIRED
  REVOKED
}
```

**Add relations to User model:**
```prisma
model User {
  // ... existing fields

  // Demo account relations
  prospectDemoAccounts  DemoAccount[] @relation("ProspectUser")
  salesRepDemoAccounts  DemoAccount[] @relation("SalesRepUser")
}
```
  </action>
  <verify>
Run: `cd apps/backend && npx prisma validate`
  </verify>
  <done>
DemoAccount entity added with prospect tracking, sales rep attribution, and expiry fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create demo user seeder with role presets</name>
  <files>apps/backend/prisma/seeders/user.seeder.ts</files>
  <action>
Create user.seeder.ts that generates the permanent demo users with role presets.

**Demo users - permanent sales rep accounts:**
```typescript
const DEMO_USERS = [
  // Admin/System roles
  { email: 'demo-admin@acme.local', role: 'SYSTEM_ADMIN', firstName: 'Alex', lastName: 'Admin', isSalesRep: true },

  // Compliance roles
  { email: 'demo-cco@acme.local', role: 'COMPLIANCE_OFFICER', firstName: 'Casey', lastName: 'Compliance', isSalesRep: true },
  { email: 'demo-triage@acme.local', role: 'TRIAGE_LEAD', firstName: 'Taylor', lastName: 'Triage', isSalesRep: true },

  // Investigation roles
  { email: 'demo-investigator@acme.local', role: 'INVESTIGATOR', firstName: 'Jordan', lastName: 'Investigator', isSalesRep: true },
  { email: 'demo-investigator2@acme.local', role: 'INVESTIGATOR', firstName: 'Jamie', lastName: 'Investigator Jr', isSalesRep: true },

  // Policy roles
  { email: 'demo-policy@acme.local', role: 'POLICY_AUTHOR', firstName: 'Pat', lastName: 'Policy', isSalesRep: true },
  { email: 'demo-reviewer@acme.local', role: 'POLICY_REVIEWER', firstName: 'Robin', lastName: 'Reviewer', isSalesRep: true },

  // Line roles
  { email: 'demo-manager@acme.local', role: 'MANAGER', firstName: 'Morgan', lastName: 'Manager', isSalesRep: true },
  { email: 'demo-employee@acme.local', role: 'EMPLOYEE', firstName: 'Sam', lastName: 'Staff', isSalesRep: true },
];
```

**Export functions:**
```typescript
export async function seedDemoUsers(
  prisma: PrismaClient,
  organizationId: string,
): Promise<string[]>

// Helper to check if user is a sales rep (for provisioning permissions)
export function isDemoSalesRep(email: string): boolean
```

**Implementation:**
- Use bcrypt with 12 rounds for password hashing (same as existing seed.ts)
- Password: 'Password123!' for all demo users
- Use upsert to handle re-running seed
- All users have emailVerifiedAt set to now()
- isActive: true for all
- Add `isSalesRep: true` flag to user metadata (or dedicated field)

**For each user:**
```typescript
await prisma.user.upsert({
  where: {
    organizationId_email: {
      organizationId,
      email: user.email,
    },
  },
  update: {},
  create: {
    organizationId,
    email: user.email,
    passwordHash,
    firstName: user.firstName,
    lastName: user.lastName,
    role: user.role as UserRole,
    emailVerifiedAt: new Date(),
    isActive: true,
    metadata: { isSalesRep: user.isSalesRep },
  },
});
```

Return array of user IDs.
  </action>
  <verify>
TypeScript check: `cd apps/backend && npx tsc --noEmit`
  </verify>
  <done>
Demo user seeder creates 9 permanent sales rep users with distinct role presets using upsert for idempotency.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create DemoService for prospect provisioning</name>
  <files>apps/backend/src/modules/demo/demo.service.ts</files>
  <action>
Create the demo service to handle prospect account provisioning and management.

**Service methods:**
```typescript
@Injectable()
export class DemoService {
  constructor(
    private prisma: PrismaService,
    private activityService: ActivityService,
  ) {}

  /**
   * Provision a new prospect account (called by sales rep)
   */
  async provisionProspectAccount(
    salesRepUserId: string,
    dto: ProvisionProspectDto,
    organizationId: string,
  ): Promise<{ user: User; demoAccount: DemoAccount }>;

  /**
   * Extend expiry date for an existing prospect account
   */
  async extendExpiry(
    demoAccountId: string,
    newExpiryDate: Date,
    salesRepUserId: string,
  ): Promise<DemoAccount>;

  /**
   * Revoke a prospect account (manual deactivation)
   */
  async revokeAccount(
    demoAccountId: string,
    salesRepUserId: string,
    reason?: string,
  ): Promise<DemoAccount>;

  /**
   * Get all prospect accounts for a sales rep
   */
  async getSalesRepProspects(
    salesRepUserId: string,
    organizationId: string,
  ): Promise<DemoAccount[]>;

  /**
   * Process expired accounts (called by scheduler)
   */
  async processExpiredAccounts(): Promise<number>;

  /**
   * Record prospect access (called on login)
   */
  async recordAccess(prospectUserId: string): Promise<void>;
}
```

**provisionProspectAccount implementation:**
```typescript
async provisionProspectAccount(
  salesRepUserId: string,
  dto: ProvisionProspectDto,
  organizationId: string,
): Promise<{ user: User; demoAccount: DemoAccount }> {
  // 1. Verify sales rep has provisioning permission
  const salesRep = await this.prisma.user.findUnique({
    where: { id: salesRepUserId },
  });
  if (!salesRep?.metadata?.isSalesRep) {
    throw new ForbiddenException('Only sales reps can provision prospect accounts');
  }

  // 2. Calculate expiry (default 14 days if not specified)
  const expiresAt = dto.expiresAt || addDays(new Date(), 14);

  // 3. Generate unique prospect email
  const prospectEmail = `prospect-${uuid().slice(0, 8)}@demo.local`;

  // 4. Create prospect user with known password
  const passwordHash = await bcrypt.hash('Password123!', 12);
  const prospectUser = await this.prisma.user.create({
    data: {
      organizationId,
      email: prospectEmail,
      passwordHash,
      firstName: dto.prospectName?.split(' ')[0] || 'Demo',
      lastName: dto.prospectName?.split(' ').slice(1).join(' ') || 'User',
      role: dto.role || 'COMPLIANCE_OFFICER',
      emailVerifiedAt: new Date(),
      isActive: true,
      metadata: { isProspect: true },
    },
  });

  // 5. Create DemoAccount record
  const demoAccount = await this.prisma.demoAccount.create({
    data: {
      organizationId,
      prospectUserId: prospectUser.id,
      prospectEmail,
      prospectName: dto.prospectName,
      prospectCompany: dto.prospectCompany,
      salesRepUserId,
      expiresAt,
      notes: dto.notes,
    },
  });

  // 6. Log activity
  await this.activityService.log({
    entityType: 'DEMO_ACCOUNT',
    entityId: demoAccount.id,
    action: 'provisioned',
    actionDescription: `${salesRep.email} provisioned prospect account for ${dto.prospectName || 'unnamed prospect'} (${dto.prospectCompany || 'unknown company'})`,
    actorUserId: salesRepUserId,
    organizationId,
  });

  return { user: prospectUser, demoAccount };
}
```

**processExpiredAccounts implementation:**
```typescript
async processExpiredAccounts(): Promise<number> {
  const now = new Date();

  // Find active accounts past expiry
  const expiredAccounts = await this.prisma.demoAccount.findMany({
    where: {
      status: 'ACTIVE',
      expiresAt: { lte: now },
    },
    include: { prospectUser: true },
  });

  for (const account of expiredAccounts) {
    await this.prisma.$transaction([
      // Deactivate the prospect user
      this.prisma.user.update({
        where: { id: account.prospectUserId },
        data: { isActive: false },
      }),
      // Mark demo account as expired
      this.prisma.demoAccount.update({
        where: { id: account.id },
        data: { status: 'EXPIRED', expiredAt: now },
      }),
    ]);
  }

  return expiredAccounts.length;
}
```
  </action>
  <verify>
TypeScript check: `cd apps/backend && npx tsc --noEmit`
  </verify>
  <done>
DemoService handles prospect provisioning, expiry management, and attribution tracking.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create DTOs for prospect provisioning</name>
  <files>apps/backend/src/modules/demo/dto/provision-prospect.dto.ts</files>
  <action>
Create DTOs for the demo provisioning API.

**ProvisionProspectDto:**
```typescript
import { IsString, IsOptional, IsDate, IsEnum } from 'class-validator';
import { Type } from 'class-transformer';
import { UserRole } from '@prisma/client';

export class ProvisionProspectDto {
  @IsOptional()
  @IsString()
  prospectName?: string;

  @IsOptional()
  @IsString()
  prospectCompany?: string;

  @IsOptional()
  @IsEnum(UserRole)
  role?: UserRole;

  @IsOptional()
  @Type(() => Date)
  @IsDate()
  expiresAt?: Date;

  @IsOptional()
  @IsString()
  notes?: string;
}

export class ExtendExpiryDto {
  @Type(() => Date)
  @IsDate()
  newExpiryDate: Date;
}

export class RevokeAccountDto {
  @IsOptional()
  @IsString()
  reason?: string;
}
```

**Response DTOs:**
```typescript
export class DemoAccountResponseDto {
  id: string;
  prospectEmail: string;
  prospectName?: string;
  prospectCompany?: string;
  role: string;
  status: string;
  expiresAt: Date;
  expiredAt?: Date;
  lastAccessAt?: Date;
  accessCount: number;
  createdAt: Date;

  // Credentials (only returned on provision)
  credentials?: {
    email: string;
    password: string;
  };
}

export class ProvisionResponseDto extends DemoAccountResponseDto {
  credentials: {
    email: string;
    password: string;
  };
}
```
  </action>
  <verify>
TypeScript check: `cd apps/backend && npx tsc --noEmit`
  </verify>
  <done>
DTOs created for prospect provisioning request/response with validation decorators.
  </done>
</task>

<task type="auto">
  <name>Task 5: Create DemoController with provisioning endpoints</name>
  <files>apps/backend/src/modules/demo/demo.controller.ts</files>
  <action>
Create the controller with REST endpoints for prospect account management.

**Endpoints:**
```typescript
@Controller('api/v1/demo')
@UseGuards(JwtAuthGuard, TenantGuard)
@ApiTags('Demo')
export class DemoController {
  constructor(private readonly demoService: DemoService) {}

  /**
   * POST /api/v1/demo/prospects
   * Provision a new prospect account (sales reps only)
   */
  @Post('prospects')
  @ApiOperation({ summary: 'Provision a new prospect demo account' })
  @ApiResponse({ status: 201, type: ProvisionResponseDto })
  async provisionProspect(
    @Body() dto: ProvisionProspectDto,
    @CurrentUser() user: User,
    @TenantId() orgId: string,
  ): Promise<ProvisionResponseDto>;

  /**
   * GET /api/v1/demo/prospects
   * List all prospect accounts for current sales rep
   */
  @Get('prospects')
  @ApiOperation({ summary: 'List prospect accounts provisioned by current user' })
  @ApiResponse({ status: 200, type: [DemoAccountResponseDto] })
  async listProspects(
    @CurrentUser() user: User,
    @TenantId() orgId: string,
  ): Promise<DemoAccountResponseDto[]>;

  /**
   * PATCH /api/v1/demo/prospects/:id/extend
   * Extend expiry date for a prospect account
   */
  @Patch('prospects/:id/extend')
  @ApiOperation({ summary: 'Extend prospect account expiry' })
  async extendExpiry(
    @Param('id') id: string,
    @Body() dto: ExtendExpiryDto,
    @CurrentUser() user: User,
  ): Promise<DemoAccountResponseDto>;

  /**
   * POST /api/v1/demo/prospects/:id/revoke
   * Revoke a prospect account
   */
  @Post('prospects/:id/revoke')
  @ApiOperation({ summary: 'Revoke prospect account' })
  async revokeAccount(
    @Param('id') id: string,
    @Body() dto: RevokeAccountDto,
    @CurrentUser() user: User,
  ): Promise<DemoAccountResponseDto>;

  /**
   * GET /api/v1/demo/credentials
   * Get demo credentials for permanent accounts (public info)
   */
  @Get('credentials')
  @Public()
  @ApiOperation({ summary: 'Get demo account credentials' })
  async getDemoCredentials(): Promise<DemoCredentialsDto>;
}
```

**getDemoCredentials implementation (public endpoint):**
```typescript
async getDemoCredentials(): Promise<DemoCredentialsDto> {
  return {
    password: 'Password123!',
    accounts: [
      { email: 'demo-cco@acme.local', role: 'COMPLIANCE_OFFICER', description: 'Chief Compliance Officer view' },
      { email: 'demo-investigator@acme.local', role: 'INVESTIGATOR', description: 'Case investigator view' },
      { email: 'demo-employee@acme.local', role: 'EMPLOYEE', description: 'Employee self-service view' },
      // ... etc
    ],
  };
}
```
  </action>
  <verify>
TypeScript check: `cd apps/backend && npx tsc --noEmit`
  </verify>
  <done>
DemoController exposes prospect provisioning API with proper guards and Swagger documentation.
  </done>
</task>

<task type="auto">
  <name>Task 6: Create scheduler for auto-expiry</name>
  <files>apps/backend/src/modules/demo/demo.scheduler.ts</files>
  <action>
Create a scheduled task to process expired prospect accounts.

**Implementation:**
```typescript
import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { DemoService } from './demo.service';

@Injectable()
export class DemoScheduler {
  private readonly logger = new Logger(DemoScheduler.name);

  constructor(private readonly demoService: DemoService) {}

  /**
   * Run every hour to expire prospect accounts
   */
  @Cron(CronExpression.EVERY_HOUR)
  async handleExpiredAccounts(): Promise<void> {
    this.logger.log('Processing expired demo accounts...');

    try {
      const expiredCount = await this.demoService.processExpiredAccounts();

      if (expiredCount > 0) {
        this.logger.log(`Expired ${expiredCount} demo account(s)`);
      }
    } catch (error) {
      this.logger.error('Failed to process expired accounts', error);
    }
  }
}
```

**Note:** Requires @nestjs/schedule module to be imported in the app. Add to demo.module.ts imports if not already present.
  </action>
  <verify>
TypeScript check: `cd apps/backend && npx tsc --noEmit`
  </verify>
  <done>
DemoScheduler runs hourly to auto-expire prospect accounts past their expiry date.
  </done>
</task>

<task type="auto">
  <name>Task 7: Create DemoModule to wire everything together</name>
  <files>apps/backend/src/modules/demo/demo.module.ts</files>
  <action>
Create the NestJS module to wire all demo components.

**Implementation:**
```typescript
import { Module } from '@nestjs/common';
import { ScheduleModule } from '@nestjs/schedule';
import { DemoService } from './demo.service';
import { DemoController } from './demo.controller';
import { DemoScheduler } from './demo.scheduler';
import { PrismaModule } from '../../common/prisma/prisma.module';
import { ActivityModule } from '../activity/activity.module';

@Module({
  imports: [
    PrismaModule,
    ActivityModule,
    ScheduleModule.forRoot(),
  ],
  controllers: [DemoController],
  providers: [DemoService, DemoScheduler],
  exports: [DemoService],
})
export class DemoModule {}
```

**Also create index.ts for clean exports:**
```typescript
// apps/backend/src/modules/demo/index.ts
export * from './demo.module';
export * from './demo.service';
export * from './dto/provision-prospect.dto';
```
  </action>
  <verify>
TypeScript check: `cd apps/backend && npx tsc --noEmit`
  </verify>
  <done>
DemoModule wires together service, controller, and scheduler with proper dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 8: Update seed.ts to use new user seeder</name>
  <files>apps/backend/prisma/seed.ts</files>
  <action>
Refactor seed.ts to use the new user seeder instead of inline user creation.

**Changes:**
1. Import { seedDemoUsers } from './seeders/user.seeder'
2. Remove the existing individual user upsert calls (admin, compliance, investigator, employee)
3. Replace with single seeder call:
   ```typescript
   const demoUserIds = await seedDemoUsers(prisma, organization.id);
   console.log(`Created ${demoUserIds.length} demo users`);
   ```
4. Update the console output showing test credentials

**Updated credential display:**
```typescript
console.log('\n========================================');
console.log('DEMO CREDENTIALS');
console.log('========================================');
console.log('\nPassword for all accounts: Password123!');
console.log('\nPermanent Sales Rep Accounts (role presets):');
console.log('  demo-admin@acme.local         - SYSTEM_ADMIN');
console.log('  demo-cco@acme.local           - COMPLIANCE_OFFICER');
console.log('  demo-triage@acme.local        - TRIAGE_LEAD');
console.log('  demo-investigator@acme.local  - INVESTIGATOR');
console.log('  demo-investigator2@acme.local - INVESTIGATOR');
console.log('  demo-policy@acme.local        - POLICY_AUTHOR');
console.log('  demo-reviewer@acme.local      - POLICY_REVIEWER');
console.log('  demo-manager@acme.local       - MANAGER');
console.log('  demo-employee@acme.local      - EMPLOYEE');
console.log('\nSales reps can provision prospect accounts via:');
console.log('  POST /api/v1/demo/prospects');
console.log('========================================\n');
```
  </action>
  <verify>
TypeScript check: `cd apps/backend && npx tsc --noEmit`
  </verify>
  <done>
seed.ts uses user seeder, creating 9 permanent demo users with role presets.
  </done>
</task>

<task type="auto">
  <name>Task 9: Run migration and verify schema</name>
  <files>apps/backend/prisma/migrations/</files>
  <action>
Create and run the Prisma migration for the DemoAccount entity.

**Commands:**
```bash
cd apps/backend
npx prisma migrate dev --name add_demo_account_entity
npx prisma generate
```

**Verify:**
- Migration file created in prisma/migrations/
- DemoAccount table created with all fields
- User model has new relations
- Prisma client regenerated with DemoAccount type
  </action>
  <verify>
Run: `cd apps/backend && npx prisma validate && npx prisma db push --dry-run`
  </verify>
  <done>
Migration created and applied, DemoAccount entity exists in database.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd apps/backend && npx tsc --noEmit`
2. Prisma schema valid: `cd apps/backend && npx prisma validate`
3. User seeder creates 9 permanent demo users with role presets
4. DemoAccount entity tracks prospect accounts with:
   - Prospect user reference
   - Sales rep attribution
   - Expiry date and status
   - Access tracking
5. DemoService provisions new prospect accounts
6. DemoController exposes REST API for provisioning
7. DemoScheduler auto-expires accounts hourly
8. Password hashing uses bcrypt with 12 rounds
9. All users have password 'Password123!'
10. Credentials display updated in seed.ts
</verification>

<success_criteria>
- 9 permanent demo users created with distinct role presets (demo-cco@, demo-investigator@, etc.)
- All demo users have password 'Password123!'
- DemoAccount entity exists for tracking prospect accounts
- Sales reps can provision prospect accounts via POST /api/v1/demo/prospects
- Prospect accounts have configurable expiry dates (default 14 days)
- Expired accounts auto-deactivate via scheduled task
- All prospect access attributed to originating sales rep
- Seeder uses upsert for idempotent re-runs
- API documented with Swagger decorators
</success_criteria>

<output>
After completion, create `.planning/phases/02-demo-tenant-seed-data/02-06-SUMMARY.md`
</output>
