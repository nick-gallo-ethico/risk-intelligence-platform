---
phase: 07-notifications-email
plan: 07
type: execute
wave: 3
depends_on: ["07-04"]
files_modified:
  - apps/backend/src/modules/notifications/services/delivery-tracker.service.ts
  - apps/backend/src/modules/jobs/processors/email.processor.ts
  - apps/backend/src/modules/notifications/controllers/webhook.controller.ts
  - apps/backend/package.json
autonomous: true

must_haves:
  truths:
    - "Email processor sends real emails via nodemailer"
    - "Failed emails retry with exponential backoff via BullMQ"
    - "Delivery status is tracked (sent, delivered, bounced, failed)"
    - "Webhook endpoint receives delivery status from email provider"
    - "Permanent failures are logged for compliance audit"
  artifacts:
    - path: "apps/backend/src/modules/jobs/processors/email.processor.ts"
      provides: "EmailProcessor that replaces Phase 1 placeholder with actual email sending"
      min_lines: 80
    - path: "apps/backend/src/modules/notifications/services/delivery-tracker.service.ts"
      provides: "DeliveryTrackerService for tracking email delivery status"
      exports: ["DeliveryTrackerService"]
      min_lines: 100
  key_links:
    - from: "apps/backend/src/modules/jobs/processors/email.processor.ts"
      to: "@nestjs-modules/mailer"
      via: "MailerService injection"
      pattern: "MailerService"
    - from: "apps/backend/src/modules/notifications/controllers/webhook.controller.ts"
      to: "apps/backend/src/modules/notifications/services/delivery-tracker.service.ts"
      via: "Webhook event processing"
      pattern: "deliveryTracker\\.processEvent"
---

<objective>
Replace the email processor placeholder and implement delivery tracking.

Purpose: Enable actual email delivery via nodemailer with comprehensive tracking of delivery status for compliance and debugging.
Output: Working email processor, delivery tracker service, and webhook controller for provider callbacks.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-notifications-email/07-CONTEXT.md
@.planning/phases/07-notifications-email/07-RESEARCH.md
@.planning/phases/07-notifications-email/07-04-PLAN.md

Reference existing placeholder:
@apps/backend/src/modules/jobs/processors/email.processor.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install nodemailer and configure MailerModule</name>
  <files>
    apps/backend/package.json
    apps/backend/src/modules/notifications/mailer.config.ts
    apps/backend/src/modules/notifications/notifications.module.ts
  </files>
  <action>
Install dependencies:
```bash
cd apps/backend && npm install @nestjs-modules/mailer nodemailer
npm install --save-dev @types/nodemailer
```

Create **mailer.config.ts**:
```typescript
import { MailerOptions } from '@nestjs-modules/mailer';
import { ConfigService } from '@nestjs/config';

export const mailerConfig = (configService: ConfigService): MailerOptions => ({
  transport: {
    host: configService.get('SMTP_HOST', 'localhost'),
    port: configService.get('SMTP_PORT', 587),
    secure: configService.get('SMTP_SECURE', 'false') === 'true',
    auth: {
      user: configService.get('SMTP_USER'),
      pass: configService.get('SMTP_PASS'),
    },
  },
  defaults: {
    from: configService.get('EMAIL_FROM', '"Ethico" <noreply@ethico.com>'),
  },
});
```

Update **notifications.module.ts** to include MailerModule:
```typescript
import { MailerModule } from '@nestjs-modules/mailer';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { mailerConfig } from './mailer.config';

@Module({
  imports: [
    // ... existing imports
    MailerModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: mailerConfig,
      inject: [ConfigService],
    }),
  ],
  // ...
})
export class NotificationsModule {}
```

Add environment variables to .env.example:
```
SMTP_HOST=smtp.sendgrid.net
SMTP_PORT=587
SMTP_SECURE=false
SMTP_USER=apikey
SMTP_PASS=your-sendgrid-api-key
EMAIL_FROM="Ethico" <noreply@ethico.com>
```
  </action>
  <verify>Run `cd apps/backend && npm list @nestjs-modules/mailer` shows package installed</verify>
  <done>MailerModule configured with SMTP transport</done>
</task>

<task type="auto">
  <name>Task 2: Create DeliveryTrackerService</name>
  <files>apps/backend/src/modules/notifications/services/delivery-tracker.service.ts</files>
  <action>
Create **delivery-tracker.service.ts**:

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { DeliveryStatus } from '@prisma/client';
import { EventEmitter2 } from '@nestjs/event-emitter';

interface DeliveryEventParams {
  messageId: string;
  status: DeliveryStatus;
  timestamp: Date;
  reason?: string;
  bounceType?: string;
}

@Injectable()
export class DeliveryTrackerService {
  private readonly logger = new Logger(DeliveryTrackerService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly eventEmitter: EventEmitter2,
  ) {}
}
```

Implement methods:

1. **recordSent(notificationId: string, messageId: string)**: Promise<void>
   - Create or update NotificationDelivery record
   - Set status to SENT, increment attempts, record timestamp
   - Update Notification.status to SENT

2. **recordDelivered(notificationId: string, messageId: string)**: Promise<void>
   - Update NotificationDelivery.status to DELIVERED
   - Update Notification.status to DELIVERED
   - Emit 'email.delivered' event for analytics

3. **recordBounced(notificationId: string, messageId: string, reason?: string, bounceType?: string)**: Promise<void>
   - Update NotificationDelivery.status to BOUNCED
   - Store bounce reason and type
   - Update Notification.status to FAILED
   - Emit 'email.bounced' event for analytics

4. **recordFailed(notificationId: string, reason: string)**: Promise<void>
   - Update NotificationDelivery.status to FAILED
   - Store error message
   - Called on send failure (before delivery)

5. **recordPermanentFailure(notificationId: string, reason: string)**: Promise<void>
   - Called after all retries exhausted
   - Update Notification.status to FAILED
   - Log for compliance audit (email never delivered)
   - Emit 'email.permanent_failure' event

6. **processWebhookEvent(event: DeliveryEventParams)**: Promise<void>
   - Look up notification by messageId
   - Route to appropriate record method based on status
   - Handle unknown messageIds gracefully (may be from other systems)

7. **getDeliveryStatus(notificationId: string)**: Promise<NotificationDelivery | null>
   - Return delivery record for a notification

8. **getFailedDeliveries(organizationId: string, since: Date)**: Promise<NotificationDelivery[]>
   - Return failed/bounced deliveries for compliance reporting
  </action>
  <verify>Run `cd apps/backend && npx tsc --noEmit` - service should compile</verify>
  <done>DeliveryTrackerService created with comprehensive status tracking</done>
</task>

<task type="auto">
  <name>Task 3: Replace EmailProcessor placeholder and add webhook controller</name>
  <files>
    apps/backend/src/modules/jobs/processors/email.processor.ts
    apps/backend/src/modules/notifications/controllers/webhook.controller.ts
  </files>
  <action>
Replace **email.processor.ts** (overwrite the Phase 1 placeholder):

```typescript
import { Processor, WorkerHost, OnWorkerEvent } from '@nestjs/bullmq';
import { Logger } from '@nestjs/common';
import { Job } from 'bullmq';
import { MailerService } from '@nestjs-modules/mailer';
import { EMAIL_QUEUE_NAME } from '../queues/email.queue';
import { EmailJobData } from '../types/job-data.types';
import { DeliveryTrackerService } from '../../notifications/services/delivery-tracker.service';

/**
 * Email Queue Worker
 *
 * Sends emails via SMTP and tracks delivery status.
 * Retry logic handled by BullMQ (3 attempts, exponential backoff).
 */
@Processor(EMAIL_QUEUE_NAME, { concurrency: 10 })
export class EmailProcessor extends WorkerHost {
  private readonly logger = new Logger(EmailProcessor.name);

  constructor(
    private readonly mailerService: MailerService,
    private readonly deliveryTracker: DeliveryTrackerService,
  ) {
    super();
  }

  async process(job: Job<EmailJobData>): Promise<{ messageId: string }> {
    const { notificationId, to, subject, html, organizationId } = job.data;

    this.logger.log(
      `Processing email job ${job.id}: to=${to} for org:${organizationId}`,
    );

    try {
      const result = await this.mailerService.sendMail({
        to,
        subject,
        html, // Pre-rendered HTML from NotificationService
      });

      // Track successful send
      await this.deliveryTracker.recordSent(notificationId, result.messageId);

      this.logger.log(`Email sent: messageId=${result.messageId}`);
      return { messageId: result.messageId };
    } catch (error) {
      this.logger.error(`Email send failed: ${error.message}`);

      // Track failure
      await this.deliveryTracker.recordFailed(notificationId, error.message);

      throw error; // Let BullMQ handle retry
    }
  }

  @OnWorkerEvent('completed')
  onCompleted(job: Job<EmailJobData>) {
    this.logger.log(`Email job ${job.id} completed successfully`);
  }

  @OnWorkerEvent('failed')
  async onFailed(job: Job<EmailJobData>, error: Error) {
    this.logger.error(
      `Email job ${job.id} failed after ${job.attemptsMade} attempts: ${error.message}`,
    );

    // After max retries, mark as permanently failed
    if (job.attemptsMade >= (job.opts.attempts || 3)) {
      await this.deliveryTracker.recordPermanentFailure(
        job.data.notificationId,
        error.message,
      );
    }
  }
}
```

Create **webhook.controller.ts** for email provider callbacks:

```typescript
import { Controller, Post, Body, HttpCode, Headers, Logger } from '@nestjs/common';
import { DeliveryTrackerService } from '../services/delivery-tracker.service';
import { ConfigService } from '@nestjs/config';
import * as crypto from 'crypto';

interface SendGridEvent {
  event: string;
  sg_message_id: string;
  timestamp: number;
  reason?: string;
  type?: string;
}

@Controller('webhooks')
export class WebhookController {
  private readonly logger = new Logger(WebhookController.name);

  constructor(
    private readonly deliveryTracker: DeliveryTrackerService,
    private readonly configService: ConfigService,
  ) {}

  @Post('email-events')
  @HttpCode(200)
  async handleEmailEvents(
    @Body() events: SendGridEvent[],
    @Headers('x-twilio-email-event-webhook-signature') signature?: string,
  ): Promise<void> {
    // Verify webhook signature if configured (SendGrid pattern)
    const webhookSecret = this.configService.get('SENDGRID_WEBHOOK_SECRET');
    if (webhookSecret && signature) {
      // Verify signature
      // Implementation depends on email provider
    }

    for (const event of events) {
      try {
        await this.deliveryTracker.processWebhookEvent({
          messageId: event.sg_message_id,
          status: this.mapEventToStatus(event.event),
          timestamp: new Date(event.timestamp * 1000),
          reason: event.reason,
          bounceType: event.type,
        });
      } catch (error) {
        this.logger.error(`Failed to process event: ${error.message}`);
        // Don't throw - process remaining events
      }
    }
  }

  private mapEventToStatus(event: string): DeliveryStatus {
    switch (event) {
      case 'delivered':
        return 'DELIVERED';
      case 'bounce':
        return 'BOUNCED';
      case 'dropped':
        return 'FAILED';
      case 'deferred':
        return 'DEFERRED';
      default:
        return 'PENDING';
    }
  }
}
```

Note: Import DeliveryStatus from @prisma/client or from notification.types.ts.
  </action>
  <verify>Run `cd apps/backend && npx tsc --noEmit` - processor and controller should compile</verify>
  <done>EmailProcessor sends real emails and WebhookController receives delivery status</done>
</task>

</tasks>

<verification>
1. `cd apps/backend && npm list nodemailer` shows nodemailer installed
2. `cd apps/backend && npx tsc --noEmit` passes
3. EmailProcessor uses MailerService (not placeholder)
4. DeliveryTrackerService has recordSent, recordDelivered, recordBounced methods
5. WebhookController processes email provider events
</verification>

<success_criteria>
- MailerModule configured with SMTP transport
- EmailProcessor sends real emails and tracks with DeliveryTrackerService
- Failed sends retry via BullMQ exponential backoff (already configured in Phase 1)
- Permanent failures logged after all retries exhausted
- Webhook endpoint receives and processes delivery status events
- Delivery status stored in NotificationDelivery model for compliance audit
</success_criteria>

<output>
After completion, create `.planning/phases/07-notifications-email/07-07-SUMMARY.md`
</output>
