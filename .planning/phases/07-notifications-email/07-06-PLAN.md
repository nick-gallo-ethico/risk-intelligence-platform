---
phase: 07-notifications-email
plan: 06
type: execute
wave: 3
depends_on: ["07-04"]
files_modified:
  - apps/backend/src/modules/notifications/services/digest.service.ts
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/notifications/templates/digest/daily-digest.mjml.hbs
  - apps/backend/src/modules/notifications/notifications.module.ts
autonomous: true

must_haves:
  truths:
    - "Low-priority events are batched into daily digest emails"
    - "Digest is sent at organization-configured time (default 17:00)"
    - "Similar events are grouped within the digest (e.g., 3 new comments on Case #X)"
    - "Digest respects user preferences - only users with digest enabled receive it"
    - "Scheduler runs daily and processes all pending digest items"
  artifacts:
    - path: "apps/backend/src/modules/notifications/services/digest.service.ts"
      provides: "DigestService with queueItem, processDigests, compileDigest methods"
      exports: ["DigestService"]
      min_lines: 150
    - path: "apps/backend/src/modules/notifications/templates/digest/daily-digest.mjml.hbs"
      provides: "Daily digest email template with grouped notifications"
      contains: "<mj-section>"
  key_links:
    - from: "apps/backend/src/modules/notifications/services/digest.service.ts"
      to: "apps/backend/prisma/schema.prisma"
      via: "DigestQueueItem model for pending items"
      pattern: "prisma\\.digestQueueItem"
---

<objective>
Create the daily digest service for batching low-priority notifications.

Purpose: Aggregate non-urgent notifications (status changes, comments, completions) into a single daily email to prevent inbox overload.
Output: DigestService with scheduling, aggregation, and compilation capabilities.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-notifications-email/07-CONTEXT.md
@.planning/phases/07-notifications-email/07-RESEARCH.md
@.planning/phases/07-notifications-email/07-04-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DigestQueueItem model to Prisma</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
Add the DigestQueueItem model to store pending digest notifications:

```prisma
/// Pending notifications to be included in daily digest
model DigestQueueItem {
  id              String   @id @default(uuid())
  organizationId  String   @map("organization_id")
  userId          String   @map("user_id")

  /// Notification type for grouping
  type            String   // STATUS_UPDATE, COMMENT, COMPLETION, etc.

  /// Entity reference for deduplication and grouping
  entityType      String?  @map("entity_type")
  entityId        String?  @map("entity_id")

  /// Additional metadata for template rendering
  metadata        Json     @default("{}")

  /// Has this item been included in a digest?
  processed       Boolean  @default(false)
  processedAt     DateTime? @map("processed_at")

  createdAt       DateTime @default(now()) @map("created_at")

  organization    Organization @relation(fields: [organizationId], references: [id])
  user            User @relation(fields: [userId], references: [id])

  @@index([organizationId, userId, processed])
  @@index([createdAt])
  @@map("digest_queue_items")
}
```

Add relation to User model if not exists:
```prisma
model User {
  // ... existing fields
  digestQueueItems  DigestQueueItem[]
}
```
  </action>
  <verify>Run `cd apps/backend && npx prisma validate` - schema should be valid</verify>
  <done>DigestQueueItem model added to schema for storing pending digest items</done>
</task>

<task type="auto">
  <name>Task 2: Create DigestService with scheduling</name>
  <files>apps/backend/src/modules/notifications/services/digest.service.ts</files>
  <action>
Create **digest.service.ts** with scheduling and aggregation:

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { PrismaService } from '../../prisma/prisma.service';
import { EmailTemplateService } from './email-template.service';
import { PreferenceService } from './preference.service';
import { OrgNotificationSettingsService } from './org-settings.service';
import { InjectQueue } from '@nestjs/bullmq';
import { Queue } from 'bullmq';
import { EMAIL_QUEUE_NAME } from '../../jobs/queues/email.queue';

interface DigestItem {
  type: string;
  entityType?: string;
  entityId?: string;
  metadata: Record<string, unknown>;
  createdAt: Date;
}

interface GroupedDigestItems {
  type: string;
  entityType?: string;
  entityId?: string;
  items: DigestItem[];
  count: number;
  latestAt: Date;
}

@Injectable()
export class DigestService {
  private readonly logger = new Logger(DigestService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly templateService: EmailTemplateService,
    private readonly preferenceService: PreferenceService,
    private readonly orgSettingsService: OrgNotificationSettingsService,
    @InjectQueue(EMAIL_QUEUE_NAME) private emailQueue: Queue,
  ) {}
}
```

Implement methods:

1. **queueForDigest(params: QueueForDigestParams)**: Promise<void>
   - Create DigestQueueItem record
   - Called by NotificationService when event is not urgent

2. **@Cron('0 * * * *') processDigestsHourly()**: Promise<void>
   - Run every hour on the hour
   - Get all organizations
   - For each org, check if current hour matches digestTime setting
   - If match, call processOrgDigest(organizationId)
   - This approach handles different digest times per org

3. **processOrgDigest(organizationId: string)**: Promise<void>
   - Get all users in org with unprocessed digest items
   - For each user:
     - Check if digest preference is enabled
     - Get pending items for user
     - If items exist, compile and send digest
     - Mark items as processed

4. **compileDigest(userId: string, organizationId: string, items: DigestQueueItem[])**: Promise<CompiledDigest>
   - Group items by type and entity for smart aggregation
   - Example: 3 comments on same case -> "3 new comments on Case #0912"
   - Sort groups by latestAt descending
   - Return grouped items for template rendering

5. **sendDigest(userId: string, organizationId: string, digest: CompiledDigest)**: Promise<void>
   - Load user email
   - Load org branding
   - Render digest template
   - Queue email job

Private helpers:
```typescript
private groupItems(items: DigestQueueItem[]): GroupedDigestItems[] {
  const groups = new Map<string, DigestItem[]>();

  for (const item of items) {
    // Group by type + entityType + entityId
    const key = `${item.type}:${item.entityType || ''}:${item.entityId || ''}`;
    const existing = groups.get(key) || [];
    existing.push({
      type: item.type,
      entityType: item.entityType,
      entityId: item.entityId,
      metadata: item.metadata,
      createdAt: item.createdAt,
    });
    groups.set(key, existing);
  }

  return Array.from(groups.entries()).map(([key, groupItems]) => ({
    type: groupItems[0].type,
    entityType: groupItems[0].entityType,
    entityId: groupItems[0].entityId,
    items: groupItems,
    count: groupItems.length,
    latestAt: new Date(Math.max(...groupItems.map(i => i.createdAt.getTime()))),
  }));
}

private getDigestSummary(group: GroupedDigestItems): string {
  // "3 new comments on Case #0912"
  // "2 status updates on Case #0913"
  const noun = group.count === 1 ? this.getTypeSingular(group.type) : this.getTypePlural(group.type);
  if (group.entityId) {
    return `${group.count} ${noun} on ${group.entityType} #${group.entityId}`;
  }
  return `${group.count} ${noun}`;
}
```
  </action>
  <verify>Run `cd apps/backend && npx tsc --noEmit` - service should compile</verify>
  <done>DigestService created with hourly scheduler and smart aggregation</done>
</task>

<task type="auto">
  <name>Task 3: Create digest email template</name>
  <files>
    apps/backend/src/modules/notifications/templates/digest/daily-digest.mjml.hbs
    apps/backend/src/modules/notifications/notifications.module.ts
  </files>
  <action>
Create **templates/digest/daily-digest.mjml.hbs**:

```handlebars
{{!-- Subject: Your Daily Compliance Update - {{formatDate today}} --}}
<mj-section background-color="#ffffff" border-radius="8px" padding="24px">
  <mj-column>
    <mj-text font-size="22px" font-weight="bold" color="#111827">
      Your Daily Update
    </mj-text>
    <mj-text font-size="14px" color="#6b7280">
      {{formatDate today}} - Here's what happened today
    </mj-text>

    <mj-divider border-color="#e5e7eb" padding="16px 0" />

    {{#if (gt groups.length 0)}}
      {{#each groups}}
        <mj-text font-size="16px" color="#374151" padding-top="12px">
          {{#if (gt count 1)}}
            <strong>{{count}}x</strong>
          {{/if}}
          {{summary}}
        </mj-text>

        {{#if entityId}}
          <mj-button href="{{../appUrl}}/{{entityType}}s/{{entityId}}"
                     background-color="#f3f4f6"
                     color="#374151"
                     border-radius="6px"
                     font-size="13px"
                     padding="8px 0">
            View {{capitalize entityType}}
          </mj-button>
        {{/if}}

        {{#unless @last}}
          <mj-divider border-color="#f3f4f6" border-width="1px" padding="8px 0" />
        {{/unless}}
      {{/each}}
    {{else}}
      <mj-text font-size="14px" color="#6b7280" align="center" padding="24px 0">
        No updates today. Great job staying on top of things!
      </mj-text>
    {{/if}}

    <mj-divider border-color="#e5e7eb" padding="16px 0" />

    <mj-button href="{{appUrl}}/notifications"
               background-color="{{default org.branding.primaryColor '#2563eb'}}"
               border-radius="6px">
      View All Notifications
    </mj-button>
  </mj-column>
</mj-section>
```

Update **notifications.module.ts** to include DigestService:
```typescript
import { ScheduleModule } from '@nestjs/schedule';
import { DigestService } from './services/digest.service';

@Module({
  imports: [
    PrismaModule,
    CacheModule.register({ ttl: 5 * 60 * 1000 }),
    BullModule.registerQueue({ name: EMAIL_QUEUE_NAME }),
    ScheduleModule.forRoot(), // Enable scheduling
  ],
  providers: [
    // ... existing providers
    DigestService,
  ],
  exports: [
    // ... existing exports
  ],
})
export class NotificationsModule {}
```

Update services/index.ts to export DigestService.
  </action>
  <verify>Template file exists and contains valid MJML structure</verify>
  <done>Digest template and scheduler integration completed</done>
</task>

</tasks>

<verification>
1. `cd apps/backend && npx prisma validate` passes with DigestQueueItem model
2. `cd apps/backend && npx tsc --noEmit` passes
3. DigestService has @Cron decorator for hourly processing
4. Digest template handles grouped items with counts
5. Service is registered in NotificationsModule
</verification>

<success_criteria>
- DigestQueueItem model stores pending digest notifications
- Hourly scheduler checks each org's digest time and processes when matched
- Smart aggregation groups similar events (e.g., "3 comments on Case #X")
- Digest respects user preferences (only sent if digest.enabled = true)
- Digest template shows grouped notifications with action links
- Items marked as processed after digest is sent
</success_criteria>

<output>
After completion, create `.planning/phases/07-notifications-email/07-06-SUMMARY.md`
</output>
