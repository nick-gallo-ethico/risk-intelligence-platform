---
phase: 07-notifications-email
plan: 08
type: execute
wave: 4
depends_on: ["07-03", "07-04", "07-05"]
files_modified:
  - apps/backend/src/modules/notifications/controllers/notifications.controller.ts
  - apps/backend/src/modules/notifications/controllers/preferences.controller.ts
  - apps/backend/src/modules/notifications/notifications.module.ts
  - apps/backend/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "Users can list their notifications with pagination and filtering"
    - "Users can mark notifications as read"
    - "Users can update their notification preferences"
    - "Admins can update organization notification settings"
    - "All endpoints enforce tenant isolation via organization context"
  artifacts:
    - path: "apps/backend/src/modules/notifications/controllers/notifications.controller.ts"
      provides: "REST API for notification CRUD operations"
      exports: ["NotificationsController"]
      min_lines: 100
    - path: "apps/backend/src/modules/notifications/controllers/preferences.controller.ts"
      provides: "REST API for preference management"
      exports: ["PreferencesController"]
      min_lines: 80
  key_links:
    - from: "apps/backend/src/modules/notifications/controllers/notifications.controller.ts"
      to: "apps/backend/src/modules/notifications/services/notification.service.ts"
      via: "Service injection"
      pattern: "NotificationService"
    - from: "apps/backend/src/app.module.ts"
      to: "apps/backend/src/modules/notifications/notifications.module.ts"
      via: "Module import"
      pattern: "NotificationsModule"
---

<objective>
Create REST API controllers for notification and preference management.

Purpose: Expose notification functionality via REST endpoints for listing, reading, and preference management.
Output: NotificationsController and PreferencesController with proper guards and validation.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-notifications-email/07-CONTEXT.md
@.planning/phases/07-notifications-email/07-RESEARCH.md
@.planning/phases/07-notifications-email/07-03-PLAN.md
@.planning/phases/07-notifications-email/07-04-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NotificationsController</name>
  <files>apps/backend/src/modules/notifications/controllers/notifications.controller.ts</files>
  <action>
Create **notifications.controller.ts**:

```typescript
import {
  Controller,
  Get,
  Post,
  Patch,
  Query,
  Body,
  Param,
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiBearerAuth, ApiResponse } from '@nestjs/swagger';
import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
import { CurrentUser } from '../../auth/decorators/current-user.decorator';
import { NotificationService } from '../services/notification.service';
import {
  NotificationQueryDto,
  MarkReadDto,
  NotificationResponseDto,
  PaginatedNotificationsDto,
} from '../dto/notification.dto';
import { User } from '@prisma/client';

@ApiTags('Notifications')
@ApiBearerAuth()
@Controller('api/v1/notifications')
@UseGuards(JwtAuthGuard)
export class NotificationsController {
  constructor(private readonly notificationService: NotificationService) {}

  @Get()
  @ApiOperation({ summary: 'List notifications for current user' })
  @ApiResponse({ status: 200, type: PaginatedNotificationsDto })
  async list(
    @CurrentUser() user: User,
    @Query() query: NotificationQueryDto,
  ): Promise<PaginatedNotificationsDto> {
    return this.notificationService.getNotifications(
      user.organizationId,
      user.id,
      query,
    );
  }

  @Get('unread-count')
  @ApiOperation({ summary: 'Get unread notification count' })
  @ApiResponse({ status: 200, schema: { properties: { count: { type: 'number' } } } })
  async getUnreadCount(
    @CurrentUser() user: User,
  ): Promise<{ count: number }> {
    const count = await this.notificationService.getUnreadCount(
      user.organizationId,
      user.id,
    );
    return { count };
  }

  @Get('recent')
  @ApiOperation({ summary: 'Get recent notifications (poll fallback)' })
  @ApiResponse({ status: 200, type: [NotificationResponseDto] })
  async getRecent(
    @CurrentUser() user: User,
    @Query('limit') limit?: number,
    @Query('since') since?: string,
  ): Promise<NotificationResponseDto[]> {
    return this.notificationService.getRecentNotifications(
      user.organizationId,
      user.id,
      limit || 20,
      since ? new Date(since) : undefined,
    );
  }

  @Post('mark-read')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Mark notifications as read' })
  @ApiResponse({ status: 200, schema: { properties: { marked: { type: 'number' } } } })
  async markAsRead(
    @CurrentUser() user: User,
    @Body() dto: MarkReadDto,
  ): Promise<{ marked: number }> {
    await this.notificationService.markAsRead(
      user.organizationId,
      user.id,
      dto.notificationIds,
    );
    return { marked: dto.notificationIds.length };
  }

  @Post('mark-all-read')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Mark all notifications as read' })
  @ApiResponse({ status: 200, schema: { properties: { marked: { type: 'number' } } } })
  async markAllAsRead(
    @CurrentUser() user: User,
  ): Promise<{ marked: number }> {
    const count = await this.notificationService.markAllAsRead(
      user.organizationId,
      user.id,
    );
    return { marked: count };
  }

  @Post(':id/archive')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Archive a notification' })
  async archive(
    @CurrentUser() user: User,
    @Param('id') id: string,
  ): Promise<void> {
    await this.notificationService.archiveNotification(
      user.organizationId,
      user.id,
      id,
    );
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get a specific notification' })
  @ApiResponse({ status: 200, type: NotificationResponseDto })
  async getOne(
    @CurrentUser() user: User,
    @Param('id') id: string,
  ): Promise<NotificationResponseDto> {
    return this.notificationService.getNotification(
      user.organizationId,
      user.id,
      id,
    );
  }
}
```

Add helper methods to NotificationService if not exists:
- markAllAsRead(organizationId, userId): Promise<number>
- archiveNotification(organizationId, userId, notificationId): Promise<void>
- getNotification(organizationId, userId, id): Promise<Notification>
  </action>
  <verify>Run `cd apps/backend && npx tsc --noEmit` - controller should compile</verify>
  <done>NotificationsController created with list, read, and archive endpoints</done>
</task>

<task type="auto">
  <name>Task 2: Create PreferencesController</name>
  <files>apps/backend/src/modules/notifications/controllers/preferences.controller.ts</files>
  <action>
Create **preferences.controller.ts**:

```typescript
import {
  Controller,
  Get,
  Put,
  Post,
  Delete,
  Body,
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiBearerAuth, ApiResponse } from '@nestjs/swagger';
import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../../auth/guards/roles.guard';
import { Roles } from '../../auth/decorators/roles.decorator';
import { CurrentUser } from '../../auth/decorators/current-user.decorator';
import { PreferenceService } from '../services/preference.service';
import { OrgNotificationSettingsService } from '../services/org-settings.service';
import {
  UpdatePreferencesDto,
  PreferencesResponseDto,
  SetOOODto,
  UpdateOrgSettingsDto,
  OrgSettingsResponseDto,
} from '../dto/notification.dto';
import { User, Role } from '@prisma/client';

@ApiTags('Notification Preferences')
@ApiBearerAuth()
@Controller('api/v1/notifications/preferences')
@UseGuards(JwtAuthGuard)
export class PreferencesController {
  constructor(
    private readonly preferenceService: PreferenceService,
    private readonly orgSettingsService: OrgNotificationSettingsService,
  ) {}

  @Get()
  @ApiOperation({ summary: 'Get current user notification preferences' })
  @ApiResponse({ status: 200, type: PreferencesResponseDto })
  async getPreferences(
    @CurrentUser() user: User,
  ): Promise<PreferencesResponseDto> {
    const prefs = await this.preferenceService.getPreferences(
      user.id,
      user.organizationId,
    );
    const orgSettings = await this.orgSettingsService.getSettings(
      user.organizationId,
    );

    return {
      ...prefs,
      enforcedCategories: orgSettings.enforcedCategories,
    };
  }

  @Put()
  @ApiOperation({ summary: 'Update notification preferences' })
  @ApiResponse({ status: 200, type: PreferencesResponseDto })
  async updatePreferences(
    @CurrentUser() user: User,
    @Body() dto: UpdatePreferencesDto,
  ): Promise<PreferencesResponseDto> {
    await this.preferenceService.updatePreferences(
      user.id,
      user.organizationId,
      dto,
    );
    return this.getPreferences(user);
  }

  @Post('ooo')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Set out-of-office status with backup' })
  async setOOO(
    @CurrentUser() user: User,
    @Body() dto: SetOOODto,
  ): Promise<void> {
    await this.preferenceService.setOOO(
      user.id,
      user.organizationId,
      dto.backupUserId,
      new Date(dto.oooUntil),
    );
  }

  @Delete('ooo')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Clear out-of-office status' })
  async clearOOO(
    @CurrentUser() user: User,
  ): Promise<void> {
    await this.preferenceService.clearOOO(
      user.id,
      user.organizationId,
    );
  }

  // Organization settings - admin only
  @Get('org-settings')
  @UseGuards(RolesGuard)
  @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER)
  @ApiOperation({ summary: 'Get organization notification settings' })
  @ApiResponse({ status: 200, type: OrgSettingsResponseDto })
  async getOrgSettings(
    @CurrentUser() user: User,
  ): Promise<OrgSettingsResponseDto> {
    return this.orgSettingsService.getSettings(user.organizationId);
  }

  @Put('org-settings')
  @UseGuards(RolesGuard)
  @Roles(Role.SYSTEM_ADMIN)
  @ApiOperation({ summary: 'Update organization notification settings' })
  @ApiResponse({ status: 200, type: OrgSettingsResponseDto })
  async updateOrgSettings(
    @CurrentUser() user: User,
    @Body() dto: UpdateOrgSettingsDto,
  ): Promise<OrgSettingsResponseDto> {
    await this.orgSettingsService.updateSettings(
      user.organizationId,
      dto,
    );
    return this.orgSettingsService.getSettings(user.organizationId);
  }
}
```

Add DTOs if not exists:
```typescript
// In notification.dto.ts
export class SetOOODto {
  @IsString()
  backupUserId: string;

  @IsISO8601()
  oooUntil: string;
}

export class UpdateOrgSettingsDto {
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  enforcedCategories?: string[];

  @IsOptional()
  @Matches(/^\d{2}:\d{2}$/)
  digestTime?: string;

  @IsOptional()
  @Matches(/^\d{2}:\d{2}$/)
  defaultQuietHoursStart?: string;

  @IsOptional()
  @Matches(/^\d{2}:\d{2}$/)
  defaultQuietHoursEnd?: string;
}
```
  </action>
  <verify>Run `cd apps/backend && npx tsc --noEmit` - controller should compile</verify>
  <done>PreferencesController created with user and org settings endpoints</done>
</task>

<task type="auto">
  <name>Task 3: Register module in AppModule and finalize exports</name>
  <files>
    apps/backend/src/modules/notifications/notifications.module.ts
    apps/backend/src/modules/notifications/controllers/index.ts
    apps/backend/src/app.module.ts
  </files>
  <action>
Update **notifications.module.ts** with controllers:

```typescript
import { Module } from '@nestjs/common';
import { CacheModule } from '@nestjs/cache-manager';
import { BullModule } from '@nestjs/bullmq';
import { ScheduleModule } from '@nestjs/schedule';
import { MailerModule } from '@nestjs-modules/mailer';
import { ConfigModule, ConfigService } from '@nestjs/config';

import { PrismaModule } from '../prisma/prisma.module';
import { EMAIL_QUEUE_NAME } from '../jobs/queues/email.queue';
import { mailerConfig } from './mailer.config';

// Services
import { PreferenceService } from './services/preference.service';
import { OrgNotificationSettingsService } from './services/org-settings.service';
import { EmailTemplateService } from './services/email-template.service';
import { NotificationService } from './services/notification.service';
import { DeliveryTrackerService } from './services/delivery-tracker.service';
import { DigestService } from './services/digest.service';

// Listeners
import { CaseEventListener } from './listeners/case.listener';
import { SlaEventListener } from './listeners/sla.listener';
import { WorkflowEventListener } from './listeners/workflow.listener';

// Gateways
import { NotificationGateway } from './gateways/notification.gateway';

// Controllers
import { NotificationsController } from './controllers/notifications.controller';
import { PreferencesController } from './controllers/preferences.controller';
import { WebhookController } from './controllers/webhook.controller';

@Module({
  imports: [
    PrismaModule,
    CacheModule.register({ ttl: 5 * 60 * 1000 }),
    BullModule.registerQueue({ name: EMAIL_QUEUE_NAME }),
    ScheduleModule.forRoot(),
    MailerModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: mailerConfig,
      inject: [ConfigService],
    }),
  ],
  controllers: [
    NotificationsController,
    PreferencesController,
    WebhookController,
  ],
  providers: [
    // Services
    PreferenceService,
    OrgNotificationSettingsService,
    EmailTemplateService,
    NotificationService,
    DeliveryTrackerService,
    DigestService,
    // Listeners
    CaseEventListener,
    SlaEventListener,
    WorkflowEventListener,
    // Gateways
    NotificationGateway,
  ],
  exports: [
    NotificationService,
    PreferenceService,
    OrgNotificationSettingsService,
  ],
})
export class NotificationsModule {}
```

Create **controllers/index.ts**:
```typescript
export * from './notifications.controller';
export * from './preferences.controller';
export * from './webhook.controller';
```

Update **app.module.ts** to import NotificationsModule:
```typescript
import { NotificationsModule } from './modules/notifications/notifications.module';

@Module({
  imports: [
    // ... existing imports
    NotificationsModule,
  ],
  // ...
})
export class AppModule {}
```
  </action>
  <verify>Run `cd apps/backend && npx tsc --noEmit` - full module should compile</verify>
  <done>NotificationsModule fully registered with all services, controllers, and gateway</done>
</task>

</tasks>

<verification>
1. `cd apps/backend && npx tsc --noEmit` passes
2. Controllers are registered in NotificationsModule
3. NotificationsModule is imported in AppModule
4. REST endpoints documented with Swagger decorators
5. RBAC guards protect org-settings endpoints (SYSTEM_ADMIN only)
</verification>

<success_criteria>
- GET /api/v1/notifications lists user notifications with pagination
- POST /api/v1/notifications/mark-read marks specific notifications as read
- GET /api/v1/notifications/preferences returns user preferences + enforced categories
- PUT /api/v1/notifications/preferences updates user preferences
- PUT /api/v1/notifications/preferences/org-settings updates org settings (admin only)
- POST /api/v1/notifications/preferences/ooo sets out-of-office with backup
- All endpoints enforce tenant isolation via user.organizationId
</success_criteria>

<output>
After completion, create `.planning/phases/07-notifications-email/07-08-SUMMARY.md`
</output>
