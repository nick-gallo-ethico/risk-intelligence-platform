---
phase: 07-notifications-email
plan: 04
type: execute
wave: 2
depends_on: ["07-01", "07-02", "07-03"]
files_modified:
  - apps/backend/src/modules/notifications/services/notification.service.ts
  - apps/backend/src/modules/notifications/listeners/case.listener.ts
  - apps/backend/src/modules/notifications/listeners/workflow.listener.ts
  - apps/backend/src/modules/notifications/listeners/sla.listener.ts
  - apps/backend/src/modules/notifications/notifications.module.ts
  - apps/backend/src/modules/events/events/index.ts
autonomous: true

must_haves:
  truths:
    - "Domain events trigger notification dispatch through listeners"
    - "Notification service checks user preferences before sending"
    - "Email notifications are pre-rendered before queueing"
    - "Urgent notifications bypass quiet hours"
    - "OOO users have notifications delegated to backup"
  artifacts:
    - path: "apps/backend/src/modules/notifications/services/notification.service.ts"
      provides: "NotificationService with queueEmail, sendInApp, queueForDigest methods"
      exports: ["NotificationService"]
      min_lines: 200
    - path: "apps/backend/src/modules/notifications/listeners/case.listener.ts"
      provides: "CaseEventListener handling case.assigned, case.status_changed, etc."
      exports: ["CaseEventListener"]
      min_lines: 80
  key_links:
    - from: "apps/backend/src/modules/notifications/listeners/case.listener.ts"
      to: "apps/backend/src/modules/events/events/case.events.ts"
      via: "@OnEvent decorators"
      pattern: "@OnEvent\\('case\\."
    - from: "apps/backend/src/modules/notifications/services/notification.service.ts"
      to: "apps/backend/src/modules/jobs/queues/email.queue.ts"
      via: "BullMQ queue injection"
      pattern: "@InjectQueue\\(EMAIL_QUEUE_NAME\\)"
---

<objective>
Create the core notification service and event listeners for dispatching notifications.

Purpose: Listen to domain events (case assigned, SLA warning, etc.) and dispatch notifications through email and in-app channels based on user preferences.
Output: NotificationService and event listeners that bridge domain events to notification delivery.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-notifications-email/07-CONTEXT.md
@.planning/phases/07-notifications-email/07-RESEARCH.md
@.planning/phases/07-notifications-email/07-01-PLAN.md

Reference existing infrastructure:
@apps/backend/src/modules/events/events/case.events.ts
@apps/backend/src/modules/events/events/base.event.ts
@apps/backend/src/modules/jobs/queues/email.queue.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NotificationService core</name>
  <files>apps/backend/src/modules/notifications/services/notification.service.ts</files>
  <action>
Create **notification.service.ts** as the central notification dispatch service:

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bullmq';
import { Queue } from 'bullmq';
import { PrismaService } from '../../prisma/prisma.service';
import { PreferenceService } from './preference.service';
import { EmailTemplateService } from './email-template.service';
import { EMAIL_QUEUE_NAME } from '../../jobs/queues/email.queue';
import {
  QueueEmailParams,
  SendInAppParams,
  QueueForDigestParams,
  NotificationCategory,
} from '../entities/notification.types';

@Injectable()
export class NotificationService {
  private readonly logger = new Logger(NotificationService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly preferenceService: PreferenceService,
    private readonly templateService: EmailTemplateService,
    @InjectQueue(EMAIL_QUEUE_NAME) private emailQueue: Queue,
  ) {}
}
```

Implement methods:

1. **queueEmail(params: QueueEmailParams)**: Promise<void>
   - Load user for email address
   - Check effective preferences (handles OOO, quiet hours, org enforcement)
   - If OOO with backup, redirect to backup user
   - If quiet hours and not urgent, skip (will be in digest)
   - Load org branding for template context
   - Pre-render template using EmailTemplateService (NOT in queue worker per RESEARCH.md pitfall)
   - Create Notification record with status QUEUED
   - Queue job with rendered HTML, notificationId, priority based on urgency

2. **sendInApp(params: SendInAppParams)**: Promise<Notification>
   - Check effective preferences
   - Create Notification record with channel IN_APP, status DELIVERED
   - Emit event for WebSocket delivery (gateway will subscribe)
   - Return created notification

3. **queueForDigest(params: QueueForDigestParams)**: Promise<void>
   - Store in DigestQueue table (to be created) for batch processing
   - Fields: organizationId, userId, type, entityType, entityId, metadata, createdAt
   - DigestService (Plan 07-06) will process these

4. **notify(params: NotifyParams)**: Promise<void>
   - High-level method that checks preferences and routes to appropriate channel(s)
   - Calls queueEmail and/or sendInApp based on effective preferences
   - Used by event listeners

5. **getNotifications(organizationId: string, userId: string, query: NotificationQueryDto)**: Promise<PaginatedNotifications>
   - Query notifications for a user
   - Filter by channel, type, isRead
   - Paginate with limit/offset

6. **markAsRead(organizationId: string, userId: string, notificationIds: string[])**: Promise<void>
   - Update notifications to isRead=true, readAt=now()
   - Verify notifications belong to user/org

7. **archiveRead(organizationId: string, userId: string, olderThan: Date)**: Promise<number>
   - Archive read notifications older than specified date
   - Return count of archived

Helper types:
```typescript
interface NotifyParams {
  organizationId: string;
  recipientUserId: string;
  category: NotificationCategory;
  type: NotificationType;
  templateId: string;
  context: Record<string, unknown>;
  entityType?: string;
  entityId?: string;
  isUrgent?: boolean;
}
```
  </action>
  <verify>Run `cd apps/backend && npx tsc --noEmit` - should compile without errors</verify>
  <done>NotificationService is created with email queueing, in-app sending, and digest queueing</done>
</task>

<task type="auto">
  <name>Task 2: Create event listeners</name>
  <files>
    apps/backend/src/modules/notifications/listeners/case.listener.ts
    apps/backend/src/modules/notifications/listeners/workflow.listener.ts
    apps/backend/src/modules/notifications/listeners/sla.listener.ts
    apps/backend/src/modules/notifications/listeners/index.ts
  </files>
  <action>
Create event listeners that subscribe to domain events and dispatch notifications.

**case.listener.ts**:
```typescript
import { Injectable, Logger } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';
import { NotificationService } from '../services/notification.service';
import {
  CaseAssignedEvent,
  CaseStatusChangedEvent,
} from '../../events/events/case.events';

@Injectable()
export class CaseEventListener {
  private readonly logger = new Logger(CaseEventListener.name);

  constructor(private readonly notificationService: NotificationService) {}

  @OnEvent('case.assigned', { async: true })
  async handleCaseAssigned(event: CaseAssignedEvent): Promise<void> {
    this.logger.debug(`Handling case.assigned for case ${event.caseId}`);

    await this.notificationService.notify({
      organizationId: event.organizationId,
      recipientUserId: event.newAssigneeId,
      category: 'ASSIGNMENT',
      type: 'ASSIGNMENT',
      templateId: 'assignment/case-assigned',
      context: {
        caseId: event.caseId,
        referenceNumber: event.referenceNumber,
        assignedBy: event.actorUserId,
        severity: event.severity,
        categoryName: event.categoryName,
      },
      entityType: 'case',
      entityId: event.caseId,
      isUrgent: true, // Assignments are always urgent per CONTEXT.md
    });
  }

  @OnEvent('case.status_changed', { async: true })
  async handleStatusChanged(event: CaseStatusChangedEvent): Promise<void> {
    // Status changes go to digest per CONTEXT.md (not urgent)
    await this.notificationService.queueForDigest({
      organizationId: event.organizationId,
      userId: event.previousAssigneeId, // Notify assignee of status change
      type: 'STATUS_UPDATE',
      entityType: 'case',
      entityId: event.caseId,
      metadata: {
        previousStatus: event.previousStatus,
        newStatus: event.newStatus,
      },
    });
  }
}
```

**sla.listener.ts**:
```typescript
@Injectable()
export class SlaEventListener {
  @OnEvent('sla.warning', { async: true })
  async handleSlaWarning(event: SlaWarningEvent): Promise<void> {
    // SLA warnings are urgent - notify assignee
    await this.notificationService.notify({
      organizationId: event.organizationId,
      recipientUserId: event.assigneeId,
      category: 'DEADLINE',
      type: 'DEADLINE',
      templateId: 'deadline/sla-warning',
      context: {
        caseId: event.caseId,
        referenceNumber: event.referenceNumber,
        hoursRemaining: event.hoursRemaining,
        dueDate: event.dueDate,
      },
      entityType: 'case',
      entityId: event.caseId,
      isUrgent: true,
    });
  }

  @OnEvent('sla.breached', { async: true })
  async handleSlaBreach(event: SlaBreachedEvent): Promise<void> {
    // Notify assignee + supervisor per CONTEXT.md
    // Assignee notification
    await this.notificationService.notify({
      organizationId: event.organizationId,
      recipientUserId: event.assigneeId,
      category: 'ESCALATION',
      type: 'ESCALATION',
      templateId: 'deadline/sla-breach',
      context: { ... },
      isUrgent: true,
    });

    // Supervisor notification if available
    if (event.supervisorId) {
      await this.notificationService.notify({
        ...
        recipientUserId: event.supervisorId,
        templateId: 'deadline/sla-breach-escalation',
      });
    }
  }
}
```

**workflow.listener.ts**:
- Handle workflow.step_completed (notify next assignee)
- Handle workflow.approval_needed (notify approver)

Use `{ async: true }` on all @OnEvent decorators per RESEARCH.md to prevent blocking.
  </action>
  <verify>Run `cd apps/backend && npx tsc --noEmit` - listeners should compile</verify>
  <done>Event listeners created for case, SLA, and workflow events</done>
</task>

<task type="auto">
  <name>Task 3: Add new event types and update module</name>
  <files>
    apps/backend/src/modules/events/events/sla.events.ts
    apps/backend/src/modules/events/events/index.ts
    apps/backend/src/modules/notifications/notifications.module.ts
  </files>
  <action>
Create **sla.events.ts** if not exists:
```typescript
import { BaseEvent } from './base.event';

export class SlaWarningEvent extends BaseEvent {
  static readonly eventName = 'sla.warning';

  readonly caseId: string;
  readonly referenceNumber: string;
  readonly assigneeId: string;
  readonly hoursRemaining: number;
  readonly dueDate: Date;
  readonly threshold: string; // 'WARNING_72H', 'WARNING_24H'

  constructor(data: Partial<SlaWarningEvent>) {
    super(data);
    // ... validation
  }
}

export class SlaBreachedEvent extends BaseEvent {
  static readonly eventName = 'sla.breached';

  readonly caseId: string;
  readonly referenceNumber: string;
  readonly assigneeId: string;
  readonly supervisorId?: string;
  readonly hoursOverdue: number;

  constructor(data: Partial<SlaBreachedEvent>) {
    super(data);
    // ... validation
  }
}

export class SlaCriticalEvent extends BaseEvent {
  static readonly eventName = 'sla.critical';
  // At 48h+ overdue, escalate to compliance officer per CONTEXT.md
  readonly complianceOfficerId: string;
  // ... other fields
}
```

Update **events/index.ts** to export new events.

Update **notifications.module.ts**:
```typescript
@Module({
  imports: [
    PrismaModule,
    CacheModule.register({ ttl: 5 * 60 * 1000 }),
    BullModule.registerQueue({ name: EMAIL_QUEUE_NAME }),
  ],
  providers: [
    PreferenceService,
    OrgNotificationSettingsService,
    EmailTemplateService,
    NotificationService,
    CaseEventListener,
    SlaEventListener,
    WorkflowEventListener,
  ],
  exports: [
    PreferenceService,
    OrgNotificationSettingsService,
    NotificationService,
  ],
})
export class NotificationsModule {}
```
  </action>
  <verify>Run `cd apps/backend && npx tsc --noEmit` - all new files should compile</verify>
  <done>SLA events created and module updated with all services and listeners</done>
</task>

</tasks>

<verification>
1. `cd apps/backend && npx tsc --noEmit` passes
2. NotificationService has queueEmail, sendInApp, queueForDigest, notify methods
3. Event listeners use `{ async: true }` per RESEARCH.md recommendations
4. SLA event types are exported from events module
5. All listeners are registered in NotificationsModule
</verification>

<success_criteria>
- NotificationService is the central dispatch point for all notifications
- Event listeners subscribe to domain events with async handlers (non-blocking)
- User preferences are checked before notification dispatch
- Urgent notifications (assignments, SLA, escalations) bypass quiet hours
- OOO delegation redirects to backup user
- Email templates are pre-rendered before queueing (not in worker)
</success_criteria>

<output>
After completion, create `.planning/phases/07-notifications-email/07-04-SUMMARY.md`
</output>
