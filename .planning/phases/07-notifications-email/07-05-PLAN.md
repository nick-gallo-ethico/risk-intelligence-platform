---
phase: 07-notifications-email
plan: 05
type: execute
wave: 3
depends_on: ["07-04"]
files_modified:
  - apps/backend/src/modules/notifications/gateways/notification.gateway.ts
  - apps/backend/src/modules/notifications/services/notification.service.ts
  - apps/backend/src/modules/notifications/notifications.module.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket gateway delivers in-app notifications instantly to connected users"
    - "Unread count is sent to clients on connection and after each notification"
    - "Clients in background tabs poll every 60 seconds for missed notifications"
    - "Room naming includes organizationId for tenant isolation"
    - "JWT authentication is verified on WebSocket handshake"
  artifacts:
    - path: "apps/backend/src/modules/notifications/gateways/notification.gateway.ts"
      provides: "NotificationGateway with WebSocket notification delivery"
      exports: ["NotificationGateway"]
      min_lines: 120
  key_links:
    - from: "apps/backend/src/modules/notifications/gateways/notification.gateway.ts"
      to: "apps/backend/src/modules/notifications/services/notification.service.ts"
      via: "EventEmitter subscription for in-app notifications"
      pattern: "@OnEvent\\('notification\\.in_app'"
    - from: "apps/backend/src/modules/notifications/gateways/notification.gateway.ts"
      to: "client WebSocket"
      via: "socket.io emit"
      pattern: "client\\.emit\\('notification"
---

<objective>
Create the WebSocket gateway for real-time in-app notification delivery.

Purpose: Enable instant notification delivery to connected users with proper tenant isolation, authentication, and fallback for disconnected clients.
Output: NotificationGateway handling WebSocket connections and notification pushes.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-notifications-email/07-CONTEXT.md
@.planning/phases/07-notifications-email/07-RESEARCH.md
@.planning/phases/07-notifications-email/07-04-PLAN.md

Reference existing gateway pattern:
@apps/backend/src/modules/ai/ai.gateway.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NotificationGateway</name>
  <files>apps/backend/src/modules/notifications/gateways/notification.gateway.ts</files>
  <action>
Create **notification.gateway.ts** following the existing AiGateway pattern:

```typescript
import {
  WebSocketGateway,
  WebSocketServer,
  OnGatewayConnection,
  OnGatewayDisconnect,
  SubscribeMessage,
  ConnectedSocket,
  MessageBody,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Logger } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';
import { NotificationService } from '../services/notification.service';
import { JwtService } from '../../auth/jwt.service';
import { InAppNotification } from '../entities/notification.types';

interface SocketContext {
  organizationId: string;
  userId: string;
  userRole: string;
}

/**
 * NotificationGateway provides WebSocket connectivity for real-time in-app notifications.
 *
 * Mounted at /notifications namespace.
 *
 * Room naming (CRITICAL for tenant isolation per RESEARCH.md):
 * - User room: `org:${organizationId}:user:${userId}`
 *
 * Events emitted to client:
 * - notification:new - New notification received
 * - notification:unread_count - Updated unread count
 * - notification:marked_read - Notification(s) marked as read
 *
 * Events from client:
 * - mark_read - Mark notification(s) as read
 * - get_unread_count - Request current unread count
 * - get_recent - Request recent notifications (poll fallback)
 */
@WebSocketGateway({
  namespace: '/notifications',
  cors: {
    origin: process.env.CORS_ORIGIN || '*',
    credentials: true,
  },
})
export class NotificationGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;

  private readonly logger = new Logger(NotificationGateway.name);
  private readonly userSockets = new Map<string, Set<string>>(); // userRoomKey -> socketIds

  constructor(
    private readonly notificationService: NotificationService,
    private readonly jwtService: JwtService,
  ) {}
}
```

Implement connection handling:

1. **handleConnection(client: Socket)**: Promise<void>
   - Extract JWT from handshake.auth.token
   - Verify token using JwtService
   - Extract organizationId, userId, userRole from token payload
   - Store context in client.data.context
   - Join user-specific room: `org:${organizationId}:user:${userId}`
   - Track socket in userSockets map
   - Immediately send unread count
   - Log connection for debugging

2. **handleDisconnect(client: Socket)**: void
   - Remove socket from userSockets map
   - Log disconnection

Implement event handlers:

3. **@SubscribeMessage('mark_read')**
   - Receive: { notificationIds: string[] }
   - Call notificationService.markAsRead()
   - Emit updated unread count to user

4. **@SubscribeMessage('get_unread_count')**
   - Get count from notificationService
   - Emit to requesting socket

5. **@SubscribeMessage('get_recent')**
   - Receive: { limit?: number, since?: Date }
   - Poll fallback for background tabs per CONTEXT.md
   - Return recent notifications (default last 20)

Implement notification delivery:

6. **@OnEvent('notification.in_app.created')**
   - Listen for in-app notification creation events
   - Build room key: `org:${notification.organizationId}:user:${notification.userId}`
   - Emit 'notification:new' to room
   - Emit updated 'notification:unread_count' to room

7. **sendToUser(userId: string, organizationId: string, notification: InAppNotification)**: void
   - Helper method called by NotificationService
   - Emits to user's room

Private helpers:
- **getUserRoomKey(organizationId: string, userId: string)**: string
- **extractContext(client: Socket)**: SocketContext | null
  </action>
  <verify>Run `cd apps/backend && npx tsc --noEmit` - gateway should compile</verify>
  <done>NotificationGateway is created with proper tenant-isolated room naming</done>
</task>

<task type="auto">
  <name>Task 2: Update NotificationService for WebSocket integration</name>
  <files>apps/backend/src/modules/notifications/services/notification.service.ts</files>
  <action>
Update **notification.service.ts** to emit events for WebSocket delivery:

Add EventEmitter2 injection:
```typescript
import { EventEmitter2 } from '@nestjs/event-emitter';

constructor(
  // ... existing injections
  private readonly eventEmitter: EventEmitter2,
) {}
```

Update **sendInApp** method:
```typescript
async sendInApp(params: SendInAppParams): Promise<Notification> {
  const { organizationId, recipientUserId, type, title, body, entityType, entityId } = params;

  // Create notification record
  const notification = await this.prisma.notification.create({
    data: {
      organizationId,
      userId: recipientUserId,
      channel: 'IN_APP',
      type,
      title,
      body,
      entityType,
      entityId,
      status: 'DELIVERED',
      isRead: false,
    },
  });

  // Emit event for WebSocket delivery
  this.eventEmitter.emit('notification.in_app.created', {
    id: notification.id,
    organizationId,
    userId: recipientUserId,
    type,
    title,
    body,
    entityType,
    entityId,
    createdAt: notification.createdAt,
  });

  return notification;
}
```

Add method to get unread count efficiently:
```typescript
async getUnreadCount(organizationId: string, userId: string): Promise<number> {
  return this.prisma.notification.count({
    where: {
      organizationId,
      userId,
      channel: 'IN_APP',
      isRead: false,
      status: { not: 'ARCHIVED' },
    },
  });
}

async getRecentNotifications(
  organizationId: string,
  userId: string,
  limit: number = 20,
  since?: Date,
): Promise<Notification[]> {
  return this.prisma.notification.findMany({
    where: {
      organizationId,
      userId,
      channel: 'IN_APP',
      status: { not: 'ARCHIVED' },
      ...(since && { createdAt: { gt: since } }),
    },
    orderBy: { createdAt: 'desc' },
    take: limit,
  });
}
```
  </action>
  <verify>Run `cd apps/backend && npx tsc --noEmit` - service updates should compile</verify>
  <done>NotificationService emits events for WebSocket gateway to deliver</done>
</task>

<task type="auto">
  <name>Task 3: Register gateway in module and add client types</name>
  <files>
    apps/backend/src/modules/notifications/notifications.module.ts
    apps/backend/src/modules/notifications/dto/websocket.dto.ts
    apps/backend/src/modules/notifications/gateways/index.ts
  </files>
  <action>
Update **notifications.module.ts**:
```typescript
import { NotificationGateway } from './gateways/notification.gateway';

@Module({
  imports: [
    PrismaModule,
    CacheModule.register({ ttl: 5 * 60 * 1000 }),
    BullModule.registerQueue({ name: EMAIL_QUEUE_NAME }),
    EventEmitterModule, // Should already be global from Phase 1
  ],
  providers: [
    // Services
    PreferenceService,
    OrgNotificationSettingsService,
    EmailTemplateService,
    NotificationService,
    // Listeners
    CaseEventListener,
    SlaEventListener,
    WorkflowEventListener,
    // Gateways
    NotificationGateway,
  ],
  exports: [
    PreferenceService,
    OrgNotificationSettingsService,
    NotificationService,
  ],
})
export class NotificationsModule {}
```

Create **websocket.dto.ts** for WebSocket message types:
```typescript
export interface MarkReadPayload {
  notificationIds: string[];
}

export interface GetRecentPayload {
  limit?: number;
  since?: string; // ISO date string
}

export interface NotificationNewEvent {
  id: string;
  type: string;
  title: string;
  body?: string;
  entityType?: string;
  entityId?: string;
  createdAt: Date;
}

export interface UnreadCountEvent {
  count: number;
}
```

Create **gateways/index.ts** barrel file:
```typescript
export * from './notification.gateway';
```
  </action>
  <verify>Run `cd apps/backend && npx tsc --noEmit` - module should compile with gateway registered</verify>
  <done>Gateway is registered in module and DTO types are defined</done>
</task>

</tasks>

<verification>
1. `cd apps/backend && npx tsc --noEmit` passes
2. NotificationGateway mounted at /notifications namespace
3. Room naming includes organizationId: `org:${orgId}:user:${userId}`
4. JWT verification on handshake (uses existing JwtService)
5. Gateway registered in NotificationsModule
</verification>

<success_criteria>
- WebSocket gateway delivers notifications to connected users instantly
- Tenant isolation enforced via room naming (org:orgId:user:userId)
- JWT authentication verified on connection handshake
- Clients receive unread count on connection and after each notification
- Poll fallback endpoint (get_recent) available for background tabs
- Event-driven architecture: NotificationService emits, Gateway listens and delivers
</success_criteria>

<output>
After completion, create `.planning/phases/07-notifications-email/07-05-SUMMARY.md`
</output>
