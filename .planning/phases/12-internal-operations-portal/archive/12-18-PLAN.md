---
phase: 12-internal-operations-portal
plan: 18
type: execute
wave: tech-debt
depends_on: []
files_modified:
  - apps/backend/test/e2e/websocket.e2e-spec.ts
  - apps/backend/test/e2e/ai-gateway.e2e-spec.ts
  - apps/backend/src/modules/auth/guards/jwt-ws.guard.ts
  - apps/backend/src/modules/auth/strategies/token-refresh.strategy.ts
  - apps/backend/src/modules/cases/case.service.ts
  - apps/backend/src/modules/investigations/investigation.service.ts
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/common/interceptors/query-optimizer.interceptor.ts
  - apps/backend/src/common/decorators/cache-key.decorator.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket E2E tests cover connection, authentication, room subscription"
    - "AI gateway E2E tests verify context loading, skill execution, streaming"
    - "Token refresh during WebSocket session handled gracefully"
    - "SSO timeout edge cases have retry logic"
    - "N+1 queries in case list and investigation detail resolved"
    - "PostgreSQL indexes added for common query patterns"
    - "Redis cache keys audited with consistent TTLs"
    - "Batch operation endpoints have pagination/limits"
  artifacts:
    - path: "apps/backend/test/e2e/websocket.e2e-spec.ts"
      provides: "End-to-end tests for WebSocket gateway"
      exports: []
    - path: "apps/backend/test/e2e/ai-gateway.e2e-spec.ts"
      provides: "End-to-end tests for AI WebSocket gateway"
      exports: []
    - path: "apps/backend/src/common/interceptors/query-optimizer.interceptor.ts"
      provides: "Query optimization with DataLoader pattern"
      exports: ["QueryOptimizerInterceptor"]
  key_links:
    - from: "websocket.e2e-spec.ts"
      to: "NotificationGateway"
      via: "Socket.io client testing"
      pattern: "io\\("
    - from: "case.service.ts"
      to: "DataLoader"
      via: "Batch loading relations"
      pattern: "dataLoader\\.load"
---

<objective>
Address accumulated backend technical debt: WebSocket E2E testing, auth edge cases, query optimization, index tuning, and batch operation limits.

Purpose: Ensure production readiness with comprehensive integration tests, efficient database queries, and proper API guardrails before launch.

Output: WebSocket and AI gateway E2E tests; auth improvements; query optimization with DataLoader; database indexes; batch endpoint limits.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-internal-operations-portal/CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebSocket and AI Gateway E2E Tests</name>
  <files>
    apps/backend/test/e2e/websocket.e2e-spec.ts
    apps/backend/test/e2e/ai-gateway.e2e-spec.ts
  </files>
  <action>
**test/e2e/websocket.e2e-spec.ts:**
```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import { Socket, io } from 'socket.io-client';
import { AppModule } from '../../src/app.module';
import { PrismaService } from '../../src/modules/prisma/prisma.service';
import { JwtService } from '@nestjs/jwt';

describe('WebSocket Gateway (E2E)', () => {
  let app: INestApplication;
  let prisma: PrismaService;
  let jwtService: JwtService;
  let socket: Socket;
  let validToken: string;
  let testUserId: string;
  let testTenantId: string;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
    await app.listen(3001);

    prisma = moduleFixture.get(PrismaService);
    jwtService = moduleFixture.get(JwtService);

    // Create test user and tenant
    const tenant = await prisma.organization.create({
      data: { name: 'Test Org', slug: 'test-org' },
    });
    testTenantId = tenant.id;

    const user = await prisma.user.create({
      data: {
        email: 'wstest@test.com',
        name: 'WS Test User',
        organizationId: tenant.id,
      },
    });
    testUserId = user.id;

    validToken = jwtService.sign({
      sub: user.id,
      tenantId: tenant.id,
      email: user.email,
    });
  });

  afterAll(async () => {
    await prisma.user.delete({ where: { id: testUserId } });
    await prisma.organization.delete({ where: { id: testTenantId } });
    await app.close();
  });

  beforeEach(() => {
    socket = io('http://localhost:3001/notifications', {
      auth: { token: validToken },
      transports: ['websocket'],
    });
  });

  afterEach(() => {
    socket.disconnect();
  });

  describe('Connection', () => {
    it('should connect with valid token', (done) => {
      socket.on('connect', () => {
        expect(socket.connected).toBe(true);
        done();
      });
    });

    it('should reject connection without token', (done) => {
      const unauthSocket = io('http://localhost:3001/notifications', {
        transports: ['websocket'],
      });

      unauthSocket.on('connect_error', (err) => {
        expect(err.message).toContain('unauthorized');
        unauthSocket.disconnect();
        done();
      });
    });

    it('should reject connection with invalid token', (done) => {
      const invalidSocket = io('http://localhost:3001/notifications', {
        auth: { token: 'invalid-token' },
        transports: ['websocket'],
      });

      invalidSocket.on('connect_error', (err) => {
        expect(err.message).toContain('unauthorized');
        invalidSocket.disconnect();
        done();
      });
    });
  });

  describe('Room Subscription', () => {
    it('should join user room on connect', (done) => {
      socket.on('connect', () => {
        // Server auto-joins user to their room
        socket.emit('debug:rooms', (rooms: string[]) => {
          expect(rooms).toContain(`user:${testUserId}`);
          done();
        });
      });
    });

    it('should receive notification in user room', (done) => {
      socket.on('connect', async () => {
        socket.on('notification:new', (data) => {
          expect(data.message).toBe('Test notification');
          done();
        });

        // Trigger notification from server
        const response = await fetch('http://localhost:3001/api/v1/test/trigger-notification', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${validToken}`,
          },
          body: JSON.stringify({ userId: testUserId, message: 'Test notification' }),
        });
      });
    });

    it('should NOT receive notifications for other users', (done) => {
      socket.on('connect', () => {
        socket.on('notification:new', () => {
          fail('Should not receive notification for other user');
        });

        // Wait and verify no notification received
        setTimeout(() => {
          done();
        }, 1000);
      });
    });
  });

  describe('Token Refresh During Session', () => {
    it('should handle token refresh gracefully', (done) => {
      socket.on('connect', () => {
        // Emit token refresh event
        const newToken = jwtService.sign({
          sub: testUserId,
          tenantId: testTenantId,
          email: 'wstest@test.com',
        });

        socket.emit('auth:refresh', { token: newToken }, (response: any) => {
          expect(response.success).toBe(true);
          expect(socket.connected).toBe(true);
          done();
        });
      });
    });

    it('should disconnect on invalid refresh token', (done) => {
      socket.on('connect', () => {
        socket.emit('auth:refresh', { token: 'invalid' }, (response: any) => {
          expect(response.success).toBe(false);
        });

        socket.on('disconnect', () => {
          done();
        });
      });
    });
  });

  describe('Reconnection', () => {
    it('should reconnect with same session state', (done) => {
      socket.on('connect', () => {
        const socketId = socket.id;

        // Force disconnect
        socket.disconnect();

        // Reconnect
        socket.connect();

        socket.on('connect', () => {
          // Should have new socket ID but same user room
          expect(socket.id).not.toBe(socketId);
          socket.emit('debug:rooms', (rooms: string[]) => {
            expect(rooms).toContain(`user:${testUserId}`);
            done();
          });
        });
      });
    });
  });
});
```

**test/e2e/ai-gateway.e2e-spec.ts:**
```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import { Socket, io } from 'socket.io-client';
import { AppModule } from '../../src/app.module';
import { PrismaService } from '../../src/modules/prisma/prisma.service';
import { JwtService } from '@nestjs/jwt';

describe('AI Gateway (E2E)', () => {
  let app: INestApplication;
  let prisma: PrismaService;
  let jwtService: JwtService;
  let socket: Socket;
  let validToken: string;
  let testCaseId: string;

  beforeAll(async () => {
    // Setup similar to WebSocket tests
    // Create test tenant, user, and a case for context
  });

  afterAll(async () => {
    await app.close();
  });

  beforeEach(() => {
    socket = io('http://localhost:3001/ai', {
      auth: { token: validToken },
      transports: ['websocket'],
    });
  });

  afterEach(() => {
    socket.disconnect();
  });

  describe('Context Loading', () => {
    it('should load case context for AI panel', (done) => {
      socket.on('connect', () => {
        socket.emit('ai:load-context', {
          entityType: 'case',
          entityId: testCaseId,
        }, (response: any) => {
          expect(response.success).toBe(true);
          expect(response.context).toBeDefined();
          expect(response.context.entityType).toBe('case');
          done();
        });
      });
    });

    it('should include available skills in context', (done) => {
      socket.on('connect', () => {
        socket.emit('ai:load-context', {
          entityType: 'case',
          entityId: testCaseId,
        }, (response: any) => {
          expect(response.availableSkills).toBeDefined();
          expect(response.availableSkills).toContain('summarize');
          expect(response.availableSkills).toContain('note-cleanup');
          done();
        });
      });
    });

    it('should respect tenant isolation in context', (done) => {
      // Attempt to load context for case in different tenant
      socket.on('connect', () => {
        socket.emit('ai:load-context', {
          entityType: 'case',
          entityId: 'other-tenant-case-id',
        }, (response: any) => {
          expect(response.success).toBe(false);
          expect(response.error).toContain('not found');
          done();
        });
      });
    });
  });

  describe('Skill Execution', () => {
    it('should execute note-cleanup skill', (done) => {
      socket.on('connect', () => {
        socket.emit('ai:execute-skill', {
          skill: 'note-cleanup',
          input: {
            text: '- caller said theft happened\n- around 2pm\n- warehouse B',
          },
        });

        socket.on('ai:skill-result', (result) => {
          expect(result.success).toBe(true);
          expect(result.output).toBeDefined();
          expect(result.output).not.toContain('- '); // Should be narrative
          done();
        });
      });
    });

    it('should execute summarize skill', (done) => {
      socket.on('connect', () => {
        socket.emit('ai:load-context', {
          entityType: 'case',
          entityId: testCaseId,
        }, () => {
          socket.emit('ai:execute-skill', { skill: 'summarize' });

          socket.on('ai:skill-result', (result) => {
            expect(result.success).toBe(true);
            expect(result.output.summary).toBeDefined();
            done();
          });
        });
      });
    });

    it('should reject unauthorized skill', (done) => {
      socket.on('connect', () => {
        socket.emit('ai:execute-skill', {
          skill: 'admin-only-skill',
        });

        socket.on('ai:skill-error', (error) => {
          expect(error.code).toBe('UNAUTHORIZED');
          done();
        });
      });
    });
  });

  describe('Streaming Responses', () => {
    it('should stream chat response chunks', (done) => {
      const chunks: string[] = [];

      socket.on('connect', () => {
        socket.emit('ai:chat', {
          message: 'Summarize this case briefly',
          entityType: 'case',
          entityId: testCaseId,
        });

        socket.on('ai:chat-chunk', (chunk) => {
          chunks.push(chunk.text);
        });

        socket.on('ai:chat-complete', () => {
          expect(chunks.length).toBeGreaterThan(0);
          const fullResponse = chunks.join('');
          expect(fullResponse.length).toBeGreaterThan(10);
          done();
        });
      });
    });

    it('should handle stream cancellation', (done) => {
      socket.on('connect', () => {
        socket.emit('ai:chat', {
          message: 'Write a very long detailed report',
          entityType: 'case',
          entityId: testCaseId,
        });

        let chunksReceived = 0;
        socket.on('ai:chat-chunk', () => {
          chunksReceived++;
          if (chunksReceived === 3) {
            socket.emit('ai:cancel');
          }
        });

        socket.on('ai:chat-cancelled', () => {
          expect(chunksReceived).toBeLessThan(10);
          done();
        });
      });
    });
  });

  describe('Rate Limiting', () => {
    it('should enforce rate limits per tenant', (done) => {
      socket.on('connect', async () => {
        // Send many requests quickly
        const promises = Array(15).fill(null).map((_, i) =>
          new Promise((resolve) => {
            socket.emit('ai:chat', {
              message: `Request ${i}`,
              entityType: 'case',
              entityId: testCaseId,
            }, resolve);
          })
        );

        socket.on('ai:rate-limited', (data) => {
          expect(data.retryAfter).toBeDefined();
          done();
        });

        await Promise.all(promises);
      });
    });
  });
});
```
  </action>
  <verify>npm run test:e2e -- websocket.e2e-spec.ts passes</verify>
  <done>WebSocket and AI Gateway E2E tests created with connection, auth, and streaming coverage</done>
</task>

<task type="auto">
  <name>Task 2: Fix Auth Edge Cases and Token Refresh</name>
  <files>
    apps/backend/src/modules/auth/guards/jwt-ws.guard.ts
    apps/backend/src/modules/auth/strategies/token-refresh.strategy.ts
    apps/backend/src/modules/auth/auth.service.ts
  </files>
  <action>
**guards/jwt-ws.guard.ts:**
```typescript
import { CanActivate, ExecutionContext, Injectable, Logger } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { WsException } from '@nestjs/websockets';
import { Socket } from 'socket.io';

@Injectable()
export class JwtWsGuard implements CanActivate {
  private readonly logger = new Logger(JwtWsGuard.name);

  constructor(private readonly jwtService: JwtService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const client: Socket = context.switchToWs().getClient();
    const token = this.extractToken(client);

    if (!token) {
      throw new WsException('Missing authentication token');
    }

    try {
      const payload = await this.jwtService.verifyAsync(token);

      // Check token expiration with buffer
      const expiresAt = payload.exp * 1000;
      const now = Date.now();
      const bufferMs = 60 * 1000; // 1 minute buffer

      if (expiresAt - now < bufferMs) {
        // Token about to expire, notify client to refresh
        client.emit('auth:refresh-needed', {
          expiresIn: Math.max(0, expiresAt - now),
        });
      }

      // Attach user to socket
      client.data.user = payload;
      client.data.tenantId = payload.tenantId;

      return true;
    } catch (error) {
      this.logger.warn(`WebSocket auth failed: ${error.message}`);

      if (error.name === 'TokenExpiredError') {
        throw new WsException('Token expired - please refresh');
      }

      throw new WsException('Invalid authentication token');
    }
  }

  private extractToken(client: Socket): string | undefined {
    // Check auth object first
    const auth = client.handshake.auth;
    if (auth?.token) return auth.token;

    // Fall back to query parameter
    const query = client.handshake.query;
    if (typeof query.token === 'string') return query.token;

    // Fall back to header
    const authHeader = client.handshake.headers.authorization;
    if (authHeader?.startsWith('Bearer ')) {
      return authHeader.slice(7);
    }

    return undefined;
  }
}
```

**strategies/token-refresh.strategy.ts:**
```typescript
import { Injectable, Logger } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { PrismaService } from '../../prisma/prisma.service';
import { ConfigService } from '@nestjs/config';

export interface RefreshResult {
  success: boolean;
  accessToken?: string;
  refreshToken?: string;
  error?: string;
}

@Injectable()
export class TokenRefreshStrategy {
  private readonly logger = new Logger(TokenRefreshStrategy.name);

  constructor(
    private readonly jwtService: JwtService,
    private readonly prisma: PrismaService,
    private readonly config: ConfigService,
  ) {}

  async refreshTokens(refreshToken: string): Promise<RefreshResult> {
    try {
      // Verify refresh token
      const payload = await this.jwtService.verifyAsync(refreshToken, {
        secret: this.config.get('JWT_REFRESH_SECRET'),
      });

      // Check if refresh token is revoked
      const storedToken = await this.prisma.refreshToken.findUnique({
        where: { token: refreshToken },
      });

      if (!storedToken || storedToken.revokedAt) {
        return { success: false, error: 'Refresh token revoked' };
      }

      // Check if token is expired
      if (new Date(storedToken.expiresAt) < new Date()) {
        return { success: false, error: 'Refresh token expired' };
      }

      // Get user
      const user = await this.prisma.user.findUnique({
        where: { id: payload.sub },
        include: { organization: true },
      });

      if (!user || user.status !== 'ACTIVE') {
        return { success: false, error: 'User not found or inactive' };
      }

      // Generate new tokens
      const newAccessToken = this.jwtService.sign({
        sub: user.id,
        email: user.email,
        tenantId: user.organizationId,
        role: user.role,
      });

      const newRefreshToken = this.jwtService.sign(
        { sub: user.id, type: 'refresh' },
        {
          secret: this.config.get('JWT_REFRESH_SECRET'),
          expiresIn: '7d',
        },
      );

      // Revoke old refresh token (rotation)
      await this.prisma.refreshToken.update({
        where: { id: storedToken.id },
        data: { revokedAt: new Date() },
      });

      // Store new refresh token
      await this.prisma.refreshToken.create({
        data: {
          token: newRefreshToken,
          userId: user.id,
          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
        },
      });

      return {
        success: true,
        accessToken: newAccessToken,
        refreshToken: newRefreshToken,
      };
    } catch (error) {
      this.logger.error(`Token refresh failed: ${error.message}`);
      return { success: false, error: 'Invalid refresh token' };
    }
  }

  async handleSsoSessionTimeout(userId: string): Promise<RefreshResult> {
    // Check if user has active SSO session
    const ssoSession = await this.prisma.ssoSession.findFirst({
      where: {
        userId,
        expiresAt: { gt: new Date() },
      },
    });

    if (ssoSession) {
      // SSO session still valid, issue new tokens
      const user = await this.prisma.user.findUnique({
        where: { id: userId },
      });

      if (!user) {
        return { success: false, error: 'User not found' };
      }

      const accessToken = this.jwtService.sign({
        sub: user.id,
        email: user.email,
        tenantId: user.organizationId,
        role: user.role,
      });

      return { success: true, accessToken };
    }

    // SSO session expired, user needs to re-authenticate
    return { success: false, error: 'SSO session expired - please login again' };
  }
}
```

**Update auth.service.ts:**
- Add retry logic for SSO callback failures (3 retries with exponential backoff)
- Handle IdP timeout gracefully with user-friendly error messages
- Add session continuation for WebSocket connections after token refresh
  </action>
  <verify>npm run test passes for auth module</verify>
  <done>Auth edge cases handled with WebSocket token refresh and SSO timeout retry</done>
</task>

<task type="auto">
  <name>Task 3: Query Optimization and Index Tuning</name>
  <files>
    apps/backend/src/common/interceptors/query-optimizer.interceptor.ts
    apps/backend/src/modules/cases/case.service.ts
    apps/backend/src/modules/investigations/investigation.service.ts
    apps/backend/prisma/schema.prisma
    apps/backend/src/common/decorators/cache-key.decorator.ts
  </files>
  <action>
**interceptors/query-optimizer.interceptor.ts:**
```typescript
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import DataLoader from 'dataloader';
import { PrismaService } from '../../modules/prisma/prisma.service';

// Request-scoped DataLoader factory
export function createDataLoaders(prisma: PrismaService) {
  return {
    userLoader: new DataLoader<string, any>(async (ids) => {
      const users = await prisma.user.findMany({
        where: { id: { in: [...ids] } },
      });
      const userMap = new Map(users.map((u) => [u.id, u]));
      return ids.map((id) => userMap.get(id) || null);
    }),

    organizationLoader: new DataLoader<string, any>(async (ids) => {
      const orgs = await prisma.organization.findMany({
        where: { id: { in: [...ids] } },
      });
      const orgMap = new Map(orgs.map((o) => [o.id, o]));
      return ids.map((id) => orgMap.get(id) || null);
    }),

    caseRiusLoader: new DataLoader<string, any[]>(async (caseIds) => {
      const rius = await prisma.rIU.findMany({
        where: { caseId: { in: [...caseIds] } },
      });
      const riuMap = new Map<string, any[]>();
      for (const riu of rius) {
        const existing = riuMap.get(riu.caseId) || [];
        existing.push(riu);
        riuMap.set(riu.caseId, existing);
      }
      return caseIds.map((id) => riuMap.get(id) || []);
    }),

    investigationStepsLoader: new DataLoader<string, any[]>(async (invIds) => {
      const steps = await prisma.investigationStep.findMany({
        where: { investigationId: { in: [...invIds] } },
        orderBy: { sortOrder: 'asc' },
      });
      const stepMap = new Map<string, any[]>();
      for (const step of steps) {
        const existing = stepMap.get(step.investigationId) || [];
        existing.push(step);
        stepMap.set(step.investigationId, existing);
      }
      return invIds.map((id) => stepMap.get(id) || []);
    }),
  };
}

@Injectable()
export class QueryOptimizerInterceptor implements NestInterceptor {
  constructor(private readonly prisma: PrismaService) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();

    // Create request-scoped DataLoaders
    request.dataLoaders = createDataLoaders(this.prisma);

    return next.handle();
  }
}
```

**Update case.service.ts:**
```typescript
// Before (N+1):
async findMany(query: CaseQueryDto) {
  const cases = await this.prisma.case.findMany({ ... });
  // Each case triggers separate query for assignee, rius, etc.
  return cases.map(c => ({
    ...c,
    assignee: await this.prisma.user.findUnique({ where: { id: c.assigneeId }}),
    rius: await this.prisma.riu.findMany({ where: { caseId: c.id }}),
  }));
}

// After (batched):
async findMany(query: CaseQueryDto, dataLoaders?: ReturnType<typeof createDataLoaders>) {
  const cases = await this.prisma.case.findMany({
    where: this.buildWhereClause(query),
    include: {
      _count: { select: { rius: true, comments: true } },
    },
    orderBy: this.buildOrderBy(query),
    skip: query.skip,
    take: query.take,
  });

  // Use DataLoader for batch loading
  if (dataLoaders) {
    const assigneeIds = cases.map(c => c.assigneeId).filter(Boolean);
    const assignees = await Promise.all(
      cases.map(c => c.assigneeId ? dataLoaders.userLoader.load(c.assigneeId) : null)
    );

    return cases.map((c, i) => ({
      ...c,
      assignee: assignees[i],
    }));
  }

  return cases;
}
```

**Add to schema.prisma indexes:**
```prisma
// Case table indexes
model Case {
  // ... existing fields ...

  @@index([organizationId, status])
  @@index([organizationId, assigneeId])
  @@index([organizationId, createdAt(sort: Desc)])
  @@index([organizationId, priority, status])
  @@index([organizationId, category])
}

// RIU table indexes
model RIU {
  // ... existing fields ...

  @@index([organizationId, status])
  @@index([organizationId, createdAt(sort: Desc)])
  @@index([organizationId, source])
  @@index([caseId])
}

// Investigation table indexes
model Investigation {
  // ... existing fields ...

  @@index([caseId])
  @@index([organizationId, status])
  @@index([organizationId, assigneeId])
}

// AuditLog indexes for reporting
model AuditLog {
  // ... existing fields ...

  @@index([organizationId, createdAt(sort: Desc)])
  @@index([entityType, entityId])
  @@index([actorId, createdAt(sort: Desc)])
}
```

**decorators/cache-key.decorator.ts:**
```typescript
import { SetMetadata } from '@nestjs/common';

export const CACHE_KEY = 'cache:key';
export const CACHE_TTL = 'cache:ttl';

// Standard TTLs
export const TTL = {
  SHORT: 60,        // 1 minute - for frequently changing data
  MEDIUM: 300,      // 5 minutes - for user/tenant info
  LONG: 3600,       // 1 hour - for static config
  DAY: 86400,       // 1 day - for rarely changing data
} as const;

// Decorator to set cache key pattern
export const CacheKey = (pattern: string) => SetMetadata(CACHE_KEY, pattern);
export const CacheTtl = (seconds: number) => SetMetadata(CACHE_TTL, seconds);

// Key builders with tenant isolation
export const cacheKeys = {
  tenant: (tenantId: string) => `tenant:${tenantId}`,
  user: (tenantId: string, userId: string) => `tenant:${tenantId}:user:${userId}`,
  case: (tenantId: string, caseId: string) => `tenant:${tenantId}:case:${caseId}`,
  caseList: (tenantId: string, hash: string) => `tenant:${tenantId}:cases:${hash}`,
  featureFlag: (key: string, tenantId?: string) =>
    tenantId ? `feature:${key}:${tenantId}` : `feature:${key}`,
  healthScore: (tenantId: string) => `tenant:${tenantId}:health`,
};
```

**Add batch limits to controllers:**
- Update bulk endpoints to enforce max batch size (default 100)
- Add pagination to all list endpoints
- Return 400 if batch size exceeds limit
  </action>
  <verify>npx prisma validate; npm run test passes</verify>
  <done>Query optimization with DataLoader, database indexes, and cache key standardization complete</done>
</task>

</tasks>

<verification>
1. Run `npm run test:e2e -- websocket` - WebSocket E2E tests pass
2. Run `npm run test:e2e -- ai-gateway` - AI gateway tests pass
3. Run `npx prisma validate` - schema is valid
4. Run `npm run test` - all unit tests pass
5. Verify N+1 queries resolved using query logging
6. Verify bulk endpoints return 400 for oversized batches
</verification>

<success_criteria>
- WebSocket E2E tests cover connection, auth, rooms, and reconnection
- AI gateway tests cover context loading, skills, streaming, and rate limiting
- Token refresh during WebSocket handled without disconnection
- SSO timeout has 3-retry logic with exponential backoff
- Case list query reduced from N+1 to 2 queries using DataLoader
- All critical query paths have appropriate indexes
- Cache keys use consistent tenant-prefixed pattern
- Batch endpoints enforce 100-item max limit
</success_criteria>

<output>
After completion, create `.planning/phases/12-internal-operations-portal/12-18-SUMMARY.md`
</output>
