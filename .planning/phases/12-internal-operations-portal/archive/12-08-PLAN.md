---
phase: 12-internal-operations-portal
plan: 08
type: execute
wave: 3
depends_on: ["12-03"]
files_modified:
  - apps/backend/src/modules/operations/client-health/health-score.service.ts
  - apps/backend/src/modules/operations/client-health/usage-metrics.service.ts
  - apps/backend/src/modules/operations/client-health/health-score.processor.ts
  - apps/backend/src/modules/operations/client-health/client-health.controller.ts
  - apps/backend/src/modules/operations/client-health/client-health.module.ts
autonomous: true

must_haves:
  truths:
    - "Health scores are calculated daily via BullMQ scheduled job"
    - "Component scores use weighted calculation per HEALTH_WEIGHTS constant"
    - "Trend detection compares current score to previous calculation"
    - "Risk level is derived from score and trend combination"
    - "Usage metrics aggregate login, case, campaign data"
  artifacts:
    - path: "apps/backend/src/modules/operations/client-health/health-score.service.ts"
      provides: "Health score calculation with weighted components"
      exports: ["HealthScoreService"]
    - path: "apps/backend/src/modules/operations/client-health/health-score.processor.ts"
      provides: "BullMQ processor for scheduled calculation"
      exports: ["HealthScoreProcessor"]
    - path: "apps/backend/src/modules/operations/client-health/usage-metrics.service.ts"
      provides: "Usage metric collection and aggregation"
      exports: ["UsageMetricsService"]
  key_links:
    - from: "health-score.service.ts"
      to: "HEALTH_WEIGHTS"
      via: "Weighted average calculation"
      pattern: "HEALTH_WEIGHTS\\."
    - from: "health-score.processor.ts"
      to: "health-score.service.ts"
      via: "Scheduled calculation"
      pattern: "healthScoreService\\.calculateHealthScore"
---

<objective>
Create the Client Success service that calculates tenant health scores from usage metrics, tracks feature adoption, and identifies renewal risk.

Purpose: CSMs need visibility into client health to proactively address issues before renewal. This service implements the weighted health score calculation from CONTEXT.md with daily scheduled recalculation.

Output: HealthScoreService for score calculation, UsageMetricsService for data collection, HealthScoreProcessor for BullMQ scheduled jobs, REST controller.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-internal-operations-portal/12-03-SUMMARY.md
@.planning/phases/12-internal-operations-portal/12-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UsageMetricsService for data collection</name>
  <files>apps/backend/src/modules/operations/client-health/usage-metrics.service.ts</files>
  <action>
Create UsageMetricsService to collect and aggregate usage data:

1. **Inject dependencies:**
   - PrismaService
   - Logger

2. **getLoginMetrics(organizationId: string, since: Date):**
   - Count total users in organization
   - Count users with lastLoginAt >= since
   - Return { totalUsers, activeUsers, loginRate }

3. **getCaseResolutionMetrics(organizationId: string, since: Date):**
   - Count cases closed in period
   - Count cases closed on time (closedAt <= slaBreachAt)
   - Calculate on-time percentage
   - Return { closedCount, onTimeCount, onTimeRate }

4. **getCampaignMetrics(organizationId: string, since: Date):**
   - Count campaigns completed in period
   - Calculate average completion rate across campaigns
   - Return { campaignsCompleted, averageCompletionRate }

5. **getFeatureAdoptionMetrics(organizationId: string):**
   - Count enabled features for org
   - Count used features (isUsed = true)
   - Calculate adoption rate
   - Return { enabledCount, usedCount, adoptionRate }

6. **getSupportTicketMetrics(organizationId: string, since: Date):**
   - Count support tickets created (if tracked in system)
   - If no ticket tracking, return default high score
   - Return { ticketCount, baselineTickets, ticketScore }

7. **recordDailyMetrics(organizationId: string, date: Date):**
   - Collect all metrics for the day
   - Upsert UsageMetric records for each MetricType
   - Calculate change percentages from previous period
   - Return collected metrics

8. **getMetricHistory(organizationId: string, metricType: MetricType, days: number):**
   - Get historical metric values for trending
   - Return array with date and value
  </action>
  <verify>npx tsc --noEmit compiles without errors</verify>
  <done>UsageMetricsService collects login, case, campaign, and feature usage data</done>
</task>

<task type="auto">
  <name>Task 2: Create HealthScoreService for score calculation</name>
  <files>apps/backend/src/modules/operations/client-health/health-score.service.ts</files>
  <action>
Create HealthScoreService implementing the calculation from 12-RESEARCH.md:

1. **Inject dependencies:**
   - PrismaService
   - UsageMetricsService
   - Logger

2. **calculateHealthScore(organizationId: string):**
   - Define calculation period: now - 30 days
   - Fetch all component data in parallel:
     ```typescript
     const [loginData, caseData, campaignData, featureData, ticketData, previousScore] =
       await Promise.all([
         this.usageMetrics.getLoginMetrics(organizationId, thirtyDaysAgo),
         this.usageMetrics.getCaseResolutionMetrics(organizationId, thirtyDaysAgo),
         this.usageMetrics.getCampaignMetrics(organizationId, thirtyDaysAgo),
         this.usageMetrics.getFeatureAdoptionMetrics(organizationId),
         this.usageMetrics.getSupportTicketMetrics(organizationId, thirtyDaysAgo),
         this.getPreviousScore(organizationId),
       ]);
     ```
   - Calculate component scores (0-100 each):
     - loginScore: `Math.min(100, Math.round((loginData.loginRate / 0.7) * 100))` (70% = 100)
     - caseResolutionScore: `Math.round(caseData.onTimeRate * 100)` (100% on-time = 100)
     - campaignCompletionScore: `Math.round(campaignData.averageCompletionRate * 100)`
     - featureAdoptionScore: `Math.round(featureData.adoptionRate * 100)`
     - supportTicketScore: Inverse - fewer tickets = higher score
   - Calculate weighted overall:
     ```typescript
     const overallScore = Math.round(
       components.loginScore * HEALTH_WEIGHTS.login +
       components.caseResolutionScore * HEALTH_WEIGHTS.caseResolution +
       components.campaignCompletionScore * HEALTH_WEIGHTS.campaignCompletion +
       components.featureAdoptionScore * HEALTH_WEIGHTS.featureAdoption +
       components.supportTicketScore * HEALTH_WEIGHTS.supportTickets
     );
     ```
   - Determine trend via determineTrend()
   - Determine risk level via determineRiskLevel()
   - Save to TenantHealthScore
   - Return created score

3. **determineTrend(current: number, previous?: number):**
   - If no previous: STABLE
   - If delta > 5: IMPROVING
   - If delta < -5: DECLINING
   - Otherwise: STABLE

4. **determineRiskLevel(score: number, trend: HealthTrend):**
   - HIGH: score < 40 OR (score < 60 AND trend === DECLINING)
   - MEDIUM: score < 70 OR trend === DECLINING
   - LOW: otherwise

5. **getPreviousScore(organizationId: string):**
   - Get most recent TenantHealthScore for org
   - Return null if none exists

6. **getLatestScore(organizationId: string):**
   - Get most recent score with all component values

7. **getScoreHistory(organizationId: string, days: number):**
   - Get score history for trending chart
   - Return array of { date, overallScore, trend, riskLevel }

8. **calculateAllTenants():**
   - Get all active organizations
   - Calculate score for each with rate limiting (100ms between)
   - Return summary { calculated, errors }
  </action>
  <verify>npx tsc --noEmit compiles without errors</verify>
  <done>HealthScoreService calculates weighted health scores with trend and risk detection</done>
</task>

<task type="auto">
  <name>Task 3: Create HealthScoreProcessor, Controller, and Module</name>
  <files>
    apps/backend/src/modules/operations/client-health/health-score.processor.ts
    apps/backend/src/modules/operations/client-health/client-health.controller.ts
    apps/backend/src/modules/operations/client-health/client-health.module.ts
  </files>
  <action>
**health-score.processor.ts:**
```typescript
import { Processor, WorkerHost, OnWorkerEvent } from '@nestjs/bullmq';
import { Job } from 'bullmq';
import { Injectable, Logger } from '@nestjs/common';
import { HealthScoreService } from './health-score.service';
import { UsageMetricsService } from './usage-metrics.service';
import { PrismaService } from '../../prisma/prisma.service';

export const HEALTH_SCORE_QUEUE = 'health-scores';

interface HealthScoreJobData {
  organizationId?: string; // Specific tenant or all
  type: 'calculate-single' | 'calculate-all' | 'record-metrics';
}

@Processor(HEALTH_SCORE_QUEUE)
export class HealthScoreProcessor extends WorkerHost {
  private readonly logger = new Logger(HealthScoreProcessor.name);

  constructor(
    private readonly healthScoreService: HealthScoreService,
    private readonly usageMetricsService: UsageMetricsService,
    private readonly prisma: PrismaService,
  ) {
    super();
  }

  async process(job: Job<HealthScoreJobData>): Promise<void> {
    this.logger.log(`Processing health score job ${job.id}: ${job.data.type}`);

    switch (job.data.type) {
      case 'calculate-single':
        if (!job.data.organizationId) throw new Error('organizationId required');
        await this.healthScoreService.calculateHealthScore(job.data.organizationId);
        break;

      case 'calculate-all':
        await this.calculateAllWithProgress(job);
        break;

      case 'record-metrics':
        await this.recordMetricsForAll(job);
        break;
    }
  }

  private async calculateAllWithProgress(job: Job): Promise<void> {
    const tenants = await this.prisma.organization.findMany({
      where: { status: 'ACTIVE' },
      select: { id: true },
    });

    for (let i = 0; i < tenants.length; i++) {
      try {
        await this.healthScoreService.calculateHealthScore(tenants[i].id);
      } catch (error) {
        this.logger.error(`Failed for tenant ${tenants[i].id}: ${error.message}`);
      }
      await job.updateProgress(Math.round((i / tenants.length) * 100));
      // Rate limiting: 100ms between calculations
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }

  private async recordMetricsForAll(job: Job): Promise<void> {
    const tenants = await this.prisma.organization.findMany({
      where: { status: 'ACTIVE' },
      select: { id: true },
    });

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    for (let i = 0; i < tenants.length; i++) {
      try {
        await this.usageMetricsService.recordDailyMetrics(tenants[i].id, today);
      } catch (error) {
        this.logger.error(`Metrics failed for ${tenants[i].id}: ${error.message}`);
      }
      await job.updateProgress(Math.round((i / tenants.length) * 100));
    }
  }

  @OnWorkerEvent('failed')
  onFailed(job: Job, error: Error) {
    this.logger.error(`Health score job ${job.id} failed: ${error.message}`);
  }
}
```

**client-health.controller.ts:**
```typescript
@Controller('api/v1/internal/client-health')
@UseGuards(InternalAuthGuard)
@Roles('CLIENT_SUCCESS', 'PLATFORM_ADMIN')
export class ClientHealthController {
  constructor(
    private readonly healthScoreService: HealthScoreService,
    private readonly usageMetricsService: UsageMetricsService,
    @InjectQueue(HEALTH_SCORE_QUEUE) private readonly healthQueue: Queue,
  ) {}

  @Get('scores')
  async listScores(@Query() query: HealthScoreQueryDto) {
    return this.healthScoreService.listScores(query);
  }

  @Get('scores/:organizationId')
  async getScore(@Param('organizationId') orgId: string) {
    return this.healthScoreService.getLatestScore(orgId);
  }

  @Get('scores/:organizationId/history')
  async getScoreHistory(
    @Param('organizationId') orgId: string,
    @Query('days') days: number = 30,
  ) {
    return this.healthScoreService.getScoreHistory(orgId, days);
  }

  @Post('scores/:organizationId/recalculate')
  async recalculate(@Param('organizationId') orgId: string) {
    await this.healthQueue.add('calculate', { organizationId: orgId, type: 'calculate-single' });
    return { message: 'Recalculation queued' };
  }

  @Get('metrics/:organizationId')
  async getMetrics(@Param('organizationId') orgId: string, @Query() query: UsageMetricQueryDto) {
    return this.usageMetricsService.getMetricHistory(orgId, query.metricType, query.days || 30);
  }

  @Get('adoption/:organizationId')
  async getAdoption(@Param('organizationId') orgId: string) {
    return this.usageMetricsService.getFeatureAdoptionMetrics(orgId);
  }

  @Post('calculate-all')
  @Roles('PLATFORM_ADMIN') // Only admins can trigger all
  async calculateAll() {
    await this.healthQueue.add('calculate-all', { type: 'calculate-all' });
    return { message: 'Calculation queued for all tenants' };
  }
}
```

**client-health.module.ts:**
```typescript
@Module({
  imports: [
    PrismaModule,
    BullModule.registerQueue({ name: HEALTH_SCORE_QUEUE }),
  ],
  providers: [
    HealthScoreService,
    UsageMetricsService,
    HealthScoreProcessor,
  ],
  controllers: [ClientHealthController],
  exports: [HealthScoreService, UsageMetricsService],
})
export class ClientHealthModule {}
```

Also add a scheduled job registration in the module or a separate scheduler service:
- Daily at 2 AM: Queue 'calculate-all' job
- Daily at 1 AM: Queue 'record-metrics' job
  </action>
  <verify>npm run lint passes; TypeScript compiles</verify>
  <done>HealthScoreProcessor handles scheduled calculation, controller provides REST API</done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` from apps/backend - TypeScript compiles
2. Run `npm run lint` - no lint errors
3. Verify HEALTH_WEIGHTS are used in calculation
4. Verify trend thresholds match 12-RESEARCH.md (+/-5 points)
5. Verify risk level logic matches CONTEXT.md criteria
6. Verify BullMQ queue is registered
</verification>

<success_criteria>
- HealthScoreService calculates weighted composite score from 5 components
- Component scores use correct formulas per CONTEXT.md
- Trend detection identifies IMPROVING/STABLE/DECLINING
- Risk level correctly combines score and trend
- BullMQ processor handles scheduled daily calculation
- Rate limiting prevents database overload (100ms between tenants)
- REST endpoints expose scores, history, and metrics
</success_criteria>

<output>
After completion, create `.planning/phases/12-internal-operations-portal/12-08-SUMMARY.md`
</output>
