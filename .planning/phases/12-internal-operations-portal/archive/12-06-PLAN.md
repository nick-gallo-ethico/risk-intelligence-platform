---
phase: 12-internal-operations-portal
plan: 06
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - apps/backend/src/modules/analytics/migration/migration-wizard.controller.ts
  - apps/backend/src/modules/analytics/migration/migration-wizard.service.ts
  - apps/backend/src/modules/analytics/migration/dto/migration-wizard.dto.ts
  - apps/backend/src/modules/analytics/migration/migration.module.ts
autonomous: true

must_haves:
  truths:
    - "File uploads are processed with format auto-detection"
    - "Field mapping suggestions use AI assistance when available"
    - "Validation preview shows errors before import execution"
    - "Import progress is tracked with percentage updates"
    - "7-day rollback window is enforced for completed imports"
  artifacts:
    - path: "apps/backend/src/modules/analytics/migration/migration-wizard.controller.ts"
      provides: "REST endpoints for wizard flow"
      exports: ["MigrationWizardController"]
    - path: "apps/backend/src/modules/analytics/migration/migration-wizard.service.ts"
      provides: "AI-assisted field mapping and wizard orchestration"
      exports: ["MigrationWizardService"]
  key_links:
    - from: "migration-wizard.service.ts"
      to: "MigrationService"
      via: "Delegates to existing migration infrastructure"
      pattern: "migrationService\\."
    - from: "migration-wizard.controller.ts"
      to: "ElevatedAccessGuard"
      via: "@UseGuards for implementation-only access"
      pattern: "@UseGuards.*ElevatedAccessGuard"
---

<objective>
Create the Migration Wizard service that extends the existing MigrationService from Phase 11 with AI-assisted field mapping and wizard flow orchestration for implementation specialists.

Purpose: The backend migration infrastructure exists from Phase 11. This plan adds the wizard controller endpoints and AI-assisted mapping service that implementation specialists use through the UI.

Output: MigrationWizardController for REST API, MigrationWizardService for AI-assisted mapping, extended DTOs for wizard flow.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-internal-operations-portal/12-01-SUMMARY.md
@apps/backend/src/modules/analytics/migration/migration.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Migration Wizard DTOs</name>
  <files>apps/backend/src/modules/analytics/migration/dto/migration-wizard.dto.ts</files>
  <action>
Create DTOs specific to the wizard flow:

```typescript
import { IsString, IsOptional, IsArray, ValidateNested, IsEnum, IsBoolean } from 'class-validator';
import { Type } from 'class-transformer';
import { MigrationSourceType } from '@prisma/client';

// Wizard step tracking
export enum WizardStep {
  UPLOAD = 'UPLOAD',
  DETECT = 'DETECT',
  MAP = 'MAP',
  VALIDATE = 'VALIDATE',
  PREVIEW = 'PREVIEW',
  IMPORT = 'IMPORT',
  VERIFY = 'VERIFY',
}

// Upload step
export class InitiateWizardDto {
  @IsString()
  organizationId: string;

  @IsOptional()
  @IsEnum(MigrationSourceType)
  sourceType?: MigrationSourceType; // If known, otherwise auto-detect
}

export class UploadResponseDto {
  jobId: string;
  fileName: string;
  fileSizeBytes: number;
  uploadedAt: Date;
  currentStep: WizardStep;
}

// AI-assisted mapping
export class AiMappingSuggestionDto {
  sourceField: string;
  suggestedTargetField: string;
  suggestedTargetEntity: string;
  confidence: number; // 0-100
  reasoning?: string;
}

export class RequestAiMappingDto {
  @IsString()
  jobId: string;

  @IsArray()
  @IsString({ each: true })
  unmappedFields: string[];

  @IsOptional()
  @IsString()
  contextHint?: string; // e.g., "NAVEX export" helps AI understand format
}

export class AiMappingResponseDto {
  suggestions: AiMappingSuggestionDto[];
  processingTime: number;
  aiUsed: boolean;
}

// Wizard status
export class WizardStatusDto {
  jobId: string;
  currentStep: WizardStep;
  completedSteps: WizardStep[];
  canProceed: boolean;
  blockingIssues: string[];
  validationSummary?: {
    validRows: number;
    errorRows: number;
    warningCount: number;
  };
  progress?: number;
}

// Step navigation
export class ProceedToStepDto {
  @IsString()
  jobId: string;

  @IsEnum(WizardStep)
  targetStep: WizardStep;
}

// Confirm import
export class ConfirmImportDto {
  @IsString()
  jobId: string;

  @IsBoolean()
  acknowledged: boolean; // Must be true

  @IsOptional()
  @IsString()
  notes?: string;
}

// Wizard session (combines job with wizard state)
export class WizardSessionDto {
  job: {
    id: string;
    fileName: string;
    sourceType: MigrationSourceType;
    status: string;
    totalRows?: number;
    validRows?: number;
    errorRows?: number;
  };
  wizard: {
    currentStep: WizardStep;
    completedSteps: WizardStep[];
    startedAt: Date;
    lastActivityAt: Date;
  };
  canRollback?: boolean;
  rollbackExpiresAt?: Date;
}
```
  </action>
  <verify>npx tsc --noEmit compiles without errors</verify>
  <done>Wizard-specific DTOs defined for all steps</done>
</task>

<task type="auto">
  <name>Task 2: Create MigrationWizardService with AI-assisted mapping</name>
  <files>apps/backend/src/modules/analytics/migration/migration-wizard.service.ts</files>
  <action>
Create MigrationWizardService that wraps MigrationService with wizard orchestration:

1. **Inject dependencies:**
   - MigrationService (existing)
   - PrismaService
   - SkillRegistry (for AI mapping)
   - CacheManager (for wizard state)
   - Logger

2. **initiateWizard(dto: InitiateWizardDto, userId: string):**
   - Create migration job via migrationService.createJob
   - Initialize wizard state in cache: `wizard:${jobId}`
   - State includes: currentStep, completedSteps[], startedAt, lastActivityAt
   - Return UploadResponseDto

3. **getWizardSession(jobId: string, organizationId: string):**
   - Get job from migrationService.getJob
   - Get wizard state from cache
   - Combine into WizardSessionDto
   - Include rollback eligibility if applicable

4. **requestAiMapping(dto: RequestAiMappingDto):**
   - If SkillRegistry has 'field-mapping' skill available:
     - Call skill with unmapped fields and context hint
     - Parse AI response into AiMappingSuggestionDto[]
   - If AI unavailable:
     - Use fuzzy matching from MigrationService
     - Set aiUsed: false in response
   - Return AiMappingResponseDto

5. **getWizardStatus(jobId: string):**
   - Determine currentStep from job status
   - Build completedSteps based on job progress
   - Check canProceed (all required fields mapped, validation passed, etc.)
   - List blockingIssues if cannot proceed
   - Return WizardStatusDto

6. **proceedToStep(dto: ProceedToStepDto, userId: string):**
   - Validate step transition is allowed (can't skip steps)
   - Execute step-specific logic:
     - DETECT: Call migrationService.detectFormat
     - VALIDATE: Call migrationService.validate
     - PREVIEW: Call migrationService.generatePreview
     - IMPORT: Queue import job
   - Update wizard state in cache
   - Return new WizardStatusDto

7. **confirmImport(dto: ConfirmImportDto, userId: string):**
   - Validate wizard is at PREVIEW step
   - Validate acknowledged is true
   - Call migrationService.startImport
   - Update wizard state to IMPORT step
   - Return job status

8. **cancelWizard(jobId: string, userId: string):**
   - If job is IMPORTING, call migrationService.cancelImport
   - Clean up wizard state from cache
   - Log cancellation

9. **Private helper - mapStepToJobStatus:**
   - Map WizardStep to expected MigrationJobStatus
   - Used for validation and status checks
  </action>
  <verify>npx tsc --noEmit compiles without errors</verify>
  <done>MigrationWizardService provides wizard orchestration with AI-assisted mapping</done>
</task>

<task type="auto">
  <name>Task 3: Create MigrationWizardController and update module</name>
  <files>
    apps/backend/src/modules/analytics/migration/migration-wizard.controller.ts
    apps/backend/src/modules/analytics/migration/migration.module.ts
  </files>
  <action>
**migration-wizard.controller.ts:**
```typescript
@Controller('api/v1/internal/migration-wizard')
@UseGuards(ElevatedAccessGuard) // Only implementation specialists
export class MigrationWizardController {
  constructor(private readonly wizardService: MigrationWizardService) {}

  @Post('initiate')
  async initiate(
    @Body() dto: InitiateWizardDto,
    @CurrentInternalUser() user: InternalUser,
  ): Promise<UploadResponseDto> {
    return this.wizardService.initiateWizard(dto, user.id);
  }

  @Get(':jobId/session')
  async getSession(
    @Param('jobId') jobId: string,
    @Query('organizationId') organizationId: string,
  ): Promise<WizardSessionDto> {
    return this.wizardService.getWizardSession(jobId, organizationId);
  }

  @Get(':jobId/status')
  async getStatus(@Param('jobId') jobId: string): Promise<WizardStatusDto> {
    return this.wizardService.getWizardStatus(jobId);
  }

  @Post(':jobId/ai-mapping')
  async requestAiMapping(
    @Param('jobId') jobId: string,
    @Body() dto: RequestAiMappingDto,
  ): Promise<AiMappingResponseDto> {
    return this.wizardService.requestAiMapping({ ...dto, jobId });
  }

  @Post(':jobId/proceed')
  async proceedToStep(
    @Param('jobId') jobId: string,
    @Body() dto: ProceedToStepDto,
    @CurrentInternalUser() user: InternalUser,
  ): Promise<WizardStatusDto> {
    return this.wizardService.proceedToStep({ ...dto, jobId }, user.id);
  }

  @Post(':jobId/confirm-import')
  async confirmImport(
    @Param('jobId') jobId: string,
    @Body() dto: ConfirmImportDto,
    @CurrentInternalUser() user: InternalUser,
  ) {
    return this.wizardService.confirmImport({ ...dto, jobId }, user.id);
  }

  @Delete(':jobId')
  async cancel(
    @Param('jobId') jobId: string,
    @CurrentInternalUser() user: InternalUser,
  ) {
    return this.wizardService.cancelWizard(jobId, user.id);
  }

  // File upload endpoint - delegates to existing storage
  @Post(':jobId/upload')
  @UseInterceptors(FileInterceptor('file'))
  async uploadFile(
    @Param('jobId') jobId: string,
    @UploadedFile() file: Express.Multer.File,
  ) {
    // Upload to storage, update job with fileUrl
    // This uses existing ModuleStorageService patterns
  }
}
```

**Update migration.module.ts:**
- Add MigrationWizardService to providers
- Add MigrationWizardController to controllers
- Import ImpersonationModule for ElevatedAccessGuard
- Import AiModule for SkillRegistry
- Import CacheModule for wizard state
  </action>
  <verify>npm run lint passes; TypeScript compiles</verify>
  <done>MigrationWizardController provides REST API for wizard flow with proper guards</done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` from apps/backend - TypeScript compiles
2. Run `npm run lint` - no lint errors
3. Verify all wizard steps have corresponding endpoints
4. Verify ElevatedAccessGuard protects all endpoints
5. Verify AI mapping falls back gracefully when unavailable
</verification>

<success_criteria>
- MigrationWizardController provides endpoints for all wizard steps
- MigrationWizardService orchestrates step progression
- AI-assisted mapping uses SkillRegistry with graceful fallback
- Wizard state persists in cache for session recovery
- All endpoints protected by ElevatedAccessGuard
- Delegates to existing MigrationService for core operations
</success_criteria>

<output>
After completion, create `.planning/phases/12-internal-operations-portal/12-06-SUMMARY.md`
</output>
