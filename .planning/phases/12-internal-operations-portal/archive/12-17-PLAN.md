---
phase: 12-internal-operations-portal
plan: 17
type: execute
wave: 5
depends_on: ["12-01", "12-04"]
files_modified:
  - apps/frontend/src/pages/internal/admin/AdminSettingsPage.tsx
  - apps/frontend/src/pages/internal/admin/FeatureFlagsPanel.tsx
  - apps/frontend/src/pages/internal/admin/TenantConfigPanel.tsx
  - apps/frontend/src/pages/internal/admin/SystemHealthPanel.tsx
  - apps/frontend/src/pages/internal/admin/AuditLogViewer.tsx
  - apps/frontend/src/services/internal/admin.api.ts
  - apps/backend/src/modules/operations/admin/admin.controller.ts
  - apps/backend/src/modules/operations/admin/admin.service.ts
  - apps/backend/src/modules/operations/admin/admin.module.ts
autonomous: true

must_haves:
  truths:
    - "Feature flags can be toggled per tenant or globally"
    - "Tenant configuration displays all settings with edit capability"
    - "System health shows service status, queue depths, and error rates"
    - "Audit log viewer shows cross-tenant operations with filtering"
    - "All admin actions are themselves audited"
  artifacts:
    - path: "apps/frontend/src/pages/internal/admin/AdminSettingsPage.tsx"
      provides: "Main admin settings page with tabbed sections"
      exports: ["AdminSettingsPage"]
    - path: "apps/frontend/src/pages/internal/admin/FeatureFlagsPanel.tsx"
      provides: "Feature flag management UI"
      exports: ["FeatureFlagsPanel"]
    - path: "apps/backend/src/modules/operations/admin/admin.service.ts"
      provides: "Backend service for admin operations"
      exports: ["AdminService"]
  key_links:
    - from: "admin.api.ts"
      to: "/api/v1/internal/admin"
      via: "API calls"
      pattern: "/internal/admin"
    - from: "admin.service.ts"
      to: "AuditService"
      via: "All operations logged"
      pattern: "auditService\\."
---

<objective>
Create the Internal Admin Settings interface for platform administrators to manage feature flags, tenant configurations, system health monitoring, and audit log viewing.

Purpose: Platform admins need centralized control over system configuration and visibility into operations. This provides the master control panel for the Ethico platform.

Output: AdminSettingsPage, FeatureFlagsPanel, TenantConfigPanel, SystemHealthPanel, AuditLogViewer components; backend AdminService and controller.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-internal-operations-portal/12-01-SUMMARY.md
@.planning/phases/12-internal-operations-portal/12-04-SUMMARY.md
@.planning/phases/12-internal-operations-portal/CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AdminService and Controller backend</name>
  <files>
    apps/backend/src/modules/operations/admin/admin.service.ts
    apps/backend/src/modules/operations/admin/admin.controller.ts
    apps/backend/src/modules/operations/admin/admin.module.ts
  </files>
  <action>
**admin.service.ts:**
```typescript
import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { AuditService } from '../../audit/audit.service';
import { InjectQueue } from '@nestjs/bullmq';
import { Queue } from 'bullmq';
import { Redis } from 'ioredis';
import { InjectRedis } from '@nestjs-modules/ioredis';

export interface FeatureFlag {
  key: string;
  name: string;
  description: string;
  defaultValue: boolean;
  overrides: { organizationId: string; value: boolean }[];
}

export interface TenantConfig {
  organizationId: string;
  settings: Record<string, unknown>;
  features: Record<string, boolean>;
  limits: Record<string, number>;
}

export interface ServiceHealth {
  service: string;
  status: 'healthy' | 'degraded' | 'down';
  latency?: number;
  lastCheck: Date;
  details?: Record<string, unknown>;
}

export interface QueueHealth {
  name: string;
  waiting: number;
  active: number;
  completed: number;
  failed: number;
}

export interface SystemHealth {
  overall: 'healthy' | 'degraded' | 'down';
  services: ServiceHealth[];
  queues: QueueHealth[];
  errorRate: { last1h: number; last24h: number };
  uptimePercent: number;
}

@Injectable()
export class AdminService {
  private readonly logger = new Logger(AdminService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly auditService: AuditService,
    @InjectRedis() private readonly redis: Redis,
    @InjectQueue('health-scores') private readonly healthQueue: Queue,
    @InjectQueue('notifications') private readonly notificationQueue: Queue,
    @InjectQueue('migrations') private readonly migrationQueue: Queue,
  ) {}

  // Feature Flags
  async getFeatureFlags(): Promise<FeatureFlag[]> {
    // Load from Redis or database
    const flags = await this.prisma.featureFlag.findMany({
      include: { overrides: true },
    });
    return flags.map((f) => ({
      key: f.key,
      name: f.name,
      description: f.description,
      defaultValue: f.defaultValue,
      overrides: f.overrides.map((o) => ({
        organizationId: o.organizationId,
        value: o.value,
      })),
    }));
  }

  async setFeatureFlagDefault(operatorId: string, key: string, value: boolean): Promise<void> {
    await this.prisma.featureFlag.update({
      where: { key },
      data: { defaultValue: value },
    });

    // Invalidate cache
    await this.redis.del(`feature:${key}`);

    await this.auditService.log({
      action: 'FEATURE_FLAG_DEFAULT_CHANGED',
      actorId: operatorId,
      entityType: 'FeatureFlag',
      entityId: key,
      newValue: { value },
    });
  }

  async setFeatureFlagOverride(
    operatorId: string,
    key: string,
    organizationId: string,
    value: boolean,
  ): Promise<void> {
    await this.prisma.featureFlagOverride.upsert({
      where: {
        flagKey_organizationId: { flagKey: key, organizationId },
      },
      create: { flagKey: key, organizationId, value },
      update: { value },
    });

    await this.redis.del(`feature:${key}:${organizationId}`);

    await this.auditService.log({
      action: 'FEATURE_FLAG_OVERRIDE_SET',
      actorId: operatorId,
      entityType: 'FeatureFlagOverride',
      entityId: `${key}:${organizationId}`,
      newValue: { value },
    });
  }

  async removeFeatureFlagOverride(
    operatorId: string,
    key: string,
    organizationId: string,
  ): Promise<void> {
    await this.prisma.featureFlagOverride.delete({
      where: {
        flagKey_organizationId: { flagKey: key, organizationId },
      },
    });

    await this.redis.del(`feature:${key}:${organizationId}`);

    await this.auditService.log({
      action: 'FEATURE_FLAG_OVERRIDE_REMOVED',
      actorId: operatorId,
      entityType: 'FeatureFlagOverride',
      entityId: `${key}:${organizationId}`,
    });
  }

  // Tenant Configuration
  async getTenantConfig(organizationId: string): Promise<TenantConfig> {
    const org = await this.prisma.organization.findUnique({
      where: { id: organizationId },
      include: { featureFlagOverrides: true },
    });

    if (!org) throw new NotFoundException('Organization not found');

    const globalFlags = await this.getFeatureFlags();
    const features: Record<string, boolean> = {};

    for (const flag of globalFlags) {
      const override = org.featureFlagOverrides.find((o) => o.flagKey === flag.key);
      features[flag.key] = override ? override.value : flag.defaultValue;
    }

    return {
      organizationId,
      settings: org.settings as Record<string, unknown>,
      features,
      limits: org.limits as Record<string, number>,
    };
  }

  async updateTenantConfig(
    operatorId: string,
    organizationId: string,
    settings: Record<string, unknown>,
  ): Promise<void> {
    const existing = await this.prisma.organization.findUnique({
      where: { id: organizationId },
    });

    await this.prisma.organization.update({
      where: { id: organizationId },
      data: { settings },
    });

    await this.auditService.log({
      action: 'TENANT_CONFIG_UPDATED',
      actorId: operatorId,
      entityType: 'Organization',
      entityId: organizationId,
      previousValue: existing?.settings,
      newValue: settings,
    });
  }

  // System Health
  async getSystemHealth(): Promise<SystemHealth> {
    const services = await this.checkServices();
    const queues = await this.checkQueues();
    const errorRate = await this.getErrorRates();

    const healthyCount = services.filter((s) => s.status === 'healthy').length;
    const overall =
      healthyCount === services.length
        ? 'healthy'
        : healthyCount >= services.length / 2
          ? 'degraded'
          : 'down';

    return {
      overall,
      services,
      queues,
      errorRate,
      uptimePercent: await this.calculateUptime(),
    };
  }

  private async checkServices(): Promise<ServiceHealth[]> {
    const services: ServiceHealth[] = [];

    // Database check
    const dbStart = Date.now();
    try {
      await this.prisma.$queryRaw`SELECT 1`;
      services.push({
        service: 'PostgreSQL',
        status: 'healthy',
        latency: Date.now() - dbStart,
        lastCheck: new Date(),
      });
    } catch {
      services.push({
        service: 'PostgreSQL',
        status: 'down',
        lastCheck: new Date(),
      });
    }

    // Redis check
    const redisStart = Date.now();
    try {
      await this.redis.ping();
      services.push({
        service: 'Redis',
        status: 'healthy',
        latency: Date.now() - redisStart,
        lastCheck: new Date(),
      });
    } catch {
      services.push({
        service: 'Redis',
        status: 'down',
        lastCheck: new Date(),
      });
    }

    // Elasticsearch check (if available)
    // Add more service checks as needed

    return services;
  }

  private async checkQueues(): Promise<QueueHealth[]> {
    const queues = [this.healthQueue, this.notificationQueue, this.migrationQueue];
    const results: QueueHealth[] = [];

    for (const queue of queues) {
      const [waiting, active, completed, failed] = await Promise.all([
        queue.getWaitingCount(),
        queue.getActiveCount(),
        queue.getCompletedCount(),
        queue.getFailedCount(),
      ]);

      results.push({
        name: queue.name,
        waiting,
        active,
        completed,
        failed,
      });
    }

    return results;
  }

  private async getErrorRates(): Promise<{ last1h: number; last24h: number }> {
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);

    const [last1h, last24h] = await Promise.all([
      this.prisma.errorLog.count({ where: { createdAt: { gte: oneHourAgo } } }),
      this.prisma.errorLog.count({ where: { createdAt: { gte: oneDayAgo } } }),
    ]);

    return { last1h, last24h };
  }

  private async calculateUptime(): Promise<number> {
    // Calculate from health check history
    // Placeholder: return 99.9%
    return 99.9;
  }

  // Audit Logs
  async getAuditLogs(params: {
    actorId?: string;
    entityType?: string;
    action?: string;
    startDate?: Date;
    endDate?: Date;
    page?: number;
    limit?: number;
  }): Promise<{ items: any[]; total: number }> {
    const where: any = {};

    if (params.actorId) where.actorId = params.actorId;
    if (params.entityType) where.entityType = params.entityType;
    if (params.action) where.action = { contains: params.action };
    if (params.startDate || params.endDate) {
      where.createdAt = {};
      if (params.startDate) where.createdAt.gte = params.startDate;
      if (params.endDate) where.createdAt.lte = params.endDate;
    }

    const [items, total] = await Promise.all([
      this.prisma.auditLog.findMany({
        where,
        orderBy: { createdAt: 'desc' },
        skip: ((params.page || 1) - 1) * (params.limit || 50),
        take: params.limit || 50,
      }),
      this.prisma.auditLog.count({ where }),
    ]);

    return { items, total };
  }
}
```

**admin.controller.ts:**
```typescript
import { Controller, Get, Post, Patch, Delete, Param, Body, Query, UseGuards } from '@nestjs/common';
import { AdminService } from './admin.service';
import { InternalAuthGuard } from '../../auth/guards/internal-auth.guard';
import { Roles } from '../../auth/decorators/roles.decorator';
import { CurrentInternalUser } from '../../auth/decorators/current-internal-user.decorator';

@Controller('api/v1/internal/admin')
@UseGuards(InternalAuthGuard)
@Roles('PLATFORM_ADMIN')
export class AdminController {
  constructor(private readonly adminService: AdminService) {}

  // Feature Flags
  @Get('feature-flags')
  async getFeatureFlags() {
    return this.adminService.getFeatureFlags();
  }

  @Patch('feature-flags/:key/default')
  async setFeatureFlagDefault(
    @Param('key') key: string,
    @Body() body: { value: boolean },
    @CurrentInternalUser() user: { id: string },
  ) {
    await this.adminService.setFeatureFlagDefault(user.id, key, body.value);
    return { success: true };
  }

  @Post('feature-flags/:key/overrides')
  async setFeatureFlagOverride(
    @Param('key') key: string,
    @Body() body: { organizationId: string; value: boolean },
    @CurrentInternalUser() user: { id: string },
  ) {
    await this.adminService.setFeatureFlagOverride(user.id, key, body.organizationId, body.value);
    return { success: true };
  }

  @Delete('feature-flags/:key/overrides/:organizationId')
  async removeFeatureFlagOverride(
    @Param('key') key: string,
    @Param('organizationId') organizationId: string,
    @CurrentInternalUser() user: { id: string },
  ) {
    await this.adminService.removeFeatureFlagOverride(user.id, key, organizationId);
    return { success: true };
  }

  // Tenant Configuration
  @Get('tenants/:organizationId/config')
  async getTenantConfig(@Param('organizationId') organizationId: string) {
    return this.adminService.getTenantConfig(organizationId);
  }

  @Patch('tenants/:organizationId/config')
  async updateTenantConfig(
    @Param('organizationId') organizationId: string,
    @Body() body: { settings: Record<string, unknown> },
    @CurrentInternalUser() user: { id: string },
  ) {
    await this.adminService.updateTenantConfig(user.id, organizationId, body.settings);
    return { success: true };
  }

  // System Health
  @Get('health')
  async getSystemHealth() {
    return this.adminService.getSystemHealth();
  }

  // Audit Logs
  @Get('audit-logs')
  async getAuditLogs(@Query() query: {
    actorId?: string;
    entityType?: string;
    action?: string;
    startDate?: string;
    endDate?: string;
    page?: string;
    limit?: string;
  }) {
    return this.adminService.getAuditLogs({
      actorId: query.actorId,
      entityType: query.entityType,
      action: query.action,
      startDate: query.startDate ? new Date(query.startDate) : undefined,
      endDate: query.endDate ? new Date(query.endDate) : undefined,
      page: query.page ? parseInt(query.page) : 1,
      limit: query.limit ? parseInt(query.limit) : 50,
    });
  }
}
```

**admin.module.ts:**
```typescript
import { Module } from '@nestjs/common';
import { AdminService } from './admin.service';
import { AdminController } from './admin.controller';
import { PrismaModule } from '../../prisma/prisma.module';
import { AuditModule } from '../../audit/audit.module';
import { BullModule } from '@nestjs/bullmq';

@Module({
  imports: [
    PrismaModule,
    AuditModule,
    BullModule.registerQueue(
      { name: 'health-scores' },
      { name: 'notifications' },
      { name: 'migrations' },
    ),
  ],
  providers: [AdminService],
  controllers: [AdminController],
  exports: [AdminService],
})
export class AdminModule {}
```
  </action>
  <verify>npx tsc --noEmit compiles without errors</verify>
  <done>AdminService and AdminController created with feature flags, config, health, and audit endpoints</done>
</task>

<task type="auto">
  <name>Task 2: Create Admin API service and FeatureFlagsPanel, TenantConfigPanel</name>
  <files>
    apps/frontend/src/services/internal/admin.api.ts
    apps/frontend/src/pages/internal/admin/FeatureFlagsPanel.tsx
    apps/frontend/src/pages/internal/admin/TenantConfigPanel.tsx
  </files>
  <action>
**services/internal/admin.api.ts:**
```typescript
import { api } from '../api';

export interface FeatureFlag {
  key: string;
  name: string;
  description: string;
  defaultValue: boolean;
  overrides: { organizationId: string; value: boolean }[];
}

export interface TenantConfig {
  organizationId: string;
  settings: Record<string, unknown>;
  features: Record<string, boolean>;
  limits: Record<string, number>;
}

export interface ServiceHealth {
  service: string;
  status: 'healthy' | 'degraded' | 'down';
  latency?: number;
  lastCheck: string;
  details?: Record<string, unknown>;
}

export interface QueueHealth {
  name: string;
  waiting: number;
  active: number;
  completed: number;
  failed: number;
}

export interface SystemHealth {
  overall: 'healthy' | 'degraded' | 'down';
  services: ServiceHealth[];
  queues: QueueHealth[];
  errorRate: { last1h: number; last24h: number };
  uptimePercent: number;
}

export interface AuditLogEntry {
  id: string;
  action: string;
  actorId: string;
  actorName?: string;
  entityType: string;
  entityId: string;
  previousValue?: unknown;
  newValue?: unknown;
  createdAt: string;
}

export const adminApi = {
  // Feature Flags
  getFeatureFlags: () =>
    api.get<FeatureFlag[]>('/internal/admin/feature-flags'),

  setFeatureFlagDefault: (key: string, value: boolean) =>
    api.patch(`/internal/admin/feature-flags/${key}/default`, { value }),

  setFeatureFlagOverride: (key: string, organizationId: string, value: boolean) =>
    api.post(`/internal/admin/feature-flags/${key}/overrides`, { organizationId, value }),

  removeFeatureFlagOverride: (key: string, organizationId: string) =>
    api.delete(`/internal/admin/feature-flags/${key}/overrides/${organizationId}`),

  // Tenant Configuration
  getTenantConfig: (organizationId: string) =>
    api.get<TenantConfig>(`/internal/admin/tenants/${organizationId}/config`),

  updateTenantConfig: (organizationId: string, settings: Record<string, unknown>) =>
    api.patch(`/internal/admin/tenants/${organizationId}/config`, { settings }),

  // System Health
  getSystemHealth: () =>
    api.get<SystemHealth>('/internal/admin/health'),

  // Audit Logs
  getAuditLogs: (params?: {
    actorId?: string;
    entityType?: string;
    action?: string;
    startDate?: string;
    endDate?: string;
    page?: number;
    limit?: number;
  }) => api.get<{ items: AuditLogEntry[]; total: number }>('/internal/admin/audit-logs', { params }),
};
```

**pages/internal/admin/FeatureFlagsPanel.tsx:**
```typescript
import { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { adminApi, FeatureFlag } from '@/services/internal/admin.api';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Switch } from '@/components/ui/switch';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Plus, X, Building2 } from 'lucide-react';

export function FeatureFlagsPanel() {
  const queryClient = useQueryClient();
  const [selectedFlag, setSelectedFlag] = useState<FeatureFlag | null>(null);
  const [newOverrideOrgId, setNewOverrideOrgId] = useState('');

  const { data: flags, isLoading } = useQuery({
    queryKey: ['feature-flags'],
    queryFn: () => adminApi.getFeatureFlags(),
  });

  const setDefaultMutation = useMutation({
    mutationFn: ({ key, value }: { key: string; value: boolean }) =>
      adminApi.setFeatureFlagDefault(key, value),
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['feature-flags'] }),
  });

  const setOverrideMutation = useMutation({
    mutationFn: ({ key, organizationId, value }: { key: string; organizationId: string; value: boolean }) =>
      adminApi.setFeatureFlagOverride(key, organizationId, value),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['feature-flags'] });
      setNewOverrideOrgId('');
    },
  });

  const removeOverrideMutation = useMutation({
    mutationFn: ({ key, organizationId }: { key: string; organizationId: string }) =>
      adminApi.removeFeatureFlagOverride(key, organizationId),
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['feature-flags'] }),
  });

  if (isLoading) return <div>Loading feature flags...</div>;

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-xl font-semibold">Feature Flags</h2>
        <p className="text-gray-500">Control feature availability globally and per tenant</p>
      </div>

      <Card>
        <CardContent className="p-0">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Feature</TableHead>
                <TableHead>Description</TableHead>
                <TableHead className="text-center">Default</TableHead>
                <TableHead className="text-center">Overrides</TableHead>
                <TableHead></TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {flags?.map((flag) => (
                <TableRow key={flag.key}>
                  <TableCell>
                    <div className="font-medium">{flag.name}</div>
                    <div className="text-xs text-gray-400 font-mono">{flag.key}</div>
                  </TableCell>
                  <TableCell className="text-sm text-gray-500">
                    {flag.description}
                  </TableCell>
                  <TableCell className="text-center">
                    <Switch
                      checked={flag.defaultValue}
                      onCheckedChange={(value) =>
                        setDefaultMutation.mutate({ key: flag.key, value })
                      }
                    />
                  </TableCell>
                  <TableCell className="text-center">
                    <Badge variant="outline">
                      {flag.overrides.length} overrides
                    </Badge>
                  </TableCell>
                  <TableCell>
                    <Dialog>
                      <DialogTrigger asChild>
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() => setSelectedFlag(flag)}
                        >
                          Manage
                        </Button>
                      </DialogTrigger>
                      <DialogContent className="max-w-2xl">
                        <DialogHeader>
                          <DialogTitle>{flag.name} Overrides</DialogTitle>
                        </DialogHeader>
                        <div className="space-y-4">
                          {/* Add override */}
                          <div className="flex gap-2">
                            <Input
                              placeholder="Organization ID"
                              value={newOverrideOrgId}
                              onChange={(e) => setNewOverrideOrgId(e.target.value)}
                            />
                            <Button
                              onClick={() =>
                                setOverrideMutation.mutate({
                                  key: flag.key,
                                  organizationId: newOverrideOrgId,
                                  value: !flag.defaultValue,
                                })
                              }
                              disabled={!newOverrideOrgId}
                            >
                              <Plus className="h-4 w-4 mr-1" />
                              Add Override
                            </Button>
                          </div>

                          {/* Override list */}
                          <div className="space-y-2">
                            {flag.overrides.map((override) => (
                              <div
                                key={override.organizationId}
                                className="flex items-center justify-between p-3 border rounded-lg"
                              >
                                <div className="flex items-center gap-2">
                                  <Building2 className="h-4 w-4 text-gray-400" />
                                  <span className="font-mono text-sm">
                                    {override.organizationId}
                                  </span>
                                </div>
                                <div className="flex items-center gap-4">
                                  <Switch
                                    checked={override.value}
                                    onCheckedChange={(value) =>
                                      setOverrideMutation.mutate({
                                        key: flag.key,
                                        organizationId: override.organizationId,
                                        value,
                                      })
                                    }
                                  />
                                  <Button
                                    variant="ghost"
                                    size="sm"
                                    onClick={() =>
                                      removeOverrideMutation.mutate({
                                        key: flag.key,
                                        organizationId: override.organizationId,
                                      })
                                    }
                                  >
                                    <X className="h-4 w-4 text-red-500" />
                                  </Button>
                                </div>
                              </div>
                            ))}
                            {flag.overrides.length === 0 && (
                              <div className="text-center py-4 text-gray-500">
                                No overrides configured
                              </div>
                            )}
                          </div>
                        </div>
                      </DialogContent>
                    </Dialog>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  );
}
```

**pages/internal/admin/TenantConfigPanel.tsx:**
- Tenant selector dropdown
- Settings display in collapsible sections (branding, notifications, security)
- JSON editor for advanced settings
- Feature overrides summary
- Limits display (users, storage, API calls)
- Save/reset buttons with confirmation
  </action>
  <verify>npx tsc --noEmit compiles without errors</verify>
  <done>Admin API service, FeatureFlagsPanel, and TenantConfigPanel created</done>
</task>

<task type="auto">
  <name>Task 3: Create SystemHealthPanel, AuditLogViewer, and AdminSettingsPage</name>
  <files>
    apps/frontend/src/pages/internal/admin/SystemHealthPanel.tsx
    apps/frontend/src/pages/internal/admin/AuditLogViewer.tsx
    apps/frontend/src/pages/internal/admin/AdminSettingsPage.tsx
  </files>
  <action>
**pages/internal/admin/SystemHealthPanel.tsx:**
```typescript
import { useQuery } from '@tanstack/react-query';
import { adminApi, SystemHealth, ServiceHealth, QueueHealth } from '@/services/internal/admin.api';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Progress } from '@/components/ui/progress';
import { CheckCircle2, AlertTriangle, XCircle, RefreshCw } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';

export function SystemHealthPanel() {
  const { data: health, isLoading, refetch, isFetching } = useQuery({
    queryKey: ['system-health'],
    queryFn: () => adminApi.getSystemHealth(),
    refetchInterval: 30000, // Auto-refresh every 30 seconds
  });

  const getStatusIcon = (status: 'healthy' | 'degraded' | 'down') => {
    switch (status) {
      case 'healthy':
        return <CheckCircle2 className="h-5 w-5 text-green-600" />;
      case 'degraded':
        return <AlertTriangle className="h-5 w-5 text-yellow-600" />;
      case 'down':
        return <XCircle className="h-5 w-5 text-red-600" />;
    }
  };

  const getStatusColor = (status: 'healthy' | 'degraded' | 'down') => {
    switch (status) {
      case 'healthy':
        return 'bg-green-100 text-green-800';
      case 'degraded':
        return 'bg-yellow-100 text-yellow-800';
      case 'down':
        return 'bg-red-100 text-red-800';
    }
  };

  if (isLoading) return <div>Loading system health...</div>;
  if (!health) return null;

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-xl font-semibold">System Health</h2>
          <p className="text-gray-500">Monitor services, queues, and error rates</p>
        </div>
        <Button variant="outline" onClick={() => refetch()} disabled={isFetching}>
          <RefreshCw className={cn("h-4 w-4 mr-2", isFetching && "animate-spin")} />
          Refresh
        </Button>
      </div>

      {/* Overall Status */}
      <Card>
        <CardContent className="pt-6">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              {getStatusIcon(health.overall)}
              <div>
                <h3 className="text-lg font-semibold">Overall Status</h3>
                <Badge className={getStatusColor(health.overall)}>
                  {health.overall.toUpperCase()}
                </Badge>
              </div>
            </div>
            <div className="text-right">
              <div className="text-2xl font-bold">{health.uptimePercent}%</div>
              <div className="text-sm text-gray-500">Uptime (30 days)</div>
            </div>
          </div>
        </CardContent>
      </Card>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* Services */}
        <Card>
          <CardHeader>
            <CardTitle>Services</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            {health.services.map((service) => (
              <div
                key={service.service}
                className="flex items-center justify-between p-3 border rounded-lg"
              >
                <div className="flex items-center gap-3">
                  {getStatusIcon(service.status)}
                  <span className="font-medium">{service.service}</span>
                </div>
                <div className="flex items-center gap-4 text-sm">
                  {service.latency && (
                    <span className="text-gray-500">{service.latency}ms</span>
                  )}
                  <Badge className={getStatusColor(service.status)}>
                    {service.status}
                  </Badge>
                </div>
              </div>
            ))}
          </CardContent>
        </Card>

        {/* Queues */}
        <Card>
          <CardHeader>
            <CardTitle>Job Queues</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            {health.queues.map((queue) => (
              <div key={queue.name} className="space-y-2">
                <div className="flex justify-between font-medium">
                  <span>{queue.name}</span>
                  <span className="text-sm text-gray-500">
                    {queue.active} active
                  </span>
                </div>
                <div className="grid grid-cols-4 gap-2 text-center text-sm">
                  <div className="p-2 bg-gray-50 rounded">
                    <div className="font-bold">{queue.waiting}</div>
                    <div className="text-gray-500">Waiting</div>
                  </div>
                  <div className="p-2 bg-blue-50 rounded">
                    <div className="font-bold text-blue-600">{queue.active}</div>
                    <div className="text-gray-500">Active</div>
                  </div>
                  <div className="p-2 bg-green-50 rounded">
                    <div className="font-bold text-green-600">{queue.completed}</div>
                    <div className="text-gray-500">Done</div>
                  </div>
                  <div className="p-2 bg-red-50 rounded">
                    <div className="font-bold text-red-600">{queue.failed}</div>
                    <div className="text-gray-500">Failed</div>
                  </div>
                </div>
              </div>
            ))}
          </CardContent>
        </Card>
      </div>

      {/* Error Rates */}
      <Card>
        <CardHeader>
          <CardTitle>Error Rates</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-2 gap-6">
            <div>
              <div className="flex justify-between mb-2">
                <span>Last 1 hour</span>
                <span className={health.errorRate.last1h > 10 ? 'text-red-600 font-bold' : ''}>
                  {health.errorRate.last1h} errors
                </span>
              </div>
              <Progress
                value={Math.min(100, health.errorRate.last1h)}
                className={health.errorRate.last1h > 10 ? 'bg-red-100' : ''}
              />
            </div>
            <div>
              <div className="flex justify-between mb-2">
                <span>Last 24 hours</span>
                <span className={health.errorRate.last24h > 100 ? 'text-red-600 font-bold' : ''}>
                  {health.errorRate.last24h} errors
                </span>
              </div>
              <Progress
                value={Math.min(100, health.errorRate.last24h / 10)}
                className={health.errorRate.last24h > 100 ? 'bg-red-100' : ''}
              />
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

**pages/internal/admin/AuditLogViewer.tsx:**
- Date range picker for filtering
- Entity type and action filters
- Actor search (user ID or name)
- Paginated table with expandable rows for value diffs
- Export to CSV button
- Real-time updates via polling

**pages/internal/admin/AdminSettingsPage.tsx:**
```typescript
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { FeatureFlagsPanel } from './FeatureFlagsPanel';
import { TenantConfigPanel } from './TenantConfigPanel';
import { SystemHealthPanel } from './SystemHealthPanel';
import { AuditLogViewer } from './AuditLogViewer';
import { Flag, Settings, Activity, FileSearch } from 'lucide-react';

export function AdminSettingsPage() {
  return (
    <div className="p-6 space-y-6">
      <div>
        <h1 className="text-2xl font-bold">Platform Administration</h1>
        <p className="text-gray-500">System configuration, monitoring, and audit</p>
      </div>

      <Tabs defaultValue="health">
        <TabsList>
          <TabsTrigger value="health" className="flex items-center gap-2">
            <Activity className="h-4 w-4" />
            System Health
          </TabsTrigger>
          <TabsTrigger value="flags" className="flex items-center gap-2">
            <Flag className="h-4 w-4" />
            Feature Flags
          </TabsTrigger>
          <TabsTrigger value="config" className="flex items-center gap-2">
            <Settings className="h-4 w-4" />
            Tenant Config
          </TabsTrigger>
          <TabsTrigger value="audit" className="flex items-center gap-2">
            <FileSearch className="h-4 w-4" />
            Audit Logs
          </TabsTrigger>
        </TabsList>

        <TabsContent value="health" className="mt-6">
          <SystemHealthPanel />
        </TabsContent>

        <TabsContent value="flags" className="mt-6">
          <FeatureFlagsPanel />
        </TabsContent>

        <TabsContent value="config" className="mt-6">
          <TenantConfigPanel />
        </TabsContent>

        <TabsContent value="audit" className="mt-6">
          <AuditLogViewer />
        </TabsContent>
      </Tabs>
    </div>
  );
}
```
  </action>
  <verify>npm run lint passes; TypeScript compiles</verify>
  <done>SystemHealthPanel, AuditLogViewer, and AdminSettingsPage created</done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` from apps/frontend and apps/backend - TypeScript compiles
2. Run `npm run lint` - no lint errors
3. Verify feature flag changes are audited
4. Verify system health auto-refreshes every 30 seconds
5. Verify audit log viewer filters work correctly
</verification>

<success_criteria>
- AdminService provides feature flags, tenant config, health, and audit APIs
- FeatureFlagsPanel enables toggle and per-tenant overrides
- TenantConfigPanel displays and edits tenant settings
- SystemHealthPanel shows service status, queues, and error rates
- AuditLogViewer displays cross-tenant operations with filtering
- All admin actions are audited via AuditService
- Only PLATFORM_ADMIN role can access admin endpoints
</success_criteria>

<output>
After completion, create `.planning/phases/12-internal-operations-portal/12-17-SUMMARY.md`
</output>
