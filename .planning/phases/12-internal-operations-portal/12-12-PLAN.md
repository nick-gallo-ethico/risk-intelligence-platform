---
phase: 12-internal-operations-portal
plan: 12
type: execute
wave: 3
depends_on: [12-06, 12-07]
files_modified:
  - apps/backend/src/modules/operations/support/support-console.service.ts
  - apps/backend/src/modules/operations/support/support-console.controller.ts
  - apps/backend/src/modules/operations/support/support.module.ts
  - apps/backend/src/modules/operations/implementation/activity-log.service.ts
  - apps/backend/src/modules/operations/implementation/escalation.processor.ts
autonomous: true

must_haves:
  truths:
    - "Support console can view error logs, config, job queues for impersonated tenant"
    - "Tenant search allows finding orgs by name, domain, or ID"
    - "Activity log service manages emails, meetings, decisions"
    - "Auto-escalation processor checks blockers and escalates per timing"
  artifacts:
    - path: "apps/backend/src/modules/operations/support/support-console.service.ts"
      provides: "Debug access for support staff"
      exports: ["SupportConsoleService"]
      min_lines: 150
    - path: "apps/backend/src/modules/operations/implementation/activity-log.service.ts"
      provides: "Activity logging with native email"
      exports: ["ActivityLogService"]
  key_links:
    - from: "SupportConsoleService"
      to: "ImpersonationService"
      via: "session context"
      pattern: "impersonationService"
---

<objective>
Create support console service and implementation activity/escalation services.

Purpose: Enable Support team per CONTEXT.md: full debug access (errors, config, jobs, feature flags) via impersonation. Enable activity logging with native email and auto-escalation for blockers.

Output: SupportConsoleService with debug tools, ActivityLogService, EscalationProcessor.
</objective>

<execution_context>
@.claude/agents/gsd-executor.md
@.claude/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-internal-operations-portal/12-CONTEXT.md
@.planning/phases/12-internal-operations-portal/12-06-SUMMARY.md
@.planning/phases/12-internal-operations-portal/12-07-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Support Console Service</name>
  <files>
    apps/backend/src/modules/operations/support/support-console.service.ts
    apps/backend/src/modules/operations/support/dto/support.dto.ts
  </files>
  <action>
Create support console service per CONTEXT.md (full debug access):

**dto/support.dto.ts:**
```typescript
import { IsString, IsOptional, IsEnum, IsDateString } from 'class-validator';

export class TenantSearchDto {
  @IsOptional()
  @IsString()
  query?: string; // Search by name, domain, or ID

  @IsOptional()
  @IsString()
  status?: string;
}

export class ErrorLogFiltersDto {
  @IsOptional()
  @IsDateString()
  startDate?: string;

  @IsOptional()
  @IsDateString()
  endDate?: string;

  @IsOptional()
  @IsEnum(['error', 'warn', 'info'])
  level?: string;
}
```

**support-console.service.ts:**
```typescript
import { Injectable, Logger, ForbiddenException } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { ImpersonationService } from '../impersonation/impersonation.service';
import { TenantSearchDto, ErrorLogFiltersDto } from './dto/support.dto';

@Injectable()
export class SupportConsoleService {
  private readonly logger = new Logger(SupportConsoleService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly impersonationService: ImpersonationService,
  ) {}

  /**
   * Search for tenants by name, domain, or ID
   */
  async searchTenants(dto: TenantSearchDto) {
    const where: any = {};

    if (dto.query) {
      where.OR = [
        { name: { contains: dto.query, mode: 'insensitive' } },
        { slug: { contains: dto.query, mode: 'insensitive' } },
        { id: dto.query },
        { domains: { some: { domain: { contains: dto.query } } } },
      ];
    }

    if (dto.status) {
      where.status = dto.status;
    }

    const tenants = await this.prisma.organization.findMany({
      where,
      select: {
        id: true,
        name: true,
        slug: true,
        status: true,
        createdAt: true,
        _count: { select: { users: true, cases: true } },
      },
      take: 20,
      orderBy: { name: 'asc' },
    });

    return tenants;
  }

  /**
   * Get tenant details for support context
   */
  async getTenantDetails(organizationId: string) {
    await this.ensureImpersonating(organizationId);

    const org = await this.prisma.organization.findUnique({
      where: { id: organizationId },
      include: {
        _count: {
          select: {
            users: true,
            cases: true,
            rius: true,
            policies: true,
            campaigns: true,
          },
        },
        ssoConfig: true,
        domains: true,
      },
    });

    return org;
  }

  /**
   * Get error logs for tenant
   */
  async getErrorLogs(organizationId: string, filters: ErrorLogFiltersDto) {
    await this.ensureImpersonating(organizationId);
    await this.logSupportAction('VIEW_ERROR_LOGS', 'Organization', organizationId);

    // Query application logs (assuming ApplicationLog model exists or use audit log)
    const where: any = {
      organizationId,
      level: { in: filters.level ? [filters.level] : ['error', 'warn'] },
    };

    if (filters.startDate) where.createdAt = { gte: new Date(filters.startDate) };
    if (filters.endDate) {
      where.createdAt = { ...where.createdAt, lte: new Date(filters.endDate) };
    }

    // Use audit log as proxy for errors (actual app logging would be separate)
    const logs = await this.prisma.auditLog.findMany({
      where: {
        organizationId,
        actionCategory: 'ERROR',
        createdAt: where.createdAt,
      },
      orderBy: { createdAt: 'desc' },
      take: 100,
    });

    return logs;
  }

  /**
   * Get tenant configuration for debugging
   */
  async getTenantConfig(organizationId: string) {
    await this.ensureImpersonating(organizationId);
    await this.logSupportAction('VIEW_CONFIG', 'Organization', organizationId);

    const org = await this.prisma.organization.findUnique({
      where: { id: organizationId },
      include: {
        ssoConfig: true,
        notificationSettings: true,
        brandingConfig: true,
      },
    });

    // Get feature flags
    const featureFlags = await this.prisma.featureAdoption.findMany({
      where: { organizationId },
    });

    // Get integration status
    const hrisIntegration = await this.prisma.hrisIntegration.findFirst({
      where: { organizationId },
      select: { id: true, provider: true, isActive: true, lastSyncAt: true },
    });

    return {
      organization: org,
      featureFlags,
      integrations: { hris: hrisIntegration },
    };
  }

  /**
   * Get job queue status for tenant
   */
  async getJobQueueStatus(organizationId: string) {
    await this.ensureImpersonating(organizationId);
    await this.logSupportAction('VIEW_JOB_QUEUES', 'Organization', organizationId);

    // Get pending jobs from various queues
    // This is a simplified version - actual implementation would query BullMQ
    const pendingJobs = await this.prisma.exportJob.findMany({
      where: { organizationId, status: { in: ['PENDING', 'PROCESSING'] } },
      orderBy: { createdAt: 'desc' },
      take: 20,
    });

    const migrationJobs = await this.prisma.migrationJob.findMany({
      where: { organizationId, status: { in: ['PENDING', 'PROCESSING'] } },
      orderBy: { createdAt: 'desc' },
      take: 20,
    });

    return {
      exports: pendingJobs,
      migrations: migrationJobs,
      // Add other queue types as needed
    };
  }

  /**
   * Get search index status
   */
  async getSearchIndexStatus(organizationId: string) {
    await this.ensureImpersonating(organizationId);
    await this.logSupportAction('VIEW_SEARCH_INDEX', 'Organization', organizationId);

    // Get counts from Elasticsearch vs database
    const [dbCases, dbRius] = await Promise.all([
      this.prisma.case.count({ where: { organizationId } }),
      this.prisma.riu.count({ where: { organizationId } }),
    ]);

    // ES counts would come from SearchService
    // For now, return DB counts as reference
    return {
      database: { cases: dbCases, rius: dbRius },
      elasticsearch: { cases: 'N/A', rius: 'N/A' }, // Would query ES
      lastIndexed: null,
    };
  }

  private async ensureImpersonating(organizationId: string): Promise<void> {
    const ctx = this.impersonationService.getCurrentContext();
    if (!ctx || ctx.targetOrganizationId !== organizationId) {
      throw new ForbiddenException('Must be impersonating target organization');
    }
  }

  private async logSupportAction(
    action: string,
    entityType: string,
    entityId: string,
  ): Promise<void> {
    await this.impersonationService.logCurrentAction(action, entityType, entityId);
  }
}
```
  </action>
  <verify>TypeScript compiles: `cd apps/backend && npx tsc --noEmit`</verify>
  <done>SupportConsoleService with tenant search, debug access, and audit logging</done>
</task>

<task type="auto">
  <name>Task 2: Create Activity Log and Escalation Services</name>
  <files>
    apps/backend/src/modules/operations/implementation/activity-log.service.ts
    apps/backend/src/modules/operations/implementation/escalation.processor.ts
  </files>
  <action>
Create activity log and auto-escalation per CONTEXT.md:

**activity-log.service.ts:**
```typescript
import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { ActivityType } from '../types/implementation.types';

export interface LogActivityDto {
  projectId: string;
  type: ActivityType;
  subject?: string;
  content?: string;
  // Email fields
  emailTo?: string[];
  emailCc?: string[];
  emailMessageId?: string;
  // Meeting fields
  attendees?: string[];
  meetingDate?: Date;
  // Decision fields
  decisionRationale?: string;
}

@Injectable()
export class ActivityLogService {
  private readonly logger = new Logger(ActivityLogService.name);

  constructor(private readonly prisma: PrismaService) {}

  /**
   * Log an activity (email, meeting, decision, note)
   */
  async logActivity(dto: LogActivityDto, createdById: string) {
    const project = await this.prisma.implementationProject.findUnique({
      where: { id: dto.projectId },
    });

    if (!project) {
      throw new NotFoundException('Project not found');
    }

    const activity = await this.prisma.implementationActivity.create({
      data: {
        projectId: dto.projectId,
        type: dto.type,
        subject: dto.subject,
        content: dto.content,
        emailTo: dto.emailTo || [],
        emailCc: dto.emailCc || [],
        emailMessageId: dto.emailMessageId,
        attendees: dto.attendees || [],
        meetingDate: dto.meetingDate,
        decisionRationale: dto.decisionRationale,
        isAutoLogged: false,
        createdById,
      },
    });

    this.logger.debug(`Activity logged for project ${dto.projectId}: ${dto.type}`);
    return activity;
  }

  /**
   * Log email sent from portal (native email per CONTEXT.md)
   */
  async logEmailSent(
    projectId: string,
    to: string[],
    cc: string[],
    subject: string,
    body: string,
    messageId: string,
    createdById: string,
  ) {
    return this.logActivity({
      projectId,
      type: ActivityType.EMAIL_SENT,
      subject,
      content: body,
      emailTo: to,
      emailCc: cc,
      emailMessageId: messageId,
    }, createdById);
  }

  /**
   * Log email received via BCC (inbound logging per CONTEXT.md)
   */
  async logEmailReceived(
    projectId: string,
    from: string,
    subject: string,
    body: string,
    messageId: string,
  ) {
    return this.prisma.implementationActivity.create({
      data: {
        projectId,
        type: ActivityType.EMAIL_RECEIVED,
        subject: `From: ${from} - ${subject}`,
        content: body,
        emailMessageId: messageId,
        isAutoLogged: true,
        createdById: 'SYSTEM',
      },
    });
  }

  /**
   * Log meeting with attendees
   */
  async logMeeting(
    projectId: string,
    title: string,
    notes: string,
    attendees: string[],
    meetingDate: Date,
    createdById: string,
  ) {
    return this.logActivity({
      projectId,
      type: ActivityType.MEETING,
      subject: title,
      content: notes,
      attendees,
      meetingDate,
    }, createdById);
  }

  /**
   * Log decision with rationale
   */
  async logDecision(
    projectId: string,
    decision: string,
    rationale: string,
    createdById: string,
  ) {
    return this.logActivity({
      projectId,
      type: ActivityType.DECISION,
      subject: decision,
      decisionRationale: rationale,
    }, createdById);
  }

  /**
   * Get activity timeline for project
   */
  async getActivityTimeline(projectId: string, limit: number = 50) {
    return this.prisma.implementationActivity.findMany({
      where: { projectId },
      orderBy: { createdAt: 'desc' },
      take: limit,
    });
  }
}
```

**escalation.processor.ts:**
```typescript
import { Processor, WorkerHost, OnWorkerEvent } from '@nestjs/bullmq';
import { Logger } from '@nestjs/common';
import { Job } from 'bullmq';
import { PrismaService } from '../../../prisma/prisma.service';
import { ESCALATION_TIMING, BlockerStatus, BlockerCategory } from '../types/implementation.types';
import { differenceInDays } from 'date-fns';

export const ESCALATION_QUEUE = 'escalation';

@Processor(ESCALATION_QUEUE)
export class EscalationProcessor extends WorkerHost {
  private readonly logger = new Logger(EscalationProcessor.name);

  constructor(private readonly prisma: PrismaService) {
    super();
  }

  async process(job: Job): Promise<{ escalated: number; reminded: number }> {
    this.logger.log(`Processing escalation check job ${job.id}`);

    const openBlockers = await this.prisma.implementationBlocker.findMany({
      where: {
        status: BlockerStatus.OPEN,
        snoozeUntil: { lt: new Date() }, // Not snoozed or snooze expired
      },
      include: {
        project: { select: { id: true, leadImplementerId: true } },
      },
    });

    let escalated = 0;
    let reminded = 0;

    for (const blocker of openBlockers) {
      const daysSinceCreation = differenceInDays(new Date(), blocker.createdAt);
      const timing = ESCALATION_TIMING[blocker.category as BlockerCategory];

      // Check if needs escalation to director
      if (
        daysSinceCreation >= timing.director &&
        !blocker.escalatedToDirectorAt
      ) {
        await this.escalateToDirector(blocker);
        escalated++;
      }
      // Check if needs escalation to manager
      else if (
        daysSinceCreation >= timing.manager &&
        !blocker.escalatedToManagerAt
      ) {
        await this.escalateToManager(blocker);
        escalated++;
      }
      // Check if needs reminder
      else if (daysSinceCreation >= timing.reminder) {
        await this.sendReminder(blocker);
        reminded++;
      }
    }

    this.logger.log(`Escalation check complete: ${escalated} escalated, ${reminded} reminded`);
    return { escalated, reminded };
  }

  private async escalateToManager(blocker: any): Promise<void> {
    await this.prisma.implementationBlocker.update({
      where: { id: blocker.id },
      data: { escalatedToManagerAt: new Date() },
    });

    // TODO: Send notification to manager
    this.logger.log(`Blocker ${blocker.id} escalated to manager`);
  }

  private async escalateToDirector(blocker: any): Promise<void> {
    await this.prisma.implementationBlocker.update({
      where: { id: blocker.id },
      data: { escalatedToDirectorAt: new Date() },
    });

    // TODO: Send notification to director
    this.logger.log(`Blocker ${blocker.id} escalated to director`);
  }

  private async sendReminder(blocker: any): Promise<void> {
    // TODO: Send reminder notification
    this.logger.log(`Reminder sent for blocker ${blocker.id}`);
  }

  @OnWorkerEvent('failed')
  onFailed(job: Job, error: Error) {
    this.logger.error(`Escalation job ${job.id} failed: ${error.message}`);
  }
}
```
  </action>
  <verify>TypeScript compiles: `cd apps/backend && npx tsc --noEmit`</verify>
  <done>ActivityLogService and EscalationProcessor with category-based timing</done>
</task>

<task type="auto">
  <name>Task 3: Create Support Module and Update Implementation Module</name>
  <files>
    apps/backend/src/modules/operations/support/support-console.controller.ts
    apps/backend/src/modules/operations/support/support.module.ts
    apps/backend/src/modules/operations/support/index.ts
    apps/backend/src/modules/operations/implementation/implementation.module.ts
    apps/backend/src/modules/operations/operations.module.ts
  </files>
  <action>
Create support module and update implementation module:

**support-console.controller.ts:**
```typescript
@Controller('api/v1/internal/support')
@UseGuards(ImpersonationGuard)
export class SupportConsoleController {
  constructor(private readonly supportService: SupportConsoleService) {}

  @Get('tenants/search')
  async searchTenants(@Query() dto: TenantSearchDto) {
    return this.supportService.searchTenants(dto);
  }

  @Get('tenants/:organizationId')
  async getTenantDetails(@Param('organizationId') organizationId: string) {
    return this.supportService.getTenantDetails(organizationId);
  }

  @Get('tenants/:organizationId/errors')
  async getErrorLogs(
    @Param('organizationId') organizationId: string,
    @Query() filters: ErrorLogFiltersDto,
  ) {
    return this.supportService.getErrorLogs(organizationId, filters);
  }

  @Get('tenants/:organizationId/config')
  async getTenantConfig(@Param('organizationId') organizationId: string) {
    return this.supportService.getTenantConfig(organizationId);
  }

  @Get('tenants/:organizationId/jobs')
  async getJobQueueStatus(@Param('organizationId') organizationId: string) {
    return this.supportService.getJobQueueStatus(organizationId);
  }

  @Get('tenants/:organizationId/search-index')
  async getSearchIndexStatus(@Param('organizationId') organizationId: string) {
    return this.supportService.getSearchIndexStatus(organizationId);
  }
}
```

**support.module.ts:**
```typescript
@Module({
  imports: [PrismaModule, ImpersonationModule],
  controllers: [SupportConsoleController],
  providers: [SupportConsoleService],
  exports: [SupportConsoleService],
})
export class SupportModule {}
```

Update **implementation.module.ts** to add ActivityLogService, EscalationProcessor, and BullMQ queue.

Update OperationsModule to import SupportModule.
  </action>
  <verify>
1. `cd apps/backend && npx tsc --noEmit` - TypeScript compiles
2. `cd apps/backend && npm run lint` - Linting passes
  </verify>
  <done>SupportModule and updated ImplementationModule with activity/escalation</done>
</task>

</tasks>

<verification>
1. `cd apps/backend && npx tsc --noEmit` - TypeScript compiles
2. `cd apps/backend && npm run lint` - No linting errors
</verification>

<success_criteria>
- SupportConsoleService requires active impersonation for all debug access
- All support actions logged via impersonation audit
- Tenant search works by name, domain, or ID
- Debug endpoints expose errors, config, jobs, search index status
- ActivityLogService supports email (sent/received), meeting, decision types
- EscalationProcessor checks blockers against ESCALATION_TIMING constants
- Day 2 reminder, Day 3 manager, Day 7 director for internal blockers
</success_criteria>

<output>
After completion, create `.planning/phases/12-internal-operations-portal/12-12-SUMMARY.md`
</output>
