---
phase: 12-internal-operations-portal
plan: 10
type: execute
wave: 2
depends_on: [12-01]
files_modified:
  - apps/backend/src/modules/operations/hotline-ops/directive-admin.service.ts
  - apps/backend/src/modules/operations/hotline-ops/bulk-qa.service.ts
  - apps/backend/src/modules/operations/hotline-ops/operator-status.service.ts
  - apps/backend/src/modules/operations/hotline-ops/hotline-ops.controller.ts
  - apps/backend/src/modules/operations/hotline-ops/hotline-ops.module.ts
  - apps/backend/src/modules/operations/hotline-ops/dto/hotline-ops.dto.ts
autonomous: true

must_haves:
  truths:
    - "Directives can be created, updated, deleted with version tracking"
    - "Bulk QA actions (approve, reject, reassign) work on multiple items"
    - "Global QA queue view shows items across all tenants"
    - "Operator status tracked in real-time (available, on call, break, offline)"
  artifacts:
    - path: "apps/backend/src/modules/operations/hotline-ops/directive-admin.service.ts"
      provides: "Directive CRUD with versioning"
      exports: ["DirectiveAdminService"]
      min_lines: 100
    - path: "apps/backend/src/modules/operations/hotline-ops/bulk-qa.service.ts"
      provides: "Bulk QA operations"
      exports: ["BulkQaService"]
  key_links:
    - from: "BulkQaService"
      to: "QaQueueService"
      via: "processItem"
      pattern: "qaQueueService"
---

<objective>
Create hotline operations services for directive management, bulk QA, and operator status.

Purpose: Enable Hotline Operations team per CONTEXT.md: edit directives (both draft, Ethico approves), bulk QA actions, global queue view, real-time operator status board.

Output: DirectiveAdminService, BulkQaService, OperatorStatusService with cross-tenant capabilities.
</objective>

<execution_context>
@.claude/agents/gsd-executor.md
@.claude/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-internal-operations-portal/12-CONTEXT.md
@.planning/phases/12-internal-operations-portal/12-RESEARCH.md
@apps/backend/src/modules/portals/operator/directives.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Hotline Ops DTOs and Types</name>
  <files>
    apps/backend/src/modules/operations/hotline-ops/dto/hotline-ops.dto.ts
    apps/backend/src/modules/operations/hotline-ops/types/operator-status.types.ts
  </files>
  <action>
Create DTOs and types for hotline operations:

**types/operator-status.types.ts:**
```typescript
export enum OperatorStatus {
  AVAILABLE = 'AVAILABLE',
  ON_CALL = 'ON_CALL',
  ON_BREAK = 'ON_BREAK',
  OFFLINE = 'OFFLINE',
}

export interface OperatorStatusUpdate {
  operatorId: string;
  status: OperatorStatus;
  languages?: string[]; // For skill-based routing
  updatedAt: Date;
}

export interface OperatorMetrics {
  operatorId: string;
  callsToday: number;
  avgHandleTime: number; // in seconds
  queueDepth: number;
}
```

**dto/hotline-ops.dto.ts:**
```typescript
import { IsString, IsArray, IsEnum, IsOptional, IsUUID, IsBoolean, ValidateNested, IsInt, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class BulkQaActionDto {
  @IsArray()
  @IsUUID('4', { each: true })
  riuIds: string[];

  @IsEnum(['APPROVE', 'REJECT', 'REASSIGN', 'CHANGE_PRIORITY'])
  action: 'APPROVE' | 'REJECT' | 'REASSIGN' | 'CHANGE_PRIORITY';

  @IsOptional()
  @IsString()
  reason?: string;

  @IsOptional()
  @IsUUID()
  assignToUserId?: string; // For REASSIGN

  @IsOptional()
  @IsInt()
  @Min(1)
  priority?: number; // For CHANGE_PRIORITY
}

export class CreateDirectiveDto {
  @IsUUID()
  organizationId: string;

  @IsEnum(['OPENING', 'INTAKE', 'CATEGORY_SPECIFIC', 'CLOSING'])
  stage: string;

  @IsOptional()
  @IsUUID()
  categoryId?: string;

  @IsString()
  title: string;

  @IsString()
  content: string;

  @IsOptional()
  @IsBoolean()
  isReadAloud?: boolean;

  @IsOptional()
  @IsBoolean()
  isDraft?: boolean; // Client drafts need Ethico approval
}

export class UpdateDirectiveDto {
  @IsOptional()
  @IsString()
  title?: string;

  @IsOptional()
  @IsString()
  content?: string;

  @IsOptional()
  @IsBoolean()
  isReadAloud?: boolean;

  @IsOptional()
  @IsBoolean()
  isActive?: boolean;

  @IsOptional()
  @IsBoolean()
  approveAndPublish?: boolean; // Ethico approves client draft
}

export class UpdateOperatorStatusDto {
  @IsEnum(['AVAILABLE', 'ON_CALL', 'ON_BREAK', 'OFFLINE'])
  status: string;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  languages?: string[];
}
```
  </action>
  <verify>TypeScript compiles: `cd apps/backend && npx tsc --noEmit`</verify>
  <done>DTOs and types for hotline operations defined</done>
</task>

<task type="auto">
  <name>Task 2: Create Directive Admin and Bulk QA Services</name>
  <files>
    apps/backend/src/modules/operations/hotline-ops/directive-admin.service.ts
    apps/backend/src/modules/operations/hotline-ops/bulk-qa.service.ts
  </files>
  <action>
Create services per CONTEXT.md requirements:

**directive-admin.service.ts:**
```typescript
import { Injectable, NotFoundException, Logger, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { AuditService } from '../../audit/audit.service';
import { CreateDirectiveDto, UpdateDirectiveDto } from './dto/hotline-ops.dto';

@Injectable()
export class DirectiveAdminService {
  private readonly logger = new Logger(DirectiveAdminService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly auditService: AuditService,
  ) {}

  /**
   * Create a directive (with optional draft status for client-submitted)
   */
  async createDirective(
    dto: CreateDirectiveDto,
    createdById: string,
  ) {
    // Validate category if CATEGORY_SPECIFIC
    if (dto.stage === 'CATEGORY_SPECIFIC' && !dto.categoryId) {
      throw new BadRequestException('categoryId required for CATEGORY_SPECIFIC stage');
    }

    // Get max order for this stage
    const maxOrder = await this.prisma.clientDirective.aggregate({
      where: { organizationId: dto.organizationId, stage: dto.stage as any },
      _max: { order: true },
    });

    const directive = await this.prisma.clientDirective.create({
      data: {
        organizationId: dto.organizationId,
        stage: dto.stage as any,
        categoryId: dto.categoryId,
        title: dto.title,
        content: dto.content,
        isReadAloud: dto.isReadAloud ?? false,
        order: (maxOrder._max.order ?? -1) + 1,
        isActive: !(dto.isDraft ?? false), // Drafts not active
        // Version tracking
        version: 1,
      },
    });

    await this.auditService.log({
      organizationId: dto.organizationId,
      entityType: 'DIRECTIVE',
      entityId: directive.id,
      action: 'DIRECTIVE_CREATED',
      actionCategory: 'CREATE',
      actionDescription: `Created directive: ${dto.title}`,
      actorUserId: createdById,
      actorType: 'INTERNAL_USER',
    });

    return directive;
  }

  /**
   * Update a directive with version tracking
   */
  async updateDirective(
    directiveId: string,
    dto: UpdateDirectiveDto,
    updatedById: string,
  ) {
    const current = await this.prisma.clientDirective.findUnique({
      where: { id: directiveId },
    });

    if (!current) {
      throw new NotFoundException('Directive not found');
    }

    // Archive current version before updating
    await this.prisma.directiveVersion.create({
      data: {
        directiveId,
        version: current.version,
        stage: current.stage,
        content: current.content,
        archivedAt: new Date(),
        archivedById: updatedById,
      },
    });

    // Build update data
    const updateData: any = {
      version: current.version + 1,
      updatedAt: new Date(),
    };

    if (dto.title !== undefined) updateData.title = dto.title;
    if (dto.content !== undefined) updateData.content = dto.content;
    if (dto.isReadAloud !== undefined) updateData.isReadAloud = dto.isReadAloud;
    if (dto.isActive !== undefined) updateData.isActive = dto.isActive;

    // Ethico approval: publish a draft
    if (dto.approveAndPublish) {
      updateData.isActive = true;
    }

    const updated = await this.prisma.clientDirective.update({
      where: { id: directiveId },
      data: updateData,
    });

    await this.auditService.log({
      organizationId: current.organizationId,
      entityType: 'DIRECTIVE',
      entityId: directiveId,
      action: dto.approveAndPublish ? 'DIRECTIVE_APPROVED' : 'DIRECTIVE_UPDATED',
      actionCategory: 'UPDATE',
      actionDescription: `${dto.approveAndPublish ? 'Approved and published' : 'Updated'} directive: ${updated.title}`,
      actorUserId: updatedById,
      actorType: 'INTERNAL_USER',
      changes: {
        content: dto.content ? { old: current.content, new: dto.content } : undefined,
      },
    });

    return updated;
  }

  /**
   * List all directives across tenants (for global management)
   */
  async listAllDirectives(filters: {
    organizationId?: string;
    stage?: string;
    includeInactive?: boolean;
    limit?: number;
    offset?: number;
  }) {
    const where: any = {};
    if (filters.organizationId) where.organizationId = filters.organizationId;
    if (filters.stage) where.stage = filters.stage;
    if (!filters.includeInactive) where.isActive = true;

    const [items, total] = await Promise.all([
      this.prisma.clientDirective.findMany({
        where,
        include: {
          category: { select: { id: true, name: true } },
          organization: { select: { id: true, name: true } },
        },
        orderBy: [{ organizationId: 'asc' }, { stage: 'asc' }, { order: 'asc' }],
        take: filters.limit || 50,
        skip: filters.offset || 0,
      }),
      this.prisma.clientDirective.count({ where }),
    ]);

    return { items, total };
  }
}
```

**bulk-qa.service.ts:**
```typescript
import { Injectable, Logger, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { BulkQaActionDto } from './dto/hotline-ops.dto';

@Injectable()
export class BulkQaService {
  private readonly logger = new Logger(BulkQaService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  /**
   * Get global QA queue across all tenants
   */
  async getGlobalQaQueue(filters: {
    qaStatus?: string;
    priority?: number;
    limit?: number;
    offset?: number;
  }) {
    const where: any = {
      qaStatus: filters.qaStatus || 'PENDING',
    };
    if (filters.priority) where.priority = { gte: filters.priority };

    const [items, total] = await Promise.all([
      this.prisma.riu.findMany({
        where,
        include: {
          organization: { select: { id: true, name: true } },
          category: { select: { id: true, name: true } },
        },
        orderBy: [
          { priority: 'desc' },  // HIGH first
          { createdAt: 'asc' },  // Oldest first
        ],
        take: filters.limit || 50,
        skip: filters.offset || 0,
      }),
      this.prisma.riu.count({ where }),
    ]);

    return { items, total };
  }

  /**
   * Perform bulk QA action
   */
  async performBulkAction(
    dto: BulkQaActionDto,
    performedById: string,
  ): Promise<{ processed: number; errors: string[] }> {
    const errors: string[] = [];
    let processed = 0;

    // Validate RIUs exist and are in correct state
    const rius = await this.prisma.riu.findMany({
      where: { id: { in: dto.riuIds } },
      select: { id: true, qaStatus: true, organizationId: true, referenceNumber: true },
    });

    if (rius.length !== dto.riuIds.length) {
      const found = new Set(rius.map(r => r.id));
      const missing = dto.riuIds.filter(id => !found.has(id));
      errors.push(`RIUs not found: ${missing.join(', ')}`);
    }

    // Check for already-processed items
    for (const riu of rius) {
      if (dto.action === 'APPROVE' || dto.action === 'REJECT') {
        if (riu.qaStatus !== 'PENDING' && riu.qaStatus !== 'IN_REVIEW') {
          errors.push(`${riu.referenceNumber}: Already processed (${riu.qaStatus})`);
          continue;
        }
      }
    }

    // Process each RIU
    for (const riu of rius) {
      try {
        switch (dto.action) {
          case 'APPROVE':
            await this.prisma.riu.update({
              where: { id: riu.id },
              data: {
                qaStatus: 'APPROVED',
                qaApprovedAt: new Date(),
                qaApprovedById: performedById,
              },
            });
            processed++;
            break;

          case 'REJECT':
            if (!dto.reason) {
              errors.push(`${riu.referenceNumber}: Rejection reason required`);
              continue;
            }
            await this.prisma.riu.update({
              where: { id: riu.id },
              data: {
                qaStatus: 'REJECTED',
                qaRejectionReason: dto.reason,
              },
            });
            processed++;
            break;

          case 'REASSIGN':
            if (!dto.assignToUserId) {
              errors.push(`${riu.referenceNumber}: Assign-to user required`);
              continue;
            }
            await this.prisma.riu.update({
              where: { id: riu.id },
              data: {
                qaReviewerId: dto.assignToUserId,
              },
            });
            processed++;
            break;

          case 'CHANGE_PRIORITY':
            if (!dto.priority) {
              errors.push(`${riu.referenceNumber}: Priority value required`);
              continue;
            }
            await this.prisma.riu.update({
              where: { id: riu.id },
              data: { priority: dto.priority },
            });
            processed++;
            break;
        }
      } catch (error) {
        errors.push(`${riu.referenceNumber}: ${error.message}`);
      }
    }

    this.logger.log(
      `Bulk QA action ${dto.action}: ${processed}/${dto.riuIds.length} processed`,
    );

    return { processed, errors };
  }

  /**
   * Get QA reviewer throughput metrics
   */
  async getReviewerMetrics(
    startDate: Date,
    endDate: Date,
  ) {
    const metrics = await this.prisma.riu.groupBy({
      by: ['qaApprovedById'],
      where: {
        qaApprovedAt: { gte: startDate, lte: endDate },
        qaApprovedById: { not: null },
      },
      _count: { id: true },
    });

    return metrics.map(m => ({
      reviewerId: m.qaApprovedById,
      itemsReviewed: m._count.id,
    }));
  }
}
```
  </action>
  <verify>TypeScript compiles: `cd apps/backend && npx tsc --noEmit`</verify>
  <done>DirectiveAdminService and BulkQaService with cross-tenant capabilities</done>
</task>

<task type="auto">
  <name>Task 3: Create Operator Status Service, Controller, and Module</name>
  <files>
    apps/backend/src/modules/operations/hotline-ops/operator-status.service.ts
    apps/backend/src/modules/operations/hotline-ops/hotline-ops.controller.ts
    apps/backend/src/modules/operations/hotline-ops/hotline-ops.module.ts
    apps/backend/src/modules/operations/hotline-ops/index.ts
    apps/backend/src/modules/operations/operations.module.ts
  </files>
  <action>
Create operator status service and controller:

**operator-status.service.ts:**
```typescript
import { Injectable, Logger } from '@nestjs/common';
import { Cache } from 'cache-manager';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Inject } from '@nestjs/common';
import { OperatorStatus, OperatorStatusUpdate } from './types/operator-status.types';

const OPERATOR_STATUS_KEY = 'operator_status';
const STATUS_TTL = 300; // 5 minutes

@Injectable()
export class OperatorStatusService {
  private readonly logger = new Logger(OperatorStatusService.name);

  constructor(
    @Inject(CACHE_MANAGER) private readonly cache: Cache,
  ) {}

  /**
   * Update operator status
   */
  async updateStatus(
    operatorId: string,
    status: OperatorStatus,
    languages?: string[],
  ): Promise<void> {
    const allStatuses = await this.getAllStatuses();

    allStatuses[operatorId] = {
      operatorId,
      status,
      languages,
      updatedAt: new Date(),
    };

    await this.cache.set(OPERATOR_STATUS_KEY, allStatuses, STATUS_TTL * 1000);
    this.logger.debug(`Operator ${operatorId} status updated to ${status}`);
  }

  /**
   * Get all operator statuses
   */
  async getAllStatuses(): Promise<Record<string, OperatorStatusUpdate>> {
    return (await this.cache.get<Record<string, OperatorStatusUpdate>>(OPERATOR_STATUS_KEY)) || {};
  }

  /**
   * Get live operator status board
   */
  async getStatusBoard() {
    const statuses = await this.getAllStatuses();
    const operators = Object.values(statuses);

    return {
      available: operators.filter(o => o.status === OperatorStatus.AVAILABLE).length,
      onCall: operators.filter(o => o.status === OperatorStatus.ON_CALL).length,
      onBreak: operators.filter(o => o.status === OperatorStatus.ON_BREAK).length,
      offline: operators.filter(o => o.status === OperatorStatus.OFFLINE).length,
      operators,
    };
  }

  /**
   * Get operators by language for skill-based routing
   */
  async getOperatorsByLanguage(language: string) {
    const statuses = await this.getAllStatuses();
    return Object.values(statuses).filter(
      o => o.status === OperatorStatus.AVAILABLE &&
           o.languages?.includes(language),
    );
  }
}
```

**hotline-ops.controller.ts:**
```typescript
@Controller('api/v1/internal/hotline-ops')
export class HotlineOpsController {
  constructor(
    private readonly directiveAdminService: DirectiveAdminService,
    private readonly bulkQaService: BulkQaService,
    private readonly operatorStatusService: OperatorStatusService,
  ) {}

  // Directives
  @Get('directives')
  async listDirectives(
    @Query('orgId') organizationId?: string,
    @Query('stage') stage?: string,
    @Query('includeInactive') includeInactive?: boolean,
  ) {
    return this.directiveAdminService.listAllDirectives({
      organizationId, stage, includeInactive,
    });
  }

  @Post('directives')
  async createDirective(@Body() dto: CreateDirectiveDto) {
    // TODO: Get user ID from auth
    return this.directiveAdminService.createDirective(dto, 'TODO');
  }

  @Patch('directives/:id')
  async updateDirective(
    @Param('id') id: string,
    @Body() dto: UpdateDirectiveDto,
  ) {
    // TODO: Get user ID from auth
    return this.directiveAdminService.updateDirective(id, dto, 'TODO');
  }

  // QA Queue
  @Get('qa-queue')
  async getGlobalQaQueue(
    @Query('status') qaStatus?: string,
    @Query('priority') priority?: number,
    @Query('limit') limit?: number,
  ) {
    return this.bulkQaService.getGlobalQaQueue({
      qaStatus, priority: priority ? Number(priority) : undefined, limit,
    });
  }

  @Post('qa-queue/bulk-action')
  async performBulkAction(@Body() dto: BulkQaActionDto) {
    // TODO: Get user ID from auth
    return this.bulkQaService.performBulkAction(dto, 'TODO');
  }

  @Get('qa-queue/reviewer-metrics')
  async getReviewerMetrics(
    @Query('startDate') startDate: string,
    @Query('endDate') endDate: string,
  ) {
    return this.bulkQaService.getReviewerMetrics(new Date(startDate), new Date(endDate));
  }

  // Operator Status
  @Get('operator-status')
  async getStatusBoard() {
    return this.operatorStatusService.getStatusBoard();
  }

  @Patch('operator-status/:operatorId')
  async updateOperatorStatus(
    @Param('operatorId') operatorId: string,
    @Body() dto: UpdateOperatorStatusDto,
  ) {
    await this.operatorStatusService.updateStatus(
      operatorId,
      dto.status as any,
      dto.languages,
    );
    return { success: true };
  }
}
```

**hotline-ops.module.ts:**
```typescript
@Module({
  imports: [PrismaModule, AuditModule, CacheModule, EventEmitterModule],
  controllers: [HotlineOpsController],
  providers: [DirectiveAdminService, BulkQaService, OperatorStatusService],
  exports: [DirectiveAdminService, BulkQaService, OperatorStatusService],
})
export class HotlineOpsModule {}
```

Update OperationsModule to import HotlineOpsModule.
  </action>
  <verify>
1. `cd apps/backend && npx tsc --noEmit` - TypeScript compiles
2. `cd apps/backend && npm run lint` - Linting passes
  </verify>
  <done>HotlineOpsModule with directive admin, bulk QA, and operator status</done>
</task>

</tasks>

<verification>
1. `cd apps/backend && npx tsc --noEmit` - TypeScript compiles
2. `cd apps/backend && npm run lint` - No linting errors
3. HotlineOpsModule exported from operations module
</verification>

<success_criteria>
- DirectiveAdminService creates/updates with version tracking and audit
- approveAndPublish flag enables Ethico to publish client drafts
- BulkQaService performs APPROVE, REJECT, REASSIGN, CHANGE_PRIORITY on multiple items
- Global QA queue fetches across all tenants sorted by priority/age
- OperatorStatusService tracks real-time status in cache
- getStatusBoard returns counts by status + operator list
</success_criteria>

<output>
After completion, create `.planning/phases/12-internal-operations-portal/12-10-SUMMARY.md`
</output>
