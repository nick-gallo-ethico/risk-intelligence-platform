---
phase: 12-internal-operations-portal
plan: 11
type: execute
wave: 2
depends_on: [12-03, 12-04]
files_modified:
  - apps/backend/src/modules/operations/client-health/peer-benchmark.service.ts
  - apps/backend/src/modules/operations/client-health/peer-benchmark.processor.ts
  - apps/backend/src/modules/operations/training/certification.service.ts
  - apps/backend/src/modules/operations/training/training.controller.ts
  - apps/backend/src/modules/operations/training/training.module.ts
autonomous: true

must_haves:
  truths:
    - "Peer benchmarks calculate nightly aggregates with privacy minimum (5 peers)"
    - "Benchmarks support filtering by industry and company size"
    - "Certification service manages courses, quizzes, certificates"
    - "Quiz attempts track progress with 80% pass threshold"
  artifacts:
    - path: "apps/backend/src/modules/operations/client-health/peer-benchmark.service.ts"
      provides: "Peer comparison with percentile calculation"
      exports: ["PeerBenchmarkService"]
      min_lines: 150
    - path: "apps/backend/src/modules/operations/training/certification.service.ts"
      provides: "Course progress and quiz management"
      exports: ["CertificationService"]
      min_lines: 200
  key_links:
    - from: "PeerBenchmarkService"
      to: "PeerBenchmark"
      via: "nightly aggregation"
      pattern: "calculateBenchmarks"
---

<objective>
Create peer benchmark service and certification/training system.

Purpose: Enable per-CONTEXT.md peer comparison (configurable filtering, 5-peer minimum, percentile display) and full certification system (courses, quizzes, 80% pass, PDF certificates).

Output: PeerBenchmarkService with nightly aggregation, CertificationService with course/quiz/certificate management.
</objective>

<execution_context>
@.claude/agents/gsd-executor.md
@.claude/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-internal-operations-portal/12-CONTEXT.md
@.planning/phases/12-internal-operations-portal/12-03-SUMMARY.md
@.planning/phases/12-internal-operations-portal/12-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Peer Benchmark Service and Processor</name>
  <files>
    apps/backend/src/modules/operations/client-health/peer-benchmark.service.ts
    apps/backend/src/modules/operations/client-health/peer-benchmark.processor.ts
  </files>
  <action>
Create peer benchmark service per CONTEXT.md:

**peer-benchmark.service.ts:**
```typescript
import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { BenchmarkDisplay } from '../types/health-metrics.types';

const MIN_PEER_COUNT = 5; // Privacy minimum per CONTEXT.md

export interface BenchmarkFilter {
  industrySector?: string;
  employeeMin?: number;
  employeeMax?: number;
}

@Injectable()
export class PeerBenchmarkService {
  private readonly logger = new Logger(PeerBenchmarkService.name);

  constructor(private readonly prisma: PrismaService) {}

  /**
   * Get benchmark comparison for a tenant
   */
  async getBenchmarkComparison(
    organizationId: string,
    metricName: string,
    filter?: BenchmarkFilter,
  ): Promise<BenchmarkDisplay | null> {
    // Get tenant's value
    const tenantValue = await this.getTenantMetricValue(organizationId, metricName);
    if (tenantValue === null) return null;

    // Get matching benchmark
    const benchmark = await this.prisma.peerBenchmark.findFirst({
      where: {
        metricName,
        industrySector: filter?.industrySector ?? null,
        employeeMin: filter?.employeeMin ?? null,
        employeeMax: filter?.employeeMax ?? null,
      },
      orderBy: { calculatedAt: 'desc' },
    });

    if (!benchmark || benchmark.peerCount < MIN_PEER_COUNT) {
      return null; // Not enough peers for privacy
    }

    // Calculate percentile
    const percentile = this.calculatePercentile(tenantValue, benchmark);

    return {
      yourValue: tenantValue,
      percentile,
      p25: benchmark.p25,
      median: benchmark.median,
      p75: benchmark.p75,
      peerCount: benchmark.peerCount,
      filterDescription: this.buildFilterDescription(filter, benchmark.peerCount),
    };
  }

  /**
   * Calculate all benchmarks (called by nightly processor)
   */
  async calculateBenchmarks(): Promise<{ metricsCalculated: number }> {
    const metrics = [
      'attestation_completion_rate',
      'case_resolution_time',
      'case_on_time_rate',
      'login_rate',
      'feature_adoption_rate',
    ];

    const filters = await this.getFilterCombinations();
    let count = 0;

    for (const metricName of metrics) {
      for (const filter of filters) {
        await this.calculateBenchmarkForFilter(metricName, filter);
        count++;
      }
    }

    this.logger.log(`Calculated ${count} benchmark aggregates`);
    return { metricsCalculated: count };
  }

  /**
   * Calculate benchmark for a specific metric and filter
   */
  private async calculateBenchmarkForFilter(
    metricName: string,
    filter: BenchmarkFilter | null,
  ): Promise<void> {
    // Get all tenant values for this metric
    const values = await this.getAllTenantValues(metricName, filter);

    if (values.length < MIN_PEER_COUNT) {
      return; // Not enough data
    }

    // Sort for percentile calculation
    values.sort((a, b) => a - b);

    const stats = {
      peerCount: values.length,
      p25: this.getPercentileValue(values, 25),
      median: this.getPercentileValue(values, 50),
      p75: this.getPercentileValue(values, 75),
      mean: values.reduce((a, b) => a + b, 0) / values.length,
      min: values[0],
      max: values[values.length - 1],
    };

    // Upsert benchmark
    await this.prisma.peerBenchmark.upsert({
      where: {
        metricName_industrySector_employeeMin_employeeMax_calculatedAt: {
          metricName,
          industrySector: filter?.industrySector ?? null,
          employeeMin: filter?.employeeMin ?? null,
          employeeMax: filter?.employeeMax ?? null,
          calculatedAt: new Date(new Date().setHours(0, 0, 0, 0)), // Today at midnight
        },
      },
      create: {
        metricName,
        industrySector: filter?.industrySector,
        employeeMin: filter?.employeeMin,
        employeeMax: filter?.employeeMax,
        ...stats,
      },
      update: stats,
    });
  }

  private async getTenantMetricValue(
    organizationId: string,
    metricName: string,
  ): Promise<number | null> {
    // Get latest health score for component values
    const score = await this.prisma.tenantHealthScore.findFirst({
      where: { organizationId },
      orderBy: { calculatedAt: 'desc' },
    });

    if (!score) return null;

    switch (metricName) {
      case 'attestation_completion_rate':
        return score.campaignCompletionScore;
      case 'case_on_time_rate':
        return score.caseResolutionScore;
      case 'login_rate':
        return score.loginScore;
      case 'feature_adoption_rate':
        return score.featureAdoptionScore;
      default:
        return null;
    }
  }

  private async getAllTenantValues(
    metricName: string,
    filter: BenchmarkFilter | null,
  ): Promise<number[]> {
    // Build org filter
    const orgWhere: any = { status: 'ACTIVE' };
    if (filter?.industrySector) {
      orgWhere.industrySector = filter.industrySector;
    }
    if (filter?.employeeMin || filter?.employeeMax) {
      orgWhere.employeeCount = {};
      if (filter?.employeeMin) orgWhere.employeeCount.gte = filter.employeeMin;
      if (filter?.employeeMax) orgWhere.employeeCount.lte = filter.employeeMax;
    }

    const orgs = await this.prisma.organization.findMany({
      where: orgWhere,
      select: { id: true },
    });

    const values: number[] = [];
    for (const org of orgs) {
      const value = await this.getTenantMetricValue(org.id, metricName);
      if (value !== null) values.push(value);
    }

    return values;
  }

  private async getFilterCombinations(): Promise<(BenchmarkFilter | null)[]> {
    // Start with no filter (all customers)
    const filters: (BenchmarkFilter | null)[] = [null];

    // Add industry filters
    const industries = await this.prisma.organization.groupBy({
      by: ['industrySector'],
      where: { industrySector: { not: null } },
    });
    for (const i of industries) {
      if (i.industrySector) {
        filters.push({ industrySector: i.industrySector });
      }
    }

    // Add size filters
    const sizes = [
      { employeeMin: 1, employeeMax: 100 },
      { employeeMin: 101, employeeMax: 500 },
      { employeeMin: 501, employeeMax: 2000 },
      { employeeMin: 2001, employeeMax: undefined },
    ];
    for (const size of sizes) {
      filters.push(size);
    }

    return filters;
  }

  private getPercentileValue(sortedValues: number[], percentile: number): number {
    const index = (percentile / 100) * (sortedValues.length - 1);
    const lower = Math.floor(index);
    const upper = Math.ceil(index);
    if (lower === upper) return sortedValues[lower];
    return sortedValues[lower] + (sortedValues[upper] - sortedValues[lower]) * (index - lower);
  }

  private calculatePercentile(value: number, benchmark: any): number {
    // Estimate percentile based on quartiles
    if (value <= benchmark.p25) {
      return Math.round((value / benchmark.p25) * 25);
    } else if (value <= benchmark.median) {
      return 25 + Math.round(((value - benchmark.p25) / (benchmark.median - benchmark.p25)) * 25);
    } else if (value <= benchmark.p75) {
      return 50 + Math.round(((value - benchmark.median) / (benchmark.p75 - benchmark.median)) * 25);
    } else {
      return 75 + Math.round(((value - benchmark.p75) / (benchmark.max - benchmark.p75)) * 25);
    }
  }

  private buildFilterDescription(filter: BenchmarkFilter | undefined, peerCount: number): string {
    const parts: string[] = [];
    if (filter?.industrySector) parts.push(filter.industrySector);
    if (filter?.employeeMin || filter?.employeeMax) {
      if (filter.employeeMin && filter.employeeMax) {
        parts.push(`${filter.employeeMin}-${filter.employeeMax} employees`);
      } else if (filter.employeeMin) {
        parts.push(`${filter.employeeMin}+ employees`);
      } else {
        parts.push(`Up to ${filter.employeeMax} employees`);
      }
    }
    const base = parts.length > 0 ? parts.join(', ') : 'all customers';
    return `${base} (${peerCount} organizations)`;
  }
}
```

**peer-benchmark.processor.ts:**
```typescript
import { Processor, WorkerHost, OnWorkerEvent } from '@nestjs/bullmq';
import { Logger } from '@nestjs/common';
import { Job } from 'bullmq';
import { PeerBenchmarkService } from './peer-benchmark.service';

export const BENCHMARK_QUEUE = 'benchmarks';

@Processor(BENCHMARK_QUEUE)
export class PeerBenchmarkProcessor extends WorkerHost {
  private readonly logger = new Logger(PeerBenchmarkProcessor.name);

  constructor(private readonly benchmarkService: PeerBenchmarkService) {
    super();
  }

  async process(job: Job): Promise<{ metricsCalculated: number }> {
    this.logger.log(`Processing benchmark calculation job ${job.id}`);
    return this.benchmarkService.calculateBenchmarks();
  }

  @OnWorkerEvent('failed')
  onFailed(job: Job, error: Error) {
    this.logger.error(`Benchmark job ${job.id} failed: ${error.message}`);
  }
}
```

Update ClientHealthModule to add PeerBenchmarkService, processor, and queue.
  </action>
  <verify>TypeScript compiles: `cd apps/backend && npx tsc --noEmit`</verify>
  <done>PeerBenchmarkService with nightly aggregation and percentile comparison</done>
</task>

<task type="auto">
  <name>Task 2: Create Certification Service</name>
  <files>
    apps/backend/src/modules/operations/training/certification.service.ts
    apps/backend/src/modules/operations/training/dto/training.dto.ts
  </files>
  <action>
Create certification service per CONTEXT.md (80% pass, PDF certificates):

**dto/training.dto.ts:**
```typescript
import { IsString, IsEnum, IsArray, IsUUID, IsOptional, IsInt, Min, Max } from 'class-validator';
import { CourseType, CertificationLevel, TrackType } from '../types/certification.types';

export class CreateTrackDto {
  @IsString()
  name: string;

  @IsString()
  slug: string;

  @IsOptional()
  @IsString()
  description?: string;

  @IsEnum(TrackType)
  type: TrackType;

  @IsEnum(CertificationLevel)
  level: CertificationLevel;

  @IsOptional()
  isRequired?: boolean;

  @IsOptional()
  @IsInt()
  estimatedMinutes?: number;
}

export class SubmitQuizDto {
  @IsArray()
  answers: { questionId: string; selectedOptionIds: string[] }[];
}
```

**certification.service.ts:**
```typescript
import { Injectable, NotFoundException, BadRequestException, Logger } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { QUIZ_PASS_THRESHOLD, QuizStatus, CertificateStatus } from '../types/certification.types';
import { nanoid } from 'nanoid';

interface QuizQuestion {
  id: string;
  question: string;
  type: 'MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'MULTI_SELECT';
  options: { id: string; text: string }[];
  correctOptionIds: string[];
}

@Injectable()
export class CertificationService {
  private readonly logger = new Logger(CertificationService.name);

  constructor(private readonly prisma: PrismaService) {}

  /**
   * Get all tracks with progress for a user
   */
  async getTracksWithProgress(userId: string, isInternalUser: boolean) {
    const tracks = await this.prisma.certificationTrack.findMany({
      where: { isActive: true },
      include: {
        courses: {
          where: { isActive: true },
          orderBy: { sortOrder: 'asc' },
        },
      },
      orderBy: [{ isRequired: 'desc' }, { sortOrder: 'asc' }],
    });

    // Get user's certifications
    const userCerts = await this.prisma.userCertification.findMany({
      where: isInternalUser ? { internalUserId: userId } : { userId },
    });

    return tracks.map(track => ({
      ...track,
      userProgress: userCerts.find(c => c.trackId === track.id),
      isCompleted: userCerts.some(c => c.trackId === track.id && c.completedAt),
    }));
  }

  /**
   * Start a quiz attempt
   */
  async startQuizAttempt(
    quizId: string,
    userId: string,
    isInternalUser: boolean,
  ) {
    const quiz = await this.prisma.quiz.findUnique({
      where: { id: quizId },
      include: { course: { include: { track: true } } },
    });

    if (!quiz) throw new NotFoundException('Quiz not found');

    // Create or get user certification record
    await this.ensureUserCertification(
      quiz.course.trackId,
      userId,
      isInternalUser,
    );

    // Create attempt
    const attempt = await this.prisma.quizAttempt.create({
      data: {
        quizId,
        userId: isInternalUser ? null : userId,
        internalUserId: isInternalUser ? userId : null,
        status: QuizStatus.IN_PROGRESS,
      },
    });

    // Return quiz without correct answers
    const questions = (quiz.questions as QuizQuestion[]).map(q => ({
      id: q.id,
      question: q.question,
      type: q.type,
      options: q.options,
      // Don't include correctOptionIds
    }));

    return { attemptId: attempt.id, questions };
  }

  /**
   * Submit quiz answers and grade
   */
  async submitQuizAttempt(
    attemptId: string,
    answers: { questionId: string; selectedOptionIds: string[] }[],
  ) {
    const attempt = await this.prisma.quizAttempt.findUnique({
      where: { id: attemptId },
      include: {
        quiz: {
          include: { course: { include: { track: true } } },
        },
      },
    });

    if (!attempt) throw new NotFoundException('Attempt not found');
    if (attempt.status !== QuizStatus.IN_PROGRESS) {
      throw new BadRequestException('Attempt already completed');
    }

    // Grade the quiz
    const questions = attempt.quiz.questions as QuizQuestion[];
    let correct = 0;

    for (const answer of answers) {
      const question = questions.find(q => q.id === answer.questionId);
      if (!question) continue;

      const isCorrect = this.checkAnswer(question, answer.selectedOptionIds);
      if (isCorrect) correct++;
    }

    const score = questions.length > 0 ? correct / questions.length : 0;
    const passed = score >= QUIZ_PASS_THRESHOLD;

    // Update attempt
    await this.prisma.quizAttempt.update({
      where: { id: attemptId },
      data: {
        completedAt: new Date(),
        status: passed ? QuizStatus.PASSED : QuizStatus.FAILED,
        score,
        answers: answers as any,
      },
    });

    // If passed, check if track is complete
    if (passed) {
      await this.checkTrackCompletion(
        attempt.quiz.course.trackId,
        attempt.userId ?? attempt.internalUserId!,
        !attempt.userId,
      );
    }

    return {
      score: Math.round(score * 100),
      passed,
      requiredScore: Math.round(QUIZ_PASS_THRESHOLD * 100),
      correctCount: correct,
      totalQuestions: questions.length,
    };
  }

  /**
   * Issue a certificate for completed track
   */
  async issueCertificate(
    trackId: string,
    userId: string,
    isInternalUser: boolean,
  ) {
    const userCert = await this.prisma.userCertification.findFirst({
      where: isInternalUser
        ? { trackId, internalUserId: userId }
        : { trackId, userId },
      include: { track: true },
    });

    if (!userCert || !userCert.completedAt) {
      throw new BadRequestException('Track not completed');
    }

    // Generate certificate number
    const year = new Date().getFullYear();
    const count = await this.prisma.certificate.count({
      where: { certificateNumber: { startsWith: `CERT-${year}` } },
    });
    const certificateNumber = `CERT-${year}-${String(count + 1).padStart(5, '0')}`;

    // Create certificate
    const certificate = await this.prisma.certificate.create({
      data: {
        certificateNumber,
        recipientName: await this.getRecipientName(userId, isInternalUser),
        trackName: userCert.track.name,
        trackVersion: userCert.track.version,
        status: CertificateStatus.ACTIVE,
        // Expiration based on major version (optional)
        expiresAt: this.calculateExpiration(userCert.track.versionMajor),
      },
    });

    // Link to user certification
    await this.prisma.userCertification.update({
      where: { id: userCert.id },
      data: {
        certificateId: certificate.id,
        completedVersion: userCert.track.version,
      },
    });

    this.logger.log(`Certificate ${certificateNumber} issued for user ${userId}`);

    return certificate;
  }

  private checkAnswer(question: QuizQuestion, selectedIds: string[]): boolean {
    const correct = new Set(question.correctOptionIds);
    const selected = new Set(selectedIds);
    if (correct.size !== selected.size) return false;
    for (const id of correct) {
      if (!selected.has(id)) return false;
    }
    return true;
  }

  private async ensureUserCertification(
    trackId: string,
    userId: string,
    isInternalUser: boolean,
  ) {
    const existing = await this.prisma.userCertification.findFirst({
      where: isInternalUser
        ? { trackId, internalUserId: userId }
        : { trackId, userId },
    });

    if (!existing) {
      await this.prisma.userCertification.create({
        data: {
          trackId,
          userId: isInternalUser ? null : userId,
          internalUserId: isInternalUser ? userId : null,
        },
      });
    }
  }

  private async checkTrackCompletion(
    trackId: string,
    userId: string,
    isInternalUser: boolean,
  ) {
    // Check if all courses in track have passed quizzes
    const track = await this.prisma.certificationTrack.findUnique({
      where: { id: trackId },
      include: {
        courses: {
          where: { isActive: true },
          include: { quiz: true },
        },
      },
    });

    if (!track) return;

    for (const course of track.courses) {
      if (!course.quiz) continue;

      const passedAttempt = await this.prisma.quizAttempt.findFirst({
        where: {
          quizId: course.quiz.id,
          status: QuizStatus.PASSED,
          ...(isInternalUser ? { internalUserId: userId } : { userId }),
        },
      });

      if (!passedAttempt) return; // Not all quizzes passed
    }

    // All quizzes passed - mark track complete
    await this.prisma.userCertification.updateMany({
      where: isInternalUser
        ? { trackId, internalUserId: userId }
        : { trackId, userId },
      data: { completedAt: new Date() },
    });

    this.logger.log(`User ${userId} completed track ${trackId}`);
  }

  private async getRecipientName(userId: string, isInternalUser: boolean): Promise<string> {
    if (isInternalUser) {
      const user = await this.prisma.internalUser.findUnique({ where: { id: userId } });
      return user?.name ?? 'Unknown';
    } else {
      const user = await this.prisma.user.findUnique({ where: { id: userId } });
      return user?.name ?? 'Unknown';
    }
  }

  private calculateExpiration(majorVersion: number): Date | null {
    // Certificates expire 2 years after issue, or when major version changes
    return new Date(Date.now() + 2 * 365 * 24 * 60 * 60 * 1000);
  }
}
```
  </action>
  <verify>TypeScript compiles: `cd apps/backend && npx tsc --noEmit`</verify>
  <done>CertificationService with quiz grading at 80% threshold and certificate issuance</done>
</task>

<task type="auto">
  <name>Task 3: Create Training Controller and Module</name>
  <files>
    apps/backend/src/modules/operations/training/training.controller.ts
    apps/backend/src/modules/operations/training/training.module.ts
    apps/backend/src/modules/operations/training/index.ts
    apps/backend/src/modules/operations/operations.module.ts
  </files>
  <action>
Create controller and module:

**training.controller.ts:**
```typescript
@Controller('api/v1/training')
export class TrainingController {
  constructor(private readonly certificationService: CertificationService) {}

  @Get('tracks')
  async getTracks(@Query('userId') userId: string, @Query('internal') internal?: boolean) {
    return this.certificationService.getTracksWithProgress(userId, !!internal);
  }

  @Post('quizzes/:quizId/start')
  async startQuiz(
    @Param('quizId') quizId: string,
    @Query('userId') userId: string,
    @Query('internal') internal?: boolean,
  ) {
    return this.certificationService.startQuizAttempt(quizId, userId, !!internal);
  }

  @Post('attempts/:attemptId/submit')
  async submitQuiz(
    @Param('attemptId') attemptId: string,
    @Body() dto: SubmitQuizDto,
  ) {
    return this.certificationService.submitQuizAttempt(attemptId, dto.answers);
  }

  @Post('tracks/:trackId/certificate')
  async issueCertificate(
    @Param('trackId') trackId: string,
    @Query('userId') userId: string,
    @Query('internal') internal?: boolean,
  ) {
    return this.certificationService.issueCertificate(trackId, userId, !!internal);
  }
}
```

**training.module.ts:**
```typescript
@Module({
  imports: [PrismaModule],
  controllers: [TrainingController],
  providers: [CertificationService],
  exports: [CertificationService],
})
export class TrainingModule {}
```

Update OperationsModule to import TrainingModule.
  </action>
  <verify>
1. `cd apps/backend && npx tsc --noEmit` - TypeScript compiles
2. `cd apps/backend && npm run lint` - Linting passes
  </verify>
  <done>TrainingModule with quiz and certificate endpoints</done>
</task>

</tasks>

<verification>
1. `cd apps/backend && npx tsc --noEmit` - TypeScript compiles
2. `cd apps/backend && npm run lint` - No linting errors
</verification>

<success_criteria>
- PeerBenchmarkService calculates nightly aggregates for all metrics
- Minimum 5 peers enforced for privacy
- Benchmarks support filtering by industry and company size
- CertificationService grades quizzes at 80% threshold
- Track completion checked when quiz passed
- Certificates issued with unique numbers and optional expiration
</success_criteria>

<output>
After completion, create `.planning/phases/12-internal-operations-portal/12-11-SUMMARY.md`
</output>
