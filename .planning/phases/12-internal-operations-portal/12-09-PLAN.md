---
phase: 12-internal-operations-portal
plan: 09
type: execute
wave: 2
depends_on: [12-05]
files_modified:
  - apps/backend/src/modules/operations/implementation/go-live.service.ts
  - apps/backend/src/modules/operations/implementation/go-live.controller.ts
  - apps/backend/src/modules/operations/implementation/dto/go-live.dto.ts
autonomous: true

must_haves:
  truths:
    - "Hard gates checked and status tracked per project"
    - "Readiness score calculated from weighted items"
    - "Client sign-off workflow captures acknowledgment and signatures"
    - "Go-live status derives from gates + score + sign-off"
  artifacts:
    - path: "apps/backend/src/modules/operations/implementation/go-live.service.ts"
      provides: "Go-live readiness logic with hybrid gates"
      exports: ["GoLiveService"]
      min_lines: 200
  key_links:
    - from: "GoLiveService"
      to: "HARD_GATES"
      via: "gate checking"
      pattern: "HARD_GATES"
---

<objective>
Create go-live readiness service with hybrid gates system.

Purpose: Implement three-tier go-live per CONTEXT.md: hard gates (must pass), readiness score (85%+ recommended), sign-off for proceeding below threshold.

Output: GoLiveService with gate checking, score calculation, and sign-off workflow.
</objective>

<execution_context>
@.claude/agents/gsd-executor.md
@.claude/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-internal-operations-portal/12-CONTEXT.md
@.planning/phases/12-internal-operations-portal/12-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Go-Live DTOs</name>
  <files>
    apps/backend/src/modules/operations/implementation/dto/go-live.dto.ts
  </files>
  <action>
Create DTOs for go-live operations:

```typescript
import { IsString, IsBoolean, IsOptional, IsArray, IsEnum, IsEmail, IsInt, Min, Max } from 'class-validator';
import { GateStatus } from '../../types/go-live.types';

export class UpdateGateDto {
  @IsEnum(GateStatus)
  status: GateStatus;

  @IsOptional()
  @IsString()
  notes?: string;

  @IsOptional()
  @IsString()
  waiverReason?: string;
}

export class UpdateReadinessItemDto {
  @IsBoolean()
  isComplete: boolean;

  @IsOptional()
  @IsInt()
  @Min(0)
  @Max(100)
  percentComplete?: number;

  @IsOptional()
  @IsString()
  notes?: string;
}

export class ClientSignoffDto {
  @IsString()
  clientSignerName: string;

  @IsEmail()
  clientSignerEmail: string;

  @IsArray()
  @IsString({ each: true })
  acknowledgedRisks: string[];

  @IsString()
  signoffStatement: string;
}

export class InternalApprovalDto {
  @IsString()
  internalApproverName: string;

  @IsOptional()
  @IsString()
  notes?: string;
}
```
  </action>
  <verify>TypeScript compiles: `cd apps/backend && npx tsc --noEmit`</verify>
  <done>Go-live DTOs for gate updates, readiness items, and sign-offs</done>
</task>

<task type="auto">
  <name>Task 2: Create Go-Live Service</name>
  <files>
    apps/backend/src/modules/operations/implementation/go-live.service.ts
  </files>
  <action>
Create service for go-live readiness management:

```typescript
import { Injectable, NotFoundException, BadRequestException, Logger } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { EventEmitter2 } from '@nestjs/event-emitter';
import {
  HARD_GATES,
  READINESS_ITEMS,
  RECOMMENDED_SCORE,
  GateStatus,
} from '../types/go-live.types';
import {
  UpdateGateDto,
  UpdateReadinessItemDto,
  ClientSignoffDto,
  InternalApprovalDto,
} from './dto/go-live.dto';

export interface GoLiveStatus {
  allGatesPassed: boolean;
  passedGates: number;
  totalGates: number;
  readinessScore: number;
  recommendedScore: number;
  isRecommendedMet: boolean;
  hasSignoff: boolean;
  canGoLive: boolean;
  blockers: string[];
}

@Injectable()
export class GoLiveService {
  private readonly logger = new Logger(GoLiveService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  /**
   * Initialize go-live tracking for a project
   */
  async initializeGoLive(projectId: string): Promise<void> {
    // Create gate records for all hard gates
    const gateData = HARD_GATES.map(gate => ({
      projectId,
      gateId: gate.id,
      status: GateStatus.PENDING,
    }));

    await this.prisma.goLiveGate.createMany({
      data: gateData,
      skipDuplicates: true,
    });

    // Create readiness item records
    const itemData = READINESS_ITEMS.map(item => ({
      projectId,
      itemId: item.id,
      isComplete: false,
      percentComplete: 0,
    }));

    await this.prisma.readinessItem.createMany({
      data: itemData,
      skipDuplicates: true,
    });

    this.logger.log(`Initialized go-live tracking for project ${projectId}`);
  }

  /**
   * Get current go-live status for a project
   */
  async getGoLiveStatus(projectId: string): Promise<GoLiveStatus> {
    const [gates, items, signoff] = await Promise.all([
      this.prisma.goLiveGate.findMany({ where: { projectId } }),
      this.prisma.readinessItem.findMany({ where: { projectId } }),
      this.prisma.goLiveSignoff.findUnique({ where: { projectId } }),
    ]);

    // Calculate gate status
    const passedGates = gates.filter(
      g => g.status === GateStatus.PASSED || g.status === GateStatus.WAIVED,
    ).length;
    const totalGates = HARD_GATES.length;
    const allGatesPassed = passedGates === totalGates;

    // Calculate readiness score (weighted)
    let readinessScore = 0;
    for (const item of items) {
      const itemDef = READINESS_ITEMS.find(i => i.id === item.itemId);
      if (itemDef) {
        const itemScore = item.isComplete ? 100 : item.percentComplete;
        readinessScore += (itemScore / 100) * itemDef.weight;
      }
    }
    readinessScore = Math.round(readinessScore);

    const isRecommendedMet = readinessScore >= RECOMMENDED_SCORE;
    const hasSignoff = !!signoff?.clientSignedAt;

    // Determine blockers
    const blockers: string[] = [];
    if (!allGatesPassed) {
      const pendingGates = gates.filter(g => g.status === GateStatus.PENDING || g.status === GateStatus.FAILED);
      for (const gate of pendingGates) {
        const gateDef = HARD_GATES.find(g => g.id === gate.gateId);
        if (gateDef) blockers.push(`Hard gate not passed: ${gateDef.name}`);
      }
    }
    if (!isRecommendedMet && !hasSignoff) {
      blockers.push(`Readiness score (${readinessScore}%) below recommended (${RECOMMENDED_SCORE}%) - sign-off required`);
    }

    // Can go live if all gates passed AND (recommended met OR signed off)
    const canGoLive = allGatesPassed && (isRecommendedMet || hasSignoff);

    return {
      allGatesPassed,
      passedGates,
      totalGates,
      readinessScore,
      recommendedScore: RECOMMENDED_SCORE,
      isRecommendedMet,
      hasSignoff,
      canGoLive,
      blockers,
    };
  }

  /**
   * Update a hard gate status
   */
  async updateGate(
    projectId: string,
    gateId: string,
    dto: UpdateGateDto,
    checkedById: string,
  ): Promise<void> {
    const gate = await this.prisma.goLiveGate.findUnique({
      where: { projectId_gateId: { projectId, gateId } },
    });

    if (!gate) {
      throw new NotFoundException(`Gate ${gateId} not found for project`);
    }

    // Waiver requires reason
    if (dto.status === GateStatus.WAIVED && !dto.waiverReason) {
      throw new BadRequestException('Waiver reason required for waived gates');
    }

    const updateData: any = {
      status: dto.status,
      checkedAt: new Date(),
      checkedById,
      notes: dto.notes,
    };

    if (dto.status === GateStatus.WAIVED) {
      updateData.waiverReason = dto.waiverReason;
      updateData.waiverApprovedById = checkedById;
      updateData.waiverApprovedAt = new Date();
    }

    await this.prisma.goLiveGate.update({
      where: { id: gate.id },
      data: updateData,
    });

    this.eventEmitter.emit('go-live.gate.updated', { projectId, gateId, status: dto.status });
  }

  /**
   * Update a readiness item
   */
  async updateReadinessItem(
    projectId: string,
    itemId: string,
    dto: UpdateReadinessItemDto,
    completedById: string,
  ): Promise<void> {
    const item = await this.prisma.readinessItem.findUnique({
      where: { projectId_itemId: { projectId, itemId } },
    });

    if (!item) {
      throw new NotFoundException(`Readiness item ${itemId} not found for project`);
    }

    await this.prisma.readinessItem.update({
      where: { id: item.id },
      data: {
        isComplete: dto.isComplete,
        percentComplete: dto.isComplete ? 100 : (dto.percentComplete ?? 0),
        completedAt: dto.isComplete ? new Date() : null,
        completedById: dto.isComplete ? completedById : null,
        notes: dto.notes,
      },
    });
  }

  /**
   * Record client sign-off
   */
  async recordClientSignoff(
    projectId: string,
    dto: ClientSignoffDto,
  ): Promise<void> {
    const status = await this.getGoLiveStatus(projectId);

    // Must have all gates passed to sign off
    if (!status.allGatesPassed) {
      throw new BadRequestException('All hard gates must pass before sign-off');
    }

    await this.prisma.goLiveSignoff.upsert({
      where: { projectId },
      create: {
        projectId,
        type: 'CLIENT',
        readinessScoreAtSignoff: status.readinessScore,
        gatesPassedAtSignoff: status.passedGates,
        gatesTotalAtSignoff: status.totalGates,
        acknowledgedRisks: dto.acknowledgedRisks,
        signoffStatement: dto.signoffStatement,
        clientSignerName: dto.clientSignerName,
        clientSignerEmail: dto.clientSignerEmail,
        clientSignedAt: new Date(),
      },
      update: {
        clientSignerName: dto.clientSignerName,
        clientSignerEmail: dto.clientSignerEmail,
        clientSignedAt: new Date(),
        acknowledgedRisks: dto.acknowledgedRisks,
        signoffStatement: dto.signoffStatement,
      },
    });

    this.eventEmitter.emit('go-live.signoff.completed', { projectId });
    this.logger.log(`Client sign-off recorded for project ${projectId}`);
  }

  /**
   * Record internal approval
   */
  async recordInternalApproval(
    projectId: string,
    dto: InternalApprovalDto,
    approverId: string,
  ): Promise<void> {
    const signoff = await this.prisma.goLiveSignoff.findUnique({
      where: { projectId },
    });

    if (!signoff) {
      throw new BadRequestException('Client sign-off required before internal approval');
    }

    await this.prisma.goLiveSignoff.update({
      where: { projectId },
      data: {
        internalApproverName: dto.internalApproverName,
        internalApproverId: approverId,
        internalApprovedAt: new Date(),
      },
    });

    this.logger.log(`Internal approval recorded for project ${projectId}`);
  }
}
```
  </action>
  <verify>TypeScript compiles: `cd apps/backend && npx tsc --noEmit`</verify>
  <done>GoLiveService with gate checking, score calculation, sign-off workflow</done>
</task>

<task type="auto">
  <name>Task 3: Create Go-Live Controller and Update Module</name>
  <files>
    apps/backend/src/modules/operations/implementation/go-live.controller.ts
    apps/backend/src/modules/operations/implementation/implementation.module.ts
  </files>
  <action>
Create controller and update module:

**go-live.controller.ts:**
```typescript
import {
  Controller,
  Get,
  Post,
  Patch,
  Param,
  Body,
} from '@nestjs/common';
import { GoLiveService } from './go-live.service';
import {
  UpdateGateDto,
  UpdateReadinessItemDto,
  ClientSignoffDto,
  InternalApprovalDto,
} from './dto/go-live.dto';

@Controller('api/v1/internal/implementations/:projectId/go-live')
export class GoLiveController {
  constructor(private readonly goLiveService: GoLiveService) {}

  @Get('status')
  async getStatus(@Param('projectId') projectId: string) {
    return this.goLiveService.getGoLiveStatus(projectId);
  }

  @Post('initialize')
  async initialize(@Param('projectId') projectId: string) {
    await this.goLiveService.initializeGoLive(projectId);
    return { success: true };
  }

  @Patch('gates/:gateId')
  async updateGate(
    @Param('projectId') projectId: string,
    @Param('gateId') gateId: string,
    @Body() dto: UpdateGateDto,
  ) {
    // TODO: Get user ID from auth
    await this.goLiveService.updateGate(projectId, gateId, dto, 'TODO');
    return { success: true };
  }

  @Patch('items/:itemId')
  async updateReadinessItem(
    @Param('projectId') projectId: string,
    @Param('itemId') itemId: string,
    @Body() dto: UpdateReadinessItemDto,
  ) {
    // TODO: Get user ID from auth
    await this.goLiveService.updateReadinessItem(projectId, itemId, dto, 'TODO');
    return { success: true };
  }

  @Post('signoff/client')
  async recordClientSignoff(
    @Param('projectId') projectId: string,
    @Body() dto: ClientSignoffDto,
  ) {
    await this.goLiveService.recordClientSignoff(projectId, dto);
    return { success: true };
  }

  @Post('signoff/internal')
  async recordInternalApproval(
    @Param('projectId') projectId: string,
    @Body() dto: InternalApprovalDto,
  ) {
    // TODO: Get user ID from auth
    await this.goLiveService.recordInternalApproval(projectId, dto, 'TODO');
    return { success: true };
  }
}
```

Update **implementation.module.ts** to include GoLiveService and GoLiveController.
  </action>
  <verify>
1. `cd apps/backend && npx tsc --noEmit` - TypeScript compiles
2. `cd apps/backend && npm run lint` - Linting passes
  </verify>
  <done>GoLiveController exposing status, gates, items, and sign-off endpoints</done>
</task>

</tasks>

<verification>
1. `cd apps/backend && npx tsc --noEmit` - TypeScript compiles
2. `cd apps/backend && npm run lint` - No linting errors
</verification>

<success_criteria>
- initializeGoLive creates gate and item records from constants
- getGoLiveStatus returns all gates, score, sign-off status, blockers, canGoLive
- updateGate validates waiver reason requirement
- Readiness score calculated from weighted items
- Sign-off requires all gates passed first
- canGoLive = allGatesPassed AND (score >= 85 OR hasSignoff)
</success_criteria>

<output>
After completion, create `.planning/phases/12-internal-operations-portal/12-09-SUMMARY.md`
</output>
