---
phase: 12-internal-operations-portal
plan: 07
type: execute
wave: 2
depends_on: [12-02]
files_modified:
  - apps/backend/src/modules/operations/implementation/implementation.service.ts
  - apps/backend/src/modules/operations/implementation/checklist.service.ts
  - apps/backend/src/modules/operations/implementation/checklist-templates.ts
  - apps/backend/src/modules/operations/implementation/implementation.controller.ts
  - apps/backend/src/modules/operations/implementation/dto/implementation.dto.ts
  - apps/backend/src/modules/operations/implementation/implementation.module.ts
autonomous: true

must_haves:
  truths:
    - "Implementation projects can be created with checklist templates"
    - "Tasks can be assigned, completed, blocked with proper status tracking"
    - "Project health score updates based on task completion and blockers"
    - "Different templates available for SMB, Enterprise, Healthcare, Financial"
  artifacts:
    - path: "apps/backend/src/modules/operations/implementation/implementation.service.ts"
      provides: "Project CRUD and lifecycle management"
      exports: ["ImplementationService"]
      min_lines: 200
    - path: "apps/backend/src/modules/operations/implementation/checklist.service.ts"
      provides: "Task management and template instantiation"
      exports: ["ChecklistService"]
      min_lines: 150
    - path: "apps/backend/src/modules/operations/implementation/checklist-templates.ts"
      provides: "Template definitions for different implementation types"
      exports: ["CHECKLIST_TEMPLATES"]
  key_links:
    - from: "ChecklistService"
      to: "ImplementationProject"
      via: "createFromTemplate"
      pattern: "createFromTemplate"
---

<objective>
Create the implementation project and checklist services.

Purpose: Enable implementation specialists to track client onboarding with phase-based checklists. Per CONTEXT.md: distinct templates per customer type, parallel task assignment, health score calculation.

Output: ImplementationService, ChecklistService, and checklist templates for all implementation types.
</objective>

<execution_context>
@.claude/agents/gsd-executor.md
@.claude/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-internal-operations-portal/12-CONTEXT.md
@.planning/phases/12-internal-operations-portal/12-RESEARCH.md
@.planning/phases/12-internal-operations-portal/12-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Checklist Templates</name>
  <files>
    apps/backend/src/modules/operations/implementation/checklist-templates.ts
  </files>
  <action>
Define checklist templates per CONTEXT.md (SMB Quick Start, Enterprise Full, Industry-Specific):

```typescript
import {
  ImplementationType,
  ImplementationPhase,
  PlgPhase,
} from '../types/implementation.types';

interface TaskTemplate {
  name: string;
  description?: string;
  isRequired: boolean;
  estimatedHours?: number;
}

interface PhaseTemplate {
  phase: ImplementationPhase | PlgPhase;
  name: string;
  tasks: TaskTemplate[];
}

interface ChecklistTemplate {
  type: ImplementationType;
  name: string;
  description: string;
  phases: PhaseTemplate[];
  estimatedWeeks: number;
}

export const CHECKLIST_TEMPLATES: Record<ImplementationType, ChecklistTemplate> = {
  [ImplementationType.SMB_QUICK_START]: {
    type: ImplementationType.SMB_QUICK_START,
    name: 'SMB Quick Start',
    description: 'Self-serve implementation for small businesses (1-2 weeks)',
    estimatedWeeks: 2,
    phases: [
      {
        phase: ImplementationPhase.CONFIGURATION,
        name: 'Setup',
        tasks: [
          { name: 'Create tenant account', isRequired: true },
          { name: 'Upload logo and configure branding', isRequired: true },
          { name: 'Set up authentication', isRequired: true },
          { name: 'Invite first admin', isRequired: true },
        ],
      },
      {
        phase: ImplementationPhase.UAT,
        name: 'First Steps',
        tasks: [
          { name: 'Create first policy', isRequired: false },
          { name: 'Set up categories', isRequired: true },
          { name: 'Configure email templates', isRequired: false },
          { name: 'Test hotline number', isRequired: true },
        ],
      },
      {
        phase: ImplementationPhase.GO_LIVE,
        name: 'Go Live',
        tasks: [
          { name: 'Invite team members', isRequired: true },
          { name: 'Complete admin certification', isRequired: true },
          { name: 'Sign terms of service', isRequired: true },
        ],
      },
    ],
  },

  [ImplementationType.ENTERPRISE_FULL]: {
    type: ImplementationType.ENTERPRISE_FULL,
    name: 'Enterprise Full',
    description: 'Guided implementation for enterprise clients (6-8 weeks)',
    estimatedWeeks: 8,
    phases: [
      {
        phase: ImplementationPhase.DISCOVERY,
        name: 'Discovery',
        tasks: [
          { name: 'Kickoff meeting', isRequired: true, estimatedHours: 2 },
          { name: 'Requirements gathering', isRequired: true, estimatedHours: 4 },
          { name: 'Process mapping workshop', isRequired: true, estimatedHours: 4 },
          { name: 'Integration requirements review', isRequired: false, estimatedHours: 2 },
          { name: 'Data migration planning', isRequired: false, estimatedHours: 3 },
        ],
      },
      {
        phase: ImplementationPhase.CONFIGURATION,
        name: 'Configuration',
        tasks: [
          { name: 'Tenant provisioning', isRequired: true },
          { name: 'Organization structure setup', isRequired: true },
          { name: 'Category taxonomy configuration', isRequired: true },
          { name: 'Workflow configuration', isRequired: true },
          { name: 'Branding and white-labeling', isRequired: true },
          { name: 'SSO integration', isRequired: false },
          { name: 'HRIS integration', isRequired: false },
          { name: 'Custom fields setup', isRequired: false },
          { name: 'Email template customization', isRequired: false },
        ],
      },
      {
        phase: ImplementationPhase.DATA_MIGRATION,
        name: 'Data Migration',
        tasks: [
          { name: 'Data export from legacy system', isRequired: false },
          { name: 'Field mapping review', isRequired: false },
          { name: 'Test migration (sandbox)', isRequired: false },
          { name: 'Migration validation', isRequired: false },
          { name: 'Production migration', isRequired: false },
        ],
      },
      {
        phase: ImplementationPhase.UAT,
        name: 'User Acceptance Testing',
        tasks: [
          { name: 'Admin training session', isRequired: true, estimatedHours: 2 },
          { name: 'Investigator training session', isRequired: true, estimatedHours: 2 },
          { name: 'End-to-end workflow testing', isRequired: true },
          { name: 'Integration testing', isRequired: false },
          { name: 'User feedback collection', isRequired: true },
          { name: 'Issue remediation', isRequired: true },
        ],
      },
      {
        phase: ImplementationPhase.GO_LIVE,
        name: 'Go-Live',
        tasks: [
          { name: 'Go-live readiness review', isRequired: true },
          { name: 'User communication sent', isRequired: true },
          { name: 'Production cutover', isRequired: true },
          { name: 'Hotline number activation', isRequired: true },
          { name: 'Post-launch monitoring (24h)', isRequired: true },
        ],
      },
      {
        phase: ImplementationPhase.OPTIMIZATION,
        name: 'Optimization',
        tasks: [
          { name: '30-day health check', isRequired: true },
          { name: 'Adoption metrics review', isRequired: true },
          { name: 'CSM handoff meeting', isRequired: true },
        ],
      },
    ],
  },

  [ImplementationType.HEALTHCARE_HIPAA]: {
    type: ImplementationType.HEALTHCARE_HIPAA,
    name: 'Healthcare (HIPAA)',
    description: 'HIPAA-compliant implementation with healthcare defaults',
    estimatedWeeks: 6,
    phases: [
      // Similar to Enterprise but with HIPAA-specific tasks
      {
        phase: ImplementationPhase.DISCOVERY,
        name: 'Discovery',
        tasks: [
          { name: 'Kickoff meeting', isRequired: true },
          { name: 'HIPAA compliance review', isRequired: true },
          { name: 'PHI handling requirements', isRequired: true },
          { name: 'Requirements gathering', isRequired: true },
        ],
      },
      {
        phase: ImplementationPhase.CONFIGURATION,
        name: 'Configuration',
        tasks: [
          { name: 'Tenant provisioning with HIPAA defaults', isRequired: true },
          { name: 'Healthcare category taxonomy', isRequired: true },
          { name: 'HIPAA disclosure directives', isRequired: true },
          { name: 'Branding configuration', isRequired: true },
          { name: 'SSO integration', isRequired: true },
        ],
      },
      // ... abbreviated for length - full template mirrors Enterprise with healthcare tweaks
    ],
  },

  [ImplementationType.FINANCIAL_SOX]: {
    type: ImplementationType.FINANCIAL_SOX,
    name: 'Financial Services (SOX)',
    description: 'SOX-compliant implementation for financial services',
    estimatedWeeks: 6,
    phases: [
      {
        phase: ImplementationPhase.DISCOVERY,
        name: 'Discovery',
        tasks: [
          { name: 'Kickoff meeting', isRequired: true },
          { name: 'SOX compliance requirements', isRequired: true },
          { name: 'Control framework mapping', isRequired: true },
          { name: 'Requirements gathering', isRequired: true },
        ],
      },
      // ... similar structure with SOX-specific items
    ],
  },

  [ImplementationType.GENERAL_BUSINESS]: {
    type: ImplementationType.GENERAL_BUSINESS,
    name: 'General Business',
    description: 'Standard implementation for general businesses (4-6 weeks)',
    estimatedWeeks: 5,
    phases: [
      // ... similar to Enterprise but fewer optional items
    ],
  },
};

/**
 * Get template for an implementation type
 */
export function getTemplate(type: ImplementationType): ChecklistTemplate {
  return CHECKLIST_TEMPLATES[type];
}

/**
 * Get total task count for a template
 */
export function getTaskCount(type: ImplementationType): { required: number; optional: number } {
  const template = CHECKLIST_TEMPLATES[type];
  let required = 0;
  let optional = 0;

  for (const phase of template.phases) {
    for (const task of phase.tasks) {
      if (task.isRequired) required++;
      else optional++;
    }
  }

  return { required, optional };
}
```
  </action>
  <verify>TypeScript compiles: `cd apps/backend && npx tsc --noEmit`</verify>
  <done>Checklist templates defined for all 5 implementation types</done>
</task>

<task type="auto">
  <name>Task 2: Create Implementation and Checklist Services</name>
  <files>
    apps/backend/src/modules/operations/implementation/implementation.service.ts
    apps/backend/src/modules/operations/implementation/checklist.service.ts
    apps/backend/src/modules/operations/implementation/dto/implementation.dto.ts
  </files>
  <action>
Create services for project and task management:

**dto/implementation.dto.ts:**
```typescript
import { IsString, IsUUID, IsOptional, IsEnum, IsDateString, IsArray } from 'class-validator';
import { ImplementationType, TaskStatus, BlockerCategory } from '../types/implementation.types';

export class CreateProjectDto {
  @IsUUID()
  clientOrganizationId: string;

  @IsEnum(ImplementationType)
  type: ImplementationType;

  @IsUUID()
  leadImplementerId: string;

  @IsOptional()
  @IsArray()
  @IsUUID('4', { each: true })
  assignedUserIds?: string[];

  @IsOptional()
  @IsDateString()
  targetGoLiveDate?: string;
}

export class UpdateTaskDto {
  @IsOptional()
  @IsEnum(TaskStatus)
  status?: TaskStatus;

  @IsOptional()
  @IsUUID()
  assignedToId?: string;

  @IsOptional()
  @IsDateString()
  dueDate?: string;

  @IsOptional()
  @IsString()
  notes?: string;
}

export class CreateBlockerDto {
  @IsString()
  title: string;

  @IsOptional()
  @IsString()
  description?: string;

  @IsEnum(BlockerCategory)
  category: BlockerCategory;

  @IsOptional()
  @IsUUID()
  taskId?: string;
}
```

**checklist.service.ts:**
```typescript
@Injectable()
export class ChecklistService {
  constructor(private readonly prisma: PrismaService) {}

  /**
   * Create checklist from template for a project
   */
  async createFromTemplate(
    projectId: string,
    type: ImplementationType,
  ): Promise<{ taskCount: number }> {
    const template = getTemplate(type);
    const tasks: Prisma.ImplementationTaskCreateManyInput[] = [];
    let sortOrder = 0;

    for (const phase of template.phases) {
      for (const task of phase.tasks) {
        tasks.push({
          projectId,
          phase: phase.phase as ImplementationPhase,
          name: task.name,
          description: task.description,
          status: TaskStatus.PENDING,
          isRequired: task.isRequired,
          sortOrder: sortOrder++,
        });
      }
    }

    await this.prisma.implementationTask.createMany({ data: tasks });
    return { taskCount: tasks.length };
  }

  /**
   * Update task status
   */
  async updateTask(
    taskId: string,
    dto: UpdateTaskDto,
    completedById?: string,
  ): Promise<ImplementationTask> {
    const data: Prisma.ImplementationTaskUpdateInput = {};

    if (dto.status !== undefined) {
      data.status = dto.status;
      if (dto.status === TaskStatus.COMPLETED) {
        data.completedAt = new Date();
        data.completedById = completedById;
      }
    }
    if (dto.assignedToId !== undefined) data.assignedToId = dto.assignedToId;
    if (dto.dueDate !== undefined) data.dueDate = new Date(dto.dueDate);
    if (dto.notes !== undefined) data.notes = dto.notes;

    return this.prisma.implementationTask.update({
      where: { id: taskId },
      data,
    });
  }

  /**
   * Calculate project health based on tasks
   */
  async calculateProjectHealth(projectId: string): Promise<number> {
    const tasks = await this.prisma.implementationTask.findMany({
      where: { projectId },
    });

    const required = tasks.filter(t => t.isRequired);
    const completedRequired = required.filter(t => t.status === TaskStatus.COMPLETED);
    const blocked = tasks.filter(t => t.status === TaskStatus.BLOCKED);
    const overdue = tasks.filter(
      t => t.dueDate && t.dueDate < new Date() && t.status !== TaskStatus.COMPLETED,
    );

    // Base: required completion %
    let score = (completedRequired.length / Math.max(required.length, 1)) * 100;

    // Penalties
    score -= blocked.length * 5;  // -5 per blocker
    score -= overdue.length * 10; // -10 per overdue

    return Math.max(0, Math.min(100, Math.round(score)));
  }
}
```

**implementation.service.ts:**
```typescript
@Injectable()
export class ImplementationService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly checklistService: ChecklistService,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  /**
   * Create new implementation project with checklist
   */
  async createProject(dto: CreateProjectDto): Promise<ImplementationProject> {
    // Validate organization exists
    const org = await this.prisma.organization.findUnique({
      where: { id: dto.clientOrganizationId },
    });
    if (!org) {
      throw new NotFoundException('Client organization not found');
    }

    // Create project
    const project = await this.prisma.implementationProject.create({
      data: {
        clientOrganizationId: dto.clientOrganizationId,
        type: dto.type,
        leadImplementerId: dto.leadImplementerId,
        assignedUserIds: dto.assignedUserIds || [dto.leadImplementerId],
        targetGoLiveDate: dto.targetGoLiveDate ? new Date(dto.targetGoLiveDate) : null,
        status: ProjectStatus.NOT_STARTED,
      },
    });

    // Create checklist from template
    await this.checklistService.createFromTemplate(project.id, dto.type);

    // Update health score
    const health = await this.checklistService.calculateProjectHealth(project.id);
    await this.prisma.implementationProject.update({
      where: { id: project.id },
      data: { healthScore: health },
    });

    this.eventEmitter.emit('implementation.project.created', { project });

    return this.getProject(project.id);
  }

  /**
   * Get project with all relations
   */
  async getProject(id: string): Promise<ImplementationProject & { tasks: ImplementationTask[] }> {
    const project = await this.prisma.implementationProject.findUnique({
      where: { id },
      include: {
        tasks: { orderBy: { sortOrder: 'asc' } },
        blockers: { where: { status: BlockerStatus.OPEN } },
        organization: { select: { id: true, name: true } },
      },
    });

    if (!project) {
      throw new NotFoundException('Project not found');
    }

    return project;
  }

  /**
   * List projects with filtering
   */
  async listProjects(filters: {
    status?: ProjectStatus;
    leadImplementerId?: string;
    clientOrganizationId?: string;
    limit?: number;
    offset?: number;
  }): Promise<{ items: ImplementationProject[]; total: number }> {
    const where: Prisma.ImplementationProjectWhereInput = {};
    if (filters.status) where.status = filters.status;
    if (filters.leadImplementerId) where.leadImplementerId = filters.leadImplementerId;
    if (filters.clientOrganizationId) where.clientOrganizationId = filters.clientOrganizationId;

    const [items, total] = await Promise.all([
      this.prisma.implementationProject.findMany({
        where,
        include: {
          organization: { select: { id: true, name: true } },
        },
        orderBy: { createdAt: 'desc' },
        take: filters.limit || 20,
        skip: filters.offset || 0,
      }),
      this.prisma.implementationProject.count({ where }),
    ]);

    return { items, total };
  }

  /**
   * Update project phase (triggers activity log)
   */
  async transitionPhase(
    projectId: string,
    newPhase: ImplementationPhase,
    userId: string,
  ): Promise<void> {
    const project = await this.prisma.implementationProject.findUnique({
      where: { id: projectId },
    });

    if (!project) throw new NotFoundException('Project not found');

    const oldPhase = project.currentPhase;

    await this.prisma.$transaction([
      this.prisma.implementationProject.update({
        where: { id: projectId },
        data: { currentPhase: newPhase },
      }),
      this.prisma.implementationActivity.create({
        data: {
          projectId,
          type: ActivityType.PHASE_TRANSITION,
          subject: `Phase transition: ${oldPhase} -> ${newPhase}`,
          isAutoLogged: true,
          createdById: userId,
        },
      }),
    ]);

    this.eventEmitter.emit('implementation.phase.changed', {
      projectId,
      oldPhase,
      newPhase,
    });
  }
}
```
  </action>
  <verify>TypeScript compiles: `cd apps/backend && npx tsc --noEmit`</verify>
  <done>ImplementationService and ChecklistService with project/task management</done>
</task>

<task type="auto">
  <name>Task 3: Create Implementation Controller and Module</name>
  <files>
    apps/backend/src/modules/operations/implementation/implementation.controller.ts
    apps/backend/src/modules/operations/implementation/implementation.module.ts
    apps/backend/src/modules/operations/implementation/index.ts
    apps/backend/src/modules/operations/operations.module.ts
  </files>
  <action>
Create controller and module:

**implementation.controller.ts:**
```typescript
@Controller('api/v1/internal/implementations')
export class ImplementationController {
  constructor(
    private readonly implementationService: ImplementationService,
    private readonly checklistService: ChecklistService,
  ) {}

  @Post()
  async createProject(@Body() dto: CreateProjectDto) {
    return this.implementationService.createProject(dto);
  }

  @Get()
  async listProjects(
    @Query('status') status?: ProjectStatus,
    @Query('leadId') leadImplementerId?: string,
    @Query('orgId') clientOrganizationId?: string,
    @Query('limit') limit?: number,
    @Query('offset') offset?: number,
  ) {
    return this.implementationService.listProjects({
      status,
      leadImplementerId,
      clientOrganizationId,
      limit: limit ? Number(limit) : undefined,
      offset: offset ? Number(offset) : undefined,
    });
  }

  @Get(':id')
  async getProject(@Param('id') id: string) {
    return this.implementationService.getProject(id);
  }

  @Patch(':id/tasks/:taskId')
  async updateTask(
    @Param('taskId') taskId: string,
    @Body() dto: UpdateTaskDto,
  ) {
    // TODO: Get user ID from auth
    return this.checklistService.updateTask(taskId, dto);
  }

  @Post(':id/blockers')
  async createBlocker(
    @Param('id') projectId: string,
    @Body() dto: CreateBlockerDto,
  ) {
    return this.prisma.implementationBlocker.create({
      data: { ...dto, projectId },
    });
  }

  @Post(':id/phase-transition')
  async transitionPhase(
    @Param('id') projectId: string,
    @Body('phase') phase: ImplementationPhase,
  ) {
    // TODO: Get user ID from auth
    await this.implementationService.transitionPhase(projectId, phase, 'TODO');
    return { success: true };
  }
}
```

**implementation.module.ts:**
```typescript
@Module({
  imports: [PrismaModule, EventEmitterModule],
  controllers: [ImplementationController],
  providers: [ImplementationService, ChecklistService],
  exports: [ImplementationService, ChecklistService],
})
export class ImplementationModule {}
```

Update OperationsModule to import ImplementationModule.
  </action>
  <verify>
1. `cd apps/backend && npx tsc --noEmit` - TypeScript compiles
2. `cd apps/backend && npm run lint` - Linting passes
  </verify>
  <done>ImplementationModule with controller exposing project and task management APIs</done>
</task>

</tasks>

<verification>
1. `cd apps/backend && npx tsc --noEmit` - TypeScript compiles
2. `cd apps/backend && npm run lint` - No linting errors
3. ImplementationModule exported from operations module
</verification>

<success_criteria>
- CHECKLIST_TEMPLATES has 5 implementation types with phase-based tasks
- ImplementationService can create projects with auto-generated checklists
- ChecklistService can update tasks and calculate health scores
- Health score calculation: completion % - blocker penalty - overdue penalty
- Phase transitions logged to activity table
- All CRUD operations exposed via controller
</success_criteria>

<output>
After completion, create `.planning/phases/12-internal-operations-portal/12-07-SUMMARY.md`
</output>
