---
phase: 12-internal-operations-portal
plan: 06
type: execute
wave: 2
depends_on: [12-01]
files_modified:
  - apps/backend/src/modules/operations/impersonation/impersonation.service.ts
  - apps/backend/src/modules/operations/impersonation/impersonation.guard.ts
  - apps/backend/src/modules/operations/impersonation/impersonation.middleware.ts
  - apps/backend/src/modules/operations/impersonation/impersonation.controller.ts
  - apps/backend/src/modules/operations/impersonation/dto/impersonation.dto.ts
  - apps/backend/src/modules/operations/impersonation/impersonation.module.ts
autonomous: true

must_haves:
  truths:
    - "ImpersonationService can start/end sessions with full audit logging"
    - "ImpersonationMiddleware sets tenant context from session header"
    - "ImpersonationGuard validates session and sets CLS context"
    - "All actions during impersonation are logged to ImpersonationAuditLog"
  artifacts:
    - path: "apps/backend/src/modules/operations/impersonation/impersonation.service.ts"
      provides: "Session management with audit logging"
      exports: ["ImpersonationService"]
      min_lines: 150
    - path: "apps/backend/src/modules/operations/impersonation/impersonation.guard.ts"
      provides: "Guard for impersonation-required routes"
      exports: ["ImpersonationGuard"]
    - path: "apps/backend/src/modules/operations/impersonation/impersonation.middleware.ts"
      provides: "Middleware to set tenant context from session"
      exports: ["ImpersonationMiddleware"]
  key_links:
    - from: "ImpersonationMiddleware"
      to: "PrismaService"
      via: "SET LOCAL app.current_tenant"
      pattern: "SET LOCAL app.current_tenant"
---

<objective>
Create the impersonation service, guard, and middleware for cross-tenant access.

Purpose: Enable Support staff to access client tenants with full audit trail. Per CONTEXT.md: full access, no approval required, banner indicator, no automatic timeout, all actions audited.

Output: ImpersonationService, ImpersonationGuard, ImpersonationMiddleware with nestjs-cls integration.
</objective>

<execution_context>
@.claude/agents/gsd-executor.md
@.claude/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-internal-operations-portal/12-CONTEXT.md
@.planning/phases/12-internal-operations-portal/12-RESEARCH.md
@.planning/phases/12-internal-operations-portal/12-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Impersonation Service</name>
  <files>
    apps/backend/src/modules/operations/impersonation/impersonation.service.ts
    apps/backend/src/modules/operations/impersonation/dto/impersonation.dto.ts
  </files>
  <action>
Create the ImpersonationService per RESEARCH.md patterns:

**dto/impersonation.dto.ts:**
```typescript
import { IsString, IsOptional, IsUUID, MinLength } from 'class-validator';

export class StartSessionDto {
  @IsUUID()
  targetOrganizationId: string;

  @IsString()
  @MinLength(10, { message: 'Reason must be at least 10 characters' })
  reason: string;

  @IsOptional()
  @IsString()
  ticketId?: string; // Support ticket reference
}

export class EndSessionDto {
  @IsOptional()
  @IsString()
  notes?: string; // Optional notes on session end
}
```

**impersonation.service.ts:**
```typescript
import { Injectable, ForbiddenException, NotFoundException, Logger } from '@nestjs/common';
import { ClsService } from 'nestjs-cls';
import { PrismaService } from '../../../prisma/prisma.service';
import { InternalRole, ROLE_PERMISSIONS } from '../types/internal-roles.types';
import { StartSessionDto } from './dto/impersonation.dto';

const SESSION_MAX_DURATION_MS = 4 * 60 * 60 * 1000; // 4 hours

export interface ImpersonationContext {
  sessionId: string;
  operatorUserId: string;
  operatorRole: InternalRole;
  targetOrganizationId: string;
  reason: string;
  ticketId?: string;
  expiresAt: Date;
}

@Injectable()
export class ImpersonationService {
  private readonly logger = new Logger(ImpersonationService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly cls: ClsService,
  ) {}

  /**
   * Start an impersonation session
   */
  async startSession(
    operatorUserId: string,
    dto: StartSessionDto,
    ipAddress?: string,
    userAgent?: string,
  ): Promise<{ sessionId: string; expiresAt: Date }> {
    // Validate operator exists and has permission
    const operator = await this.prisma.internalUser.findUnique({
      where: { id: operatorUserId },
    });

    if (!operator || !operator.isActive) {
      throw new ForbiddenException('Operator not found or inactive');
    }

    if (!this.canImpersonate(operator.role as InternalRole)) {
      throw new ForbiddenException('Insufficient permissions for impersonation');
    }

    // Validate target organization exists
    const org = await this.prisma.organization.findUnique({
      where: { id: dto.targetOrganizationId },
    });

    if (!org) {
      throw new NotFoundException('Target organization not found');
    }

    // Create session (no automatic timeout per CONTEXT.md - manual exit only)
    // But set max expiration for security
    const expiresAt = new Date(Date.now() + SESSION_MAX_DURATION_MS);

    const session = await this.prisma.impersonationSession.create({
      data: {
        operatorUserId,
        operatorRole: operator.role as InternalRole,
        targetOrganizationId: dto.targetOrganizationId,
        reason: dto.reason,
        ticketId: dto.ticketId,
        expiresAt,
        ipAddress,
        userAgent,
      },
    });

    // Log session start
    await this.logAction(session.id, 'SESSION_STARTED', null, null, {
      organizationName: org.name,
      reason: dto.reason,
      ticketId: dto.ticketId,
    });

    this.logger.log(
      `Impersonation session started: ${session.id} by ${operator.email} for ${org.name}`,
    );

    return { sessionId: session.id, expiresAt };
  }

  /**
   * End an impersonation session
   */
  async endSession(sessionId: string, notes?: string): Promise<void> {
    const session = await this.prisma.impersonationSession.findUnique({
      where: { id: sessionId },
    });

    if (!session) {
      throw new NotFoundException('Session not found');
    }

    if (session.endedAt) {
      throw new ForbiddenException('Session already ended');
    }

    await this.prisma.impersonationSession.update({
      where: { id: sessionId },
      data: { endedAt: new Date() },
    });

    await this.logAction(sessionId, 'SESSION_ENDED', null, null, { notes });

    this.logger.log(`Impersonation session ended: ${sessionId}`);
  }

  /**
   * Validate a session is active
   */
  async validateSession(sessionId: string): Promise<ImpersonationContext | null> {
    const session = await this.prisma.impersonationSession.findUnique({
      where: { id: sessionId },
    });

    if (!session) return null;
    if (session.endedAt) return null;
    if (new Date() > session.expiresAt) return null;

    return {
      sessionId: session.id,
      operatorUserId: session.operatorUserId,
      operatorRole: session.operatorRole as InternalRole,
      targetOrganizationId: session.targetOrganizationId,
      reason: session.reason,
      ticketId: session.ticketId ?? undefined,
      expiresAt: session.expiresAt,
    };
  }

  /**
   * Get current impersonation context from CLS
   */
  getCurrentContext(): ImpersonationContext | null {
    return this.cls.get<ImpersonationContext>('impersonation') ?? null;
  }

  /**
   * Check if currently impersonating
   */
  isImpersonating(): boolean {
    const ctx = this.getCurrentContext();
    return !!ctx && new Date() < ctx.expiresAt;
  }

  /**
   * Get effective organization ID (impersonated or normal)
   */
  getEffectiveOrganizationId(): string | undefined {
    const ctx = this.getCurrentContext();
    if (ctx && new Date() < ctx.expiresAt) {
      return ctx.targetOrganizationId;
    }
    return this.cls.get('organizationId');
  }

  /**
   * Log an action during impersonation
   */
  async logAction(
    sessionId: string,
    action: string,
    entityType: string | null,
    entityId: string | null,
    details?: Record<string, unknown>,
  ): Promise<void> {
    await this.prisma.impersonationAuditLog.create({
      data: {
        sessionId,
        action,
        entityType,
        entityId,
        details: details as any,
      },
    });
  }

  /**
   * Log an action from current context
   */
  async logCurrentAction(
    action: string,
    entityType: string,
    entityId: string,
    details?: Record<string, unknown>,
  ): Promise<void> {
    const ctx = this.getCurrentContext();
    if (ctx) {
      await this.logAction(ctx.sessionId, action, entityType, entityId, details);
    }
  }

  private canImpersonate(role: InternalRole): boolean {
    const permissions = ROLE_PERMISSIONS[role] || [];
    return permissions.includes('*') || permissions.includes('impersonate');
  }
}
```
  </action>
  <verify>TypeScript compiles: `cd apps/backend && npx tsc --noEmit`</verify>
  <done>ImpersonationService with session lifecycle and audit logging</done>
</task>

<task type="auto">
  <name>Task 2: Create Impersonation Middleware and Guard</name>
  <files>
    apps/backend/src/modules/operations/impersonation/impersonation.middleware.ts
    apps/backend/src/modules/operations/impersonation/impersonation.guard.ts
  </files>
  <action>
Create middleware and guard per RESEARCH.md patterns:

**impersonation.middleware.ts:**
```typescript
import { Injectable, NestMiddleware, Logger } from '@nestjs/common';
import { ClsService } from 'nestjs-cls';
import { Request, Response, NextFunction } from 'express';
import { PrismaService } from '../../../prisma/prisma.service';
import { ImpersonationService, ImpersonationContext } from './impersonation.service';

/**
 * ImpersonationMiddleware
 *
 * Detects X-Impersonation-Session header and sets tenant context.
 * Also sets response headers for client UI (remaining time, org name).
 */
@Injectable()
export class ImpersonationMiddleware implements NestMiddleware {
  private readonly logger = new Logger(ImpersonationMiddleware.name);

  constructor(
    private readonly cls: ClsService,
    private readonly prisma: PrismaService,
    private readonly impersonationService: ImpersonationService,
  ) {}

  async use(req: Request, res: Response, next: NextFunction) {
    const sessionId = req.headers['x-impersonation-session'] as string;

    if (sessionId) {
      const context = await this.impersonationService.validateSession(sessionId);

      if (context) {
        // Set impersonation context in CLS
        this.cls.set<ImpersonationContext>('impersonation', context);

        // Override tenant context for RLS
        await this.prisma.$executeRawUnsafe(
          `SET LOCAL app.current_tenant = '${context.targetOrganizationId}'`,
        );

        // Add response headers for client UI
        const remaining = context.expiresAt.getTime() - Date.now();
        res.setHeader('X-Impersonation-Remaining', Math.floor(remaining / 1000));
        res.setHeader('X-Impersonation-Org', context.targetOrganizationId);

        this.logger.debug(
          `Impersonation context set for session ${sessionId} -> org ${context.targetOrganizationId}`,
        );
      } else {
        // Invalid/expired session - client should clear header
        res.setHeader('X-Impersonation-Invalid', 'true');
        this.logger.warn(`Invalid impersonation session: ${sessionId}`);
      }
    }

    next();
  }
}
```

**impersonation.guard.ts:**
```typescript
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';
import { ClsService } from 'nestjs-cls';
import { ImpersonationService, ImpersonationContext } from './impersonation.service';

/**
 * ImpersonationGuard
 *
 * Use on routes that REQUIRE active impersonation session.
 * Validates session and ensures context is set.
 */
@Injectable()
export class ImpersonationGuard implements CanActivate {
  constructor(
    private readonly cls: ClsService,
    private readonly impersonationService: ImpersonationService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const sessionId = request.headers['x-impersonation-session'] as string;

    if (!sessionId) {
      throw new ForbiddenException('Impersonation session required');
    }

    const impersonationContext = await this.impersonationService.validateSession(sessionId);

    if (!impersonationContext) {
      throw new ForbiddenException('Invalid or expired impersonation session');
    }

    // Ensure CLS context is set (middleware should have done this)
    if (!this.cls.get<ImpersonationContext>('impersonation')) {
      this.cls.set<ImpersonationContext>('impersonation', impersonationContext);
    }

    return true;
  }
}
```
  </action>
  <verify>TypeScript compiles: `cd apps/backend && npx tsc --noEmit`</verify>
  <done>ImpersonationMiddleware sets RLS context, ImpersonationGuard validates session</done>
</task>

<task type="auto">
  <name>Task 3: Create Impersonation Controller and Module</name>
  <files>
    apps/backend/src/modules/operations/impersonation/impersonation.controller.ts
    apps/backend/src/modules/operations/impersonation/impersonation.module.ts
    apps/backend/src/modules/operations/impersonation/index.ts
    apps/backend/src/modules/operations/operations.module.ts
  </files>
  <action>
Create controller and module:

**impersonation.controller.ts:**
```typescript
import {
  Controller,
  Post,
  Delete,
  Body,
  Param,
  UseGuards,
  Req,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { Request } from 'express';
import { ImpersonationService } from './impersonation.service';
import { StartSessionDto, EndSessionDto } from './dto/impersonation.dto';
// TODO: Add InternalAuthGuard when internal auth is implemented
// import { InternalAuthGuard } from '../auth/internal-auth.guard';

@Controller('api/v1/internal/impersonation')
export class ImpersonationController {
  constructor(private readonly impersonationService: ImpersonationService) {}

  /**
   * Start an impersonation session
   * POST /api/v1/internal/impersonation/sessions
   */
  @Post('sessions')
  // @UseGuards(InternalAuthGuard)
  async startSession(
    @Body() dto: StartSessionDto,
    @Req() req: Request,
  ) {
    // TODO: Get operator ID from internal auth
    const operatorUserId = (req as any).internalUser?.id;
    if (!operatorUserId) {
      // Temporary: require operatorUserId in body for testing
      throw new Error('Internal auth not yet implemented');
    }

    const ipAddress = req.ip || req.headers['x-forwarded-for']?.toString();
    const userAgent = req.headers['user-agent'];

    return this.impersonationService.startSession(
      operatorUserId,
      dto,
      ipAddress,
      userAgent,
    );
  }

  /**
   * End an impersonation session
   * DELETE /api/v1/internal/impersonation/sessions/:sessionId
   */
  @Delete('sessions/:sessionId')
  @HttpCode(HttpStatus.NO_CONTENT)
  async endSession(
    @Param('sessionId') sessionId: string,
    @Body() dto: EndSessionDto,
  ) {
    await this.impersonationService.endSession(sessionId, dto.notes);
  }

  /**
   * Validate current session (health check)
   * POST /api/v1/internal/impersonation/sessions/:sessionId/validate
   */
  @Post('sessions/:sessionId/validate')
  async validateSession(@Param('sessionId') sessionId: string) {
    const context = await this.impersonationService.validateSession(sessionId);
    if (!context) {
      return { valid: false };
    }
    return {
      valid: true,
      organizationId: context.targetOrganizationId,
      expiresAt: context.expiresAt,
      remainingSeconds: Math.floor((context.expiresAt.getTime() - Date.now()) / 1000),
    };
  }
}
```

**impersonation.module.ts:**
```typescript
import { Module, MiddlewareConsumer, NestModule } from '@nestjs/common';
import { ClsModule } from 'nestjs-cls';
import { PrismaModule } from '../../../prisma/prisma.module';
import { ImpersonationService } from './impersonation.service';
import { ImpersonationGuard } from './impersonation.guard';
import { ImpersonationMiddleware } from './impersonation.middleware';
import { ImpersonationController } from './impersonation.controller';

@Module({
  imports: [PrismaModule, ClsModule],
  controllers: [ImpersonationController],
  providers: [ImpersonationService, ImpersonationGuard],
  exports: [ImpersonationService, ImpersonationGuard],
})
export class ImpersonationModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    // Apply middleware to all routes that might use impersonation
    consumer
      .apply(ImpersonationMiddleware)
      .forRoutes('*');
  }
}
```

**index.ts:**
```typescript
export * from './impersonation.service';
export * from './impersonation.guard';
export * from './impersonation.module';
export * from './dto/impersonation.dto';
```

Update **operations.module.ts** to import ImpersonationModule.
  </action>
  <verify>
1. `cd apps/backend && npx tsc --noEmit` - TypeScript compiles
2. `cd apps/backend && npm run lint` - Linting passes
  </verify>
  <done>ImpersonationModule with controller, service, guard, middleware all wired up</done>
</task>

</tasks>

<verification>
1. `cd apps/backend && npx tsc --noEmit` - TypeScript compiles
2. `cd apps/backend && npm run lint` - No linting errors
3. ImpersonationModule exported from operations module
</verification>

<success_criteria>
- ImpersonationService can start/end sessions with audit logging
- Sessions have 4-hour max expiration (security cap)
- ImpersonationMiddleware sets CLS context and RLS from X-Impersonation-Session header
- ImpersonationGuard validates session for routes requiring impersonation
- Response headers include remaining time for client UI timer
- All actions during impersonation logged via logCurrentAction()
</success_criteria>

<output>
After completion, create `.planning/phases/12-internal-operations-portal/12-06-SUMMARY.md`
</output>
