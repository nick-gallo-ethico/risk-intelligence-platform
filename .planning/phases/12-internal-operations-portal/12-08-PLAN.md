---
phase: 12-internal-operations-portal
plan: 08
type: execute
wave: 2
depends_on: [12-03]
files_modified:
  - apps/backend/src/modules/operations/client-health/health-score.service.ts
  - apps/backend/src/modules/operations/client-health/usage-metrics.service.ts
  - apps/backend/src/modules/operations/client-health/health-score.processor.ts
  - apps/backend/src/modules/operations/client-health/client-health.controller.ts
  - apps/backend/src/modules/operations/client-health/client-health.module.ts
autonomous: true

must_haves:
  truths:
    - "Health scores calculated from 5 weighted components (login 20%, case 25%, campaign 25%, features 15%, tickets 15%)"
    - "BullMQ processor runs nightly to recalculate all tenant health scores"
    - "Usage metrics collected daily for trend analysis"
    - "Risk level derived from score + trend (HIGH if <40 or declining <60)"
  artifacts:
    - path: "apps/backend/src/modules/operations/client-health/health-score.service.ts"
      provides: "Health score calculation with component breakdown"
      exports: ["HealthScoreService"]
      min_lines: 200
    - path: "apps/backend/src/modules/operations/client-health/health-score.processor.ts"
      provides: "BullMQ job for scheduled calculation"
      exports: ["HealthScoreProcessor"]
  key_links:
    - from: "HealthScoreProcessor"
      to: "HealthScoreService"
      via: "calculateHealthScore"
      pattern: "calculateHealthScore"
---

<objective>
Create the client health score calculation service and BullMQ processor.

Purpose: Calculate tenant health using blended scoring (usage + outcome metrics) with scheduled nightly recalculation. Per CONTEXT.md: traffic light + numeric, configurable alerts, peer comparison support.

Output: HealthScoreService, UsageMetricsService, and HealthScoreProcessor with BullMQ integration.
</objective>

<execution_context>
@.claude/agents/gsd-executor.md
@.claude/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-internal-operations-portal/12-CONTEXT.md
@.planning/phases/12-internal-operations-portal/12-RESEARCH.md
@.planning/phases/12-internal-operations-portal/12-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Usage Metrics Service</name>
  <files>
    apps/backend/src/modules/operations/client-health/usage-metrics.service.ts
  </files>
  <action>
Create service to collect and store daily usage metrics:

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { subDays, startOfDay, endOfDay } from 'date-fns';

export interface LoginMetrics {
  activeUsers: number;
  totalUsers: number;
}

export interface CaseMetrics {
  casesCreated: number;
  casesClosed: number;
  casesOnTime: number;
  casesOverdue: number;
}

export interface CampaignMetrics {
  campaignsActive: number;
  assignmentsTotal: number;
  assignmentsCompleted: number;
}

@Injectable()
export class UsageMetricsService {
  private readonly logger = new Logger(UsageMetricsService.name);

  constructor(private readonly prisma: PrismaService) {}

  /**
   * Collect and store daily usage metrics for a tenant
   */
  async collectDailyMetrics(
    organizationId: string,
    forDate: Date = new Date(),
  ): Promise<void> {
    const dateStart = startOfDay(forDate);
    const dateEnd = endOfDay(forDate);
    const thirtyDaysAgo = subDays(forDate, 30);

    // Use RLS bypass for cross-tenant metrics collection
    const [login, cases, campaigns, support] = await Promise.all([
      this.getLoginMetrics(organizationId, thirtyDaysAgo, forDate),
      this.getCaseMetrics(organizationId, dateStart, dateEnd),
      this.getCampaignMetrics(organizationId),
      this.getSupportTicketCount(organizationId, thirtyDaysAgo, forDate),
    ]);

    // Upsert daily metrics
    await this.prisma.usageMetric.upsert({
      where: {
        organizationId_metricDate: {
          organizationId,
          metricDate: dateStart,
        },
      },
      create: {
        organizationId,
        metricDate: dateStart,
        activeUsers: login.activeUsers,
        totalUsers: login.totalUsers,
        casesCreated: cases.casesCreated,
        casesClosed: cases.casesClosed,
        casesOnTime: cases.casesOnTime,
        casesOverdue: cases.casesOverdue,
        campaignsActive: campaigns.campaignsActive,
        assignmentsTotal: campaigns.assignmentsTotal,
        assignmentsCompleted: campaigns.assignmentsCompleted,
        supportTickets: support,
      },
      update: {
        activeUsers: login.activeUsers,
        totalUsers: login.totalUsers,
        casesCreated: cases.casesCreated,
        casesClosed: cases.casesClosed,
        casesOnTime: cases.casesOnTime,
        casesOverdue: cases.casesOverdue,
        campaignsActive: campaigns.campaignsActive,
        assignmentsTotal: campaigns.assignmentsTotal,
        assignmentsCompleted: campaigns.assignmentsCompleted,
        supportTickets: support,
      },
    });

    this.logger.debug(`Collected metrics for org ${organizationId} on ${dateStart.toISOString()}`);
  }

  /**
   * Get login metrics for a period
   */
  async getLoginMetrics(
    organizationId: string,
    startDate: Date,
    endDate: Date,
  ): Promise<LoginMetrics> {
    const [activeUsers, totalUsers] = await Promise.all([
      this.prisma.user.count({
        where: {
          organizationId,
          lastLoginAt: { gte: startDate, lte: endDate },
          isActive: true,
        },
      }),
      this.prisma.user.count({
        where: {
          organizationId,
          isActive: true,
        },
      }),
    ]);

    return { activeUsers, totalUsers };
  }

  /**
   * Get case metrics for a period
   */
  async getCaseMetrics(
    organizationId: string,
    startDate: Date,
    endDate: Date,
  ): Promise<CaseMetrics> {
    const [created, closed, onTime, overdue] = await Promise.all([
      this.prisma.case.count({
        where: {
          organizationId,
          createdAt: { gte: startDate, lte: endDate },
        },
      }),
      this.prisma.case.count({
        where: {
          organizationId,
          closedAt: { gte: startDate, lte: endDate },
        },
      }),
      // On-time: closed before SLA breach
      this.prisma.case.count({
        where: {
          organizationId,
          closedAt: { gte: startDate, lte: endDate },
          slaStatus: { in: ['ON_TRACK', 'WARNING'] },
        },
      }),
      // Overdue: still open and SLA breached
      this.prisma.case.count({
        where: {
          organizationId,
          closedAt: null,
          slaStatus: { in: ['BREACHED', 'CRITICAL'] },
        },
      }),
    ]);

    return {
      casesCreated: created,
      casesClosed: closed,
      casesOnTime: onTime,
      casesOverdue: overdue,
    };
  }

  /**
   * Get campaign metrics (current state)
   */
  async getCampaignMetrics(organizationId: string): Promise<CampaignMetrics> {
    const [activeCampaigns, assignmentStats] = await Promise.all([
      this.prisma.campaign.count({
        where: {
          organizationId,
          status: 'ACTIVE',
        },
      }),
      this.prisma.campaignAssignment.groupBy({
        by: ['status'],
        where: {
          campaign: { organizationId },
        },
        _count: true,
      }),
    ]);

    const total = assignmentStats.reduce((sum, s) => sum + s._count, 0);
    const completed = assignmentStats.find(s => s.status === 'COMPLETED')?._count || 0;

    return {
      campaignsActive: activeCampaigns,
      assignmentsTotal: total,
      assignmentsCompleted: completed,
    };
  }

  /**
   * Get support ticket count (placeholder - integrate with support system)
   */
  async getSupportTicketCount(
    organizationId: string,
    startDate: Date,
    endDate: Date,
  ): Promise<number> {
    // TODO: Integrate with actual support system
    // For now, return 0 as placeholder
    return 0;
  }
}
```
  </action>
  <verify>TypeScript compiles: `cd apps/backend && npx tsc --noEmit`</verify>
  <done>UsageMetricsService collecting login, case, campaign metrics</done>
</task>

<task type="auto">
  <name>Task 2: Create Health Score Service</name>
  <files>
    apps/backend/src/modules/operations/client-health/health-score.service.ts
  </files>
  <action>
Create health score calculation service per RESEARCH.md:

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { UsageMetricsService, LoginMetrics, CaseMetrics, CampaignMetrics } from './usage-metrics.service';
import {
  HEALTH_WEIGHTS,
  RiskLevel,
  HealthTrend,
  HealthScoreComponents,
  TrackedFeature,
} from '../types/health-metrics.types';
import { subDays } from 'date-fns';

@Injectable()
export class HealthScoreService {
  private readonly logger = new Logger(HealthScoreService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly usageMetricsService: UsageMetricsService,
  ) {}

  /**
   * Calculate health score for a tenant
   */
  async calculateHealthScore(organizationId: string): Promise<{
    overallScore: number;
    components: HealthScoreComponents;
    trend: HealthTrend;
    riskLevel: RiskLevel;
  }> {
    const now = new Date();
    const thirtyDaysAgo = subDays(now, 30);

    // Fetch component data in parallel
    const [loginData, caseData, campaignData, featureData, ticketData, previousScore] =
      await Promise.all([
        this.usageMetricsService.getLoginMetrics(organizationId, thirtyDaysAgo, now),
        this.usageMetricsService.getCaseMetrics(organizationId, thirtyDaysAgo, now),
        this.usageMetricsService.getCampaignMetrics(organizationId),
        this.getFeatureAdoptionScore(organizationId),
        this.usageMetricsService.getSupportTicketCount(organizationId, thirtyDaysAgo, now),
        this.getPreviousScore(organizationId),
      ]);

    // Calculate component scores (0-100)
    const components: HealthScoreComponents = {
      loginScore: this.calculateLoginScore(loginData),
      caseResolutionScore: this.calculateCaseResolutionScore(caseData),
      campaignCompletionScore: this.calculateCampaignScore(campaignData),
      featureAdoptionScore: featureData,
      supportTicketScore: this.calculateTicketScore(ticketData),
    };

    // Calculate weighted overall score
    const overallScore = Math.round(
      components.loginScore * HEALTH_WEIGHTS.login +
      components.caseResolutionScore * HEALTH_WEIGHTS.caseResolution +
      components.campaignCompletionScore * HEALTH_WEIGHTS.campaignCompletion +
      components.featureAdoptionScore * HEALTH_WEIGHTS.featureAdoption +
      components.supportTicketScore * HEALTH_WEIGHTS.supportTickets,
    );

    // Determine trend and risk level
    const trend = this.determineTrend(overallScore, previousScore);
    const riskLevel = this.determineRiskLevel(overallScore, trend);

    // Save score
    await this.prisma.tenantHealthScore.create({
      data: {
        organizationId,
        calculatedAt: now,
        loginScore: components.loginScore,
        caseResolutionScore: components.caseResolutionScore,
        campaignCompletionScore: components.campaignCompletionScore,
        featureAdoptionScore: components.featureAdoptionScore,
        supportTicketScore: components.supportTicketScore,
        overallScore,
        trend,
        riskLevel,
        previousScore,
      },
    });

    this.logger.log(`Health score calculated for org ${organizationId}: ${overallScore} (${riskLevel})`);

    return { overallScore, components, trend, riskLevel };
  }

  /**
   * Get latest health score for a tenant
   */
  async getLatestScore(organizationId: string) {
    return this.prisma.tenantHealthScore.findFirst({
      where: { organizationId },
      orderBy: { calculatedAt: 'desc' },
    });
  }

  /**
   * Get health score history for trends
   */
  async getScoreHistory(
    organizationId: string,
    days: number = 30,
  ) {
    const startDate = subDays(new Date(), days);
    return this.prisma.tenantHealthScore.findMany({
      where: {
        organizationId,
        calculatedAt: { gte: startDate },
      },
      orderBy: { calculatedAt: 'asc' },
    });
  }

  // --- Component Calculators ---

  private calculateLoginScore(data: LoginMetrics): number {
    if (data.totalUsers === 0) return 0;
    const activeRatio = data.activeUsers / data.totalUsers;
    // Target: 70% of users active in last 30 days = 100 score
    return Math.min(100, Math.round((activeRatio / 0.7) * 100));
  }

  private calculateCaseResolutionScore(data: CaseMetrics): number {
    if (data.casesClosed === 0) return 100; // No cases to resolve = perfect
    const onTimeRatio = data.casesOnTime / data.casesClosed;
    // Target: 90% on-time resolution = 100 score
    return Math.min(100, Math.round((onTimeRatio / 0.9) * 100));
  }

  private calculateCampaignScore(data: CampaignMetrics): number {
    if (data.assignmentsTotal === 0) return 100; // No campaigns = not penalized
    const completionRatio = data.assignmentsCompleted / data.assignmentsTotal;
    // Target: 85% completion = 100 score
    return Math.min(100, Math.round((completionRatio / 0.85) * 100));
  }

  private async getFeatureAdoptionScore(organizationId: string): Promise<number> {
    const adoptions = await this.prisma.featureAdoption.findMany({
      where: { organizationId },
    });

    const totalFeatures = Object.keys(TrackedFeature).length;
    const adoptedFeatures = adoptions.filter(a => a.isAdopted).length;

    // Target: 60% feature adoption = 100 score
    const adoptionRatio = adoptedFeatures / totalFeatures;
    return Math.min(100, Math.round((adoptionRatio / 0.6) * 100));
  }

  private calculateTicketScore(ticketCount: number): number {
    // Lower tickets = higher score
    // 0 tickets = 100, scale down from there
    // 10+ tickets in 30 days = 0
    return Math.max(0, 100 - ticketCount * 10);
  }

  private async getPreviousScore(organizationId: string): Promise<number | null> {
    const previous = await this.prisma.tenantHealthScore.findFirst({
      where: { organizationId },
      orderBy: { calculatedAt: 'desc' },
    });
    return previous?.overallScore ?? null;
  }

  private determineTrend(current: number, previous: number | null): HealthTrend {
    if (previous === null) return HealthTrend.STABLE;
    const delta = current - previous;
    if (delta > 5) return HealthTrend.IMPROVING;
    if (delta < -5) return HealthTrend.DECLINING;
    return HealthTrend.STABLE;
  }

  private determineRiskLevel(score: number, trend: HealthTrend): RiskLevel {
    // Per CONTEXT.md: traffic light
    if (score < 40 || (score < 60 && trend === HealthTrend.DECLINING)) {
      return RiskLevel.HIGH;
    }
    if (score < 70 || trend === HealthTrend.DECLINING) {
      return RiskLevel.MEDIUM;
    }
    return RiskLevel.LOW;
  }
}
```
  </action>
  <verify>TypeScript compiles: `cd apps/backend && npx tsc --noEmit`</verify>
  <done>HealthScoreService with 5-component weighted calculation and risk level</done>
</task>

<task type="auto">
  <name>Task 3: Create Health Score Processor and Module</name>
  <files>
    apps/backend/src/modules/operations/client-health/health-score.processor.ts
    apps/backend/src/modules/operations/client-health/client-health.controller.ts
    apps/backend/src/modules/operations/client-health/client-health.module.ts
    apps/backend/src/modules/operations/client-health/index.ts
    apps/backend/src/modules/operations/operations.module.ts
  </files>
  <action>
Create BullMQ processor and controller:

**health-score.processor.ts:**
```typescript
import { Processor, WorkerHost, OnWorkerEvent } from '@nestjs/bullmq';
import { Logger } from '@nestjs/common';
import { Job } from 'bullmq';
import { PrismaService } from '../../../prisma/prisma.service';
import { HealthScoreService } from './health-score.service';
import { UsageMetricsService } from './usage-metrics.service';

export const HEALTH_SCORE_QUEUE = 'health-scores';

interface HealthScoreJobData {
  organizationId?: string; // Optional: specific tenant or all
  collectMetrics?: boolean; // Also collect daily metrics
}

@Processor(HEALTH_SCORE_QUEUE)
export class HealthScoreProcessor extends WorkerHost {
  private readonly logger = new Logger(HealthScoreProcessor.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly healthScoreService: HealthScoreService,
    private readonly usageMetricsService: UsageMetricsService,
  ) {
    super();
  }

  async process(job: Job<HealthScoreJobData>): Promise<{ processed: number }> {
    this.logger.log(`Processing health score job ${job.id}`);

    if (job.data.organizationId) {
      // Single tenant calculation
      if (job.data.collectMetrics) {
        await this.usageMetricsService.collectDailyMetrics(job.data.organizationId);
      }
      await this.healthScoreService.calculateHealthScore(job.data.organizationId);
      return { processed: 1 };
    }

    // Calculate for all active tenants
    const tenants = await this.prisma.organization.findMany({
      where: { status: 'ACTIVE' },
      select: { id: true },
    });

    let processed = 0;
    for (let i = 0; i < tenants.length; i++) {
      try {
        if (job.data.collectMetrics) {
          await this.usageMetricsService.collectDailyMetrics(tenants[i].id);
        }
        await this.healthScoreService.calculateHealthScore(tenants[i].id);
        processed++;

        // Update progress
        await job.updateProgress(Math.round((i / tenants.length) * 100));

        // Rate limiting: wait between calculations per RESEARCH.md pitfall
        await new Promise(resolve => setTimeout(resolve, 100));
      } catch (error) {
        this.logger.error(`Failed to calculate score for org ${tenants[i].id}: ${error.message}`);
      }
    }

    this.logger.log(`Health score job complete: ${processed}/${tenants.length} tenants processed`);
    return { processed };
  }

  @OnWorkerEvent('failed')
  onFailed(job: Job, error: Error) {
    this.logger.error(`Health score job ${job.id} failed: ${error.message}`);
  }
}
```

**client-health.controller.ts:**
```typescript
@Controller('api/v1/internal/client-health')
export class ClientHealthController {
  constructor(
    private readonly healthScoreService: HealthScoreService,
    @InjectQueue(HEALTH_SCORE_QUEUE) private readonly healthQueue: Queue,
  ) {}

  @Get(':organizationId/score')
  async getScore(@Param('organizationId') organizationId: string) {
    return this.healthScoreService.getLatestScore(organizationId);
  }

  @Get(':organizationId/history')
  async getHistory(
    @Param('organizationId') organizationId: string,
    @Query('days') days?: number,
  ) {
    return this.healthScoreService.getScoreHistory(organizationId, days ? Number(days) : 30);
  }

  @Post(':organizationId/calculate')
  async triggerCalculation(@Param('organizationId') organizationId: string) {
    const job = await this.healthQueue.add('calculate-single', {
      organizationId,
      collectMetrics: true,
    });
    return { jobId: job.id };
  }

  @Post('calculate-all')
  async triggerAllCalculations() {
    const job = await this.healthQueue.add('calculate-all', {
      collectMetrics: true,
    });
    return { jobId: job.id };
  }
}
```

**client-health.module.ts:**
```typescript
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bullmq';
import { PrismaModule } from '../../../prisma/prisma.module';
import { HealthScoreService } from './health-score.service';
import { UsageMetricsService } from './usage-metrics.service';
import { HealthScoreProcessor, HEALTH_SCORE_QUEUE } from './health-score.processor';
import { ClientHealthController } from './client-health.controller';

@Module({
  imports: [
    PrismaModule,
    BullModule.registerQueue({
      name: HEALTH_SCORE_QUEUE,
      defaultJobOptions: {
        attempts: 3,
        backoff: { type: 'exponential', delay: 5000 },
      },
    }),
  ],
  controllers: [ClientHealthController],
  providers: [HealthScoreService, UsageMetricsService, HealthScoreProcessor],
  exports: [HealthScoreService, UsageMetricsService],
})
export class ClientHealthModule {}
```

Update OperationsModule to import ClientHealthModule.
  </action>
  <verify>
1. `cd apps/backend && npx tsc --noEmit` - TypeScript compiles
2. `cd apps/backend && npm run lint` - Linting passes
  </verify>
  <done>HealthScoreProcessor with rate limiting and progress tracking</done>
</task>

</tasks>

<verification>
1. `cd apps/backend && npx tsc --noEmit` - TypeScript compiles
2. `cd apps/backend && npm run lint` - No linting errors
3. ClientHealthModule exported from operations module
</verification>

<success_criteria>
- UsageMetricsService collects daily login, case, campaign, ticket metrics
- HealthScoreService calculates 5 components with HEALTH_WEIGHTS
- Risk level: HIGH if score <40 or (declining + <60), MEDIUM if <70 or declining, else LOW
- HealthScoreProcessor runs with rate limiting (100ms delay between tenants)
- Controller exposes score retrieval and manual calculation triggers
</success_criteria>

<output>
After completion, create `.planning/phases/12-internal-operations-portal/12-08-SUMMARY.md`
</output>
