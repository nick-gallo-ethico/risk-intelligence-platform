---
phase: 12-internal-operations-portal
plan: 18
type: execute
wave: 5
depends_on: []
files_modified:
  - apps/backend/test/e2e/websocket.e2e-spec.ts
  - apps/backend/test/e2e/ai-gateway.e2e-spec.ts
  - apps/backend/src/modules/auth/guards/jwt-ws.guard.ts
  - apps/backend/src/modules/auth/services/token-refresh.service.ts
  - apps/backend/src/common/interceptors/dataloader.interceptor.ts
  - apps/backend/prisma/migrations/add_indexes.sql
  - apps/backend/src/modules/cases/case.service.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket E2E tests cover connection, auth, rooms, token refresh"
    - "AI gateway E2E tests verify context loading and streaming"
    - "Token refresh during WebSocket handled without disconnection"
    - "N+1 queries resolved with DataLoader pattern"
    - "Database indexes added for common query patterns"
  artifacts:
    - path: "apps/backend/test/e2e/websocket.e2e-spec.ts"
      provides: "WebSocket gateway E2E tests"
      min_lines: 150
    - path: "apps/backend/src/common/interceptors/dataloader.interceptor.ts"
      provides: "Request-scoped DataLoader for N+1 resolution"
      min_lines: 60
  key_links:
    - from: "websocket.e2e-spec.ts"
      to: "NotificationGateway"
      via: "socket.io client"
      pattern: "socket\\.emit"
---

<objective>
Address accumulated backend technical debt: WebSocket E2E testing, auth edge cases, and query optimization.

Purpose: Ensure production readiness with comprehensive integration tests, efficient database queries, and proper handling of WebSocket authentication edge cases.

Output: E2E tests for WebSocket and AI gateways; token refresh improvements; DataLoader pattern for N+1 resolution; database indexes.
</objective>

<execution_context>
@.claude/agents/gsd-executor.md
@.claude/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-internal-operations-portal/12-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebSocket E2E Tests</name>
  <files>
    apps/backend/test/e2e/websocket.e2e-spec.ts
    apps/backend/test/e2e/test-helpers.ts
  </files>
  <action>
Create comprehensive WebSocket E2E tests:

**test/e2e/test-helpers.ts:**
```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { PrismaService } from '../../src/modules/prisma/prisma.service';
import { AppModule } from '../../src/app.module';

export async function createTestApp(): Promise<{
  app: INestApplication;
  prisma: PrismaService;
  jwtService: JwtService;
}> {
  const moduleFixture: TestingModule = await Test.createTestingModule({
    imports: [AppModule],
  }).compile();

  const app = moduleFixture.createNestApplication();
  await app.init();

  const prisma = moduleFixture.get(PrismaService);
  const jwtService = moduleFixture.get(JwtService);

  return { app, prisma, jwtService };
}

export async function createTestUser(
  prisma: PrismaService,
  overrides: Partial<{ email: string; name: string; role: string }> = {}
) {
  // Create tenant first
  const tenant = await prisma.organization.create({
    data: {
      name: `Test Org ${Date.now()}`,
      slug: `test-org-${Date.now()}`,
    },
  });

  // Create user
  const user = await prisma.user.create({
    data: {
      email: overrides.email || `test-${Date.now()}@test.com`,
      name: overrides.name || 'Test User',
      organizationId: tenant.id,
      role: overrides.role || 'USER',
    },
  });

  return { user, tenant };
}

export function generateToken(
  jwtService: JwtService,
  payload: { sub: string; tenantId: string; email: string; role?: string }
) {
  return jwtService.sign(payload);
}

export async function cleanupTestData(
  prisma: PrismaService,
  userId: string,
  tenantId: string
) {
  await prisma.user.deleteMany({ where: { id: userId } });
  await prisma.organization.deleteMany({ where: { id: tenantId } });
}
```

**test/e2e/websocket.e2e-spec.ts:**
```typescript
import { INestApplication } from '@nestjs/common';
import { Socket, io } from 'socket.io-client';
import { PrismaService } from '../../src/modules/prisma/prisma.service';
import { JwtService } from '@nestjs/jwt';
import {
  createTestApp,
  createTestUser,
  generateToken,
  cleanupTestData,
} from './test-helpers';

describe('WebSocket Gateway (E2E)', () => {
  let app: INestApplication;
  let prisma: PrismaService;
  let jwtService: JwtService;
  let socket: Socket;
  let validToken: string;
  let testUserId: string;
  let testTenantId: string;

  const WS_URL = 'http://localhost:3001';

  beforeAll(async () => {
    const setup = await createTestApp();
    app = setup.app;
    prisma = setup.prisma;
    jwtService = setup.jwtService;

    await app.listen(3001);

    // Create test user
    const { user, tenant } = await createTestUser(prisma);
    testUserId = user.id;
    testTenantId = tenant.id;

    validToken = generateToken(jwtService, {
      sub: user.id,
      tenantId: tenant.id,
      email: user.email,
    });
  });

  afterAll(async () => {
    await cleanupTestData(prisma, testUserId, testTenantId);
    await app.close();
  });

  beforeEach(() => {
    socket = io(`${WS_URL}/notifications`, {
      auth: { token: validToken },
      transports: ['websocket'],
      autoConnect: false,
    });
  });

  afterEach(() => {
    if (socket?.connected) {
      socket.disconnect();
    }
  });

  describe('Connection', () => {
    it('should connect with valid token', (done) => {
      socket.connect();
      socket.on('connect', () => {
        expect(socket.connected).toBe(true);
        done();
      });
    });

    it('should reject connection without token', (done) => {
      const unauthSocket = io(`${WS_URL}/notifications`, {
        transports: ['websocket'],
      });

      unauthSocket.on('connect_error', (err) => {
        expect(err.message).toMatch(/unauthorized|token/i);
        unauthSocket.disconnect();
        done();
      });
    });

    it('should reject connection with invalid token', (done) => {
      const invalidSocket = io(`${WS_URL}/notifications`, {
        auth: { token: 'invalid.token.here' },
        transports: ['websocket'],
      });

      invalidSocket.on('connect_error', (err) => {
        expect(err.message).toMatch(/unauthorized|invalid|token/i);
        invalidSocket.disconnect();
        done();
      });
    });

    it('should reject connection with expired token', (done) => {
      const expiredToken = jwtService.sign(
        { sub: testUserId, tenantId: testTenantId, email: 'test@test.com' },
        { expiresIn: '-1s' }
      );

      const expiredSocket = io(`${WS_URL}/notifications`, {
        auth: { token: expiredToken },
        transports: ['websocket'],
      });

      expiredSocket.on('connect_error', (err) => {
        expect(err.message).toMatch(/expired|invalid|unauthorized/i);
        expiredSocket.disconnect();
        done();
      });
    });
  });

  describe('Room Subscription', () => {
    it('should auto-join user room on connect', (done) => {
      socket.connect();
      socket.on('connect', () => {
        // Request rooms for debugging
        socket.emit('debug:my-rooms', (rooms: string[]) => {
          expect(rooms).toContain(`user:${testUserId}`);
          expect(rooms).toContain(`tenant:${testTenantId}`);
          done();
        });
      });
    });

    it('should NOT join other user rooms', (done) => {
      socket.connect();
      socket.on('connect', () => {
        socket.emit('subscribe', { room: 'user:other-user-id' });

        socket.emit('debug:my-rooms', (rooms: string[]) => {
          expect(rooms).not.toContain('user:other-user-id');
          done();
        });
      });
    });

    it('should NOT join other tenant rooms', (done) => {
      socket.connect();
      socket.on('connect', () => {
        socket.emit('subscribe', { room: 'tenant:other-tenant-id' });

        socket.emit('debug:my-rooms', (rooms: string[]) => {
          expect(rooms).not.toContain('tenant:other-tenant-id');
          done();
        });
      });
    });
  });

  describe('Notification Delivery', () => {
    it('should receive notification in user room', (done) => {
      socket.connect();
      socket.on('connect', async () => {
        socket.on('notification:new', (data) => {
          expect(data.message).toBe('Test notification');
          expect(data.userId).toBe(testUserId);
          done();
        });

        // Trigger notification via API
        await fetch(`${WS_URL}/api/v1/test/emit-notification`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${validToken}`,
          },
          body: JSON.stringify({
            userId: testUserId,
            message: 'Test notification',
          }),
        });
      });
    });

    it('should NOT receive notifications for other users', (done) => {
      socket.connect();
      socket.on('connect', async () => {
        let receivedNotification = false;

        socket.on('notification:new', () => {
          receivedNotification = true;
        });

        // Emit notification for different user
        await fetch(`${WS_URL}/api/v1/test/emit-notification`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${validToken}`,
          },
          body: JSON.stringify({
            userId: 'other-user-id',
            message: 'Should not receive',
          }),
        });

        // Wait and verify
        setTimeout(() => {
          expect(receivedNotification).toBe(false);
          done();
        }, 500);
      });
    });
  });

  describe('Token Refresh During Session', () => {
    it('should accept refreshed token without disconnection', (done) => {
      socket.connect();
      socket.on('connect', () => {
        const newToken = generateToken(jwtService, {
          sub: testUserId,
          tenantId: testTenantId,
          email: 'test@test.com',
        });

        socket.emit('auth:refresh', { token: newToken }, (response: any) => {
          expect(response.success).toBe(true);
          expect(socket.connected).toBe(true);
          done();
        });
      });
    });

    it('should disconnect on invalid refresh token', (done) => {
      socket.connect();
      socket.on('connect', () => {
        socket.emit('auth:refresh', { token: 'invalid' }, (response: any) => {
          expect(response.success).toBe(false);
        });

        socket.on('disconnect', (reason) => {
          expect(reason).toMatch(/server|forced/i);
          done();
        });
      });
    });

    it('should emit refresh-needed when token about to expire', (done) => {
      // Create token expiring in 30 seconds
      const shortLivedToken = jwtService.sign(
        { sub: testUserId, tenantId: testTenantId, email: 'test@test.com' },
        { expiresIn: '30s' }
      );

      const shortLivedSocket = io(`${WS_URL}/notifications`, {
        auth: { token: shortLivedToken },
        transports: ['websocket'],
      });

      shortLivedSocket.on('auth:refresh-needed', (data) => {
        expect(data.expiresIn).toBeLessThan(60000); // Less than 60s
        shortLivedSocket.disconnect();
        done();
      });

      shortLivedSocket.connect();
    });
  });

  describe('Reconnection', () => {
    it('should maintain room subscriptions after reconnect', (done) => {
      socket.connect();
      socket.on('connect', () => {
        const originalSocketId = socket.id;

        // Force disconnect and reconnect
        socket.disconnect();
        socket.connect();

        socket.on('connect', () => {
          expect(socket.id).not.toBe(originalSocketId);

          socket.emit('debug:my-rooms', (rooms: string[]) => {
            expect(rooms).toContain(`user:${testUserId}`);
            done();
          });
        });
      });
    });
  });

  describe('Error Handling', () => {
    it('should handle malformed events gracefully', (done) => {
      socket.connect();
      socket.on('connect', () => {
        socket.emit('unknown:event', { bad: 'data' });

        // Should not disconnect
        setTimeout(() => {
          expect(socket.connected).toBe(true);
          done();
        }, 500);
      });
    });
  });
});
```
  </action>
  <verify>npm run test:e2e -- websocket.e2e-spec.ts passes</verify>
  <done>WebSocket E2E tests covering connection, auth, rooms, and token refresh</done>
</task>

<task type="auto">
  <name>Task 2: Create AI Gateway E2E Tests and Fix Auth Edge Cases</name>
  <files>
    apps/backend/test/e2e/ai-gateway.e2e-spec.ts
    apps/backend/src/modules/auth/guards/jwt-ws.guard.ts
    apps/backend/src/modules/auth/services/token-refresh.service.ts
  </files>
  <action>
Create AI gateway E2E tests and fix auth edge cases:

**test/e2e/ai-gateway.e2e-spec.ts:**
```typescript
import { INestApplication } from '@nestjs/common';
import { Socket, io } from 'socket.io-client';
import { PrismaService } from '../../src/modules/prisma/prisma.service';
import { JwtService } from '@nestjs/jwt';
import {
  createTestApp,
  createTestUser,
  generateToken,
  cleanupTestData,
} from './test-helpers';

describe('AI Gateway (E2E)', () => {
  let app: INestApplication;
  let prisma: PrismaService;
  let jwtService: JwtService;
  let socket: Socket;
  let validToken: string;
  let testUserId: string;
  let testTenantId: string;
  let testCaseId: string;

  const WS_URL = 'http://localhost:3002';

  beforeAll(async () => {
    const setup = await createTestApp();
    app = setup.app;
    prisma = setup.prisma;
    jwtService = setup.jwtService;

    await app.listen(3002);

    // Create test user
    const { user, tenant } = await createTestUser(prisma);
    testUserId = user.id;
    testTenantId = tenant.id;

    // Create test case for context loading
    const testCase = await prisma.case.create({
      data: {
        organizationId: tenant.id,
        title: 'Test Case for AI',
        status: 'OPEN',
        priority: 2,
      },
    });
    testCaseId = testCase.id;

    validToken = generateToken(jwtService, {
      sub: user.id,
      tenantId: tenant.id,
      email: user.email,
    });
  });

  afterAll(async () => {
    await prisma.case.deleteMany({ where: { id: testCaseId } });
    await cleanupTestData(prisma, testUserId, testTenantId);
    await app.close();
  });

  beforeEach(() => {
    socket = io(`${WS_URL}/ai`, {
      auth: { token: validToken },
      transports: ['websocket'],
      autoConnect: false,
    });
  });

  afterEach(() => {
    if (socket?.connected) {
      socket.disconnect();
    }
  });

  describe('Context Loading', () => {
    it('should load case context successfully', (done) => {
      socket.connect();
      socket.on('connect', () => {
        socket.emit(
          'ai:load-context',
          { entityType: 'case', entityId: testCaseId },
          (response: any) => {
            expect(response.success).toBe(true);
            expect(response.context).toBeDefined();
            expect(response.context.entityType).toBe('case');
            expect(response.context.entityId).toBe(testCaseId);
            done();
          }
        );
      });
    });

    it('should return available skills with context', (done) => {
      socket.connect();
      socket.on('connect', () => {
        socket.emit(
          'ai:load-context',
          { entityType: 'case', entityId: testCaseId },
          (response: any) => {
            expect(response.availableSkills).toBeDefined();
            expect(Array.isArray(response.availableSkills)).toBe(true);
            expect(response.availableSkills).toContain('summarize');
            expect(response.availableSkills).toContain('note-cleanup');
            done();
          }
        );
      });
    });

    it('should reject context load for other tenant case', (done) => {
      socket.connect();
      socket.on('connect', () => {
        socket.emit(
          'ai:load-context',
          { entityType: 'case', entityId: 'non-existent-case-id' },
          (response: any) => {
            expect(response.success).toBe(false);
            expect(response.error).toMatch(/not found|access denied/i);
            done();
          }
        );
      });
    });
  });

  describe('Skill Execution', () => {
    it('should execute note-cleanup skill', (done) => {
      socket.connect();
      socket.on('connect', () => {
        socket.emit('ai:execute-skill', {
          skill: 'note-cleanup',
          input: {
            text: '- caller reported theft\n- happened at 2pm\n- warehouse B location',
          },
        });

        socket.on('ai:skill-result', (result) => {
          expect(result.success).toBe(true);
          expect(result.output).toBeDefined();
          expect(typeof result.output).toBe('string');
          // Should be prose, not bullet points
          expect(result.output).not.toMatch(/^- /m);
          done();
        });
      });
    }, 30000); // Longer timeout for AI calls

    it('should reject unknown skill', (done) => {
      socket.connect();
      socket.on('connect', () => {
        socket.emit('ai:execute-skill', {
          skill: 'unknown-skill',
          input: {},
        });

        socket.on('ai:skill-error', (error) => {
          expect(error.code).toMatch(/UNKNOWN|NOT_FOUND/i);
          done();
        });
      });
    });
  });

  describe('Streaming Responses', () => {
    it('should stream chat response chunks', (done) => {
      const chunks: string[] = [];

      socket.connect();
      socket.on('connect', () => {
        // Load context first
        socket.emit(
          'ai:load-context',
          { entityType: 'case', entityId: testCaseId },
          () => {
            socket.emit('ai:chat', {
              message: 'Summarize this case briefly in 2 sentences',
            });

            socket.on('ai:chat-chunk', (chunk) => {
              chunks.push(chunk.text);
            });

            socket.on('ai:chat-complete', () => {
              expect(chunks.length).toBeGreaterThan(0);
              const fullResponse = chunks.join('');
              expect(fullResponse.length).toBeGreaterThan(10);
              done();
            });
          }
        );
      });
    }, 60000); // Longer timeout for streaming

    it('should handle stream cancellation', (done) => {
      let chunksReceived = 0;

      socket.connect();
      socket.on('connect', () => {
        socket.emit(
          'ai:load-context',
          { entityType: 'case', entityId: testCaseId },
          () => {
            socket.emit('ai:chat', {
              message: 'Write a very long detailed analysis of this case',
            });

            socket.on('ai:chat-chunk', () => {
              chunksReceived++;
              if (chunksReceived === 3) {
                socket.emit('ai:cancel');
              }
            });

            socket.on('ai:chat-cancelled', () => {
              expect(chunksReceived).toBeGreaterThanOrEqual(3);
              expect(chunksReceived).toBeLessThan(20);
              done();
            });
          }
        );
      });
    }, 60000);
  });
});
```

**src/modules/auth/guards/jwt-ws.guard.ts:**
```typescript
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  Logger,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { WsException } from '@nestjs/websockets';
import { Socket } from 'socket.io';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class JwtWsGuard implements CanActivate {
  private readonly logger = new Logger(JwtWsGuard.name);
  private readonly refreshBufferMs: number;

  constructor(
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
  ) {
    // Notify client 60s before token expires
    this.refreshBufferMs = 60 * 1000;
  }

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const client: Socket = context.switchToWs().getClient();
    const token = this.extractToken(client);

    if (!token) {
      this.logger.warn('WebSocket connection without token');
      throw new WsException({ code: 'UNAUTHORIZED', message: 'Missing token' });
    }

    try {
      const payload = await this.jwtService.verifyAsync(token, {
        secret: this.configService.get('JWT_SECRET'),
      });

      // Check if token is about to expire
      const expiresAt = payload.exp * 1000;
      const now = Date.now();
      const timeUntilExpiry = expiresAt - now;

      if (timeUntilExpiry < this.refreshBufferMs && timeUntilExpiry > 0) {
        // Emit refresh-needed event
        client.emit('auth:refresh-needed', {
          expiresIn: timeUntilExpiry,
        });
      }

      // Attach user data to socket
      client.data.user = {
        id: payload.sub,
        email: payload.email,
        role: payload.role,
      };
      client.data.tenantId = payload.tenantId;

      return true;
    } catch (error) {
      this.logger.warn(`WebSocket auth failed: ${error.message}`);

      if (error.name === 'TokenExpiredError') {
        throw new WsException({
          code: 'TOKEN_EXPIRED',
          message: 'Token expired - please refresh',
        });
      }

      if (error.name === 'JsonWebTokenError') {
        throw new WsException({
          code: 'INVALID_TOKEN',
          message: 'Invalid token format',
        });
      }

      throw new WsException({
        code: 'UNAUTHORIZED',
        message: 'Authentication failed',
      });
    }
  }

  private extractToken(client: Socket): string | undefined {
    // Priority 1: auth object (recommended)
    const auth = client.handshake.auth;
    if (auth?.token) {
      return auth.token;
    }

    // Priority 2: Authorization header
    const authHeader = client.handshake.headers.authorization;
    if (authHeader?.startsWith('Bearer ')) {
      return authHeader.slice(7);
    }

    // Priority 3: Query parameter (fallback)
    const query = client.handshake.query;
    if (typeof query.token === 'string') {
      return query.token;
    }

    return undefined;
  }
}
```

**src/modules/auth/services/token-refresh.service.ts:**
```typescript
import { Injectable, Logger } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../../prisma/prisma.service';

export interface RefreshResult {
  success: boolean;
  accessToken?: string;
  refreshToken?: string;
  error?: string;
}

@Injectable()
export class TokenRefreshService {
  private readonly logger = new Logger(TokenRefreshService.name);

  constructor(
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
    private readonly prisma: PrismaService,
  ) {}

  async refreshAccessToken(refreshToken: string): Promise<RefreshResult> {
    try {
      // Verify refresh token
      const payload = await this.jwtService.verifyAsync(refreshToken, {
        secret: this.configService.get('JWT_REFRESH_SECRET'),
      });

      // Check if token is revoked
      const storedToken = await this.prisma.refreshToken.findUnique({
        where: { token: refreshToken },
      });

      if (!storedToken) {
        return { success: false, error: 'Refresh token not found' };
      }

      if (storedToken.revokedAt) {
        this.logger.warn(`Attempt to use revoked token: ${storedToken.id}`);
        return { success: false, error: 'Refresh token revoked' };
      }

      if (new Date(storedToken.expiresAt) < new Date()) {
        return { success: false, error: 'Refresh token expired' };
      }

      // Get user
      const user = await this.prisma.user.findUnique({
        where: { id: payload.sub },
        include: { organization: true },
      });

      if (!user) {
        return { success: false, error: 'User not found' };
      }

      if (user.status !== 'ACTIVE') {
        return { success: false, error: 'User account is not active' };
      }

      // Generate new access token
      const newAccessToken = this.jwtService.sign({
        sub: user.id,
        email: user.email,
        tenantId: user.organizationId,
        role: user.role,
      });

      // Rotate refresh token
      const newRefreshToken = this.jwtService.sign(
        { sub: user.id, type: 'refresh' },
        {
          secret: this.configService.get('JWT_REFRESH_SECRET'),
          expiresIn: '7d',
        },
      );

      // Revoke old, store new
      await this.prisma.$transaction([
        this.prisma.refreshToken.update({
          where: { id: storedToken.id },
          data: { revokedAt: new Date() },
        }),
        this.prisma.refreshToken.create({
          data: {
            token: newRefreshToken,
            userId: user.id,
            expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
          },
        }),
      ]);

      return {
        success: true,
        accessToken: newAccessToken,
        refreshToken: newRefreshToken,
      };
    } catch (error) {
      this.logger.error(`Token refresh failed: ${error.message}`);
      return { success: false, error: 'Invalid refresh token' };
    }
  }

  /**
   * Refresh WebSocket session token without full refresh token flow.
   * Used for in-flight WebSocket connections.
   */
  async refreshWebSocketToken(currentToken: string): Promise<RefreshResult> {
    try {
      // Decode without verifying (token may be expired but within grace period)
      const decoded = this.jwtService.decode(currentToken) as any;

      if (!decoded?.sub) {
        return { success: false, error: 'Invalid token format' };
      }

      // Check token isn't too old (max 5 minutes grace period)
      const expiredAt = decoded.exp * 1000;
      const gracePeriod = 5 * 60 * 1000;

      if (Date.now() > expiredAt + gracePeriod) {
        return { success: false, error: 'Token too old for WebSocket refresh' };
      }

      // Get user
      const user = await this.prisma.user.findUnique({
        where: { id: decoded.sub },
      });

      if (!user || user.status !== 'ACTIVE') {
        return { success: false, error: 'User not found or inactive' };
      }

      // Generate new access token
      const newAccessToken = this.jwtService.sign({
        sub: user.id,
        email: user.email,
        tenantId: user.organizationId,
        role: user.role,
      });

      return {
        success: true,
        accessToken: newAccessToken,
      };
    } catch (error) {
      return { success: false, error: 'Token refresh failed' };
    }
  }
}
```
  </action>
  <verify>npm run test:e2e -- ai-gateway.e2e-spec.ts passes</verify>
  <done>AI gateway E2E tests and improved WebSocket auth handling</done>
</task>

<task type="auto">
  <name>Task 3: Add DataLoader Pattern and Database Indexes</name>
  <files>
    apps/backend/src/common/interceptors/dataloader.interceptor.ts
    apps/backend/src/common/dataloader/dataloader.factory.ts
    apps/backend/src/modules/cases/case.service.ts
    apps/backend/prisma/migrations/20260205_add_indexes/migration.sql
  </files>
  <action>
Add DataLoader pattern for N+1 resolution and database indexes:

**src/common/dataloader/dataloader.factory.ts:**
```typescript
import DataLoader from 'dataloader';
import { PrismaService } from '../../modules/prisma/prisma.service';

export interface DataLoaders {
  userLoader: DataLoader<string, any>;
  organizationLoader: DataLoader<string, any>;
  caseRiusLoader: DataLoader<string, any[]>;
  caseAssigneeLoader: DataLoader<string, any>;
  investigationStepsLoader: DataLoader<string, any[]>;
}

export function createDataLoaders(prisma: PrismaService): DataLoaders {
  return {
    userLoader: new DataLoader<string, any>(async (ids) => {
      const users = await prisma.user.findMany({
        where: { id: { in: [...ids] } },
      });
      const userMap = new Map(users.map((u) => [u.id, u]));
      return ids.map((id) => userMap.get(id) || null);
    }),

    organizationLoader: new DataLoader<string, any>(async (ids) => {
      const orgs = await prisma.organization.findMany({
        where: { id: { in: [...ids] } },
      });
      const orgMap = new Map(orgs.map((o) => [o.id, o]));
      return ids.map((id) => orgMap.get(id) || null);
    }),

    caseRiusLoader: new DataLoader<string, any[]>(async (caseIds) => {
      const rius = await prisma.rIU.findMany({
        where: { caseId: { in: [...caseIds] } },
        orderBy: { createdAt: 'desc' },
      });
      const riuMap = new Map<string, any[]>();
      for (const riu of rius) {
        if (!riuMap.has(riu.caseId)) {
          riuMap.set(riu.caseId, []);
        }
        riuMap.get(riu.caseId)!.push(riu);
      }
      return caseIds.map((id) => riuMap.get(id) || []);
    }),

    caseAssigneeLoader: new DataLoader<string, any>(async (caseIds) => {
      const cases = await prisma.case.findMany({
        where: { id: { in: [...caseIds] } },
        select: { id: true, assigneeId: true },
      });

      const assigneeIds = cases
        .map((c) => c.assigneeId)
        .filter(Boolean) as string[];

      const users = await prisma.user.findMany({
        where: { id: { in: assigneeIds } },
      });

      const userMap = new Map(users.map((u) => [u.id, u]));
      const caseAssigneeMap = new Map(
        cases.map((c) => [c.id, c.assigneeId ? userMap.get(c.assigneeId) : null])
      );

      return caseIds.map((id) => caseAssigneeMap.get(id) || null);
    }),

    investigationStepsLoader: new DataLoader<string, any[]>(async (invIds) => {
      const steps = await prisma.investigationStep.findMany({
        where: { investigationId: { in: [...invIds] } },
        orderBy: { sortOrder: 'asc' },
      });
      const stepMap = new Map<string, any[]>();
      for (const step of steps) {
        if (!stepMap.has(step.investigationId)) {
          stepMap.set(step.investigationId, []);
        }
        stepMap.get(step.investigationId)!.push(step);
      }
      return invIds.map((id) => stepMap.get(id) || []);
    }),
  };
}
```

**src/common/interceptors/dataloader.interceptor.ts:**
```typescript
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { PrismaService } from '../../modules/prisma/prisma.service';
import { createDataLoaders, DataLoaders } from '../dataloader/dataloader.factory';

export const DATALOADER_CONTEXT_KEY = 'dataLoaders';

@Injectable()
export class DataLoaderInterceptor implements NestInterceptor {
  constructor(private readonly prisma: PrismaService) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();

    // Create request-scoped DataLoaders
    if (!request[DATALOADER_CONTEXT_KEY]) {
      request[DATALOADER_CONTEXT_KEY] = createDataLoaders(this.prisma);
    }

    return next.handle();
  }
}

// Decorator to inject DataLoaders
export function GetDataLoaders(): ParameterDecorator {
  return (target, propertyKey, parameterIndex) => {
    // This will be handled by a custom pipe or the interceptor
  };
}
```

**Update src/modules/cases/case.service.ts (example):**
```typescript
// Add method that uses DataLoaders
async findManyOptimized(
  query: CaseQueryDto,
  dataLoaders?: DataLoaders
): Promise<CaseWithRelations[]> {
  const cases = await this.prisma.case.findMany({
    where: this.buildWhereClause(query),
    orderBy: this.buildOrderBy(query),
    skip: query.skip,
    take: query.take,
    select: {
      id: true,
      title: true,
      status: true,
      priority: true,
      assigneeId: true,
      createdAt: true,
      updatedAt: true,
      _count: {
        select: { rius: true, comments: true },
      },
    },
  });

  if (!dataLoaders) {
    return cases;
  }

  // Batch load assignees using DataLoader
  const assignees = await Promise.all(
    cases.map((c) =>
      c.assigneeId ? dataLoaders.userLoader.load(c.assigneeId) : null
    )
  );

  return cases.map((c, i) => ({
    ...c,
    assignee: assignees[i],
  }));
}
```

**prisma/migrations/20260205_add_indexes/migration.sql:**
```sql
-- Case table indexes for common queries
CREATE INDEX CONCURRENTLY IF NOT EXISTS "Case_organizationId_status_idx"
ON "Case" ("organizationId", "status");

CREATE INDEX CONCURRENTLY IF NOT EXISTS "Case_organizationId_assigneeId_idx"
ON "Case" ("organizationId", "assigneeId");

CREATE INDEX CONCURRENTLY IF NOT EXISTS "Case_organizationId_createdAt_idx"
ON "Case" ("organizationId", "createdAt" DESC);

CREATE INDEX CONCURRENTLY IF NOT EXISTS "Case_organizationId_priority_status_idx"
ON "Case" ("organizationId", "priority", "status");

-- RIU table indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS "RIU_organizationId_status_idx"
ON "RIU" ("organizationId", "status");

CREATE INDEX CONCURRENTLY IF NOT EXISTS "RIU_organizationId_createdAt_idx"
ON "RIU" ("organizationId", "createdAt" DESC);

CREATE INDEX CONCURRENTLY IF NOT EXISTS "RIU_caseId_idx"
ON "RIU" ("caseId");

-- Investigation table indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS "Investigation_caseId_idx"
ON "Investigation" ("caseId");

CREATE INDEX CONCURRENTLY IF NOT EXISTS "Investigation_organizationId_status_idx"
ON "Investigation" ("organizationId", "status");

CREATE INDEX CONCURRENTLY IF NOT EXISTS "Investigation_organizationId_assigneeId_idx"
ON "Investigation" ("organizationId", "assigneeId");

-- AuditLog indexes for reporting and querying
CREATE INDEX CONCURRENTLY IF NOT EXISTS "AuditLog_organizationId_createdAt_idx"
ON "AuditLog" ("organizationId", "createdAt" DESC);

CREATE INDEX CONCURRENTLY IF NOT EXISTS "AuditLog_entityType_entityId_idx"
ON "AuditLog" ("entityType", "entityId");

CREATE INDEX CONCURRENTLY IF NOT EXISTS "AuditLog_actorId_createdAt_idx"
ON "AuditLog" ("actorId", "createdAt" DESC);

-- Notification indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS "Notification_userId_isRead_createdAt_idx"
ON "Notification" ("userId", "isRead", "createdAt" DESC);

-- Internal operations indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS "ImpersonationSession_operatorId_idx"
ON "ImpersonationSession" ("operatorId");

CREATE INDEX CONCURRENTLY IF NOT EXISTS "ImpersonationSession_organizationId_idx"
ON "ImpersonationSession" ("organizationId");

CREATE INDEX CONCURRENTLY IF NOT EXISTS "ImplementationProject_organizationId_status_idx"
ON "ImplementationProject" ("organizationId", "status");

CREATE INDEX CONCURRENTLY IF NOT EXISTS "TenantHealthScore_organizationId_calculatedAt_idx"
ON "TenantHealthScore" ("organizationId", "calculatedAt" DESC);
```
  </action>
  <verify>npx prisma validate; npm run test passes</verify>
  <done>DataLoader pattern and database indexes for query optimization</done>
</task>

</tasks>

<verification>
1. `npm run test:e2e -- websocket.e2e-spec.ts` - WebSocket tests pass
2. `npm run test:e2e -- ai-gateway.e2e-spec.ts` - AI gateway tests pass
3. `npx prisma validate` - Schema is valid
4. `npm run test` - All unit tests pass
5. Verify N+1 resolved via query logging
</verification>

<success_criteria>
- WebSocket E2E tests cover connection, auth, rooms, token refresh
- AI gateway E2E tests verify context loading, skill execution, streaming
- Token refresh during WebSocket handled without disconnection
- JwtWsGuard emits refresh-needed before token expires
- DataLoader pattern eliminates N+1 queries in case list
- Database indexes added for common query patterns
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-internal-operations-portal/12-18-SUMMARY.md`
</output>
