---
phase: 25.1-case-detail-page-vision-revision
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/frontend/src/components/record-detail/PipelineStageBar.tsx
  - apps/frontend/src/hooks/usePipeline.ts
autonomous: true

must_haves:
  truths:
    - "Sticky pipeline stage bar shows 7 stages at top of center column"
    - "Current stage is visually highlighted with color fill"
    - "Clicking a stage opens a confirmation dialog with rationale field"
    - "In stage for N days chip displays below current stage"
    - "Hover on any stage shows tooltip with description, date entered, time spent"
  artifacts:
    - path: "apps/frontend/src/components/record-detail/PipelineStageBar.tsx"
      provides: "Sticky pipeline visualization with click-to-advance"
      contains: "PipelineStageBar"
    - path: "apps/frontend/src/hooks/usePipeline.ts"
      provides: "Pipeline stage management hook"
      contains: "usePipeline"
  key_links:
    - from: "apps/frontend/src/components/record-detail/PipelineStageBar.tsx"
      to: "apps/frontend/src/hooks/usePipeline.ts"
      via: "hook usage"
      pattern: "usePipeline"
---

<objective>
Build the PipelineStageBar component and usePipeline hook. The pipeline bar is position:sticky at the top of the center column, shows all 7 default stages, highlights the current stage, and supports click-to-advance with a confirmation dialog.

Purpose: The pipeline stage bar is the most prominent new element in the Case Detail Page. It provides at-a-glance lifecycle status and one-click stage advancement. Building it independently (no dependency on Plan 01) allows parallel Wave 1 execution.
Output: PipelineStageBar.tsx, usePipeline.ts hook.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/25.1-case-detail-page-vision-revision/25.1-RESEARCH.md

# Key reference

@.planning/hubspot-view-system-spec.md (Section 15.1 — Pipeline Stage Bar)
@apps/frontend/src/components/workflows/workflow-progress-indicator.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usePipeline hook</name>
  <files>apps/frontend/src/hooks/usePipeline.ts</files>
  <action>
Create `apps/frontend/src/hooks/usePipeline.ts`:

```typescript
"use client";

import { useState, useCallback, useMemo } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { apiClient } from "@/lib/api";
import type { PipelineStage } from "@/types/record-detail";

interface UsePipelineOptions {
  caseId: string;
  currentStage: string;
  stages: PipelineStage[];
  stageEnteredAt?: string; // ISO date when current stage was entered
  onStageChange?: (newStage: string) => void;
}

interface UsePipelineReturn {
  stages: PipelineStage[];
  currentStage: PipelineStage | undefined;
  currentStageIndex: number;
  daysInCurrentStage: number;
  canTransitionTo: (stageId: string) => boolean;
  requestTransition: (stageId: string, rationale?: string) => Promise<void>;
  isTransitioning: boolean;
}

export function usePipeline({
  caseId,
  currentStage,
  stages,
  stageEnteredAt,
  onStageChange,
}: UsePipelineOptions): UsePipelineReturn {
  const queryClient = useQueryClient();

  const currentStageObj = useMemo(
    () => stages.find((s) => s.id === currentStage),
    [stages, currentStage],
  );

  const currentStageIndex = useMemo(
    () => stages.findIndex((s) => s.id === currentStage),
    [stages, currentStage],
  );

  const daysInCurrentStage = useMemo(() => {
    if (!stageEnteredAt) return 0;
    const entered = new Date(stageEnteredAt);
    const now = new Date();
    return Math.floor(
      (now.getTime() - entered.getTime()) / (1000 * 60 * 60 * 24),
    );
  }, [stageEnteredAt]);

  const canTransitionTo = useCallback(
    (stageId: string): boolean => {
      if (!currentStageObj) return false;
      return currentStageObj.allowedTransitions.includes(stageId);
    },
    [currentStageObj],
  );

  const transitionMutation = useMutation({
    mutationFn: async ({
      stageId,
      rationale,
    }: {
      stageId: string;
      rationale?: string;
    }) => {
      // Use the existing case pipeline moveToStage endpoint
      await apiClient.patch(`/cases/${caseId}`, {
        pipelineStage: stageId,
        statusRationale: rationale,
      });
    },
    onSuccess: (_, { stageId }) => {
      // Invalidate case queries to refresh data
      queryClient.invalidateQueries({ queryKey: ["case", caseId] });
      queryClient.invalidateQueries({ queryKey: ["cases"] });
      onStageChange?.(stageId);
    },
  });

  const requestTransition = useCallback(
    async (stageId: string, rationale?: string) => {
      await transitionMutation.mutateAsync({ stageId, rationale });
    },
    [transitionMutation],
  );

  return {
    stages,
    currentStage: currentStageObj,
    currentStageIndex,
    daysInCurrentStage,
    canTransitionTo,
    requestTransition,
    isTransitioning: transitionMutation.isPending,
  };
}
```

Import PipelineStage type from `@/types/record-detail`. If that file does not exist yet (Plan 01 runs in parallel), define the PipelineStage interface locally and add a comment: `// TODO: import from @/types/record-detail once Plan 01 completes`.
</action>
<verify> - Hook exports `usePipeline` with correct return type - `canTransitionTo` checks `allowedTransitions` array - `daysInCurrentStage` computes correctly from stageEnteredAt - TypeScript compiles without errors
</verify>
<done>usePipeline hook provides stage management, days-in-stage calculation, and transition mutation</done>
</task>

<task type="auto">
  <name>Task 2: Create PipelineStageBar component</name>
  <files>apps/frontend/src/components/record-detail/PipelineStageBar.tsx</files>
  <action>
Create `apps/frontend/src/components/record-detail/PipelineStageBar.tsx`:

This component renders a horizontal pipeline bar with stages as circles connected by lines. Design matches spec Section 15.1:

1. **Layout**: Horizontal bar with stage circles connected by lines. Position: sticky, top: 0, z-10, white background, border-bottom.

2. **Stage circles**: Each stage is a circle with:
   - Completed stages (order < current): filled with stage color, checkmark icon
   - Current stage: filled with stage color, pulsing ring animation
   - Future stages: outlined/empty (gray border)
   - Circle size: ~28-32px

3. **Stage labels**: Below each circle, the stage name. Current stage label is bold.

4. **Connecting lines**: Horizontal lines between circles. Completed = colored, future = gray.

5. **"In stage for N days" chip**: Below the current stage label, a small pill/badge showing days in stage.

6. **Click handler**: Click any stage to initiate transition.
   - If `canTransitionTo(stageId)` returns true, show confirmation dialog
   - If false, show toast explaining transition is not available from current stage
   - Confirmation dialog (use shadcn AlertDialog): title = "Move to {StageName}?", description = "This will advance the case from {CurrentStage} to {NewStage}.", optional textarea for rationale, Cancel + Confirm buttons.

7. **Hover tooltip**: On any stage circle, show a Tooltip (shadcn) with:
   - Stage name and description
   - "Entered: {date}" if completed or current
   - "Time in stage: N days" if completed or current

Props interface:

```typescript
interface PipelineStageBarProps {
  stages: PipelineStage[];
  currentStageId: string;
  stageEnteredAt?: string;
  stageHistory?: Array<{
    stageId: string;
    enteredAt: string;
    exitedAt?: string;
  }>;
  onStageTransition: (stageId: string, rationale?: string) => Promise<void>;
  canTransitionTo: (stageId: string) => boolean;
  isTransitioning?: boolean;
  daysInCurrentStage?: number;
}
```

Use shadcn components: Tooltip, TooltipTrigger, TooltipContent, TooltipProvider, AlertDialog, AlertDialogTrigger, AlertDialogContent, AlertDialogHeader, AlertDialogTitle, AlertDialogDescription, AlertDialogFooter, AlertDialogCancel, AlertDialogAction, Textarea.

Use lucide-react icons: Check, Loader2.

Use cn() from @/lib/utils for conditional className merging.

The component should be self-contained and reusable for any record type with pipeline stages.
</action>
<verify> - PipelineStageBar renders 7 default stages when given DEFAULT_CASE_PIPELINE - Current stage is visually distinct (filled, pulsing) - Completed stages show checkmark - Future stages are outlined/gray - "In stage for N days" chip visible below current stage - Clicking a valid transition stage opens confirmation dialog - Confirmation dialog has rationale textarea - Hover tooltip shows stage info - Component is position:sticky with white background - TypeScript compiles
</verify>
<done>PipelineStageBar renders all stages with visual states, click-to-advance confirmation, hover tooltips, and sticky positioning</done>
</task>

</tasks>

<verification>
1. PipelineStageBar renders correctly with 7 stages
2. Visual distinction between completed, current, and future stages
3. Click-to-advance opens AlertDialog with rationale field
4. "In stage for N days" chip displays correctly
5. Hover tooltips show stage information
6. usePipeline hook manages state and API calls
7. `npm run typecheck` passes
</verification>

<success_criteria>

- PipelineStageBar is a standalone, reusable component accepting stages as props
- No hardcoded stage names — always renders from data
- Click-to-advance with confirmation works end-to-end
- Days-in-stage calculation is accurate
- Component is position:sticky for center column usage
  </success_criteria>

<output>
After completion, create `.planning/phases/25.1-case-detail-page-vision-revision/25.1-02-SUMMARY.md`
</output>
