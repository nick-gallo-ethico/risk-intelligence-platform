---
phase: 25.1-case-detail-page-vision-revision
plan: 10
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/src/modules/cases/cases.controller.ts
  - apps/backend/src/modules/cases/pipeline.controller.ts
  - apps/backend/src/modules/cases/pipeline.service.ts
  - apps/backend/src/modules/cases/dto/pipeline.dto.ts
  - apps/backend/src/modules/cases/cases.module.ts
  - apps/frontend/src/lib/api/pipeline.ts
  - apps/frontend/src/hooks/usePipeline.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/pipelines returns tenant pipeline configuration with stages"
    - "PUT /api/cases/:id/activities/:activityId/pin toggles pin status on activity"
    - "GET /api/cases/:id returns statusHistory array for Status History Timeline"
    - "Pipeline stages from API are used by PipelineStageBar instead of hardcoded defaults"
  artifacts:
    - path: "apps/backend/src/modules/cases/pipeline.controller.ts"
      provides: "REST endpoints for tenant pipeline configuration"
      contains: "PipelineController"
    - path: "apps/backend/src/modules/cases/pipeline.service.ts"
      provides: "Pipeline CRUD service with tenant scoping"
      contains: "PipelineService"
    - path: "apps/frontend/src/lib/api/pipeline.ts"
      provides: "Frontend API client for pipeline endpoints"
      contains: "fetchPipelines"
  key_links:
    - from: "apps/frontend/src/hooks/usePipeline.ts"
      to: "apps/frontend/src/lib/api/pipeline.ts"
      via: "API client usage"
      pattern: "fetchPipelines"
    - from: "apps/backend/src/modules/cases/pipeline.controller.ts"
      to: "apps/backend/src/modules/cases/pipeline.service.ts"
      via: "service injection"
      pattern: "PipelineService"
---

<objective>
Wire backend API endpoints needed by the new frontend components: pipeline configuration endpoint, activity pinning endpoint, and status history on case GET. Connect the frontend usePipeline hook to the real API.

Purpose: This plan creates the backend endpoints needed by the frontend components (Plans 01-09). It runs in parallel as Wave 1 since the backend has no dependency on frontend plans. The frontend hooks (usePipeline from Plan 02, useActivities from Plan 06) will be refactored to consume these endpoints once both are complete. Pipeline stages become tenant-configurable, activity pinning persists to the database, and status history renders real transitions.
Output: PipelineController, PipelineService, activity pin endpoint, status history in case response, frontend API client.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/25.1-case-detail-page-vision-revision/25.1-RESEARCH.md

# Key source files

@apps/backend/src/modules/cases/cases.controller.ts
@apps/backend/src/modules/cases/cases.service.ts
@apps/backend/src/modules/cases/cases.module.ts
@apps/backend/prisma/schema.prisma
@apps/frontend/src/hooks/usePipeline.ts
@apps/frontend/src/lib/api/cases.ts
@.planning/hubspot-view-system-spec.md (Sections 19.1, 20)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pipeline Configuration API</name>
  <files>
    apps/backend/src/modules/cases/pipeline.controller.ts
    apps/backend/src/modules/cases/pipeline.service.ts
    apps/backend/src/modules/cases/dto/pipeline.dto.ts
    apps/backend/src/modules/cases/cases.module.ts
  </files>
  <action>
1. **Check if PipelineConfig model exists in Prisma schema:**

Look at `apps/backend/prisma/schema.prisma` for a PipelineConfig or Pipeline model. If it exists from Phase 1 (Workflow Engine), use it. If not, create a lightweight service that returns default stages and stores custom configurations in a JSON column or dedicated table.

**Option A: If PipelineConfig Prisma model exists:**

- Create PipelineService that wraps Prisma CRUD
- Tenant-scoped queries (always filter by tenantId from request context)

**Option B: If no Prisma model exists:**

- Create PipelineService that returns DEFAULT_CASE_PIPELINE from a constant
- Add a `pipeline_configs` JSON field on the Tenant model OR use the existing WorkflowDefinition model
- For MVP: return defaults, log a TODO for full tenant-configurable persistence

2. **Create DTOs** at `apps/backend/src/modules/cases/dto/pipeline.dto.ts`:

```typescript
export class PipelineStageDto {
  id: string;
  name: string;
  order: number;
  color: string;
  isClosed: boolean;
  allowedTransitions: string[];
  description?: string;
}

export class PipelineConfigDto {
  id: string;
  moduleType: string;
  name: string;
  stages: PipelineStageDto[];
  isDefault: boolean;
}

export class UpdatePipelineDto {
  name?: string;
  stages?: PipelineStageDto[];
}
```

3. **Create PipelineController** at `apps/backend/src/modules/cases/pipeline.controller.ts`:

```typescript
@Controller("pipelines")
@UseGuards(AuthGuard, TenantGuard)
export class PipelineController {
  constructor(private pipelineService: PipelineService) {}

  @Get()
  async listPipelines(@Req() req: AuthenticatedRequest) {
    // Returns all pipeline configs for this tenant
    // For now, returns default case pipeline
    return this.pipelineService.findAll(req.tenantId);
  }

  @Get(":id")
  async getPipeline(@Param("id") id: string, @Req() req: AuthenticatedRequest) {
    return this.pipelineService.findOne(id, req.tenantId);
  }

  @Put(":id")
  @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER)
  @UseGuards(RolesGuard)
  async updatePipeline(
    @Param("id") id: string,
    @Body() dto: UpdatePipelineDto,
    @Req() req: AuthenticatedRequest,
  ) {
    return this.pipelineService.update(id, dto, req.tenantId);
  }
}
```

4. **Register in CasesModule:**
   - Add PipelineController to controllers array
   - Add PipelineService to providers array
   - Ensure proper imports

5. **Verify backend Activity/AuditLog model supports all 8 activity types:**
   Check the Activity model in `apps/backend/prisma/schema.prisma` (or equivalent audit log model). The frontend (Plan 06) requires 8+ activity types: `note`, `email`, `call`, `task`, `interview`, `document_upload`, `status_change`, `assignment_change`, `system_event`. If the model uses an enum for action types, verify all 8 are present. If any are missing, add them to the enum/model and create a migration. If the model uses a freeform string field, no changes needed — just confirm by examining the schema.

6. **PipelineService implementation:**

```typescript
@Injectable()
export class PipelineService {
  constructor(private prisma: PrismaService) {}

  // Default pipeline stages (same as frontend constant)
  private readonly DEFAULT_STAGES = [
    {
      id: "new",
      name: "New",
      order: 0,
      color: "#6B7280",
      isClosed: false,
      allowedTransitions: ["assigned"],
    },
    {
      id: "assigned",
      name: "Assigned",
      order: 1,
      color: "#3B82F6",
      isClosed: false,
      allowedTransitions: ["active", "new"],
    },
    {
      id: "active",
      name: "Active",
      order: 2,
      color: "#8B5CF6",
      isClosed: false,
      allowedTransitions: ["review", "assigned"],
    },
    {
      id: "review",
      name: "Review",
      order: 3,
      color: "#F59E0B",
      isClosed: false,
      allowedTransitions: ["active", "closed"],
    },
    {
      id: "closed",
      name: "Closed",
      order: 4,
      color: "#10B981",
      isClosed: true,
      allowedTransitions: ["remediation", "active"],
    },
    {
      id: "remediation",
      name: "Remediation",
      order: 5,
      color: "#EF4444",
      isClosed: false,
      allowedTransitions: ["archived", "closed"],
    },
    {
      id: "archived",
      name: "Archived",
      order: 6,
      color: "#9CA3AF",
      isClosed: true,
      allowedTransitions: [],
    },
  ];

  async findAll(tenantId: string): Promise<PipelineConfigDto[]> {
    // Check if tenant has custom pipeline config
    // If exists, return from DB
    // If not, return default
    return [
      {
        id: "default-case-pipeline",
        moduleType: "cases",
        name: "Default Case Pipeline",
        stages: this.DEFAULT_STAGES,
        isDefault: true,
      },
    ];
  }

  async findOne(id: string, tenantId: string): Promise<PipelineConfigDto> {
    // Lookup or return default
  }

  async update(
    id: string,
    dto: UpdatePipelineDto,
    tenantId: string,
  ): Promise<PipelineConfigDto> {
    // Persist custom stages for tenant
    // Validate: stages must have unique IDs, valid transitions
  }
}
```

  </action>
  <verify>
    - GET /api/pipelines returns at least one pipeline config with 7 stages
    - Pipeline stages match spec default (New, Assigned, Active, Review, Closed, Remediation, Archived)
    - PUT /api/pipelines/:id updates pipeline (admin only)
    - Non-admin users get 403 on PUT
    - Pipeline responses are tenant-scoped
    - Activity/AuditLog model supports all 8 activity types required by Plan 06 (note, email, call, task, interview, document_upload, status_change, assignment_change, system_event)
    - TypeScript compiles: `cd apps/backend && npx tsc --noEmit`
  </verify>
  <done>Pipeline configuration API serving default stages with tenant-scoped CRUD, activity types verified/added</done>
</task>

<task type="auto">
  <name>Task 2: Add activity pinning endpoint and wire frontend</name>
  <files>
    apps/backend/src/modules/cases/cases.controller.ts
    apps/frontend/src/lib/api/pipeline.ts
    apps/frontend/src/hooks/usePipeline.ts
  </files>
  <action>
1. **Add activity pin endpoint** to cases.controller.ts:

Check if `/api/cases/:id/activities/:activityId/pin` already exists. If not, add:

```typescript
@Put(':id/activities/:activityId/pin')
@UseGuards(AuthGuard, TenantGuard)
async pinActivity(
  @Param('id') caseId: string,
  @Param('activityId') activityId: string,
  @Body() body: { isPinned: boolean },
  @Req() req: AuthenticatedRequest,
) {
  return this.casesService.pinActivity(caseId, activityId, body.isPinned, req.tenantId);
}
```

In CasesService (or ActivityService if it exists separately):

```typescript
async pinActivity(caseId: string, activityId: string, isPinned: boolean, tenantId: string) {
  // Verify activity belongs to case and tenant
  // Update activity.isPinned
  // If Activity model doesn't have isPinned field, check if it can be added to metadata JSON
  // Return updated activity
}
```

If the Activity model doesn't have an `isPinned` boolean column:

- Check if the model has a `metadata` JSON field — store `isPinned` there
- OR add `isPinned` to the Prisma model and run a migration (preferred if feasible)
- OR use localStorage fallback documented in Plan 06 (acceptable for MVP)

2. **Enhance case GET to include statusHistory:**

In the GET /api/cases/:id response, add a `statusHistory` array computed from activities:

```typescript
// In cases.service.ts findOne method:
const statusHistory = await this.prisma.activity.findMany({
  where: {
    entityId: caseId,
    entityType: "case",
    action: { in: ["status_changed", "stage_changed", "STATUS_CHANGE"] },
    tenantId,
  },
  orderBy: { createdAt: "desc" },
  select: {
    id: true,
    metadata: true, // Contains oldStatus, newStatus
    createdAt: true,
    createdBy: true, // Or actorId
  },
});

// Map to StatusChange format:
const statusChanges = statusHistory.map((a) => ({
  status: a.metadata?.newStatus || a.metadata?.status,
  date: a.createdAt.toISOString(),
  changedBy: a.createdBy, // Resolve to user name
  rationale: a.metadata?.rationale || a.metadata?.reason,
}));
```

Add `statusHistory` to the case response object. If already included, ensure format matches what StatusHistoryTimeline expects.

3. **Create frontend pipeline API client** at `apps/frontend/src/lib/api/pipeline.ts`:

```typescript
import { apiClient } from "./client";
import type { PipelineConfig } from "@/types/record-detail";

export async function fetchPipelines(): Promise<PipelineConfig[]> {
  const response = await apiClient.get("/pipelines");
  return response.data;
}

export async function fetchPipelineById(id: string): Promise<PipelineConfig> {
  const response = await apiClient.get(`/pipelines/${id}`);
  return response.data;
}

export async function updatePipeline(
  id: string,
  data: Partial<PipelineConfig>,
): Promise<PipelineConfig> {
  const response = await apiClient.put(`/pipelines/${id}`, data);
  return response.data;
}

export async function pinActivity(
  caseId: string,
  activityId: string,
  isPinned: boolean,
): Promise<void> {
  await apiClient.put(`/cases/${caseId}/activities/${activityId}/pin`, {
    isPinned,
  });
}
```

4. **Refactor usePipeline hook from Plan 02 to fetch from API, keeping DEFAULT_CASE_PIPELINE as fallback:**

Update `apps/frontend/src/hooks/usePipeline.ts` (created by Plan 02 with hardcoded DEFAULT_CASE_PIPELINE stages):

- Add React Query fetch: `useQuery(['pipelines'], fetchPipelines)` to load tenant pipeline config from API
- Use API stages when available, fall back to `DEFAULT_CASE_PIPELINE` constant from Plan 02 if API fails or returns empty
- The `handleStageTransition` mutation should call PATCH /cases/:id with the new pipeline stage
- Add `isLoading` / `isPipelineLoading` state while pipeline config loads
- Preserve the existing hook interface (UsePipelineOptions/UsePipelineReturn) so PipelineStageBar consumers do not break

```typescript
export function usePipeline(caseId: string, currentStageId: string) {
  const { data: pipelines, isLoading: isPipelineLoading } = useQuery(
    ["pipelines"],
    fetchPipelines,
    { staleTime: 5 * 60 * 1000 }, // Cache for 5 minutes
  );

  const pipelineConfig = pipelines?.[0] || {
    stages: DEFAULT_CASE_PIPELINE,
  };

  // ... rest of hook logic using pipelineConfig.stages
}
```

5. **Wire useActivities hook to real pin API:**

If useActivities (Plan 06) uses localStorage for pinning, update it to call the backend pin endpoint when available, falling back to localStorage if the endpoint returns 404.
</action>
<verify> - PUT /api/cases/:id/activities/:activityId/pin returns 200 and persists pin state - GET /api/cases/:id response includes statusHistory array - Frontend PipelineStageBar renders stages from API (not just hardcoded) - If API is unavailable, PipelineStageBar falls back to default stages - Activity pinning persists across page reloads (not just localStorage) - `npm run typecheck` passes (both frontend and backend)
</verify>
<done>Pipeline API connected to frontend, activity pinning wired to backend, status history served from case response</done>
</task>

</tasks>

<verification>
1. GET /api/pipelines returns 7-stage default pipeline
2. PUT /api/pipelines/:id allows admin to customize stages
3. PUT /api/cases/:id/activities/:activityId/pin toggles pin state
4. GET /api/cases/:id includes statusHistory array
5. PipelineStageBar renders from API data (or defaults on error)
6. Activity pinning persists to database (not just localStorage)
7. Frontend usePipeline hook uses React Query with API fallback
8. `npm run typecheck` passes (both apps)
9. Backend tests pass: `cd apps/backend && npm test`
</verification>

<success_criteria>

- Pipeline stages are served from API (tenant-configurable)
- Activity pinning persists server-side
- Status history timeline has real data
- Frontend gracefully degrades if API unavailable
  </success_criteria>

<output>
After completion, create `.planning/phases/25.1-case-detail-page-vision-revision/25.1-10-SUMMARY.md`
</output>
