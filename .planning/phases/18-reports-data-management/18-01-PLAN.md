---
phase: 18-reports-data-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/analytics/reports/report-field-registry.service.ts
  - apps/backend/src/modules/analytics/reports/dto/report.dto.ts
  - apps/backend/src/modules/analytics/reports/entities/saved-report.entity.ts
autonomous: true

must_haves:
  truths:
    - "All entity fields (case, RIU, person, campaign, disclosure, investigation) are discoverable as report dimensions"
    - "Custom properties per tenant are included in field registry"
    - "Field metadata includes label, type, group, filterable, sortable, aggregatable flags"
    - "Users can save report configurations and retrieve them later"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "SavedReport model with all report configuration fields"
      contains: "model SavedReport"
    - path: "apps/backend/src/modules/analytics/reports/report-field-registry.service.ts"
      provides: "Dynamic field discovery from Prisma schema + custom properties"
      exports: ["ReportFieldRegistryService"]
    - path: "apps/backend/src/modules/analytics/reports/dto/report.dto.ts"
      provides: "DTOs for report CRUD, field metadata, report config"
      exports: ["CreateReportDto", "UpdateReportDto", "ReportFieldDto"]
    - path: "apps/backend/src/modules/analytics/reports/entities/saved-report.entity.ts"
      provides: "SavedReport entity type and enums"
      exports: ["ReportVisualizationType", "ReportVisibility"]
  key_links:
    - from: "report-field-registry.service.ts"
      to: "prisma"
      via: "CustomPropertyDefinition lookup for tenant custom fields"
      pattern: "customPropertyDefinition\\.findMany"
    - from: "report-field-registry.service.ts"
      to: "query-to-prisma.service.ts"
      via: "Extends ALLOWED_FIELDS pattern with dynamic field discovery"
      pattern: "FieldDefinition|EntityFieldWhitelist"
---

<objective>
Create the SavedReport Prisma model and ReportFieldRegistryService that exposes ALL entity fields (including tenant-specific custom properties) as reportable dimensions.

Purpose: This is the data foundation for the entire report designer. Without a field registry, users cannot discover what fields are available. Without the SavedReport model, reports cannot be persisted.

Output: SavedReport Prisma model, ReportFieldRegistryService with per-entity-type field catalogs, report DTOs.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-reports-data-management/18-RESEARCH.md
@apps/backend/prisma/schema.prisma
@apps/backend/src/modules/analytics/ai-query/query-to-prisma.service.ts
@apps/backend/src/modules/analytics/ai-query/dto/ai-query.dto.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: SavedReport Prisma model and migration</name>
  <files>
    apps/backend/prisma/schema.prisma
    apps/backend/src/modules/analytics/reports/entities/saved-report.entity.ts
    apps/backend/src/modules/analytics/reports/dto/report.dto.ts
  </files>
  <action>
Add SavedReport model to schema.prisma following the existing pattern (organizationId, RLS, timestamps):

```prisma
model SavedReport {
  id              String   @id @default(uuid())
  organizationId  String   @map("organization_id")
  name            String
  description     String?
  entityType      String   @map("entity_type")      // cases, rius, persons, campaigns, policies, disclosures, investigations
  columns         Json                                // Array of field IDs to display
  filters         Json     @default("[]")             // Filter conditions (same format as AdvancedFiltersPanel)
  groupBy         Json?    @map("group_by")           // Aggregation grouping fields
  aggregation     Json?                               // SUM, COUNT, AVG config
  visualization   String   @default("table")          // table, bar, line, pie, kpi, funnel, stacked_bar
  chartConfig     Json?    @map("chart_config")       // Colors, labels, formatting options
  sortBy          String?  @map("sort_by")
  sortOrder       String?  @map("sort_order")         // asc, desc
  isTemplate      Boolean  @default(false) @map("is_template")
  templateCategory String? @map("template_category")  // compliance, operations, executive
  visibility      String   @default("PRIVATE")        // PRIVATE, TEAM, EVERYONE
  lastRunAt       DateTime? @map("last_run_at")
  lastRunDuration Int?     @map("last_run_duration")  // milliseconds
  lastRunRowCount Int?     @map("last_run_row_count")
  isFavorite      Boolean  @default(false) @map("is_favorite")
  scheduledExportId String? @map("scheduled_export_id")
  createdById     String   @map("created_by_id")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  organization    Organization @relation(fields: [organizationId], references: [id])
  createdBy       User         @relation("ReportCreatedBy", fields: [createdById], references: [id])
  scheduledExport ScheduledExport? @relation(fields: [scheduledExportId], references: [id])

  @@index([organizationId])
  @@index([organizationId, createdById])
  @@index([organizationId, isTemplate])
  @@index([organizationId, visibility])
  @@map("saved_reports")
}
```

Add the relation fields to Organization, User, and ScheduledExport models:

- Organization: `savedReports SavedReport[]`
- User: `createdReports SavedReport[] @relation("ReportCreatedBy")`
- ScheduledExport: `savedReport SavedReport?` (optional one-to-one back-reference)

Create entities/saved-report.entity.ts with enums:

```typescript
export const ReportVisualizationType = {
  TABLE: "table",
  BAR: "bar",
  LINE: "line",
  PIE: "pie",
  KPI: "kpi",
  FUNNEL: "funnel",
  STACKED_BAR: "stacked_bar",
} as const;

export const ReportVisibility = {
  PRIVATE: "PRIVATE",
  TEAM: "TEAM",
  EVERYONE: "EVERYONE",
} as const;

export const ReportEntityType = {
  CASES: "cases",
  RIUS: "rius",
  PERSONS: "persons",
  CAMPAIGNS: "campaigns",
  POLICIES: "policies",
  DISCLOSURES: "disclosures",
  INVESTIGATIONS: "investigations",
} as const;
```

Create dto/report.dto.ts with:

- CreateReportDto (name, entityType, columns, filters, groupBy, aggregation, visualization, chartConfig, sortBy, sortOrder, visibility, isTemplate, templateCategory)
- UpdateReportDto (all fields optional)
- ReportFieldDto (id, label, type, group, filterable, sortable, groupable, aggregatable, enumValues?)
- ReportFieldGroupDto (groupName, fields: ReportFieldDto[])
- RunReportDto (overrideFilters?, dateRange?, limit?, offset?)

Use class-validator decorators on DTOs. Use IsString, IsOptional, IsEnum, IsArray, IsBoolean, IsObject, ValidateNested, MaxLength.

Run `npx prisma generate` after schema changes (do NOT run migrate -- just generate the client).
</action>
<verify>
`cd apps/backend && npx prisma generate` completes without errors.
`cd apps/backend && npx tsc --noEmit --pretty` compiles without type errors in the new files.
</verify>
<done>SavedReport model exists in schema.prisma with all fields, relations, and indexes. Entity types and DTOs exported for use by service and controller.</done>
</task>

<task type="auto">
  <name>Task 2: ReportFieldRegistryService with dynamic field discovery</name>
  <files>
    apps/backend/src/modules/analytics/reports/report-field-registry.service.ts
  </files>
  <action>
Create ReportFieldRegistryService that provides comprehensive field catalogs for all entity types. This service extends the ALLOWED_FIELDS concept from QueryToPrismaService but adds:
- Human-readable labels and grouping
- Custom property inclusion per tenant
- Relationship traversal (e.g., case.category.name, case.assignee.email)

Inject PrismaService for custom property lookup.

Define field registries as static data structures (not from Prisma introspection -- Prisma client doesn't expose schema metadata at runtime). Use a comprehensive hardcoded registry that covers ALL fields from each Prisma model, grouped logically:

For CASES entity type, groups should include:

- "Case Details": id, referenceNumber, title, description, status, outcome, pipelineStage, severity, createdAt, updatedAt, outcomeAt, closedAt
- "Classification": categoryId, categoryName (joined), subcategoryId, subcategoryName
- "Assignment": assigneeId, assigneeName (joined), createdById, createdByName
- "Location": locationId, locationName, locationCity, locationState, locationCountry, businessUnitId, businessUnitName
- "Metrics": daysOpen (computed), slaStatus, slaDueAt, riuCount (aggregated)
- "Custom Properties": dynamically loaded from CustomPropertyDefinition where entityType = 'CASE'

For RIUS: "RIU Details", "Source", "Classification", "Reporter", "QA", "Location", "Custom Properties"
For PERSONS: "Person Details", "Employment", "Organization", "Contact", "History" (computed counts), "Custom Properties"
For CAMPAIGNS: "Campaign Details", "Schedule", "Audience", "Progress" (computed stats)
For POLICIES: "Policy Details", "Version", "Approval", "Compliance"
For DISCLOSURES: "Disclosure Details", "Review", "Risk", "Submitter"
For INVESTIGATIONS: "Investigation Details", "Assignment", "Outcome", "Timeline"

Each field entry should have: { id, label, type, group, prismaField, filterable, sortable, groupable, aggregatable, enumValues?, isComputed?, isCustomProperty?, joinPath? }

The `getFieldsForEntityType(entityType, organizationId)` method:

1. Gets the static fields for the entity type
2. Queries CustomPropertyDefinition for the org's custom properties matching that entity type
3. Maps custom properties to ReportFieldDto format (with isCustomProperty: true)
4. Returns combined array grouped by group name

Also provide `getFieldGroups(entityType, organizationId)` that returns fields organized into ReportFieldGroupDto arrays.

Keep field count reasonable per entity (30-50 fields including relations, not 200+). Focus on fields users actually want in compliance reports.

Do NOT import from QueryToPrismaService -- this is a separate, richer registry. The QueryToPrismaService whitelist is for AI safety; this registry is for the UI field picker.
</action>
<verify>
`cd apps/backend && npx tsc --noEmit --pretty` compiles without type errors.
The service exports getFieldsForEntityType and getFieldGroups methods.
</verify>
<done>ReportFieldRegistryService returns comprehensive field catalogs for all 7 entity types, including tenant-specific custom properties loaded from the database.</done>
</task>

</tasks>

<verification>
- SavedReport model in schema.prisma with organizationId, all config fields, proper indexes
- Prisma client generates without errors
- ReportFieldRegistryService covers all 7 entity types with 30-50 fields each
- Custom properties are dynamically loaded per organization
- DTOs have proper class-validator decorators
- No import errors or type errors
</verification>

<success_criteria>

1. SavedReport Prisma model exists with all fields from RESEARCH.md spec
2. ReportFieldRegistryService.getFieldsForEntityType('cases', orgId) returns 30+ fields grouped logically
3. Custom properties are included in field registry output
4. All DTOs have proper validation decorators
5. TypeScript compiles without errors
   </success_criteria>

<output>
After completion, create `.planning/phases/18-reports-data-management/18-01-SUMMARY.md`
</output>
