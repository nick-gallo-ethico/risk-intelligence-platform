---
phase: 18-reports-data-management
plan: 03
type: execute
wave: 2
depends_on: ["18-01", "18-02"]
files_modified:
  - apps/backend/src/modules/analytics/reports/report.controller.ts
  - apps/backend/src/modules/analytics/reports/report.module.ts
  - apps/backend/src/modules/analytics/analytics.module.ts
autonomous: true

must_haves:
  truths:
    - "REST API endpoints exist for all report operations"
    - "Field registry endpoint returns fields grouped by entity type"
    - "Report CRUD endpoints enforce authentication and role-based access"
    - "Report run endpoint returns data shaped for visualization"
  artifacts:
    - path: "apps/backend/src/modules/analytics/reports/report.controller.ts"
      provides: "REST endpoints for reports CRUD, execution, fields, AI generation"
      exports: ["ReportController"]
    - path: "apps/backend/src/modules/analytics/reports/report.module.ts"
      provides: "NestJS module wiring for report services"
      exports: ["ReportModule"]
  key_links:
    - from: "report.controller.ts"
      to: "report.service.ts"
      via: "Service injection for CRUD operations"
      pattern: "reportService\\."
    - from: "report.controller.ts"
      to: "report-field-registry.service.ts"
      via: "Field registry injection for field discovery"
      pattern: "fieldRegistryService\\."
    - from: "report.module.ts"
      to: "analytics.module.ts"
      via: "Module import in AnalyticsModule"
      pattern: "ReportModule"
---

<objective>
Create the ReportController (REST API) and ReportModule (NestJS wiring) for the report system.

Purpose: Exposes the report services via REST endpoints that the frontend report designer will consume. This is the API layer between the React UI and the backend report engine.

Output: Complete REST API at /api/v1/reports/\* with field discovery, CRUD, execution, export, and AI generation endpoints.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/18-reports-data-management/18-RESEARCH.md
@apps/backend/src/modules/analytics/exports/exports.controller.ts
@apps/backend/src/modules/analytics/ai-query/ai-query.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: ReportController with all REST endpoints</name>
  <files>
    apps/backend/src/modules/analytics/reports/report.controller.ts
  </files>
  <action>
Create ReportController at route '/api/v1/reports'. Use JwtAuthGuard and RolesGuard. Follow the ExportsController pattern for structure.

Inject: ReportService, ReportFieldRegistryService, AiQueryService (from existing ai-query module).

Endpoints:

1. `GET /api/v1/reports/fields/:entityType` - Get available fields for an entity type.
   - Roles: Any authenticated user
   - Params: entityType (string: cases, rius, persons, etc.)
   - Returns: ReportFieldGroupDto[] (fields grouped by group name)
   - Calls: fieldRegistryService.getFieldGroups(entityType, user.organizationId)

2. `GET /api/v1/reports/templates` - List pre-built report templates.
   - Roles: Any authenticated user
   - Returns: SavedReport[] where isTemplate = true
   - Calls: reportService.getTemplates(user.organizationId)

3. `GET /api/v1/reports` - List saved reports.
   - Roles: Any authenticated user
   - Query params: visibility?, isTemplate?, search?, page?, pageSize?
   - Returns: { data: SavedReport[], total: number }
   - Calls: reportService.findAll(user.organizationId, user.id, query)

4. `POST /api/v1/reports` - Create a new report.
   - Roles: SYSTEM_ADMIN, COMPLIANCE_OFFICER, POLICY_AUTHOR
   - Body: CreateReportDto
   - Returns: 201 with SavedReport
   - Calls: reportService.create(user.organizationId, user.id, dto)

5. `GET /api/v1/reports/:id` - Get a single report config.
   - Roles: Any authenticated user
   - Returns: SavedReport (with createdBy relation)
   - Calls: reportService.findOne(user.organizationId, id)
   - Throw NotFoundException if not found

6. `PUT /api/v1/reports/:id` - Update a report.
   - Roles: SYSTEM_ADMIN, COMPLIANCE_OFFICER, POLICY_AUTHOR
   - Body: UpdateReportDto
   - Returns: SavedReport
   - Calls: reportService.update(user.organizationId, user.id, id, dto)

7. `DELETE /api/v1/reports/:id` - Delete a report.
   - Roles: SYSTEM_ADMIN, COMPLIANCE_OFFICER
   - Returns: 204 No Content
   - Calls: reportService.delete(user.organizationId, user.id, id)

8. `POST /api/v1/reports/:id/run` - Execute a saved report.
   - Roles: Any authenticated user
   - Body: RunReportDto (optional overrides)
   - Returns: ReportResult (columns, rows, groupedData, summary)
   - Calls: reportService.run(user.organizationId, id, dto)

9. `POST /api/v1/reports/:id/duplicate` - Duplicate a report.
   - Roles: SYSTEM_ADMIN, COMPLIANCE_OFFICER, POLICY_AUTHOR
   - Returns: 201 with new SavedReport
   - Calls: reportService.duplicate(user.organizationId, user.id, id)

10. `POST /api/v1/reports/:id/favorite` - Toggle favorite.
    - Roles: Any authenticated user
    - Returns: { isFavorite: boolean }
    - Calls: reportService.toggleFavorite(user.organizationId, user.id, id)

11. `POST /api/v1/reports/:id/export` - Export report results.
    - Roles: Any authenticated user
    - Body: { format: 'excel' | 'csv' | 'pdf' }
    - For Excel/CSV: Run the report, pass results to ExcelExportService, return download URL or 202 with job ID for large exports.
    - For PDF: Run the report, pass to BoardReportService for PDF generation.
    - Returns: { jobId?: string, downloadUrl?: string, status: string }
    - For simplicity in this plan: create an ExportJob record, queue the export, return 202 Accepted with jobId. The user polls GET /api/v1/exports/:id for status.

12. `POST /api/v1/reports/ai-generate` - Generate report from natural language.
    - Roles: SYSTEM_ADMIN, COMPLIANCE_OFFICER
    - Body: { query: string } (natural language question)
    - Calls: AiQueryService.executeQuery() to get parsed query and results
    - Converts the AI parsed query into a SavedReport config (entityType from parsedQuery.entityType, columns from parsedQuery.selectFields, filters from parsedQuery.filters, etc.)
    - Returns: { report: SavedReport (unsaved config), results: ReportResult, interpretation: string }
    - The frontend can then save this as a report if the user wants

Add Swagger decorators (@ApiTags, @ApiOperation, @ApiResponse, @ApiBearerAuth, @ApiParam, @ApiQuery) to all endpoints.
</action>
<verify>
`cd apps/backend && npx tsc --noEmit --pretty` compiles without type errors.
Controller exports all 12 endpoint methods.
</verify>
<done>ReportController provides complete REST API for report operations including field discovery, CRUD, execution, export, and AI generation.</done>
</task>

<task type="auto">
  <name>Task 2: ReportModule and AnalyticsModule integration</name>
  <files>
    apps/backend/src/modules/analytics/reports/report.module.ts
    apps/backend/src/modules/analytics/reports/index.ts
    apps/backend/src/modules/analytics/analytics.module.ts
  </files>
  <action>
Create ReportModule as a NestJS module:

```typescript
@Module({
  imports: [
    // BullMQ for export queue (reuse existing FLAT_EXPORT_QUEUE_NAME)
    BullModule.registerQueue({ name: FLAT_EXPORT_QUEUE_NAME }),
  ],
  controllers: [ReportController],
  providers: [
    ReportService,
    ReportExecutionService,
    ReportFieldRegistryService,
  ],
  exports: [ReportService, ReportFieldRegistryService],
})
export class ReportModule {}
```

Create index.ts barrel export for the reports module.

Update AnalyticsModule to import ReportModule. The AnalyticsModule currently imports DashboardModule, ExportsModule, MyWorkModule, MigrationModule. Add ReportModule to the imports array.

If AiQueryService needs to be injected into ReportController, either:

- Import the AI query module in ReportModule, OR
- Make AiQueryService available via the AnalyticsModule's existing wiring

Check how AiQueryService is currently provided (likely in AnalyticsModule or a sub-module) and ensure ReportController can inject it. If needed, add forwardRef or explicit module imports.

Also ensure PrismaModule and AuditModule are available (they should be @Global() from Phase 1).
</action>
<verify>
`cd apps/backend && npx tsc --noEmit --pretty` compiles without type errors.
`cd apps/backend && npx tsc --noEmit --pretty 2>&1 | findstr "error"` returns no errors.
</verify>
<done>ReportModule is wired into AnalyticsModule. All services are properly provided and exported. The /api/v1/reports/\* routes are registered.</done>
</task>

</tasks>

<verification>
- All 12 REST endpoints compile and have correct route decorators
- ReportModule is imported by AnalyticsModule
- AiQueryService is injectable in ReportController
- Swagger decorators on all endpoints
- TypeScript compiles without errors
</verification>

<success_criteria>

1. GET /api/v1/reports/fields/cases returns field groups
2. POST /api/v1/reports creates a SavedReport
3. POST /api/v1/reports/:id/run executes the report and returns results
4. POST /api/v1/reports/ai-generate converts natural language to report config
5. All endpoints have proper auth guards and role requirements
   </success_criteria>

<output>
After completion, create `.planning/phases/18-reports-data-management/18-03-SUMMARY.md`
</output>
