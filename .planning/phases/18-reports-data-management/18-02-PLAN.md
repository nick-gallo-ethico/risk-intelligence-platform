---
phase: 18-reports-data-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/src/modules/analytics/reports/report-execution.service.ts
  - apps/backend/src/modules/analytics/reports/report.service.ts
autonomous: true

must_haves:
  truths:
    - "Reports execute against the database with proper tenant isolation"
    - "Reports return data shaped for the selected visualization type"
    - "Complex reports with grouping and aggregation produce correct results"
    - "Reports can be saved, retrieved, updated, and deleted"
  artifacts:
    - path: "apps/backend/src/modules/analytics/reports/report-execution.service.ts"
      provides: "Report query execution with dynamic Prisma queries"
      exports: ["ReportExecutionService"]
    - path: "apps/backend/src/modules/analytics/reports/report.service.ts"
      provides: "SavedReport CRUD operations"
      exports: ["ReportService"]
  key_links:
    - from: "report-execution.service.ts"
      to: "prisma"
      via: "Dynamic delegate access (prisma as any)[model]"
      pattern: "prisma.*as any.*\\["
    - from: "report.service.ts"
      to: "prisma.savedReport"
      via: "Prisma CRUD for SavedReport model"
      pattern: "prisma\\.savedReport\\.(create|findMany|findFirst|update|delete)"
---

<objective>
Create the ReportExecutionService (runs reports against the database) and ReportService (CRUD for saved reports).

Purpose: These are the core backend services that power the report designer. The execution service translates report configuration into Prisma queries and returns formatted results. The CRUD service manages saved report lifecycle.

Output: ReportExecutionService that runs any saved report config, ReportService for CRUD.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/18-reports-data-management/18-RESEARCH.md
@apps/backend/src/modules/analytics/ai-query/query-to-prisma.service.ts
@apps/backend/src/modules/analytics/ai-query/dto/ai-query.dto.ts
@apps/backend/src/modules/analytics/exports/excel-export.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: ReportExecutionService for running reports</name>
  <files>
    apps/backend/src/modules/analytics/reports/report-execution.service.ts
  </files>
  <action>
Create ReportExecutionService that translates a saved report configuration into Prisma queries and returns data.

Inject PrismaService. Follow the existing pattern from QueryToPrismaService for dynamic model access: `(this.prisma as any)[modelName]`.

Key method: `async runReport(config: ReportConfig, organizationId: string): Promise<ReportResult>`

ReportConfig interface (internal, not DTO):

```typescript
interface ReportConfig {
  entityType: string;
  columns: string[]; // Field IDs to select
  filters: ReportFilter[]; // Filter conditions
  groupBy?: string[]; // Fields to group by
  aggregation?: ReportAggregation; // COUNT, SUM, AVG etc.
  sortBy?: string;
  sortOrder?: "asc" | "desc";
  limit?: number;
  offset?: number;
}
```

ReportResult interface:

```typescript
interface ReportResult {
  columns: Array<{ key: string; label: string; type: string }>;
  rows: Array<Record<string, unknown>>;
  totalCount: number;
  groupedData?: Array<{
    label: string;
    value: number;
    metadata?: Record<string, unknown>;
  }>;
  summary?: { totalRows: number; executionTimeMs: number };
}
```

Model name mapping (entityType to Prisma model):

- cases -> 'case'
- rius -> 'riskIntelligenceUnit'
- persons -> 'person'
- campaigns -> 'campaign'
- policies -> 'policy'
- disclosures -> 'disclosureSubmission'
- investigations -> 'investigation'

Implementation approach:

1. Map entity type to Prisma model name
2. Build `where` clause: always include `organizationId`, then map each filter to Prisma conditions. Support operators: eq, neq, gt, gte, lt, lte, contains, in, notIn, isNull, isNotNull, between. Follow the toPrismaCondition pattern from QueryToPrismaService.
3. Build `select` or `include` based on columns. For joined fields (e.g., category.name), use Prisma `include` with nested `select`.
4. Build `orderBy` from sortBy/sortOrder.
5. For groupBy queries: Use Prisma `groupBy` with `_count`, `_sum`, `_avg` as needed. Return as groupedData array.
6. For non-grouped queries: Use `findMany` with pagination (take/skip).
7. Get totalCount with `count` query (same where clause).

Handle relationship fields by detecting dot notation (e.g., 'assignee.firstName'). Map the first part to a Prisma include, the second to a select. Store a RELATIONSHIP_MAP:

```typescript
const RELATIONSHIP_MAP: Record<
  string,
  Record<string, { relation: string; field: string }>
> = {
  cases: {
    categoryName: { relation: "category", field: "name" },
    assigneeName: { relation: "assignee", field: "firstName" },
    businessUnitName: { relation: "businessUnit", field: "name" },
    locationName: { relation: "location", field: "name" },
    createdByName: { relation: "createdBy", field: "firstName" },
  },
  // ... similar for other entity types
};
```

For computed fields like 'daysOpen', compute them post-query: `Math.floor((Date.now() - createdAt.getTime()) / 86400000)`.

Add error handling: wrap Prisma queries in try-catch, return meaningful error messages. Log slow queries (>5s) as warnings.

Default limit: 1000 rows. Maximum limit: 10000 rows.
</action>
<verify>
`cd apps/backend && npx tsc --noEmit --pretty` compiles without type errors.
ReportExecutionService exports runReport method.
</verify>
<done>ReportExecutionService can execute any report configuration, returning formatted results with proper tenant isolation. Supports simple queries, grouped aggregations, relationship joins, and computed fields.</done>
</task>

<task type="auto">
  <name>Task 2: ReportService for SavedReport CRUD</name>
  <files>
    apps/backend/src/modules/analytics/reports/report.service.ts
  </files>
  <action>
Create ReportService for SavedReport CRUD operations.

Inject PrismaService, AuditService, ReportExecutionService.

Methods:

1. `create(orgId, userId, dto: CreateReportDto): Promise<SavedReport>` - Create and save a report. Validate entityType is one of the allowed values. Audit log: "Created report '{name}' for {entityType}".

2. `findAll(orgId, userId, query: { visibility?, isTemplate?, search?, page?, pageSize? }): Promise<{ data: SavedReport[], total: number }>` - List reports. Filter logic:
   - PRIVATE: only creator's reports
   - TEAM: reports from same organization where visibility is TEAM or EVERYONE
   - Templates: isTemplate = true (accessible to all in org)
   - Search: name CONTAINS or description CONTAINS (case insensitive)
   - Pagination: default page=1, pageSize=20
   - Include createdBy relation (select firstName, lastName)

3. `findOne(orgId, reportId): Promise<SavedReport | null>` - Get single report with createdBy.

4. `update(orgId, userId, reportId, dto: UpdateReportDto): Promise<SavedReport>` - Only creator or SYSTEM_ADMIN can update. Audit log update.

5. `delete(orgId, userId, reportId): Promise<void>` - Soft consideration: for now hard delete. Only creator or SYSTEM_ADMIN can delete. Audit log deletion.

6. `run(orgId, reportId, options?: RunReportDto): Promise<ReportResult>` - Load report config, merge with any override options, call ReportExecutionService.runReport(). Update lastRunAt, lastRunDuration, lastRunRowCount on the SavedReport record.

7. `duplicate(orgId, userId, reportId): Promise<SavedReport>` - Clone a report with name "{original} (Copy)", set visibility to PRIVATE, new creator.

8. `toggleFavorite(orgId, userId, reportId): Promise<{ isFavorite: boolean }>` - Toggle the isFavorite flag.

9. `getTemplates(orgId): Promise<SavedReport[]>` - Return all reports where isTemplate = true AND (organizationId = orgId OR isSystem template from seed data). For system templates, use a special check: isTemplate = true AND createdById is null (or a system user).

Use the existing AuditService pattern (try-catch around audit logging, never throw on audit failure). Use AuditEntityType.REPORT and appropriate AuditActionCategory values.

Follow existing NestJS service patterns: @Injectable(), Logger, constructor injection.
</action>
<verify>
`cd apps/backend && npx tsc --noEmit --pretty` compiles without type errors.
ReportService exports all CRUD methods.
</verify>
<done>ReportService provides full CRUD for saved reports including run, duplicate, favorite toggle, and template listing. All operations enforce tenant isolation via organizationId.</done>
</task>

</tasks>

<verification>
- ReportExecutionService.runReport() builds valid Prisma queries with organizationId filter
- ReportService.findAll() respects visibility rules (PRIVATE only to creator, TEAM/EVERYONE to org)
- Report run updates lastRunAt and lastRunDuration
- All methods enforce organizationId (tenant isolation)
- TypeScript compiles without errors
</verification>

<success_criteria>

1. ReportExecutionService runs queries for all 7 entity types with proper tenant isolation
2. ReportService CRUD works for create, read, update, delete, run, duplicate, favorite
3. Grouped aggregation queries return correct groupedData format
4. Relationship fields (categoryName, assigneeName) resolve via Prisma includes
5. TypeScript compiles without errors
   </success_criteria>

<output>
After completion, create `.planning/phases/18-reports-data-management/18-02-SUMMARY.md`
</output>
