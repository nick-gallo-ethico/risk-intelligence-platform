---
phase: 01-foundation-infrastructure
plan: 05
type: execute
wave: 4
depends_on: ["01-04"]
files_modified:
  - apps/backend/src/modules/workflow/sla/sla-tracker.service.ts
  - apps/backend/src/modules/workflow/sla/sla-scheduler.service.ts
  - apps/backend/src/modules/workflow/assignment/assignment-rules.service.ts
  - apps/backend/src/modules/workflow/assignment/strategies/round-robin.strategy.ts
  - apps/backend/src/modules/workflow/assignment/strategies/least-loaded.strategy.ts
  - apps/backend/src/modules/workflow/assignment/strategies/geographic.strategy.ts
  - apps/backend/src/modules/workflow/assignment/strategies/index.ts
  - apps/backend/src/modules/workflow/workflow.module.ts
autonomous: true

must_haves:
  truths:
    - "SLA tracker calculates and updates workflow instance SLA status"
    - "SLA scheduler runs periodically to check for at-risk and breached items"
    - "Assignment rules can auto-route based on category, location, round-robin"
    - "SLA breach events are emitted for notification integration"
    - "Assignment strategies are pluggable (round-robin, least-loaded, geographic)"
  artifacts:
    - path: "apps/backend/src/modules/workflow/sla/sla-tracker.service.ts"
      provides: "SLA status calculation and updates"
      contains: "calculateSlaStatus"
    - path: "apps/backend/src/modules/workflow/sla/sla-scheduler.service.ts"
      provides: "Scheduled SLA check job"
      contains: "@Cron"
    - path: "apps/backend/src/modules/workflow/assignment/assignment-rules.service.ts"
      provides: "Auto-assignment based on rules"
      contains: "resolveAssignee"
  key_links:
    - from: "apps/backend/src/modules/workflow/sla/sla-scheduler.service.ts"
      to: "WorkflowSlaBreach event"
      via: "eventEmitter.emit"
      pattern: "workflow\\.sla_breach"
---

<objective>
Implement SLA tracking with automatic status updates, breach detection, and the assignment rules engine with pluggable strategies.

Purpose: Cases and investigations have SLA requirements (e.g., 14 days to resolve). Auto-assignment reduces manual routing. This extends the workflow engine with time-based automation.

Output: SLA tracker/scheduler services and assignment rules engine with multiple strategies.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-04-SUMMARY.md
@apps/backend/src/modules/workflow/workflow.module.ts
@apps/backend/src/modules/workflow/engine/workflow-engine.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SLA Tracker Service</name>
  <files>
    apps/backend/src/modules/workflow/sla/sla-tracker.service.ts
    apps/backend/src/modules/workflow/sla/sla.types.ts
    apps/backend/src/modules/workflow/events/workflow.events.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/workflow/sla/sla.types.ts`:
       ```typescript
       export interface SlaConfig {
         defaultDays: number;
         warningThresholdPercent: number;  // Default 80%
         criticalThresholdHours: number;   // Hours after breach to escalate further
         stageOverrides?: Record<string, number>;  // Stage-specific days
       }

       export interface SlaCalculation {
         status: 'on_track' | 'warning' | 'breached' | 'critical';
         dueDate: Date;
         remainingHours: number;
         percentUsed: number;
         breachedAt?: Date;
       }
       ```

    2. Add SLA breach event to `apps/backend/src/modules/workflow/events/workflow.events.ts` if not already present:
       ```typescript
       export class WorkflowSlaWarningEvent extends BaseEvent {
         static readonly eventName = 'workflow.sla_warning';
         instanceId: string;
         entityType: string;
         entityId: string;
         stage: string;
         dueDate: Date;
         percentUsed: number;
       }

       export class WorkflowSlaBreachEvent extends BaseEvent {
         static readonly eventName = 'workflow.sla_breach';
         instanceId: string;
         entityType: string;
         entityId: string;
         stage: string;
         breachLevel: 'warning' | 'breached' | 'critical';
         hoursOverdue: number;
       }
       ```

    3. Create `apps/backend/src/modules/workflow/sla/sla-tracker.service.ts`:
       ```typescript
       import { Injectable, Logger } from '@nestjs/common';
       import { EventEmitter2 } from '@nestjs/event-emitter';
       import { PrismaService } from '../../prisma/prisma.service';
       import { SlaStatus } from '@prisma/client';
       import { SlaConfig, SlaCalculation } from './sla.types';
       import { WorkflowSlaWarningEvent, WorkflowSlaBreachEvent } from '../events/workflow.events';

       @Injectable()
       export class SlaTrackerService {
         private readonly logger = new Logger(SlaTrackerService.name);
         private readonly DEFAULT_WARNING_THRESHOLD = 80;  // 80% of time used
         private readonly CRITICAL_THRESHOLD_HOURS = 24;   // 24h after breach

         constructor(
           private prisma: PrismaService,
           private eventEmitter: EventEmitter2,
         ) {}

         /**
          * Calculate current SLA status for a workflow instance
          */
         calculateSlaStatus(dueDate: Date, slaConfig?: SlaConfig): SlaCalculation {
           const now = new Date();
           const remainingMs = dueDate.getTime() - now.getTime();
           const remainingHours = remainingMs / (1000 * 60 * 60);

           // If we don't know start time, estimate from due date and default days
           const totalDays = slaConfig?.defaultDays || 14;
           const totalMs = totalDays * 24 * 60 * 60 * 1000;
           const startTime = new Date(dueDate.getTime() - totalMs);
           const elapsedMs = now.getTime() - startTime.getTime();
           const percentUsed = Math.min(100, Math.max(0, (elapsedMs / totalMs) * 100));

           const warningThreshold = slaConfig?.warningThresholdPercent || this.DEFAULT_WARNING_THRESHOLD;
           const criticalHours = slaConfig?.criticalThresholdHours || this.CRITICAL_THRESHOLD_HOURS;

           let status: SlaCalculation['status'];

           if (remainingHours <= -criticalHours) {
             status = 'critical';
           } else if (remainingHours <= 0) {
             status = 'breached';
           } else if (percentUsed >= warningThreshold) {
             status = 'warning';
           } else {
             status = 'on_track';
           }

           return {
             status,
             dueDate,
             remainingHours,
             percentUsed,
             breachedAt: remainingHours <= 0 ? new Date() : undefined,
           };
         }

         /**
          * Update SLA status for all active workflow instances
          */
         async updateAllSlaStatuses(): Promise<{
           checked: number;
           warnings: number;
           breaches: number;
         }> {
           const instances = await this.prisma.workflowInstance.findMany({
             where: {
               status: 'ACTIVE',
               dueDate: { not: null },
             },
             include: { template: true },
           });

           let warnings = 0;
           let breaches = 0;

           for (const instance of instances) {
             if (!instance.dueDate) continue;

             const slaConfig = instance.template.slaConfig as unknown as SlaConfig;
             const calc = this.calculateSlaStatus(instance.dueDate, slaConfig);

             const previousStatus = instance.slaStatus;
             const newStatus = this.mapToDbStatus(calc.status);

             // Only update if status changed
             if (previousStatus !== newStatus) {
               await this.prisma.workflowInstance.update({
                 where: { id: instance.id },
                 data: {
                   slaStatus: newStatus,
                   ...(calc.status === 'breached' && !instance.slaBreachedAt && {
                     slaBreachedAt: new Date(),
                   }),
                 },
               });

               // Emit events for warnings and breaches
               if (calc.status === 'warning' && previousStatus === 'ON_TRACK') {
                 warnings++;
                 this.eventEmitter.emit(
                   WorkflowSlaWarningEvent.eventName,
                   new WorkflowSlaWarningEvent({
                     organizationId: instance.organizationId,
                     actorType: 'SYSTEM',
                     instanceId: instance.id,
                     entityType: instance.entityType,
                     entityId: instance.entityId,
                     stage: instance.currentStage,
                     dueDate: instance.dueDate,
                     percentUsed: calc.percentUsed,
                   }),
                 );
               }

               if ((calc.status === 'breached' || calc.status === 'critical') &&
                   previousStatus !== 'OVERDUE') {
                 breaches++;
                 this.eventEmitter.emit(
                   WorkflowSlaBreachEvent.eventName,
                   new WorkflowSlaBreachEvent({
                     organizationId: instance.organizationId,
                     actorType: 'SYSTEM',
                     instanceId: instance.id,
                     entityType: instance.entityType,
                     entityId: instance.entityId,
                     stage: instance.currentStage,
                     breachLevel: calc.status,
                     hoursOverdue: Math.abs(calc.remainingHours),
                   }),
                 );
               }
             }
           }

           this.logger.log(`SLA check complete: ${instances.length} checked, ${warnings} warnings, ${breaches} breaches`);

           return { checked: instances.length, warnings, breaches };
         }

         private mapToDbStatus(calcStatus: SlaCalculation['status']): SlaStatus {
           switch (calcStatus) {
             case 'warning':
               return SlaStatus.WARNING;
             case 'breached':
             case 'critical':
               return SlaStatus.OVERDUE;
             default:
               return SlaStatus.ON_TRACK;
           }
         }
       }
       ```
  </action>
  <verify>
    - File compiles: `cd apps/backend && npx tsc --noEmit`
    - Types properly defined
  </verify>
  <done>SlaTrackerService calculates SLA status and emits warning/breach events</done>
</task>

<task type="auto">
  <name>Task 2: Create SLA Scheduler Service</name>
  <files>
    apps/backend/src/modules/workflow/sla/sla-scheduler.service.ts
    apps/backend/package.json
  </files>
  <action>
    1. Install node-cron if not already installed:
       ```bash
       cd apps/backend && npm install @nestjs/schedule
       ```

    2. Create `apps/backend/src/modules/workflow/sla/sla-scheduler.service.ts`:
       ```typescript
       import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
       import { Cron, CronExpression } from '@nestjs/schedule';
       import { SlaTrackerService } from './sla-tracker.service';

       @Injectable()
       export class SlaSchedulerService implements OnModuleInit {
         private readonly logger = new Logger(SlaSchedulerService.name);
         private isRunning = false;

         constructor(private slaTracker: SlaTrackerService) {}

         onModuleInit() {
           this.logger.log('SLA Scheduler initialized - will run every 5 minutes');
         }

         /**
          * Run SLA checks every 5 minutes
          * Per CONTEXT.md: "SLA checks every 5min"
          */
         @Cron(CronExpression.EVERY_5_MINUTES)
         async handleSlaCheck(): Promise<void> {
           if (this.isRunning) {
             this.logger.warn('SLA check already running, skipping');
             return;
           }

           this.isRunning = true;
           this.logger.log('Starting scheduled SLA check');

           try {
             const result = await this.slaTracker.updateAllSlaStatuses();
             this.logger.log(
               `SLA check completed: ${result.checked} checked, ${result.warnings} warnings, ${result.breaches} breaches`,
             );
           } catch (error) {
             this.logger.error(`SLA check failed: ${error.message}`, error.stack);
           } finally {
             this.isRunning = false;
           }
         }

         /**
          * Manual trigger for testing or admin use
          */
         async runNow(): Promise<{ checked: number; warnings: number; breaches: number }> {
           return this.slaTracker.updateAllSlaStatuses();
         }
       }
       ```

    3. Import ScheduleModule in WorkflowModule:
       ```typescript
       import { ScheduleModule } from '@nestjs/schedule';

       @Module({
         imports: [ScheduleModule.forRoot()],
         // ... rest of module
       })
       ```
  </action>
  <verify>
    - App builds: `cd apps/backend && npm run build`
    - App starts with scheduler log: "SLA Scheduler initialized"
  </verify>
  <done>SlaSchedulerService runs SLA checks every 5 minutes via @Cron decorator</done>
</task>

<task type="auto">
  <name>Task 3: Create Assignment Rules Engine with Strategies</name>
  <files>
    apps/backend/src/modules/workflow/assignment/assignment-rules.service.ts
    apps/backend/src/modules/workflow/assignment/strategies/base.strategy.ts
    apps/backend/src/modules/workflow/assignment/strategies/round-robin.strategy.ts
    apps/backend/src/modules/workflow/assignment/strategies/least-loaded.strategy.ts
    apps/backend/src/modules/workflow/assignment/strategies/geographic.strategy.ts
    apps/backend/src/modules/workflow/assignment/strategies/index.ts
    apps/backend/src/modules/workflow/workflow.module.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/workflow/assignment/strategies/base.strategy.ts`:
       ```typescript
       export interface AssignmentContext {
         organizationId: string;
         entityType: string;
         entityId: string;
         category?: { id: string; name: string };
         location?: { id: string; name: string; country?: string };
         severity?: string;
         metadata?: Record<string, unknown>;
       }

       export interface AssignmentResult {
         userId: string;
         reason: string;
       }

       export abstract class AssignmentStrategy {
         abstract readonly type: string;

         abstract resolve(
           context: AssignmentContext,
           config: Record<string, unknown>,
         ): Promise<AssignmentResult | null>;
       }
       ```

    2. Create `apps/backend/src/modules/workflow/assignment/strategies/round-robin.strategy.ts`:
       ```typescript
       import { Injectable } from '@nestjs/common';
       import { PrismaService } from '../../../prisma/prisma.service';
       import { AssignmentStrategy, AssignmentContext, AssignmentResult } from './base.strategy';

       @Injectable()
       export class RoundRobinStrategy extends AssignmentStrategy {
         readonly type = 'round_robin';

         constructor(private prisma: PrismaService) {
           super();
         }

         async resolve(
           context: AssignmentContext,
           config: { teamId?: string; roleFilter?: string[] },
         ): Promise<AssignmentResult | null> {
           // Get eligible users
           const users = await this.prisma.user.findMany({
             where: {
               organizationId: context.organizationId,
               isActive: true,
               ...(config.roleFilter && { role: { in: config.roleFilter as any } }),
             },
             select: { id: true, firstName: true, lastName: true },
             orderBy: { lastLoginAt: 'asc' },  // Simple round-robin: least recently active
           });

           if (users.length === 0) return null;

           // Find last assigned user for this type (simple round-robin)
           const lastAssignment = await this.prisma.auditLog.findFirst({
             where: {
               organizationId: context.organizationId,
               entityType: context.entityType as any,
               action: 'assigned',
             },
             orderBy: { createdAt: 'desc' },
             select: { changes: true },
           });

           let nextIndex = 0;
           if (lastAssignment?.changes) {
             const changes = lastAssignment.changes as { assignedTo?: { new: string } };
             const lastUserId = changes.assignedTo?.new;
             if (lastUserId) {
               const lastIndex = users.findIndex(u => u.id === lastUserId);
               nextIndex = (lastIndex + 1) % users.length;
             }
           }

           const assignee = users[nextIndex];

           return {
             userId: assignee.id,
             reason: `Round-robin assignment to ${assignee.firstName} ${assignee.lastName}`,
           };
         }
       }
       ```

    3. Create `apps/backend/src/modules/workflow/assignment/strategies/least-loaded.strategy.ts`:
       ```typescript
       import { Injectable } from '@nestjs/common';
       import { PrismaService } from '../../../prisma/prisma.service';
       import { AssignmentStrategy, AssignmentContext, AssignmentResult } from './base.strategy';

       @Injectable()
       export class LeastLoadedStrategy extends AssignmentStrategy {
         readonly type = 'least_loaded';

         constructor(private prisma: PrismaService) {
           super();
         }

         async resolve(
           context: AssignmentContext,
           config: { teamId?: string; roleFilter?: string[]; maxLoad?: number },
         ): Promise<AssignmentResult | null> {
           // Get users with their current case load
           const users = await this.prisma.user.findMany({
             where: {
               organizationId: context.organizationId,
               isActive: true,
               ...(config.roleFilter && { role: { in: config.roleFilter as any } }),
             },
             select: {
               id: true,
               firstName: true,
               lastName: true,
               _count: {
                 select: {
                   investigationsPrimaryInvestigator: {
                     where: { status: { not: 'CLOSED' } },
                   },
                 },
               },
             },
           });

           if (users.length === 0) return null;

           // Sort by load (ascending)
           const sorted = users.sort(
             (a, b) =>
               a._count.investigationsPrimaryInvestigator -
               b._count.investigationsPrimaryInvestigator,
           );

           // Check max load limit if configured
           const assignee = sorted[0];
           if (config.maxLoad && assignee._count.investigationsPrimaryInvestigator >= config.maxLoad) {
             return null;  // Everyone at capacity
           }

           return {
             userId: assignee.id,
             reason: `Least-loaded assignment to ${assignee.firstName} ${assignee.lastName} (${assignee._count.investigationsPrimaryInvestigator} active)`,
           };
         }
       }
       ```

    4. Create `apps/backend/src/modules/workflow/assignment/strategies/geographic.strategy.ts`:
       ```typescript
       import { Injectable } from '@nestjs/common';
       import { PrismaService } from '../../../prisma/prisma.service';
       import { AssignmentStrategy, AssignmentContext, AssignmentResult } from './base.strategy';

       @Injectable()
       export class GeographicStrategy extends AssignmentStrategy {
         readonly type = 'geographic';

         constructor(private prisma: PrismaService) {
           super();
         }

         async resolve(
           context: AssignmentContext,
           config: { locationMapping?: Record<string, string> },
         ): Promise<AssignmentResult | null> {
           if (!context.location) return null;

           // Look up designated assignee for this location
           const locationKey = context.location.country || context.location.name;
           const designatedUserId = config.locationMapping?.[locationKey];

           if (!designatedUserId) return null;

           const user = await this.prisma.user.findFirst({
             where: {
               id: designatedUserId,
               organizationId: context.organizationId,
               isActive: true,
             },
             select: { id: true, firstName: true, lastName: true },
           });

           if (!user) return null;

           return {
             userId: user.id,
             reason: `Geographic assignment to ${user.firstName} ${user.lastName} for ${locationKey}`,
           };
         }
       }
       ```

    5. Create `apps/backend/src/modules/workflow/assignment/assignment-rules.service.ts`:
       ```typescript
       import { Injectable, Logger } from '@nestjs/common';
       import { PrismaService } from '../../prisma/prisma.service';
       import { AssignmentContext, AssignmentResult, AssignmentStrategy } from './strategies/base.strategy';
       import { RoundRobinStrategy } from './strategies/round-robin.strategy';
       import { LeastLoadedStrategy } from './strategies/least-loaded.strategy';
       import { GeographicStrategy } from './strategies/geographic.strategy';

       export interface AssignmentRule {
         id: string;
         name: string;
         priority: number;
         conditions: {
           entityType?: string;
           categoryId?: string;
           severity?: string;
           location?: string;
         };
         strategy: {
           type: string;
           config: Record<string, unknown>;
         };
       }

       @Injectable()
       export class AssignmentRulesService {
         private readonly logger = new Logger(AssignmentRulesService.name);
         private strategies: Map<string, AssignmentStrategy>;

         constructor(
           private prisma: PrismaService,
           roundRobin: RoundRobinStrategy,
           leastLoaded: LeastLoadedStrategy,
           geographic: GeographicStrategy,
         ) {
           this.strategies = new Map([
             ['round_robin', roundRobin],
             ['least_loaded', leastLoaded],
             ['geographic', geographic],
           ]);
         }

         /**
          * Resolve assignee for an entity based on configured rules
          */
         async resolveAssignee(context: AssignmentContext): Promise<AssignmentResult | null> {
           // For now, load rules from category configuration
           // In future, could be stored in dedicated rules table
           if (context.category) {
             const category = await this.prisma.category.findUnique({
               where: { id: context.category.id },
               select: { routingRules: true, defaultAssigneeId: true },
             });

             // If category has direct assignee, use that
             if (category?.defaultAssigneeId) {
               const user = await this.prisma.user.findUnique({
                 where: { id: category.defaultAssigneeId },
                 select: { id: true, firstName: true, lastName: true, isActive: true },
               });

               if (user?.isActive) {
                 return {
                   userId: user.id,
                   reason: `Category default assignment to ${user.firstName} ${user.lastName}`,
                 };
               }
             }

             // If category has routing rules, apply them
             if (category?.routingRules) {
               const rules = category.routingRules as unknown as { strategy: string; config: Record<string, unknown> };
               const strategy = this.strategies.get(rules.strategy);
               if (strategy) {
                 const result = await strategy.resolve(context, rules.config);
                 if (result) return result;
               }
             }
           }

           // Fallback: round-robin among investigators
           const roundRobin = this.strategies.get('round_robin');
           return roundRobin?.resolve(context, { roleFilter: ['INVESTIGATOR', 'TRIAGE_LEAD'] }) || null;
         }

         /**
          * Register a custom strategy
          */
         registerStrategy(strategy: AssignmentStrategy): void {
           this.strategies.set(strategy.type, strategy);
         }
       }
       ```

    6. Create barrel export and update WorkflowModule:
       ```typescript
       // workflow.module.ts additions
       import { SlaTrackerService } from './sla/sla-tracker.service';
       import { SlaSchedulerService } from './sla/sla-scheduler.service';
       import { AssignmentRulesService } from './assignment/assignment-rules.service';
       import { RoundRobinStrategy } from './assignment/strategies/round-robin.strategy';
       import { LeastLoadedStrategy } from './assignment/strategies/least-loaded.strategy';
       import { GeographicStrategy } from './assignment/strategies/geographic.strategy';

       @Module({
         imports: [ScheduleModule.forRoot()],
         providers: [
           WorkflowEngineService,
           WorkflowService,
           SlaTrackerService,
           SlaSchedulerService,
           AssignmentRulesService,
           RoundRobinStrategy,
           LeastLoadedStrategy,
           GeographicStrategy,
         ],
         controllers: [WorkflowController],
         exports: [WorkflowEngineService, WorkflowService, SlaTrackerService, AssignmentRulesService],
       })
       export class WorkflowModule {}
       ```
  </action>
  <verify>
    - App builds: `cd apps/backend && npm run build`
    - App starts and logs "SLA Scheduler initialized"
    - No errors on startup
  </verify>
  <done>Assignment rules engine with round-robin, least-loaded, and geographic strategies created</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build succeeds: `cd apps/backend && npm run build`
2. App starts and logs scheduler initialization
3. SLA check runs (wait 5 minutes or call runNow manually)
4. Can programmatically call assignmentRulesService.resolveAssignee()
5. SLA breach events emitted when instances breach their due dates
</verification>

<success_criteria>
- SlaTrackerService calculates SLA status based on due date
- SlaSchedulerService runs checks every 5 minutes per CONTEXT.md
- SLA warning/breach events emitted for notification integration
- Assignment strategies are pluggable (round-robin, least-loaded, geographic)
- AssignmentRulesService falls back through rules to find assignee
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-05-SUMMARY.md`
</output>
