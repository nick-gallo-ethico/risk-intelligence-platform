---
phase: 01-foundation-infrastructure
plan: 09
type: execute
wave: 2
depends_on: ["01-02"]
files_modified:
  - apps/backend/src/modules/storage/storage.module.ts
  - apps/backend/src/modules/storage/storage.service.ts
  - apps/backend/src/modules/storage/providers/azure-blob.provider.ts
  - apps/backend/src/modules/storage/providers/local-storage.provider.ts
  - apps/backend/src/modules/storage/document-processing.service.ts
  - apps/backend/src/modules/storage/dto/upload-file.dto.ts
  - apps/backend/src/modules/storage/storage.controller.ts
  - apps/backend/src/app.module.ts
  - apps/backend/package.json
autonomous: true

must_haves:
  truths:
    - "Files are stored with per-tenant container isolation"
    - "Storage provider is abstracted (Azure Blob, local for dev)"
    - "Signed URLs with expiration are generated for downloads"
    - "Document processing extracts text for search indexing"
    - "File metadata is stored in Attachment model with storage reference"
  artifacts:
    - path: "apps/backend/src/modules/storage/storage.service.ts"
      provides: "Unified storage API"
      contains: "uploadFile"
    - path: "apps/backend/src/modules/storage/providers/azure-blob.provider.ts"
      provides: "Azure Blob Storage integration"
      contains: "BlobServiceClient"
    - path: "apps/backend/src/modules/storage/document-processing.service.ts"
      provides: "PDF/Office text extraction"
      contains: "extractText"
  key_links:
    - from: "apps/backend/src/modules/storage/storage.service.ts"
      to: "azure-blob.provider"
      via: "StorageProvider interface"
      pattern: "StorageProvider"
---

<objective>
Build the file storage service with Azure Blob integration, per-tenant isolation, and document processing for text extraction.

Purpose: Cases, investigations, and disclosures need file attachments. Document text extraction enables search indexing. Signed URLs ensure secure, time-limited downloads.

Output: StorageModule with Azure Blob provider, local fallback, and document processing.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md
@apps/backend/src/common/services/storage.service.ts
@apps/backend/src/common/services/storage.interface.ts
@apps/backend/src/common/services/local-storage.adapter.ts
@apps/backend/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Azure Storage SDK and create provider interface</name>
  <files>
    apps/backend/package.json
    apps/backend/src/modules/storage/providers/storage-provider.interface.ts
    apps/backend/src/config/configuration.ts
  </files>
  <action>
    1. Install Azure Storage SDK:
       ```bash
       cd apps/backend && npm install @azure/storage-blob @azure/identity
       ```

    2. Note: The project already has basic storage abstractions in src/common/services/.
       We will enhance these into a full module in src/modules/storage/.

    3. Create `apps/backend/src/modules/storage/providers/storage-provider.interface.ts`:
       ```typescript
       export interface StorageProvider {
         /**
          * Upload a file to storage
          */
         uploadFile(params: {
           organizationId: string;
           path: string;
           content: Buffer;
           contentType: string;
           metadata?: Record<string, string>;
         }): Promise<{ key: string; url: string; size: number }>;

         /**
          * Get a signed URL for download (time-limited)
          */
         getSignedUrl(params: {
           organizationId: string;
           path: string;
           expiresInMinutes?: number;
         }): Promise<string>;

         /**
          * Delete a file
          */
         deleteFile(params: {
           organizationId: string;
           path: string;
         }): Promise<void>;

         /**
          * Check if file exists
          */
         fileExists(params: {
           organizationId: string;
           path: string;
         }): Promise<boolean>;

         /**
          * Download file content
          */
         downloadFile(params: {
           organizationId: string;
           path: string;
         }): Promise<Buffer>;
       }

       export const STORAGE_PROVIDER = Symbol('STORAGE_PROVIDER');
       ```

    4. Update `apps/backend/src/config/configuration.ts` with Azure Storage config:
       ```typescript
       storage: {
         provider: process.env.STORAGE_PROVIDER || 'local',  // 'azure' or 'local'
         azure: {
           accountName: process.env.AZURE_STORAGE_ACCOUNT_NAME,
           accountKey: process.env.AZURE_STORAGE_ACCOUNT_KEY,
           containerPrefix: process.env.AZURE_STORAGE_CONTAINER_PREFIX || 'ethico',
         },
         local: {
           basePath: process.env.LOCAL_STORAGE_PATH || './uploads',
         },
       },
       ```

    5. Add to `.env.example`:
       ```
       STORAGE_PROVIDER=local
       AZURE_STORAGE_ACCOUNT_NAME=
       AZURE_STORAGE_ACCOUNT_KEY=
       AZURE_STORAGE_CONTAINER_PREFIX=ethico
       LOCAL_STORAGE_PATH=./uploads
       ```
  </action>
  <verify>
    - Packages installed: grep "@azure/storage-blob" apps/backend/package.json
    - Interface file exists and compiles
  </verify>
  <done>Azure Storage SDK installed and StorageProvider interface defined</done>
</task>

<task type="auto">
  <name>Task 2: Create Azure Blob and Local storage providers</name>
  <files>
    apps/backend/src/modules/storage/providers/azure-blob.provider.ts
    apps/backend/src/modules/storage/providers/local-storage.provider.ts
    apps/backend/src/modules/storage/providers/index.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/storage/providers/azure-blob.provider.ts`:
       ```typescript
       import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
       import { ConfigService } from '@nestjs/config';
       import {
         BlobServiceClient,
         ContainerClient,
         StorageSharedKeyCredential,
         generateBlobSASQueryParameters,
         BlobSASPermissions,
       } from '@azure/storage-blob';
       import { StorageProvider } from './storage-provider.interface';

       @Injectable()
       export class AzureBlobProvider implements StorageProvider, OnModuleInit {
         private readonly logger = new Logger(AzureBlobProvider.name);
         private blobServiceClient: BlobServiceClient;
         private sharedKeyCredential: StorageSharedKeyCredential;
         private containerPrefix: string;

         constructor(private configService: ConfigService) {}

         onModuleInit() {
           const accountName = this.configService.get<string>('storage.azure.accountName');
           const accountKey = this.configService.get<string>('storage.azure.accountKey');
           this.containerPrefix = this.configService.get<string>('storage.azure.containerPrefix') || 'ethico';

           if (!accountName || !accountKey) {
             this.logger.warn('Azure Storage credentials not configured');
             return;
           }

           this.sharedKeyCredential = new StorageSharedKeyCredential(accountName, accountKey);
           this.blobServiceClient = new BlobServiceClient(
             `https://${accountName}.blob.core.windows.net`,
             this.sharedKeyCredential,
           );

           this.logger.log('Azure Blob Storage provider initialized');
         }

         private getContainerName(organizationId: string): string {
           // Per-tenant container: ethico-org-{uuid}
           return `${this.containerPrefix}-org-${organizationId}`.toLowerCase();
         }

         private async getContainer(organizationId: string): Promise<ContainerClient> {
           const containerName = this.getContainerName(organizationId);
           const container = this.blobServiceClient.getContainerClient(containerName);

           // Create if doesn't exist
           await container.createIfNotExists({
             access: 'container',  // Private access
           });

           return container;
         }

         async uploadFile(params: {
           organizationId: string;
           path: string;
           content: Buffer;
           contentType: string;
           metadata?: Record<string, string>;
         }): Promise<{ key: string; url: string; size: number }> {
           const container = await this.getContainer(params.organizationId);
           const blob = container.getBlockBlobClient(params.path);

           await blob.upload(params.content, params.content.length, {
             blobHTTPHeaders: { blobContentType: params.contentType },
             metadata: params.metadata,
           });

           return {
             key: params.path,
             url: blob.url,
             size: params.content.length,
           };
         }

         async getSignedUrl(params: {
           organizationId: string;
           path: string;
           expiresInMinutes?: number;
         }): Promise<string> {
           const container = await this.getContainer(params.organizationId);
           const blob = container.getBlockBlobClient(params.path);

           const expiresOn = new Date();
           expiresOn.setMinutes(expiresOn.getMinutes() + (params.expiresInMinutes || 15));

           const sasToken = generateBlobSASQueryParameters({
             containerName: this.getContainerName(params.organizationId),
             blobName: params.path,
             permissions: BlobSASPermissions.parse('r'),
             startsOn: new Date(),
             expiresOn,
           }, this.sharedKeyCredential).toString();

           return `${blob.url}?${sasToken}`;
         }

         async deleteFile(params: {
           organizationId: string;
           path: string;
         }): Promise<void> {
           const container = await this.getContainer(params.organizationId);
           const blob = container.getBlockBlobClient(params.path);
           await blob.deleteIfExists();
         }

         async fileExists(params: {
           organizationId: string;
           path: string;
         }): Promise<boolean> {
           const container = await this.getContainer(params.organizationId);
           const blob = container.getBlockBlobClient(params.path);
           return blob.exists();
         }

         async downloadFile(params: {
           organizationId: string;
           path: string;
         }): Promise<Buffer> {
           const container = await this.getContainer(params.organizationId);
           const blob = container.getBlockBlobClient(params.path);
           const response = await blob.downloadToBuffer();
           return response;
         }
       }
       ```

    2. Create `apps/backend/src/modules/storage/providers/local-storage.provider.ts`:
       ```typescript
       import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
       import { ConfigService } from '@nestjs/config';
       import * as fs from 'fs/promises';
       import * as path from 'path';
       import { StorageProvider } from './storage-provider.interface';

       @Injectable()
       export class LocalStorageProvider implements StorageProvider, OnModuleInit {
         private readonly logger = new Logger(LocalStorageProvider.name);
         private basePath: string;

         constructor(private configService: ConfigService) {}

         async onModuleInit() {
           this.basePath = this.configService.get<string>('storage.local.basePath') || './uploads';

           // Ensure base directory exists
           await fs.mkdir(this.basePath, { recursive: true });
           this.logger.log(`Local Storage provider initialized at ${this.basePath}`);
         }

         private getOrgPath(organizationId: string): string {
           return path.join(this.basePath, `org-${organizationId}`);
         }

         private getFilePath(organizationId: string, filePath: string): string {
           return path.join(this.getOrgPath(organizationId), filePath);
         }

         async uploadFile(params: {
           organizationId: string;
           path: string;
           content: Buffer;
           contentType: string;
           metadata?: Record<string, string>;
         }): Promise<{ key: string; url: string; size: number }> {
           const fullPath = this.getFilePath(params.organizationId, params.path);
           const dir = path.dirname(fullPath);

           await fs.mkdir(dir, { recursive: true });
           await fs.writeFile(fullPath, params.content);

           // Store metadata in sidecar file
           if (params.metadata) {
             await fs.writeFile(`${fullPath}.meta.json`, JSON.stringify({
               contentType: params.contentType,
               ...params.metadata,
             }));
           }

           return {
             key: params.path,
             url: `/api/v1/storage/files/${params.organizationId}/${params.path}`,
             size: params.content.length,
           };
         }

         async getSignedUrl(params: {
           organizationId: string;
           path: string;
           expiresInMinutes?: number;
         }): Promise<string> {
           // For local storage, return direct path (no signing in dev)
           // In production, this would use a token-based system
           return `/api/v1/storage/files/${params.organizationId}/${params.path}`;
         }

         async deleteFile(params: {
           organizationId: string;
           path: string;
         }): Promise<void> {
           const fullPath = this.getFilePath(params.organizationId, params.path);
           try {
             await fs.unlink(fullPath);
             await fs.unlink(`${fullPath}.meta.json`).catch(() => {});
           } catch (error) {
             if (error.code !== 'ENOENT') throw error;
           }
         }

         async fileExists(params: {
           organizationId: string;
           path: string;
         }): Promise<boolean> {
           const fullPath = this.getFilePath(params.organizationId, params.path);
           try {
             await fs.access(fullPath);
             return true;
           } catch {
             return false;
           }
         }

         async downloadFile(params: {
           organizationId: string;
           path: string;
         }): Promise<Buffer> {
           const fullPath = this.getFilePath(params.organizationId, params.path);
           return fs.readFile(fullPath);
         }
       }
       ```

    3. Create barrel export.
  </action>
  <verify>
    - Files compile: `cd apps/backend && npx tsc --noEmit`
    - Both providers implement StorageProvider interface
  </verify>
  <done>Azure Blob and Local storage providers created with per-tenant isolation</done>
</task>

<task type="auto">
  <name>Task 3: Create StorageService, DocumentProcessing, and controller</name>
  <files>
    apps/backend/src/modules/storage/storage.service.ts
    apps/backend/src/modules/storage/document-processing.service.ts
    apps/backend/src/modules/storage/dto/upload-response.dto.ts
    apps/backend/src/modules/storage/storage.controller.ts
    apps/backend/src/modules/storage/storage.module.ts
    apps/backend/src/app.module.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/storage/storage.service.ts`:
       ```typescript
       import { Injectable, Inject, Logger } from '@nestjs/common';
       import { PrismaService } from '../prisma/prisma.service';
       import { EventEmitter2 } from '@nestjs/event-emitter';
       import { AttachmentEntityType } from '@prisma/client';
       import { StorageProvider, STORAGE_PROVIDER } from './providers/storage-provider.interface';
       import { DocumentProcessingService } from './document-processing.service';
       import { nanoid } from 'nanoid';

       export interface UploadFileParams {
         organizationId: string;
         entityType: AttachmentEntityType;
         entityId: string;
         fileName: string;
         content: Buffer;
         contentType: string;
         uploadedById: string;
         isEvidence?: boolean;
         description?: string;
       }

       @Injectable()
       export class StorageService {
         private readonly logger = new Logger(StorageService.name);

         constructor(
           @Inject(STORAGE_PROVIDER) private storageProvider: StorageProvider,
           private prisma: PrismaService,
           private documentProcessing: DocumentProcessingService,
           private eventEmitter: EventEmitter2,
         ) {}

         async uploadFile(params: UploadFileParams): Promise<{
           attachmentId: string;
           url: string;
           size: number;
         }> {
           // Generate unique file key
           const fileKey = `${params.entityType.toLowerCase()}/${params.entityId}/${nanoid(10)}-${params.fileName}`;

           // Upload to storage
           const uploadResult = await this.storageProvider.uploadFile({
             organizationId: params.organizationId,
             path: fileKey,
             content: params.content,
             contentType: params.contentType,
             metadata: {
               entityType: params.entityType,
               entityId: params.entityId,
               originalFileName: params.fileName,
             },
           });

           // Create Attachment record
           const attachment = await this.prisma.attachment.create({
             data: {
               organizationId: params.organizationId,
               entityType: params.entityType,
               entityId: params.entityId,
               fileName: params.fileName,
               fileKey,
               mimeType: params.contentType,
               fileSize: uploadResult.size,
               description: params.description,
               isEvidence: params.isEvidence || false,
               uploadedById: params.uploadedById,
             },
           });

           // Queue text extraction for searchable documents
           if (this.documentProcessing.isExtractable(params.contentType)) {
             this.eventEmitter.emit('file.uploaded', {
               organizationId: params.organizationId,
               attachmentId: attachment.id,
               fileKey,
               contentType: params.contentType,
             });
           }

           return {
             attachmentId: attachment.id,
             url: uploadResult.url,
             size: uploadResult.size,
           };
         }

         async getDownloadUrl(organizationId: string, attachmentId: string): Promise<string> {
           const attachment = await this.prisma.attachment.findFirst({
             where: { id: attachmentId, organizationId },
           });

           if (!attachment) {
             throw new Error('Attachment not found');
           }

           return this.storageProvider.getSignedUrl({
             organizationId,
             path: attachment.fileKey,
             expiresInMinutes: 15,
           });
         }

         async deleteFile(organizationId: string, attachmentId: string): Promise<void> {
           const attachment = await this.prisma.attachment.findFirst({
             where: { id: attachmentId, organizationId },
           });

           if (!attachment) return;

           await this.storageProvider.deleteFile({
             organizationId,
             path: attachment.fileKey,
           });

           await this.prisma.attachment.delete({ where: { id: attachmentId } });
         }

         async getAttachment(organizationId: string, attachmentId: string) {
           return this.prisma.attachment.findFirst({
             where: { id: attachmentId, organizationId },
           });
         }

         async listAttachments(
           organizationId: string,
           entityType: AttachmentEntityType,
           entityId: string,
         ) {
           return this.prisma.attachment.findMany({
             where: { organizationId, entityType, entityId },
             orderBy: { createdAt: 'desc' },
           });
         }
       }
       ```

    2. Create `apps/backend/src/modules/storage/document-processing.service.ts`:
       ```typescript
       import { Injectable, Logger } from '@nestjs/common';
       import { InjectQueue } from '@nestjs/bullmq';
       import { Queue } from 'bullmq';

       @Injectable()
       export class DocumentProcessingService {
         private readonly logger = new Logger(DocumentProcessingService.name);

         private readonly EXTRACTABLE_TYPES = [
           'application/pdf',
           'application/msword',
           'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
           'text/plain',
           'text/html',
         ];

         isExtractable(contentType: string): boolean {
           return this.EXTRACTABLE_TYPES.includes(contentType);
         }

         /**
          * Extract text from document (placeholder)
          * Full implementation would use pdf-parse, mammoth, etc.
          */
         async extractText(content: Buffer, contentType: string): Promise<string | null> {
           this.logger.log(`Would extract text from ${contentType} document`);

           // Placeholder - actual implementation would use:
           // - pdf-parse for PDFs
           // - mammoth for DOCX
           // - direct string for TXT

           if (contentType === 'text/plain') {
             return content.toString('utf-8');
           }

           // For now, return null - implement in future iteration
           return null;
         }
       }
       ```

    3. Create `apps/backend/src/modules/storage/storage.controller.ts`:
       ```typescript
       import {
         Controller,
         Get,
         Post,
         Delete,
         Param,
         Query,
         Res,
         UseGuards,
         UseInterceptors,
         UploadedFile,
         BadRequestException,
       } from '@nestjs/common';
       import { Response } from 'express';
       import { FileInterceptor } from '@nestjs/platform-express';
       import { JwtAuthGuard } from '../../common/guards/jwt-auth.guard';
       import { TenantGuard } from '../../common/guards/tenant.guard';
       import { CurrentUser } from '../../common/decorators/current-user.decorator';
       import { TenantId } from '../../common/decorators/tenant-id.decorator';
       import { StorageService } from './storage.service';
       import { AttachmentEntityType } from '@prisma/client';

       @Controller('api/v1/storage')
       @UseGuards(JwtAuthGuard, TenantGuard)
       export class StorageController {
         constructor(private storageService: StorageService) {}

         @Post('upload')
         @UseInterceptors(FileInterceptor('file', {
           limits: { fileSize: 50 * 1024 * 1024 },  // 50MB limit
         }))
         async uploadFile(
           @TenantId() orgId: string,
           @CurrentUser() user: { id: string },
           @UploadedFile() file: Express.Multer.File,
           @Query('entityType') entityType: AttachmentEntityType,
           @Query('entityId') entityId: string,
           @Query('isEvidence') isEvidence?: string,
           @Query('description') description?: string,
         ) {
           if (!file) {
             throw new BadRequestException('No file provided');
           }

           if (!entityType || !entityId) {
             throw new BadRequestException('entityType and entityId are required');
           }

           return this.storageService.uploadFile({
             organizationId: orgId,
             entityType,
             entityId,
             fileName: file.originalname,
             content: file.buffer,
             contentType: file.mimetype,
             uploadedById: user.id,
             isEvidence: isEvidence === 'true',
             description,
           });
         }

         @Get('attachments/:id/download')
         async getDownloadUrl(
           @TenantId() orgId: string,
           @Param('id') attachmentId: string,
         ) {
           const url = await this.storageService.getDownloadUrl(orgId, attachmentId);
           return { url };
         }

         @Get('attachments/:id')
         async getAttachment(
           @TenantId() orgId: string,
           @Param('id') attachmentId: string,
         ) {
           return this.storageService.getAttachment(orgId, attachmentId);
         }

         @Get('entity/:entityType/:entityId')
         async listAttachments(
           @TenantId() orgId: string,
           @Param('entityType') entityType: AttachmentEntityType,
           @Param('entityId') entityId: string,
         ) {
           return this.storageService.listAttachments(orgId, entityType, entityId);
         }

         @Delete('attachments/:id')
         async deleteAttachment(
           @TenantId() orgId: string,
           @Param('id') attachmentId: string,
         ) {
           await this.storageService.deleteFile(orgId, attachmentId);
           return { success: true };
         }
       }
       ```

    4. Create `apps/backend/src/modules/storage/storage.module.ts`:
       ```typescript
       import { Module, Global } from '@nestjs/common';
       import { ConfigService } from '@nestjs/config';
       import { StorageService } from './storage.service';
       import { DocumentProcessingService } from './document-processing.service';
       import { StorageController } from './storage.controller';
       import { AzureBlobProvider } from './providers/azure-blob.provider';
       import { LocalStorageProvider } from './providers/local-storage.provider';
       import { STORAGE_PROVIDER } from './providers/storage-provider.interface';

       @Global()
       @Module({
         providers: [
           {
             provide: STORAGE_PROVIDER,
             useFactory: (configService: ConfigService) => {
               const provider = configService.get<string>('storage.provider');
               if (provider === 'azure') {
                 return new AzureBlobProvider(configService);
               }
               return new LocalStorageProvider(configService);
             },
             inject: [ConfigService],
           },
           StorageService,
           DocumentProcessingService,
         ],
         controllers: [StorageController],
         exports: [StorageService, DocumentProcessingService, STORAGE_PROVIDER],
       })
       export class StorageModule {}
       ```

    5. Install Multer types:
       ```bash
       cd apps/backend && npm install -D @types/multer
       ```

    6. Update `apps/backend/src/app.module.ts`:
       - Import StorageModule
       - Add to imports array
  </action>
  <verify>
    - App builds: `cd apps/backend && npm run build`
    - App starts: `cd apps/backend && npm run start:dev`
    - Upload file: POST /api/v1/storage/upload with multipart form
    - Get download URL: GET /api/v1/storage/attachments/:id/download
  </verify>
  <done>StorageModule with provider abstraction, per-tenant isolation, and document processing created</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build succeeds: `cd apps/backend && npm run build`
2. App starts with storage provider log message
3. Upload file via API (use Postman or curl with multipart)
4. Verify Attachment record created in database
5. Get download URL and verify it works
6. Delete attachment and verify file removed
</verification>

<success_criteria>
- Files stored with per-tenant container isolation (org-{uuid})
- Storage provider is abstracted (Azure or Local based on config)
- Signed URLs with expiration generated for downloads
- Document processing service ready for text extraction
- Attachment metadata stored with storage reference
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-09-SUMMARY.md`
</output>
