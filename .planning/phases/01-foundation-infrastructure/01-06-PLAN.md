---
phase: 01-foundation-infrastructure
plan: 06
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - apps/backend/src/modules/search/search.module.ts
  - apps/backend/src/modules/search/search.service.ts
  - apps/backend/src/modules/search/indexing/indexing.service.ts
  - apps/backend/src/modules/search/indexing/index-mappings/case.mapping.ts
  - apps/backend/src/modules/search/indexing/index-mappings/policy.mapping.ts
  - apps/backend/src/modules/search/query/query-builder.service.ts
  - apps/backend/src/modules/search/query/permission-filter.service.ts
  - apps/backend/src/modules/search/handlers/case-indexing.handler.ts
  - apps/backend/src/modules/search/search.controller.ts
  - apps/backend/src/app.module.ts
  - apps/backend/package.json
  - docker-compose.yml
autonomous: true

must_haves:
  truths:
    - "Elasticsearch indices are per-tenant (org_{tenantId}_cases)"
    - "Search queries return results within 500ms"
    - "Permission filters are injected at query time"
    - "Index updates happen asynchronously via job queue"
    - "Fuzzy matching and highlighting are supported"
  artifacts:
    - path: "apps/backend/src/modules/search/search.service.ts"
      provides: "Unified search service"
      contains: "search"
    - path: "apps/backend/src/modules/search/indexing/indexing.service.ts"
      provides: "Index management and document indexing"
      contains: "getIndexName"
    - path: "apps/backend/src/modules/search/query/permission-filter.service.ts"
      provides: "Query-time permission filtering"
      contains: "buildPermissionFilter"
  key_links:
    - from: "apps/backend/src/modules/search/handlers/case-indexing.handler.ts"
      to: "indexing job queue"
      via: "@InjectQueue"
      pattern: "indexing"
---

<objective>
Implement Elasticsearch integration with per-tenant indices, async indexing via job queue, and permission-filtered search queries.

Purpose: Fast, full-text search across Cases, RIUs, Policies, and other entities. Per-tenant indices ensure data isolation. Async indexing keeps writes fast.

Output: SearchModule with indexing pipeline, query builder, and search API.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md
@apps/backend/src/modules/jobs/jobs.module.ts
@docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Elasticsearch packages and configure in docker-compose</name>
  <files>
    apps/backend/package.json
    docker-compose.yml
    apps/backend/src/config/configuration.ts
  </files>
  <action>
    1. Install Elasticsearch packages:
       ```bash
       cd apps/backend && npm install @nestjs/elasticsearch@^11.1.0 @elastic/elasticsearch@^9.0.0
       ```

    2. Update `docker-compose.yml` to add Elasticsearch service:
       ```yaml
       elasticsearch:
         image: docker.elastic.co/elasticsearch/elasticsearch:8.15.0
         container_name: ethico-elasticsearch
         environment:
           - discovery.type=single-node
           - xpack.security.enabled=false
           - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
         ports:
           - "9200:9200"
         volumes:
           - elasticsearch_data:/usr/share/elasticsearch/data
         healthcheck:
           test: ["CMD-SHELL", "curl -s http://localhost:9200/_cluster/health | grep -q '\"status\":\"green\"\\|\"status\":\"yellow\"'"]
           interval: 30s
           timeout: 10s
           retries: 5
       ```
       Add `elasticsearch_data:` to volumes section.

    3. Update `apps/backend/src/config/configuration.ts` to add Elasticsearch config:
       ```typescript
       elasticsearch: {
         node: process.env.ELASTICSEARCH_NODE || 'http://localhost:9200',
         maxRetries: 3,
         requestTimeout: 30000,
       },
       ```

    4. Add to `.env.example`:
       ```
       ELASTICSEARCH_NODE=http://localhost:9200
       ```
  </action>
  <verify>
    - Packages in package.json: grep elastic apps/backend/package.json
    - Elasticsearch in docker-compose: grep elasticsearch docker-compose.yml
    - Start services: `docker-compose up -d elasticsearch` and verify with `curl http://localhost:9200`
  </verify>
  <done>Elasticsearch 8.x configured in docker-compose and dependencies installed</done>
</task>

<task type="auto">
  <name>Task 2: Create indexing service with per-tenant indices</name>
  <files>
    apps/backend/src/modules/search/search.module.ts
    apps/backend/src/modules/search/indexing/indexing.service.ts
    apps/backend/src/modules/search/indexing/index-mappings/case.mapping.ts
    apps/backend/src/modules/search/indexing/index-mappings/riu.mapping.ts
    apps/backend/src/modules/search/indexing/index-mappings/index.ts
    apps/backend/src/modules/search/handlers/case-indexing.handler.ts
    apps/backend/src/modules/search/handlers/index.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/search/indexing/index-mappings/case.mapping.ts`:
       ```typescript
       export const CASE_INDEX_MAPPING = {
         mappings: {
           properties: {
             referenceNumber: { type: 'keyword' },
             status: { type: 'keyword' },
             severity: { type: 'keyword' },
             categoryName: { type: 'keyword' },
             categoryId: { type: 'keyword' },
             details: { type: 'text', analyzer: 'standard' },
             summary: { type: 'text', analyzer: 'standard' },
             aiSummary: { type: 'text', analyzer: 'standard' },
             assigneeId: { type: 'keyword' },
             assigneeName: { type: 'text' },
             createdById: { type: 'keyword' },
             createdAt: { type: 'date' },
             updatedAt: { type: 'date' },
             // Denormalized for filtering
             businessUnitId: { type: 'keyword' },
             locationId: { type: 'keyword' },
             locationCity: { type: 'keyword' },
             locationCountry: { type: 'keyword' },
             sourceChannel: { type: 'keyword' },
             reporterType: { type: 'keyword' },
             tags: { type: 'keyword' },
           },
         },
         settings: {
           number_of_shards: 1,
           number_of_replicas: 0,  // Dev setting - increase in prod
           analysis: {
             analyzer: {
               compliance_analyzer: {
                 type: 'custom',
                 tokenizer: 'standard',
                 filter: ['lowercase', 'asciifolding', 'compliance_synonyms'],
               },
             },
             filter: {
               compliance_synonyms: {
                 type: 'synonym',
                 synonyms: [
                   'harassment, bullying, hostile work environment',
                   'theft, stealing, embezzlement',
                   'fraud, deception, misrepresentation',
                   'discrimination, bias, prejudice',
                   'retaliation, retribution, revenge',
                 ],
               },
             },
           },
         },
       };
       ```

    2. Create RIU mapping similarly in `apps/backend/src/modules/search/indexing/index-mappings/riu.mapping.ts`.

    3. Create `apps/backend/src/modules/search/indexing/indexing.service.ts`:
       ```typescript
       import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
       import { ElasticsearchService } from '@nestjs/elasticsearch';
       import { InjectQueue } from '@nestjs/bullmq';
       import { Queue } from 'bullmq';
       import { INDEXING_QUEUE_NAME } from '../../jobs/queues/indexing.queue';
       import { IndexingJobData } from '../../jobs/types/job-data.types';
       import { CASE_INDEX_MAPPING } from './index-mappings/case.mapping';
       import { RIU_INDEX_MAPPING } from './index-mappings/riu.mapping';

       @Injectable()
       export class IndexingService implements OnModuleInit {
         private readonly logger = new Logger(IndexingService.name);

         constructor(
           private readonly esService: ElasticsearchService,
           @InjectQueue(INDEXING_QUEUE_NAME) private readonly indexingQueue: Queue,
         ) {}

         async onModuleInit() {
           // Verify ES connection
           try {
             const health = await this.esService.cluster.health({});
             this.logger.log(`Elasticsearch cluster status: ${health.status}`);
           } catch (error) {
             this.logger.warn(`Elasticsearch not available: ${error.message}`);
           }
         }

         /**
          * Get index name for a tenant and entity type
          * Per CONTEXT.md: org_{tenantId}_cases, org_{tenantId}_rius, etc.
          */
         getIndexName(organizationId: string, entityType: string): string {
           return `org_${organizationId}_${entityType}`.toLowerCase();
         }

         /**
          * Ensure index exists with correct mapping
          */
         async ensureIndex(organizationId: string, entityType: string): Promise<void> {
           const indexName = this.getIndexName(organizationId, entityType);

           try {
             const exists = await this.esService.indices.exists({ index: indexName });

             if (!exists) {
               const mapping = this.getMappingForType(entityType);
               await this.esService.indices.create({
                 index: indexName,
                 ...mapping,
               });
               this.logger.log(`Created index: ${indexName}`);
             }
           } catch (error) {
             this.logger.error(`Failed to ensure index ${indexName}: ${error.message}`);
           }
         }

         /**
          * Queue a document for indexing (async)
          */
         async queueIndex(params: {
           organizationId: string;
           entityType: string;
           entityId: string;
           operation: 'create' | 'update' | 'delete';
         }): Promise<void> {
           const jobData: IndexingJobData = {
             organizationId: params.organizationId,
             entityType: params.entityType,
             entityId: params.entityId,
             operation: params.operation,
           };

           // Include orgId in job ID to prevent tenant collision
           await this.indexingQueue.add('index-entity', jobData, {
             jobId: `${params.organizationId}:${params.entityType}:${params.entityId}:${Date.now()}`,
           });
         }

         /**
          * Index a document directly (called by job processor)
          */
         async indexDocument(
           organizationId: string,
           entityType: string,
           entityId: string,
           document: Record<string, unknown>,
         ): Promise<void> {
           await this.ensureIndex(organizationId, entityType);
           const indexName = this.getIndexName(organizationId, entityType);

           await this.esService.index({
             index: indexName,
             id: entityId,
             document,
             refresh: false,  // Don't wait for refresh (eventual consistency)
           });
         }

         /**
          * Delete a document from index
          */
         async deleteDocument(
           organizationId: string,
           entityType: string,
           entityId: string,
         ): Promise<void> {
           const indexName = this.getIndexName(organizationId, entityType);

           try {
             await this.esService.delete({
               index: indexName,
               id: entityId,
               refresh: false,
             });
           } catch (error) {
             if (error.meta?.statusCode !== 404) {
               throw error;
             }
             // Ignore 404 - document already gone
           }
         }

         private getMappingForType(entityType: string) {
           switch (entityType.toLowerCase()) {
             case 'cases':
               return CASE_INDEX_MAPPING;
             case 'rius':
               return RIU_INDEX_MAPPING;
             default:
               return {};
           }
         }
       }
       ```

    4. Create `apps/backend/src/modules/search/handlers/case-indexing.handler.ts`:
       ```typescript
       import { Injectable, Logger } from '@nestjs/common';
       import { OnEvent } from '@nestjs/event-emitter';
       import { PrismaService } from '../../prisma/prisma.service';
       import { IndexingService } from '../indexing/indexing.service';
       import { CaseCreatedEvent, CaseUpdatedEvent } from '../../events/events';

       @Injectable()
       export class CaseIndexingHandler {
         private readonly logger = new Logger(CaseIndexingHandler.name);

         constructor(
           private prisma: PrismaService,
           private indexingService: IndexingService,
         ) {}

         @OnEvent('case.created', { async: true })
         async handleCaseCreated(event: CaseCreatedEvent): Promise<void> {
           this.logger.log(`Queueing index for new case: ${event.caseId}`);
           await this.indexingService.queueIndex({
             organizationId: event.organizationId,
             entityType: 'cases',
             entityId: event.caseId,
             operation: 'create',
           });
         }

         @OnEvent('case.updated', { async: true })
         async handleCaseUpdated(event: CaseUpdatedEvent): Promise<void> {
           await this.indexingService.queueIndex({
             organizationId: event.organizationId,
             entityType: 'cases',
             entityId: event.caseId,
             operation: 'update',
           });
         }
       }
       ```

    5. Update indexing processor to actually index:
       Update `apps/backend/src/modules/jobs/processors/indexing.processor.ts` to inject IndexingService and PrismaService, load entity data, and call indexDocument.
  </action>
  <verify>
    - Files compile: `cd apps/backend && npx tsc --noEmit`
    - ES running: `curl http://localhost:9200`
  </verify>
  <done>IndexingService with per-tenant indices and event-driven queue integration created</done>
</task>

<task type="auto">
  <name>Task 3: Create search service with permission filtering</name>
  <files>
    apps/backend/src/modules/search/search.service.ts
    apps/backend/src/modules/search/query/query-builder.service.ts
    apps/backend/src/modules/search/query/permission-filter.service.ts
    apps/backend/src/modules/search/dto/search-query.dto.ts
    apps/backend/src/modules/search/dto/search-result.dto.ts
    apps/backend/src/modules/search/search.controller.ts
    apps/backend/src/modules/search/search.module.ts
    apps/backend/src/app.module.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/search/dto/search-query.dto.ts`:
       ```typescript
       import { IsOptional, IsString, IsArray, IsInt, Min, Max, IsEnum } from 'class-validator';
       import { Type } from 'class-transformer';

       export class SearchQueryDto {
         @IsOptional()
         @IsString()
         q?: string;  // Free text query

         @IsOptional()
         @IsArray()
         @IsString({ each: true })
         entityTypes?: string[];  // ['cases', 'rius', 'policies']

         @IsOptional()
         filters?: Record<string, string | string[]>;  // { status: 'OPEN', severity: ['HIGH', 'MEDIUM'] }

         @IsOptional()
         @IsString()
         sortBy?: string;

         @IsOptional()
         @IsEnum(['asc', 'desc'])
         sortOrder?: 'asc' | 'desc' = 'desc';

         @IsOptional()
         @Type(() => Number)
         @IsInt()
         @Min(0)
         offset?: number = 0;

         @IsOptional()
         @Type(() => Number)
         @IsInt()
         @Min(1)
         @Max(100)
         limit?: number = 25;
       }
       ```

    2. Create `apps/backend/src/modules/search/query/permission-filter.service.ts`:
       ```typescript
       import { Injectable } from '@nestjs/common';
       import { PrismaService } from '../../prisma/prisma.service';
       import { UserRole } from '@prisma/client';

       export interface PermissionContext {
         userId: string;
         organizationId: string;
         role: UserRole;
       }

       @Injectable()
       export class PermissionFilterService {
         constructor(private prisma: PrismaService) {}

         /**
          * Build Elasticsearch filter clauses based on user permissions
          * Per CONTEXT.md: "Permission filters injected into ES query"
          */
         async buildPermissionFilter(
           ctx: PermissionContext,
           entityType: string,
         ): Promise<Array<Record<string, unknown>>> {
           const filters: Array<Record<string, unknown>> = [];

           // System admins and compliance officers see everything in their org
           if ([UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER].includes(ctx.role)) {
             return filters;  // No additional filtering
           }

           // Investigators only see cases they're assigned to
           if (ctx.role === UserRole.INVESTIGATOR) {
             if (entityType === 'cases') {
               // Get case IDs where user is assigned as investigator
               const investigations = await this.prisma.investigation.findMany({
                 where: {
                   organizationId: ctx.organizationId,
                   primaryInvestigatorId: ctx.userId,
                 },
                 select: { caseId: true },
               });

               const caseIds = investigations.map(i => i.caseId);

               if (caseIds.length > 0) {
                 filters.push({
                   terms: { _id: caseIds },
                 });
               } else {
                 // No access - filter to impossible condition
                 filters.push({
                   term: { _id: '__no_access__' },
                 });
               }
             }
           }

           // Employees only see their own reports
           if (ctx.role === UserRole.EMPLOYEE) {
             filters.push({
               term: { createdById: ctx.userId },
             });
           }

           return filters;
         }
       }
       ```

    3. Create `apps/backend/src/modules/search/search.service.ts`:
       ```typescript
       import { Injectable, Logger } from '@nestjs/common';
       import { ElasticsearchService } from '@nestjs/elasticsearch';
       import { IndexingService } from './indexing/indexing.service';
       import { PermissionFilterService, PermissionContext } from './query/permission-filter.service';
       import { SearchQueryDto } from './dto/search-query.dto';

       export interface SearchResult {
         hits: Array<{
           id: string;
           type: string;
           score: number;
           document: Record<string, unknown>;
           highlight?: Record<string, string[]>;
         }>;
         total: number;
         aggregations?: Record<string, unknown>;
         took: number;
       }

       @Injectable()
       export class SearchService {
         private readonly logger = new Logger(SearchService.name);

         constructor(
           private esService: ElasticsearchService,
           private indexingService: IndexingService,
           private permissionService: PermissionFilterService,
         ) {}

         async search(
           ctx: PermissionContext,
           query: SearchQueryDto,
         ): Promise<SearchResult> {
           const entityTypes = query.entityTypes || ['cases'];
           const indices = entityTypes.map(t =>
             this.indexingService.getIndexName(ctx.organizationId, t),
           );

           // Build permission filters
           const permissionFilters: Array<Record<string, unknown>> = [];
           for (const entityType of entityTypes) {
             const filters = await this.permissionService.buildPermissionFilter(ctx, entityType);
             permissionFilters.push(...filters);
           }

           // Build main query
           const must: Array<Record<string, unknown>> = [];
           if (query.q) {
             must.push({
               multi_match: {
                 query: query.q,
                 fields: ['*'],
                 fuzziness: 'AUTO',
                 operator: 'and',
               },
             });
           }

           // Build filters from query params
           const filter: Array<Record<string, unknown>> = [...permissionFilters];
           if (query.filters) {
             for (const [field, value] of Object.entries(query.filters)) {
               if (Array.isArray(value)) {
                 filter.push({ terms: { [field]: value } });
               } else {
                 filter.push({ term: { [field]: value } });
               }
             }
           }

           // Execute search
           const response = await this.esService.search({
             index: indices,
             body: {
               query: {
                 bool: {
                   must: must.length > 0 ? must : [{ match_all: {} }],
                   filter,
                 },
               },
               highlight: {
                 fields: {
                   details: { pre_tags: ['<mark>'], post_tags: ['</mark>'] },
                   summary: { pre_tags: ['<mark>'], post_tags: ['</mark>'] },
                   aiSummary: { pre_tags: ['<mark>'], post_tags: ['</mark>'] },
                 },
               },
               aggs: {
                 by_status: { terms: { field: 'status' } },
                 by_severity: { terms: { field: 'severity' } },
                 by_category: { terms: { field: 'categoryName' } },
               },
               from: query.offset,
               size: query.limit,
               sort: query.sortBy
                 ? [{ [query.sortBy]: query.sortOrder || 'desc' }]
                 : [{ _score: 'desc' }, { createdAt: 'desc' }],
             },
           });

           return {
             hits: response.hits.hits.map(hit => ({
               id: hit._id,
               type: hit._index.split('_').pop() || 'unknown',
               score: hit._score || 0,
               document: hit._source as Record<string, unknown>,
               highlight: hit.highlight as Record<string, string[]>,
             })),
             total: typeof response.hits.total === 'number'
               ? response.hits.total
               : response.hits.total?.value || 0,
             aggregations: response.aggregations as Record<string, unknown>,
             took: response.took,
           };
         }
       }
       ```

    4. Create `apps/backend/src/modules/search/search.controller.ts`:
       ```typescript
       import { Controller, Get, Query, UseGuards } from '@nestjs/common';
       import { JwtAuthGuard } from '../../common/guards/jwt-auth.guard';
       import { TenantGuard } from '../../common/guards/tenant.guard';
       import { CurrentUser } from '../../common/decorators/current-user.decorator';
       import { TenantId } from '../../common/decorators/tenant-id.decorator';
       import { SearchService } from './search.service';
       import { SearchQueryDto } from './dto/search-query.dto';

       @Controller('api/v1/search')
       @UseGuards(JwtAuthGuard, TenantGuard)
       export class SearchController {
         constructor(private searchService: SearchService) {}

         @Get()
         async search(
           @CurrentUser() user: { id: string; role: string },
           @TenantId() orgId: string,
           @Query() query: SearchQueryDto,
         ) {
           return this.searchService.search(
             { userId: user.id, organizationId: orgId, role: user.role as any },
             query,
           );
         }
       }
       ```

    5. Create `apps/backend/src/modules/search/search.module.ts`:
       ```typescript
       import { Module } from '@nestjs/common';
       import { ElasticsearchModule } from '@nestjs/elasticsearch';
       import { ConfigService } from '@nestjs/config';
       import { SearchService } from './search.service';
       import { IndexingService } from './indexing/indexing.service';
       import { PermissionFilterService } from './query/permission-filter.service';
       import { CaseIndexingHandler } from './handlers/case-indexing.handler';
       import { SearchController } from './search.controller';

       @Module({
         imports: [
           ElasticsearchModule.registerAsync({
             useFactory: (configService: ConfigService) => ({
               node: configService.get('elasticsearch.node'),
               maxRetries: configService.get('elasticsearch.maxRetries'),
               requestTimeout: configService.get('elasticsearch.requestTimeout'),
             }),
             inject: [ConfigService],
           }),
         ],
         providers: [
           SearchService,
           IndexingService,
           PermissionFilterService,
           CaseIndexingHandler,
         ],
         controllers: [SearchController],
         exports: [SearchService, IndexingService],
       })
       export class SearchModule {}
       ```

    6. Update `apps/backend/src/app.module.ts`:
       - Import SearchModule
       - Add to imports array
  </action>
  <verify>
    - App builds: `cd apps/backend && npm run build`
    - App starts: `cd apps/backend && npm run start:dev` (check ES connection log)
    - Search endpoint accessible: GET /api/v1/search?q=test
  </verify>
  <done>SearchService with permission filtering, fuzzy matching, and highlighting created</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build succeeds: `cd apps/backend && npm run build`
2. Elasticsearch running: `curl http://localhost:9200/_cluster/health`
3. Create a case, wait 2-5 seconds
4. Search for case: GET /api/v1/search?q=<keyword>
5. Verify results include highlighting and aggregations
6. Verify permission filtering (investigator sees only assigned cases)
</verification>

<success_criteria>
- Per-tenant indices: org_{tenantId}_cases pattern
- Async indexing via job queue (2-5s eventual consistency)
- Search returns results with highlighting and facets
- Permission filters injected at query time (CRITICAL for security)
- Fuzzy matching and compliance synonyms supported
- Search responds within 500ms
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-06-SUMMARY.md`
</output>
