---
phase: 01-foundation-infrastructure
plan: 04
type: execute
wave: 3
depends_on: ["01-01", "01-02", "01-03"]
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/workflow/workflow.module.ts
  - apps/backend/src/modules/workflow/entities/workflow-template.entity.ts
  - apps/backend/src/modules/workflow/entities/workflow-instance.entity.ts
  - apps/backend/src/modules/workflow/engine/workflow-engine.service.ts
  - apps/backend/src/modules/workflow/engine/step-executor.service.ts
  - apps/backend/src/modules/workflow/dto/create-workflow-template.dto.ts
  - apps/backend/src/modules/workflow/workflow.controller.ts
  - apps/backend/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "Workflow templates define pipelines with stages, steps, and transitions"
    - "Workflow instances track entity progress through pipeline"
    - "Workflow engine transitions entities according to pipeline definitions"
    - "In-flight instances complete on their version when template is updated"
    - "Workflow events are emitted for audit and notification integration"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "WorkflowTemplate, WorkflowStage, WorkflowInstance models"
      contains: "WorkflowTemplate"
    - path: "apps/backend/src/modules/workflow/engine/workflow-engine.service.ts"
      provides: "Core workflow execution logic"
      contains: "transition"
    - path: "apps/backend/src/modules/workflow/workflow.module.ts"
      provides: "Workflow module with engine and services"
      exports: ["WorkflowEngineService"]
  key_links:
    - from: "apps/backend/src/modules/workflow/engine/workflow-engine.service.ts"
      to: "EventEmitter2"
      via: "this.eventEmitter.emit"
      pattern: "workflow\\."
---

<objective>
Build the workflow engine that manages configurable pipelines, stages, and transitions for entity lifecycle management.

Purpose: Cases, Investigations, Disclosures, and Policies all need configurable workflows. This engine provides the foundation for status transitions, approval chains, and automated routing.

Output: Workflow models in Prisma, WorkflowEngineService with transition logic, and template CRUD API.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md
@.planning/phases/01-foundation-infrastructure/01-03-SUMMARY.md
@apps/backend/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Workflow Prisma models</name>
  <files>
    apps/backend/prisma/schema.prisma
  </files>
  <action>
    1. Add WorkflowTemplate model:
       ```prisma
       /// WorkflowTemplate defines a reusable workflow pipeline.
       /// Templates are versioned - version increments on publish.
       /// entityType determines which entities this workflow applies to.
       model WorkflowTemplate {
         id             String @id @default(uuid())
         organizationId String @map("organization_id")

         // Identity
         name        String
         description String?
         entityType  WorkflowEntityType @map("entity_type") // CASE, INVESTIGATION, DISCLOSURE, etc.
         version     Int    @default(1)
         isActive    Boolean @default(true) @map("is_active")
         isDefault   Boolean @default(false) @map("is_default") // Default workflow for this entity type

         // Configuration (JSON)
         stages        Json  // Array of WorkflowStage definitions
         transitions   Json  // Array of allowed transitions
         initialStage  String @map("initial_stage") // Stage ID to start at

         // SLA Configuration
         defaultSlaDays Int? @map("default_sla_days")
         slaConfig      Json? @map("sla_config") // Stage-level SLA overrides

         // Metadata
         sourceTemplateId String? @map("source_template_id") // If cloned from Ethico library
         tags             String[] @default([])

         // Audit
         createdAt   DateTime @default(now()) @map("created_at")
         updatedAt   DateTime @updatedAt @map("updated_at")
         createdById String?  @map("created_by_id")

         // Relations
         organization Organization      @relation(fields: [organizationId], references: [id], onDelete: Cascade)
         instances    WorkflowInstance[]

         @@unique([organizationId, name, version])
         @@index([organizationId])
         @@index([organizationId, entityType])
         @@index([organizationId, isActive])
         @@map("workflow_templates")
       }

       enum WorkflowEntityType {
         CASE
         INVESTIGATION
         DISCLOSURE
         POLICY
         CAMPAIGN

         @@map("workflow_entity_type")
       }
       ```

    2. Add WorkflowInstance model:
       ```prisma
       /// WorkflowInstance tracks an entity's progress through a workflow.
       /// Links to the specific template VERSION to ensure in-flight stability.
       model WorkflowInstance {
         id             String @id @default(uuid())
         organizationId String @map("organization_id")
         templateId     String @map("template_id")
         templateVersion Int   @map("template_version")

         // Entity Reference (polymorphic)
         entityType WorkflowEntityType @map("entity_type")
         entityId   String             @map("entity_id")

         // Current State
         currentStage   String   @map("current_stage")
         currentStep    String?  @map("current_step")
         status         WorkflowInstanceStatus @default(ACTIVE)
         stepStates     Json     @default("{}") @map("step_states") // { stepId: { status, completedAt, assignee } }

         // SLA Tracking
         dueDate       DateTime? @map("due_date")
         slaStatus     SlaStatus @default(ON_TRACK) @map("sla_status")
         slaBreachedAt DateTime? @map("sla_breached_at")

         // Completion
         completedAt DateTime? @map("completed_at")
         outcome     String?   // Final outcome (if workflow has outcomes)

         // Audit
         createdAt   DateTime @default(now()) @map("created_at")
         updatedAt   DateTime @updatedAt @map("updated_at")
         startedById String?  @map("started_by_id")

         // Relations
         organization Organization     @relation(fields: [organizationId], references: [id], onDelete: Cascade)
         template     WorkflowTemplate @relation(fields: [templateId], references: [id])

         @@unique([entityType, entityId]) // One active workflow per entity
         @@index([organizationId])
         @@index([organizationId, entityType])
         @@index([organizationId, status])
         @@index([organizationId, currentStage])
         @@index([organizationId, slaStatus])
         @@map("workflow_instances")
       }

       enum WorkflowInstanceStatus {
         ACTIVE
         COMPLETED
         CANCELLED
         PAUSED

         @@map("workflow_instance_status")
       }
       ```

    3. Add relations to Organization model:
       ```prisma
       // In Organization model
       workflowTemplates WorkflowTemplate[]
       workflowInstances WorkflowInstance[]
       ```

    4. Run migration:
       ```bash
       cd apps/backend && npx prisma migrate dev --name add_workflow_models
       ```
  </action>
  <verify>
    - Schema valid: `cd apps/backend && npx prisma validate`
    - Migration runs: Migration file created in prisma/migrations/
    - Prisma client generated: `cd apps/backend && npx prisma generate`
  </verify>
  <done>WorkflowTemplate and WorkflowInstance models added to schema with versioning support</done>
</task>

<task type="auto">
  <name>Task 2: Create WorkflowEngineService with transition logic</name>
  <files>
    apps/backend/src/modules/workflow/workflow.module.ts
    apps/backend/src/modules/workflow/engine/workflow-engine.service.ts
    apps/backend/src/modules/workflow/engine/step-executor.service.ts
    apps/backend/src/modules/workflow/events/workflow.events.ts
    apps/backend/src/modules/workflow/types/workflow.types.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/workflow/types/workflow.types.ts`:
       ```typescript
       export interface WorkflowStage {
         id: string;
         name: string;
         description?: string;
         steps: WorkflowStep[];
         slaDays?: number;
         gates?: StageGate[];
       }

       export interface WorkflowStep {
         id: string;
         name: string;
         type: 'manual' | 'automatic' | 'approval' | 'notification';
         config?: Record<string, unknown>;
         assigneeStrategy?: AssigneeStrategy;
         timeoutHours?: number;
         onTimeout?: 'pause' | 'skip' | 'escalate';
       }

       export interface StageGate {
         type: 'required_fields' | 'approval' | 'condition' | 'time';
         config: Record<string, unknown>;
       }

       export interface WorkflowTransition {
         from: string;  // stage ID or '*' for any
         to: string;    // stage ID
         conditions?: TransitionCondition[];
         actions?: TransitionAction[];
       }

       export interface TransitionCondition {
         type: 'field' | 'approval' | 'time' | 'expression';
         config: Record<string, unknown>;
       }

       export interface TransitionAction {
         type: 'notification' | 'assignment' | 'field_update' | 'webhook';
         config: Record<string, unknown>;
       }

       export type AssigneeStrategy =
         | { type: 'specific_user'; userId: string }
         | { type: 'round_robin'; teamId: string }
         | { type: 'least_loaded'; teamId: string }
         | { type: 'manager_of'; field: string }
         | { type: 'team_queue'; teamId: string };

       export interface TransitionResult {
         success: boolean;
         previousStage: string;
         newStage: string;
         error?: string;
       }
       ```

    2. Create `apps/backend/src/modules/workflow/events/workflow.events.ts`:
       ```typescript
       import { BaseEvent } from '../../events/events/base.event';

       export class WorkflowInstanceCreatedEvent extends BaseEvent {
         static readonly eventName = 'workflow.instance_created';
         instanceId: string;
         templateId: string;
         entityType: string;
         entityId: string;
         initialStage: string;
       }

       export class WorkflowTransitionedEvent extends BaseEvent {
         static readonly eventName = 'workflow.transitioned';
         instanceId: string;
         entityType: string;
         entityId: string;
         previousStage: string;
         newStage: string;
         triggeredBy: string;
       }

       export class WorkflowCompletedEvent extends BaseEvent {
         static readonly eventName = 'workflow.completed';
         instanceId: string;
         entityType: string;
         entityId: string;
         outcome: string;
       }

       export class WorkflowSlaBreach extends BaseEvent {
         static readonly eventName = 'workflow.sla_breach';
         instanceId: string;
         entityType: string;
         entityId: string;
         stage: string;
         breachLevel: 'warning' | 'breached' | 'critical';
       }
       ```

    3. Create `apps/backend/src/modules/workflow/engine/workflow-engine.service.ts`:
       ```typescript
       import { Injectable, Logger, BadRequestException, NotFoundException } from '@nestjs/common';
       import { EventEmitter2 } from '@nestjs/event-emitter';
       import { PrismaService } from '../../prisma/prisma.service';
       import { WorkflowEntityType, WorkflowInstanceStatus, Prisma } from '@prisma/client';
       import { WorkflowStage, WorkflowTransition, TransitionResult } from '../types/workflow.types';
       import {
         WorkflowInstanceCreatedEvent,
         WorkflowTransitionedEvent,
         WorkflowCompletedEvent,
       } from '../events/workflow.events';

       @Injectable()
       export class WorkflowEngineService {
         private readonly logger = new Logger(WorkflowEngineService.name);

         constructor(
           private prisma: PrismaService,
           private eventEmitter: EventEmitter2,
         ) {}

         /**
          * Start a new workflow instance for an entity
          */
         async startWorkflow(params: {
           organizationId: string;
           entityType: WorkflowEntityType;
           entityId: string;
           templateId?: string;
           actorUserId?: string;
         }): Promise<string> {
           const { organizationId, entityType, entityId, templateId, actorUserId } = params;

           // Find template (specific or default for entity type)
           const template = templateId
             ? await this.prisma.workflowTemplate.findFirst({
                 where: { id: templateId, organizationId, isActive: true },
               })
             : await this.prisma.workflowTemplate.findFirst({
                 where: { organizationId, entityType, isDefault: true, isActive: true },
               });

           if (!template) {
             throw new NotFoundException(`No active workflow template found for ${entityType}`);
           }

           const stages = template.stages as unknown as WorkflowStage[];
           const initialStage = stages.find(s => s.id === template.initialStage);

           if (!initialStage) {
             throw new BadRequestException('Invalid workflow template: initial stage not found');
           }

           // Calculate due date from SLA
           const dueDate = template.defaultSlaDays
             ? new Date(Date.now() + template.defaultSlaDays * 24 * 60 * 60 * 1000)
             : null;

           // Create instance locked to this template VERSION
           const instance = await this.prisma.workflowInstance.create({
             data: {
               organizationId,
               templateId: template.id,
               templateVersion: template.version,
               entityType,
               entityId,
               currentStage: template.initialStage,
               status: WorkflowInstanceStatus.ACTIVE,
               stepStates: {},
               dueDate,
               startedById: actorUserId,
             },
           });

           // Emit event
           this.eventEmitter.emit(
             WorkflowInstanceCreatedEvent.eventName,
             new WorkflowInstanceCreatedEvent({
               organizationId,
               actorUserId,
               actorType: actorUserId ? 'USER' : 'SYSTEM',
               instanceId: instance.id,
               templateId: template.id,
               entityType,
               entityId,
               initialStage: template.initialStage,
             }),
           );

           this.logger.log(`Started workflow ${instance.id} for ${entityType}:${entityId}`);
           return instance.id;
         }

         /**
          * Transition entity to a new stage
          */
         async transition(params: {
           instanceId: string;
           toStage: string;
           actorUserId?: string;
           validateGates?: boolean;
         }): Promise<TransitionResult> {
           const { instanceId, toStage, actorUserId, validateGates = true } = params;

           const instance = await this.prisma.workflowInstance.findUnique({
             where: { id: instanceId },
             include: { template: true },
           });

           if (!instance) {
             return { success: false, previousStage: '', newStage: toStage, error: 'Instance not found' };
           }

           if (instance.status !== WorkflowInstanceStatus.ACTIVE) {
             return { success: false, previousStage: instance.currentStage, newStage: toStage, error: 'Workflow not active' };
           }

           const transitions = instance.template.transitions as unknown as WorkflowTransition[];
           const stages = instance.template.stages as unknown as WorkflowStage[];

           // Validate transition is allowed
           const allowedTransition = transitions.find(
             t => (t.from === instance.currentStage || t.from === '*') && t.to === toStage,
           );

           if (!allowedTransition) {
             return {
               success: false,
               previousStage: instance.currentStage,
               newStage: toStage,
               error: `Transition from ${instance.currentStage} to ${toStage} not allowed`,
             };
           }

           // Validate stage gates if required
           if (validateGates) {
             const currentStage = stages.find(s => s.id === instance.currentStage);
             if (currentStage?.gates) {
               const gateResult = await this.validateGates(currentStage.gates, instance);
               if (!gateResult.valid) {
                 return {
                   success: false,
                   previousStage: instance.currentStage,
                   newStage: toStage,
                   error: `Gate validation failed: ${gateResult.error}`,
                 };
               }
             }
           }

           const previousStage = instance.currentStage;

           // Perform transition
           await this.prisma.workflowInstance.update({
             where: { id: instanceId },
             data: {
               currentStage: toStage,
               stepStates: {
                 ...(instance.stepStates as object),
                 [previousStage]: {
                   completedAt: new Date().toISOString(),
                   completedBy: actorUserId,
                 },
               },
             },
           });

           // Emit event
           this.eventEmitter.emit(
             WorkflowTransitionedEvent.eventName,
             new WorkflowTransitionedEvent({
               organizationId: instance.organizationId,
               actorUserId,
               actorType: actorUserId ? 'USER' : 'SYSTEM',
               instanceId,
               entityType: instance.entityType,
               entityId: instance.entityId,
               previousStage,
               newStage: toStage,
               triggeredBy: actorUserId || 'system',
             }),
           );

           this.logger.log(`Transitioned ${instanceId} from ${previousStage} to ${toStage}`);

           return { success: true, previousStage, newStage: toStage };
         }

         /**
          * Complete a workflow instance
          */
         async complete(params: {
           instanceId: string;
           outcome?: string;
           actorUserId?: string;
         }): Promise<void> {
           const { instanceId, outcome, actorUserId } = params;

           const instance = await this.prisma.workflowInstance.update({
             where: { id: instanceId },
             data: {
               status: WorkflowInstanceStatus.COMPLETED,
               completedAt: new Date(),
               outcome,
             },
           });

           this.eventEmitter.emit(
             WorkflowCompletedEvent.eventName,
             new WorkflowCompletedEvent({
               organizationId: instance.organizationId,
               actorUserId,
               actorType: actorUserId ? 'USER' : 'SYSTEM',
               instanceId,
               entityType: instance.entityType,
               entityId: instance.entityId,
               outcome: outcome || 'completed',
             }),
           );
         }

         /**
          * Get current workflow state for an entity
          */
         async getInstanceByEntity(
           organizationId: string,
           entityType: WorkflowEntityType,
           entityId: string,
         ) {
           return this.prisma.workflowInstance.findUnique({
             where: {
               entityType_entityId: { entityType, entityId },
             },
             include: { template: true },
           });
         }

         private async validateGates(
           gates: { type: string; config: Record<string, unknown> }[],
           instance: any,
         ): Promise<{ valid: boolean; error?: string }> {
           // Placeholder - full gate validation in future iteration
           for (const gate of gates) {
             if (gate.type === 'required_fields') {
               // Would check entity has required fields filled
             }
             if (gate.type === 'approval') {
               // Would check approval status
             }
           }
           return { valid: true };
         }
       }
       ```

    4. Create barrel export and index files.
  </action>
  <verify>
    - Files compile: `cd apps/backend && npx tsc --noEmit`
    - All imports resolve
  </verify>
  <done>WorkflowEngineService created with startWorkflow, transition, and complete methods</done>
</task>

<task type="auto">
  <name>Task 3: Create WorkflowModule and Controller</name>
  <files>
    apps/backend/src/modules/workflow/workflow.module.ts
    apps/backend/src/modules/workflow/workflow.service.ts
    apps/backend/src/modules/workflow/workflow.controller.ts
    apps/backend/src/modules/workflow/dto/create-workflow-template.dto.ts
    apps/backend/src/modules/workflow/dto/transition.dto.ts
    apps/backend/src/modules/workflow/dto/index.ts
    apps/backend/src/app.module.ts
  </files>
  <action>
    1. Create DTOs in `apps/backend/src/modules/workflow/dto/`:
       - `create-workflow-template.dto.ts`: name, description, entityType, stages, transitions, initialStage, defaultSlaDays
       - `update-workflow-template.dto.ts`: PartialType of create
       - `transition.dto.ts`: toStage, validateGates (optional boolean)

    2. Create `apps/backend/src/modules/workflow/workflow.service.ts`:
       - Template CRUD operations
       - findByEntityType, findDefault
       - Version on publish (increment version, create copy if instances exist)

    3. Create `apps/backend/src/modules/workflow/workflow.controller.ts`:
       ```typescript
       @Controller('api/v1/workflows')
       @UseGuards(JwtAuthGuard, TenantGuard, RolesGuard)
       export class WorkflowController {
         constructor(
           private workflowService: WorkflowService,
           private workflowEngine: WorkflowEngineService,
         ) {}

         // Template endpoints
         @Post('templates')
         @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
         async createTemplate(...) { }

         @Get('templates')
         async listTemplates(...) { }

         @Get('templates/:id')
         async getTemplate(...) { }

         @Patch('templates/:id')
         @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
         async updateTemplate(...) { }

         // Instance endpoints
         @Post('instances')
         async startWorkflow(...) { }

         @Get('instances/:id')
         async getInstance(...) { }

         @Post('instances/:id/transition')
         async transition(@Param('id') id: string, @Body() dto: TransitionDto) { }

         @Get('entity/:entityType/:entityId')
         async getByEntity(...) { }
       }
       ```

    4. Create `apps/backend/src/modules/workflow/workflow.module.ts`:
       ```typescript
       import { Module } from '@nestjs/common';
       import { WorkflowEngineService } from './engine/workflow-engine.service';
       import { WorkflowService } from './workflow.service';
       import { WorkflowController } from './workflow.controller';

       @Module({
         providers: [WorkflowEngineService, WorkflowService],
         controllers: [WorkflowController],
         exports: [WorkflowEngineService, WorkflowService],
       })
       export class WorkflowModule {}
       ```

    5. Update `apps/backend/src/app.module.ts`:
       - Import WorkflowModule
       - Add to imports array
  </action>
  <verify>
    - App builds: `cd apps/backend && npm run build`
    - App starts: `cd apps/backend && npm run start:dev`
    - POST /api/v1/workflows/templates creates a template
    - GET /api/v1/workflows/templates lists templates
  </verify>
  <done>WorkflowModule with template CRUD and instance management API created</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build succeeds: `cd apps/backend && npm run build`
2. Database has workflow_templates and workflow_instances tables
3. Can create a workflow template via API
4. Can start a workflow instance for an entity
5. Can transition workflow between stages
6. Workflow events are emitted (check audit log)
</verification>

<success_criteria>
- WorkflowTemplate stores versioned pipeline definitions
- WorkflowInstance tracks entity progress, locked to template version
- WorkflowEngineService validates and executes transitions
- Events emitted for instance creation, transitions, completion
- API allows template CRUD and instance management
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-04-SUMMARY.md`
</output>
