---
phase: 01-foundation-infrastructure
plan: 08
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/reporting/reporting.module.ts
  - apps/backend/src/modules/reporting/query-builder.service.ts
  - apps/backend/src/modules/reporting/report-template.service.ts
  - apps/backend/src/modules/reporting/export.service.ts
  - apps/backend/src/modules/reporting/dto/report-query.dto.ts
  - apps/backend/src/modules/reporting/reporting.controller.ts
  - apps/backend/src/app.module.ts
  - apps/backend/package.json
autonomous: true

must_haves:
  truths:
    - "Query builder generates Prisma queries from report definitions"
    - "Reports can be exported to Excel with streaming for large datasets"
    - "Report templates define columns, filters, and aggregations"
    - "Report generation runs in job queue for large reports"
    - "Pre-built report templates exist for common compliance reports"
  artifacts:
    - path: "apps/backend/src/modules/reporting/query-builder.service.ts"
      provides: "Dynamic Prisma query generation"
      contains: "buildQuery"
    - path: "apps/backend/src/modules/reporting/export.service.ts"
      provides: "Excel and CSV export"
      contains: "exportToExcel"
    - path: "apps/backend/prisma/schema.prisma"
      provides: "ReportTemplate model"
      contains: "ReportTemplate"
  key_links:
    - from: "apps/backend/src/modules/reporting/export.service.ts"
      to: "job queue"
      via: "@InjectQueue"
      pattern: "export"
---

<objective>
Build the reporting engine with query builder framework for dynamic reports, Excel/CSV export, and report templates.

Purpose: Compliance teams need custom reports (case aging, category breakdown, SLA performance). This engine provides a flexible framework for defining and generating reports.

Output: QueryBuilder service, export service, and report template API.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md
@apps/backend/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ReportTemplate model and install ExcelJS</name>
  <files>
    apps/backend/prisma/schema.prisma
    apps/backend/package.json
  </files>
  <action>
    1. Install ExcelJS for Excel export:
       ```bash
       cd apps/backend && npm install exceljs
       ```

    2. Add ReportTemplate model to schema.prisma:
       ```prisma
       /// ReportTemplate defines reusable report configurations.
       /// Templates specify data source, columns, filters, and aggregations.
       model ReportTemplate {
         id             String @id @default(uuid())
         organizationId String? @map("organization_id")  // Null for system templates

         // Identity
         name        String
         description String?
         category    String?  // 'compliance', 'operational', 'board', etc.
         isSystem    Boolean @default(false) @map("is_system")  // Ethico-provided
         isPublic    Boolean @default(false) @map("is_public")  // Visible to all users

         // Configuration
         dataSource  ReportDataSource @map("data_source")  // CASES, RIUS, INVESTIGATIONS, etc.
         columns     Json  // Array of column definitions
         filters     Json? // Default filters
         aggregations Json? // Sum, count, avg, group by
         sortBy      String? @map("sort_by")
         sortOrder   String? @map("sort_order")

         // Display
         chartType   String? @map("chart_type")  // 'bar', 'pie', 'line', 'table'
         chartConfig Json?   @map("chart_config")

         // Access
         allowedRoles String[] @default([]) @map("allowed_roles")

         // Audit
         createdAt   DateTime @default(now()) @map("created_at")
         updatedAt   DateTime @updatedAt @map("updated_at")
         createdById String?  @map("created_by_id")

         // Relations
         organization Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)
         executions   ReportExecution[]

         @@index([organizationId])
         @@index([dataSource])
         @@index([isSystem])
         @@map("report_templates")
       }

       enum ReportDataSource {
         CASES
         RIUS
         INVESTIGATIONS
         DISCLOSURES
         POLICIES
         AUDIT_LOGS
         USERS
         CAMPAIGNS

         @@map("report_data_source")
       }
       ```

    3. Add ReportExecution model for tracking report runs:
       ```prisma
       /// ReportExecution tracks report generation history.
       /// Used for async report generation and download links.
       model ReportExecution {
         id             String @id @default(uuid())
         organizationId String @map("organization_id")
         templateId     String @map("template_id")

         // Execution details
         status      ReportExecutionStatus @default(PENDING)
         filters     Json?  // Filters used for this execution
         parameters  Json?  // Additional parameters

         // Results
         rowCount    Int?    @map("row_count")
         fileKey     String? @map("file_key")  // Storage key for exported file
         fileUrl     String? @map("file_url")  // Signed URL (temporary)
         expiresAt   DateTime? @map("expires_at")

         // Timing
         startedAt   DateTime? @map("started_at")
         completedAt DateTime? @map("completed_at")
         errorMessage String? @map("error_message")

         // Audit
         createdAt   DateTime @default(now()) @map("created_at")
         requestedById String @map("requested_by_id")

         // Relations
         organization Organization    @relation(fields: [organizationId], references: [id], onDelete: Cascade)
         template     ReportTemplate @relation(fields: [templateId], references: [id])

         @@index([organizationId])
         @@index([organizationId, status])
         @@index([templateId])
         @@map("report_executions")
       }

       enum ReportExecutionStatus {
         PENDING
         RUNNING
         COMPLETED
         FAILED

         @@map("report_execution_status")
       }
       ```

    4. Add relations to Organization:
       ```prisma
       // In Organization model
       reportTemplates  ReportTemplate[]
       reportExecutions ReportExecution[]
       ```

    5. Run migration:
       ```bash
       cd apps/backend && npx prisma migrate dev --name add_reporting
       ```
  </action>
  <verify>
    - Schema valid: `cd apps/backend && npx prisma validate`
    - Migration runs successfully
    - ExcelJS installed: grep exceljs apps/backend/package.json
  </verify>
  <done>ReportTemplate and ReportExecution models created, ExcelJS installed</done>
</task>

<task type="auto">
  <name>Task 2: Create QueryBuilder and ReportTemplate services</name>
  <files>
    apps/backend/src/modules/reporting/query-builder.service.ts
    apps/backend/src/modules/reporting/report-template.service.ts
    apps/backend/src/modules/reporting/types/report.types.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/reporting/types/report.types.ts`:
       ```typescript
       import { ReportDataSource } from '@prisma/client';

       export interface ColumnDefinition {
         field: string;
         label: string;
         type: 'string' | 'number' | 'date' | 'boolean' | 'currency';
         format?: string;  // Date format, number decimals
         width?: number;
         aggregation?: 'sum' | 'count' | 'avg' | 'min' | 'max';
       }

       export interface FilterDefinition {
         field: string;
         operator: 'eq' | 'neq' | 'gt' | 'gte' | 'lt' | 'lte' | 'in' | 'contains' | 'between';
         value: unknown;
       }

       export interface AggregationDefinition {
         type: 'sum' | 'count' | 'avg' | 'min' | 'max' | 'group';
         field: string;
         alias?: string;
         groupBy?: string[];
       }

       export interface ReportQueryResult {
         data: Record<string, unknown>[];
         total: number;
         aggregations?: Record<string, unknown>;
       }

       export interface ReportExecutionParams {
         organizationId: string;
         templateId: string;
         filters?: FilterDefinition[];
         limit?: number;
         offset?: number;
         format?: 'json' | 'excel' | 'csv';
       }
       ```

    2. Create `apps/backend/src/modules/reporting/query-builder.service.ts`:
       ```typescript
       import { Injectable, Logger, BadRequestException } from '@nestjs/common';
       import { PrismaService } from '../prisma/prisma.service';
       import { ReportDataSource, Prisma } from '@prisma/client';
       import { ColumnDefinition, FilterDefinition, ReportQueryResult } from './types/report.types';

       @Injectable()
       export class QueryBuilderService {
         private readonly logger = new Logger(QueryBuilderService.name);

         constructor(private prisma: PrismaService) {}

         async executeQuery(params: {
           organizationId: string;
           dataSource: ReportDataSource;
           columns: ColumnDefinition[];
           filters?: FilterDefinition[];
           sortBy?: string;
           sortOrder?: 'asc' | 'desc';
           limit?: number;
           offset?: number;
         }): Promise<ReportQueryResult> {
           const model = this.getModelForDataSource(params.dataSource);
           const where = this.buildWhereClause(params.organizationId, params.filters);
           const select = this.buildSelectClause(params.columns);
           const orderBy = params.sortBy
             ? { [params.sortBy]: params.sortOrder || 'desc' }
             : { createdAt: 'desc' as const };

           const [data, total] = await Promise.all([
             (this.prisma[model] as any).findMany({
               where,
               select,
               orderBy,
               take: params.limit || 1000,
               skip: params.offset || 0,
             }),
             (this.prisma[model] as any).count({ where }),
           ]);

           return { data, total };
         }

         async executeAggregation(params: {
           organizationId: string;
           dataSource: ReportDataSource;
           filters?: FilterDefinition[];
           groupBy: string[];
           aggregations: { field: string; type: 'count' | 'sum' | 'avg' | 'min' | 'max' }[];
         }): Promise<Record<string, unknown>[]> {
           const model = this.getModelForDataSource(params.dataSource);
           const where = this.buildWhereClause(params.organizationId, params.filters);

           // Build aggregation object
           const agg: Record<string, unknown> = {};
           for (const a of params.aggregations) {
             agg[`_${a.type}`] = { [a.field]: true };
           }

           const result = await (this.prisma[model] as any).groupBy({
             by: params.groupBy,
             where,
             ...agg,
           });

           return result;
         }

         private getModelForDataSource(dataSource: ReportDataSource): string {
           const mapping: Record<ReportDataSource, string> = {
             CASES: 'case',
             RIUS: 'riskIntelligenceUnit',
             INVESTIGATIONS: 'investigation',
             DISCLOSURES: 'formSubmission',  // Disclosure forms are FormSubmissions
             POLICIES: 'policy',
             AUDIT_LOGS: 'auditLog',
             USERS: 'user',
             CAMPAIGNS: 'campaign',
           };
           return mapping[dataSource];
         }

         private buildWhereClause(
           organizationId: string,
           filters?: FilterDefinition[],
         ): Record<string, unknown> {
           const where: Record<string, unknown> = { organizationId };

           if (!filters) return where;

           for (const filter of filters) {
             switch (filter.operator) {
               case 'eq':
                 where[filter.field] = filter.value;
                 break;
               case 'neq':
                 where[filter.field] = { not: filter.value };
                 break;
               case 'gt':
                 where[filter.field] = { gt: filter.value };
                 break;
               case 'gte':
                 where[filter.field] = { gte: filter.value };
                 break;
               case 'lt':
                 where[filter.field] = { lt: filter.value };
                 break;
               case 'lte':
                 where[filter.field] = { lte: filter.value };
                 break;
               case 'in':
                 where[filter.field] = { in: filter.value as unknown[] };
                 break;
               case 'contains':
                 where[filter.field] = { contains: filter.value, mode: 'insensitive' };
                 break;
               case 'between':
                 const [min, max] = filter.value as [unknown, unknown];
                 where[filter.field] = { gte: min, lte: max };
                 break;
             }
           }

           return where;
         }

         private buildSelectClause(columns: ColumnDefinition[]): Record<string, boolean> {
           const select: Record<string, boolean> = { id: true };
           for (const col of columns) {
             select[col.field] = true;
           }
           return select;
         }
       }
       ```

    3. Create `apps/backend/src/modules/reporting/report-template.service.ts`:
       ```typescript
       import { Injectable, Logger, NotFoundException } from '@nestjs/common';
       import { PrismaService } from '../prisma/prisma.service';
       import { ReportDataSource, Prisma } from '@prisma/client';
       import { ColumnDefinition, FilterDefinition } from './types/report.types';

       export interface CreateReportTemplateDto {
         name: string;
         description?: string;
         category?: string;
         dataSource: ReportDataSource;
         columns: ColumnDefinition[];
         filters?: FilterDefinition[];
         sortBy?: string;
         sortOrder?: string;
         chartType?: string;
         allowedRoles?: string[];
       }

       @Injectable()
       export class ReportTemplateService {
         private readonly logger = new Logger(ReportTemplateService.name);

         constructor(private prisma: PrismaService) {}

         async create(organizationId: string, dto: CreateReportTemplateDto, createdById?: string) {
           return this.prisma.reportTemplate.create({
             data: {
               organizationId,
               name: dto.name,
               description: dto.description,
               category: dto.category,
               dataSource: dto.dataSource,
               columns: dto.columns as Prisma.InputJsonValue,
               filters: dto.filters as Prisma.InputJsonValue,
               sortBy: dto.sortBy,
               sortOrder: dto.sortOrder,
               chartType: dto.chartType,
               allowedRoles: dto.allowedRoles,
               createdById,
             },
           });
         }

         async findById(organizationId: string, id: string) {
           const template = await this.prisma.reportTemplate.findFirst({
             where: {
               id,
               OR: [
                 { organizationId },
                 { isSystem: true },
               ],
             },
           });

           if (!template) {
             throw new NotFoundException(`Report template ${id} not found`);
           }

           return template;
         }

         async findAll(organizationId: string, category?: string) {
           return this.prisma.reportTemplate.findMany({
             where: {
               OR: [
                 { organizationId },
                 { isSystem: true },
               ],
               ...(category && { category }),
             },
             orderBy: { name: 'asc' },
           });
         }

         async delete(organizationId: string, id: string) {
           const template = await this.findById(organizationId, id);

           if (template.isSystem) {
             throw new Error('Cannot delete system templates');
           }

           await this.prisma.reportTemplate.delete({ where: { id } });
         }
       }
       ```
  </action>
  <verify>
    - Files compile: `cd apps/backend && npx tsc --noEmit`
  </verify>
  <done>QueryBuilderService for dynamic queries and ReportTemplateService for CRUD created</done>
</task>

<task type="auto">
  <name>Task 3: Create export service and controller</name>
  <files>
    apps/backend/src/modules/reporting/export.service.ts
    apps/backend/src/modules/reporting/dto/run-report.dto.ts
    apps/backend/src/modules/reporting/dto/index.ts
    apps/backend/src/modules/reporting/reporting.controller.ts
    apps/backend/src/modules/reporting/reporting.module.ts
    apps/backend/src/modules/jobs/queues/export.queue.ts
    apps/backend/src/modules/jobs/processors/export.processor.ts
    apps/backend/src/app.module.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/jobs/queues/export.queue.ts`:
       ```typescript
       export const EXPORT_QUEUE_NAME = 'export';

       export const EXPORT_QUEUE_OPTIONS = {
         defaultJobOptions: {
           attempts: 2,
           backoff: { type: 'fixed' as const, delay: 5000 },
           removeOnComplete: { count: 100, age: 60 * 60 },  // 1 hour
           removeOnFail: { count: 500, age: 24 * 60 * 60 },
         },
       };
       ```

    2. Register export queue in jobs.module.ts.

    3. Create `apps/backend/src/modules/reporting/export.service.ts`:
       ```typescript
       import { Injectable, Logger } from '@nestjs/common';
       import { InjectQueue } from '@nestjs/bullmq';
       import { Queue } from 'bullmq';
       import * as ExcelJS from 'exceljs';
       import { PrismaService } from '../prisma/prisma.service';
       import { QueryBuilderService } from './query-builder.service';
       import { ReportTemplateService } from './report-template.service';
       import { EXPORT_QUEUE_NAME } from '../jobs/queues/export.queue';
       import { ColumnDefinition, FilterDefinition } from './types/report.types';
       import { ReportExecutionStatus } from '@prisma/client';

       @Injectable()
       export class ExportService {
         private readonly logger = new Logger(ExportService.name);

         constructor(
           private prisma: PrismaService,
           private queryBuilder: QueryBuilderService,
           private templateService: ReportTemplateService,
           @InjectQueue(EXPORT_QUEUE_NAME) private exportQueue: Queue,
         ) {}

         /**
          * Queue a report for async export (for large reports)
          */
         async queueExport(params: {
           organizationId: string;
           templateId: string;
           filters?: FilterDefinition[];
           format: 'excel' | 'csv';
           requestedById: string;
         }) {
           // Create execution record
           const execution = await this.prisma.reportExecution.create({
             data: {
               organizationId: params.organizationId,
               templateId: params.templateId,
               status: ReportExecutionStatus.PENDING,
               filters: params.filters as any,
               requestedById: params.requestedById,
             },
           });

           // Queue job
           await this.exportQueue.add('export-report', {
             executionId: execution.id,
             organizationId: params.organizationId,
             templateId: params.templateId,
             filters: params.filters,
             format: params.format,
           });

           return { executionId: execution.id, status: 'queued' };
         }

         /**
          * Generate Excel directly (for small reports)
          */
         async exportToExcel(params: {
           organizationId: string;
           templateId: string;
           filters?: FilterDefinition[];
         }): Promise<Buffer> {
           const template = await this.templateService.findById(
             params.organizationId,
             params.templateId,
           );

           const columns = template.columns as unknown as ColumnDefinition[];

           const result = await this.queryBuilder.executeQuery({
             organizationId: params.organizationId,
             dataSource: template.dataSource,
             columns,
             filters: params.filters,
             sortBy: template.sortBy,
             sortOrder: template.sortOrder as 'asc' | 'desc',
             limit: 10000,  // Cap for direct export
           });

           const workbook = new ExcelJS.Workbook();
           workbook.creator = 'Ethico Risk Intelligence Platform';
           workbook.created = new Date();

           const worksheet = workbook.addWorksheet(template.name);

           // Add header row
           worksheet.columns = columns.map(col => ({
             header: col.label,
             key: col.field,
             width: col.width || 15,
           }));

           // Style header
           worksheet.getRow(1).font = { bold: true };
           worksheet.getRow(1).fill = {
             type: 'pattern',
             pattern: 'solid',
             fgColor: { argb: 'FFE0E0E0' },
           };

           // Add data rows
           for (const row of result.data) {
             const formattedRow: Record<string, unknown> = {};
             for (const col of columns) {
               formattedRow[col.field] = this.formatValue(row[col.field], col);
             }
             worksheet.addRow(formattedRow);
           }

           // Auto-filter
           worksheet.autoFilter = {
             from: { row: 1, column: 1 },
             to: { row: 1, column: columns.length },
           };

           return workbook.xlsx.writeBuffer() as Promise<Buffer>;
         }

         /**
          * Generate CSV
          */
         async exportToCsv(params: {
           organizationId: string;
           templateId: string;
           filters?: FilterDefinition[];
         }): Promise<string> {
           const template = await this.templateService.findById(
             params.organizationId,
             params.templateId,
           );

           const columns = template.columns as unknown as ColumnDefinition[];

           const result = await this.queryBuilder.executeQuery({
             organizationId: params.organizationId,
             dataSource: template.dataSource,
             columns,
             filters: params.filters,
             limit: 50000,
           });

           // Build CSV
           const headers = columns.map(c => `"${c.label}"`).join(',');
           const rows = result.data.map(row =>
             columns.map(col => {
               const value = this.formatValue(row[col.field], col);
               return typeof value === 'string' ? `"${value.replace(/"/g, '""')}"` : value;
             }).join(','),
           );

           return [headers, ...rows].join('\n');
         }

         private formatValue(value: unknown, column: ColumnDefinition): unknown {
           if (value === null || value === undefined) return '';

           switch (column.type) {
             case 'date':
               return new Date(value as string).toISOString().split('T')[0];
             case 'currency':
               return typeof value === 'number' ? value.toFixed(2) : value;
             default:
               return value;
           }
         }
       }
       ```

    4. Create `apps/backend/src/modules/reporting/dto/run-report.dto.ts`:
       ```typescript
       import { IsOptional, IsArray, IsEnum, IsInt, Min, Max } from 'class-validator';
       import { Type } from 'class-transformer';

       export class RunReportDto {
         @IsOptional()
         @IsArray()
         filters?: Array<{ field: string; operator: string; value: unknown }>;

         @IsOptional()
         @Type(() => Number)
         @IsInt()
         @Min(1)
         @Max(10000)
         limit?: number = 1000;

         @IsOptional()
         @IsEnum(['json', 'excel', 'csv'])
         format?: 'json' | 'excel' | 'csv' = 'json';
       }
       ```

    5. Create `apps/backend/src/modules/reporting/reporting.controller.ts`:
       ```typescript
       import { Controller, Get, Post, Body, Param, Query, Res, UseGuards } from '@nestjs/common';
       import { Response } from 'express';
       import { JwtAuthGuard } from '../../common/guards/jwt-auth.guard';
       import { TenantGuard } from '../../common/guards/tenant.guard';
       import { RolesGuard } from '../../common/guards/roles.guard';
       import { Roles } from '../../common/decorators/roles.decorator';
       import { CurrentUser } from '../../common/decorators/current-user.decorator';
       import { TenantId } from '../../common/decorators/tenant-id.decorator';
       import { ReportTemplateService, CreateReportTemplateDto } from './report-template.service';
       import { QueryBuilderService } from './query-builder.service';
       import { ExportService } from './export.service';
       import { RunReportDto } from './dto/run-report.dto';
       import { UserRole } from '@prisma/client';

       @Controller('api/v1/reports')
       @UseGuards(JwtAuthGuard, TenantGuard)
       export class ReportingController {
         constructor(
           private templateService: ReportTemplateService,
           private queryBuilder: QueryBuilderService,
           private exportService: ExportService,
         ) {}

         // --- Template Endpoints ---

         @Post('templates')
         @UseGuards(RolesGuard)
         @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
         async createTemplate(
           @TenantId() orgId: string,
           @CurrentUser() user: { id: string },
           @Body() dto: CreateReportTemplateDto,
         ) {
           return this.templateService.create(orgId, dto, user.id);
         }

         @Get('templates')
         async listTemplates(
           @TenantId() orgId: string,
           @Query('category') category?: string,
         ) {
           return this.templateService.findAll(orgId, category);
         }

         @Get('templates/:id')
         async getTemplate(
           @TenantId() orgId: string,
           @Param('id') id: string,
         ) {
           return this.templateService.findById(orgId, id);
         }

         // --- Execution Endpoints ---

         @Post('templates/:id/run')
         async runReport(
           @TenantId() orgId: string,
           @Param('id') templateId: string,
           @Body() dto: RunReportDto,
           @Res() res: Response,
         ) {
           const template = await this.templateService.findById(orgId, templateId);

           // For JSON format, return directly
           if (dto.format === 'json' || !dto.format) {
             const result = await this.queryBuilder.executeQuery({
               organizationId: orgId,
               dataSource: template.dataSource,
               columns: template.columns as any,
               filters: dto.filters as any,
               limit: dto.limit,
             });
             return res.json(result);
           }

           // For Excel/CSV, generate and stream
           if (dto.format === 'excel') {
             const buffer = await this.exportService.exportToExcel({
               organizationId: orgId,
               templateId,
               filters: dto.filters as any,
             });

             res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
             res.setHeader('Content-Disposition', `attachment; filename="${template.name}.xlsx"`);
             return res.send(buffer);
           }

           if (dto.format === 'csv') {
             const csv = await this.exportService.exportToCsv({
               organizationId: orgId,
               templateId,
               filters: dto.filters as any,
             });

             res.setHeader('Content-Type', 'text/csv');
             res.setHeader('Content-Disposition', `attachment; filename="${template.name}.csv"`);
             return res.send(csv);
           }
         }

         @Post('templates/:id/queue')
         @UseGuards(RolesGuard)
         @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
         async queueReport(
           @TenantId() orgId: string,
           @Param('id') templateId: string,
           @CurrentUser() user: { id: string },
           @Body() dto: RunReportDto,
         ) {
           return this.exportService.queueExport({
             organizationId: orgId,
             templateId,
             filters: dto.filters as any,
             format: dto.format === 'csv' ? 'csv' : 'excel',
             requestedById: user.id,
           });
         }
       }
       ```

    6. Create `apps/backend/src/modules/reporting/reporting.module.ts`:
       ```typescript
       import { Module } from '@nestjs/common';
       import { QueryBuilderService } from './query-builder.service';
       import { ReportTemplateService } from './report-template.service';
       import { ExportService } from './export.service';
       import { ReportingController } from './reporting.controller';

       @Module({
         providers: [QueryBuilderService, ReportTemplateService, ExportService],
         controllers: [ReportingController],
         exports: [QueryBuilderService, ReportTemplateService, ExportService],
       })
       export class ReportingModule {}
       ```

    7. Update `apps/backend/src/app.module.ts`:
       - Import ReportingModule
       - Add to imports array
  </action>
  <verify>
    - App builds: `cd apps/backend && npm run build`
    - App starts: `cd apps/backend && npm run start:dev`
    - Create report template via API
    - Run report: POST /api/v1/reports/templates/:id/run
    - Export to Excel: POST /api/v1/reports/templates/:id/run with format=excel
  </verify>
  <done>ReportingModule with query builder, Excel/CSV export, and API endpoints created</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build succeeds: `cd apps/backend && npm run build`
2. Database has report_templates and report_executions tables
3. Create a report template for Cases
4. Run report as JSON: POST /api/v1/reports/templates/:id/run
5. Export to Excel: POST /api/v1/reports/templates/:id/run?format=excel
6. Verify Excel opens correctly and has data
</verification>

<success_criteria>
- QueryBuilderService generates Prisma queries from template definitions
- Reports can be exported to Excel with proper formatting
- CSV export supported for simple data transfer
- Large reports can be queued for async generation
- Report templates are reusable and shareable
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-08-SUMMARY.md`
</output>
