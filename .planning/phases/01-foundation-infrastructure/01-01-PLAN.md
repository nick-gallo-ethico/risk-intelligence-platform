---
phase: 01-foundation-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/src/modules/events/events.module.ts
  - apps/backend/src/modules/events/events/base.event.ts
  - apps/backend/src/modules/events/events/case.events.ts
  - apps/backend/src/modules/events/events/investigation.events.ts
  - apps/backend/src/modules/events/events/index.ts
  - apps/backend/src/app.module.ts
  - apps/backend/package.json
autonomous: true

must_haves:
  truths:
    - "Events emitted from service layer are consumed by handlers without blocking the request"
    - "Services can emit typed events without knowing who subscribes"
    - "Multiple handlers can subscribe to the same event"
    - "Event handlers run asynchronously and failures don't crash the emitter"
  artifacts:
    - path: "apps/backend/src/modules/events/events.module.ts"
      provides: "Global event emitter module"
      contains: "@Global"
    - path: "apps/backend/src/modules/events/events/base.event.ts"
      provides: "Base event class with common fields"
      contains: "organizationId"
    - path: "apps/backend/src/modules/events/events/case.events.ts"
      provides: "Case domain events"
      exports: ["CaseCreatedEvent", "CaseUpdatedEvent", "CaseStatusChangedEvent"]
  key_links:
    - from: "apps/backend/src/app.module.ts"
      to: "EventsModule"
      via: "imports array"
      pattern: "EventsModule"
---

<objective>
Set up the foundational event bus using @nestjs/event-emitter that enables loose coupling between modules throughout the platform.

Purpose: All subsequent modules (audit logging, search indexing, notifications, workflows) need to react to domain events. This establishes the event-driven architecture pattern.

Output: Global EventsModule with base event class and initial Case/Investigation events.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@apps/backend/src/app.module.ts
@apps/backend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @nestjs/event-emitter and create EventsModule</name>
  <files>
    apps/backend/package.json
    apps/backend/src/modules/events/events.module.ts
  </files>
  <action>
    1. Install the event-emitter package:
       ```bash
       cd apps/backend && npm install @nestjs/event-emitter@^3.0.1
       ```

    2. Create `apps/backend/src/modules/events/events.module.ts`:
       - Import EventEmitterModule from @nestjs/event-emitter
       - Configure with: wildcard: true, delimiter: '.', newListener: false, removeListener: false, maxListeners: 20, verboseMemoryLeak: true, ignoreErrors: false
       - Mark as @Global() module so event emitter is available everywhere
       - Export EventEmitterModule for re-export

    3. Pattern reference:
       ```typescript
       import { Module, Global } from '@nestjs/common';
       import { EventEmitterModule } from '@nestjs/event-emitter';

       @Global()
       @Module({
         imports: [
           EventEmitterModule.forRoot({
             wildcard: true,
             delimiter: '.',
             newListener: false,
             removeListener: false,
             maxListeners: 20,
             verboseMemoryLeak: true,
             ignoreErrors: false,
           }),
         ],
         exports: [EventEmitterModule],
       })
       export class EventsModule {}
       ```
  </action>
  <verify>
    - Package exists in package.json dependencies
    - Module file exists and compiles: `cd apps/backend && npx tsc --noEmit`
  </verify>
  <done>EventsModule created with EventEmitterModule.forRoot() configuration</done>
</task>

<task type="auto">
  <name>Task 2: Create base event class and domain events</name>
  <files>
    apps/backend/src/modules/events/events/base.event.ts
    apps/backend/src/modules/events/events/case.events.ts
    apps/backend/src/modules/events/events/investigation.events.ts
    apps/backend/src/modules/events/events/index.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/events/events/base.event.ts`:
       - Define BaseEvent class with common fields:
         - organizationId: string (REQUIRED - tenant isolation)
         - actorUserId: string | null (who triggered the event)
         - actorType: 'USER' | 'SYSTEM' | 'AI' | 'INTEGRATION' | 'ANONYMOUS'
         - timestamp: Date (defaults to now)
         - correlationId?: string (for request tracing)
       - Constructor accepts Partial<BaseEvent> for flexibility

    2. Create `apps/backend/src/modules/events/events/case.events.ts`:
       - CaseCreatedEvent extends BaseEvent with:
         - caseId: string
         - referenceNumber: string
         - sourceChannel: string
         - categoryId?: string
         - severity: string
       - CaseUpdatedEvent extends BaseEvent with:
         - caseId: string
         - changes: Record<string, { old: any; new: any }>
       - CaseStatusChangedEvent extends BaseEvent with:
         - caseId: string
         - previousStatus: string
         - newStatus: string
         - rationale?: string
       - CaseAssignedEvent extends BaseEvent with:
         - caseId: string
         - previousAssigneeId: string | null
         - newAssigneeId: string

    3. Create `apps/backend/src/modules/events/events/investigation.events.ts`:
       - InvestigationCreatedEvent extends BaseEvent with:
         - investigationId: string
         - caseId: string
         - investigationNumber: number
       - InvestigationStatusChangedEvent extends BaseEvent with:
         - investigationId: string
         - caseId: string
         - previousStatus: string
         - newStatus: string
       - InvestigationAssignedEvent extends BaseEvent with:
         - investigationId: string
         - caseId: string
         - previousInvestigatorId: string | null
         - newInvestigatorId: string

    4. Create `apps/backend/src/modules/events/events/index.ts` barrel export:
       - Export all events from base.event.ts, case.events.ts, investigation.events.ts

    5. Event naming convention: Use dot notation for event names
       - 'case.created', 'case.updated', 'case.status_changed', 'case.assigned'
       - 'investigation.created', 'investigation.status_changed', 'investigation.assigned'
       - Define as static constants on each event class: `static readonly eventName = 'case.created'`
  </action>
  <verify>
    - All event files compile: `cd apps/backend && npx tsc --noEmit`
    - Events exported from index: grep export apps/backend/src/modules/events/events/index.ts
  </verify>
  <done>BaseEvent class and 7 domain events created with proper typing and event names</done>
</task>

<task type="auto">
  <name>Task 3: Register EventsModule and add example event emission</name>
  <files>
    apps/backend/src/app.module.ts
    apps/backend/src/modules/cases/cases.service.ts
  </files>
  <action>
    1. Update `apps/backend/src/app.module.ts`:
       - Import EventsModule from './modules/events/events.module'
       - Add EventsModule to imports array (as first module after ConfigModule since others depend on it)

    2. Update `apps/backend/src/modules/cases/cases.service.ts`:
       - Import EventEmitter2 from '@nestjs/event-emitter'
       - Import CaseCreatedEvent, CaseUpdatedEvent, CaseStatusChangedEvent from '../events/events'
       - Inject EventEmitter2 in constructor
       - In create() method, after case is created in DB, emit CaseCreatedEvent:
         ```typescript
         this.eventEmitter.emit(
           CaseCreatedEvent.eventName,
           new CaseCreatedEvent({
             organizationId: orgId,
             actorUserId: userId,
             actorType: 'USER',
             caseId: createdCase.id,
             referenceNumber: createdCase.referenceNumber,
             sourceChannel: createdCase.sourceChannel,
             categoryId: createdCase.primaryCategoryId,
             severity: createdCase.severity,
           }),
         );
         ```
       - In update() method, emit CaseUpdatedEvent with changes
       - Do NOT emit in the HTTP request path - emit AFTER successful DB write

    3. CRITICAL: Wrap event emission in try-catch to prevent emit errors from failing requests:
       ```typescript
       try {
         this.eventEmitter.emit(eventName, event);
       } catch (error) {
         this.logger.error(`Failed to emit event ${eventName}`, error);
         // Don't rethrow - request should succeed even if event fails
       }
       ```
  </action>
  <verify>
    - App compiles: `cd apps/backend && npm run build`
    - App starts: `cd apps/backend && npm run start:dev` (check for errors, then Ctrl+C)
  </verify>
  <done>EventsModule registered in app.module.ts and CasesService emits events on create/update</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build succeeds: `cd apps/backend && npm run build`
2. Type check passes: `cd apps/backend && npx tsc --noEmit`
3. Events module loaded: Start the app and check console for EventEmitterModule initialization
4. Event emission works: The logging in try-catch should show if events fire (add temporary console.log if needed)
</verification>

<success_criteria>
- EventsModule is global and imported first in app.module.ts
- BaseEvent class exists with organizationId (tenant) and actorUserId fields
- Case and Investigation events exist with proper typing
- CasesService emits CaseCreatedEvent after successful creation
- Build and typecheck pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md`
</output>
