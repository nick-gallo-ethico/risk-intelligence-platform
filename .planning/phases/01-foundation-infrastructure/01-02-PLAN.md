---
phase: 01-foundation-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - apps/backend/src/modules/jobs/jobs.module.ts
  - apps/backend/src/modules/jobs/queues/ai.queue.ts
  - apps/backend/src/modules/jobs/queues/email.queue.ts
  - apps/backend/src/modules/jobs/queues/indexing.queue.ts
  - apps/backend/src/modules/jobs/processors/ai.processor.ts
  - apps/backend/src/modules/jobs/processors/email.processor.ts
  - apps/backend/src/modules/jobs/processors/indexing.processor.ts
  - apps/backend/src/modules/jobs/admin/bull-board.controller.ts
  - apps/backend/src/app.module.ts
  - apps/backend/package.json
  - docker-compose.yml
autonomous: true

must_haves:
  truths:
    - "Background jobs execute without blocking HTTP requests"
    - "Failed jobs retry with exponential backoff"
    - "Dead letter queue captures jobs that exhaust retries"
    - "Admin dashboard shows queue status at /admin/queues"
    - "AI queue has dedicated workers separate from general processing"
  artifacts:
    - path: "apps/backend/src/modules/jobs/jobs.module.ts"
      provides: "BullMQ module configuration"
      contains: "BullModule.forRootAsync"
    - path: "apps/backend/src/modules/jobs/processors/ai.processor.ts"
      provides: "AI job processor with retry logic"
      contains: "@Processor"
    - path: "apps/backend/src/modules/jobs/admin/bull-board.controller.ts"
      provides: "Bull Board admin UI mount point"
      contains: "/admin/queues"
  key_links:
    - from: "apps/backend/src/modules/jobs/jobs.module.ts"
      to: "Redis connection"
      via: "BullModule.forRootAsync"
      pattern: "REDIS_HOST"
---

<objective>
Set up BullMQ job queue infrastructure with Redis backend, providing background job processing with retry logic, priority queues, and admin monitoring.

Purpose: AI calls, email sends, search indexing, and report generation must run asynchronously to keep API responses fast. This provides the durable job queue all async operations depend on.

Output: JobsModule with three queues (AI, Email, Indexing), processors, and Bull Board admin dashboard.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
@apps/backend/src/app.module.ts
@apps/backend/package.json
@docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install BullMQ packages and configure Redis in docker-compose</name>
  <files>
    apps/backend/package.json
    docker-compose.yml
    apps/backend/src/config/configuration.ts
  </files>
  <action>
    1. Install BullMQ packages:
       ```bash
       cd apps/backend && npm install @nestjs/bullmq@^11.0.4 bullmq@^5.0.0 ioredis@^5.0.0
       npm install @bull-board/nestjs @bull-board/api @bull-board/express
       ```

    2. Update `docker-compose.yml` to add Redis service (if not present):
       ```yaml
       redis:
         image: redis:7-alpine
         container_name: ethico-redis
         ports:
           - "6379:6379"
         volumes:
           - redis_data:/data
         command: redis-server --appendonly yes
         healthcheck:
           test: ["CMD", "redis-cli", "ping"]
           interval: 10s
           timeout: 5s
           retries: 3
       ```
       Add `redis_data:` to volumes section.

    3. Update `apps/backend/src/config/configuration.ts` to add Redis config:
       ```typescript
       redis: {
         host: process.env.REDIS_HOST || 'localhost',
         port: parseInt(process.env.REDIS_PORT, 10) || 6379,
         password: process.env.REDIS_PASSWORD || undefined,
       },
       ```

    4. Add to `.env.example` (create if not exists):
       ```
       REDIS_HOST=localhost
       REDIS_PORT=6379
       REDIS_PASSWORD=
       ```
  </action>
  <verify>
    - Packages in package.json: grep bullmq apps/backend/package.json
    - Redis in docker-compose: grep redis docker-compose.yml
    - Docker compose validates: docker-compose config
  </verify>
  <done>BullMQ and Bull Board packages installed, Redis configured in docker-compose</done>
</task>

<task type="auto">
  <name>Task 2: Create JobsModule with queue registrations</name>
  <files>
    apps/backend/src/modules/jobs/jobs.module.ts
    apps/backend/src/modules/jobs/queues/ai.queue.ts
    apps/backend/src/modules/jobs/queues/email.queue.ts
    apps/backend/src/modules/jobs/queues/indexing.queue.ts
    apps/backend/src/modules/jobs/queues/index.ts
  </files>
  <action>
    1. Create queue constants in `apps/backend/src/modules/jobs/queues/ai.queue.ts`:
       ```typescript
       export const AI_QUEUE_NAME = 'ai-processing';

       export const AI_QUEUE_OPTIONS = {
         defaultJobOptions: {
           attempts: 5,  // AI calls get more retries
           backoff: {
             type: 'exponential' as const,
             delay: 2000,  // 2s, 4s, 8s, 16s, 32s
           },
           removeOnComplete: {
             count: 1000,
             age: 24 * 60 * 60,  // 24 hours
           },
           removeOnFail: {
             count: 5000,
             age: 7 * 24 * 60 * 60,  // 7 days for investigation
           },
         },
       };
       ```

    2. Create `apps/backend/src/modules/jobs/queues/email.queue.ts`:
       ```typescript
       export const EMAIL_QUEUE_NAME = 'email';

       export const EMAIL_QUEUE_OPTIONS = {
         defaultJobOptions: {
           attempts: 3,
           backoff: {
             type: 'exponential' as const,
             delay: 1000,
           },
           priority: 2,  // Higher priority than general
           removeOnComplete: { count: 500, age: 12 * 60 * 60 },
           removeOnFail: { count: 1000, age: 3 * 24 * 60 * 60 },
         },
       };
       ```

    3. Create `apps/backend/src/modules/jobs/queues/indexing.queue.ts`:
       ```typescript
       export const INDEXING_QUEUE_NAME = 'indexing';

       export const INDEXING_QUEUE_OPTIONS = {
         defaultJobOptions: {
           attempts: 3,
           backoff: {
             type: 'fixed' as const,
             delay: 5000,
           },
           priority: 5,  // Lower priority (bulk operations)
           removeOnComplete: { count: 2000, age: 6 * 60 * 60 },
           removeOnFail: { count: 5000, age: 24 * 60 * 60 },
         },
       };
       ```

    4. Create `apps/backend/src/modules/jobs/queues/index.ts` barrel export.

    5. Create `apps/backend/src/modules/jobs/jobs.module.ts`:
       ```typescript
       import { Module } from '@nestjs/common';
       import { BullModule } from '@nestjs/bullmq';
       import { ConfigService } from '@nestjs/config';
       import { BullBoardModule } from '@bull-board/nestjs';
       import { ExpressAdapter } from '@bull-board/express';
       import { BullMQAdapter } from '@bull-board/api/bullMQAdapter';
       import { AI_QUEUE_NAME, AI_QUEUE_OPTIONS } from './queues/ai.queue';
       import { EMAIL_QUEUE_NAME, EMAIL_QUEUE_OPTIONS } from './queues/email.queue';
       import { INDEXING_QUEUE_NAME, INDEXING_QUEUE_OPTIONS } from './queues/indexing.queue';
       import { AiProcessor } from './processors/ai.processor';
       import { EmailProcessor } from './processors/email.processor';
       import { IndexingProcessor } from './processors/indexing.processor';

       @Module({
         imports: [
           BullModule.forRootAsync({
             useFactory: (configService: ConfigService) => ({
               connection: {
                 host: configService.get('redis.host'),
                 port: configService.get('redis.port'),
                 password: configService.get('redis.password'),
               },
               prefix: 'ethico',
             }),
             inject: [ConfigService],
           }),
           BullModule.registerQueue({
             name: AI_QUEUE_NAME,
             ...AI_QUEUE_OPTIONS,
           }),
           BullModule.registerQueue({
             name: EMAIL_QUEUE_NAME,
             ...EMAIL_QUEUE_OPTIONS,
           }),
           BullModule.registerQueue({
             name: INDEXING_QUEUE_NAME,
             ...INDEXING_QUEUE_OPTIONS,
           }),
           BullBoardModule.forRoot({
             route: '/admin/queues',
             adapter: ExpressAdapter,
           }),
           BullBoardModule.forFeature({
             name: AI_QUEUE_NAME,
             adapter: BullMQAdapter,
           }),
           BullBoardModule.forFeature({
             name: EMAIL_QUEUE_NAME,
             adapter: BullMQAdapter,
           }),
           BullBoardModule.forFeature({
             name: INDEXING_QUEUE_NAME,
             adapter: BullMQAdapter,
           }),
         ],
         providers: [AiProcessor, EmailProcessor, IndexingProcessor],
         exports: [BullModule],
       })
       export class JobsModule {}
       ```
  </action>
  <verify>
    - Module file exists and compiles: `cd apps/backend && npx tsc --noEmit`
    - Three queues registered in module
  </verify>
  <done>JobsModule created with AI, Email, and Indexing queues with different retry configurations</done>
</task>

<task type="auto">
  <name>Task 3: Create job processors with proper error handling</name>
  <files>
    apps/backend/src/modules/jobs/processors/ai.processor.ts
    apps/backend/src/modules/jobs/processors/email.processor.ts
    apps/backend/src/modules/jobs/processors/indexing.processor.ts
    apps/backend/src/modules/jobs/processors/index.ts
    apps/backend/src/modules/jobs/types/job-data.types.ts
    apps/backend/src/app.module.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/jobs/types/job-data.types.ts` with job data interfaces:
       ```typescript
       export interface BaseJobData {
         organizationId: string;
         correlationId?: string;
       }

       export interface AiJobData extends BaseJobData {
         type: 'generate-summary' | 'translate' | 'categorize' | 'note-cleanup';
         entityType: string;
         entityId: string;
         content?: string;
         targetLanguage?: string;
       }

       export interface EmailJobData extends BaseJobData {
         templateId: string;
         to: string | string[];
         subject?: string;
         context: Record<string, unknown>;
       }

       export interface IndexingJobData extends BaseJobData {
         operation: 'create' | 'update' | 'delete' | 'reindex';
         entityType: string;
         entityId: string;
         data?: Record<string, unknown>;
       }
       ```

    2. Create `apps/backend/src/modules/jobs/processors/ai.processor.ts`:
       ```typescript
       import { Processor, WorkerHost, OnWorkerEvent } from '@nestjs/bullmq';
       import { Logger } from '@nestjs/common';
       import { Job } from 'bullmq';
       import { AI_QUEUE_NAME } from '../queues/ai.queue';
       import { AiJobData } from '../types/job-data.types';

       @Processor(AI_QUEUE_NAME, { concurrency: 5 })
       export class AiProcessor extends WorkerHost {
         private readonly logger = new Logger(AiProcessor.name);

         async process(job: Job<AiJobData>): Promise<unknown> {
           this.logger.log(`Processing AI job ${job.id}: ${job.data.type}`);

           // Placeholder - actual AI service integration in Phase 5
           switch (job.data.type) {
             case 'generate-summary':
               return this.generateSummary(job.data);
             case 'translate':
               return this.translate(job.data);
             case 'categorize':
               return this.categorize(job.data);
             case 'note-cleanup':
               return this.noteCleanup(job.data);
             default:
               throw new Error(`Unknown AI job type: ${job.data.type}`);
           }
         }

         private async generateSummary(data: AiJobData): Promise<{ summary: string }> {
           // Placeholder - returns mock data
           this.logger.log(`Would generate summary for ${data.entityType}:${data.entityId}`);
           return { summary: 'AI summary placeholder' };
         }

         private async translate(data: AiJobData): Promise<{ translation: string }> {
           this.logger.log(`Would translate to ${data.targetLanguage}`);
           return { translation: 'Translation placeholder' };
         }

         private async categorize(data: AiJobData): Promise<{ categoryId: string }> {
           this.logger.log(`Would categorize ${data.entityType}:${data.entityId}`);
           return { categoryId: 'placeholder-category' };
         }

         private async noteCleanup(data: AiJobData): Promise<{ cleanedContent: string }> {
           this.logger.log(`Would clean up notes for ${data.entityId}`);
           return { cleanedContent: data.content || '' };
         }

         @OnWorkerEvent('completed')
         onCompleted(job: Job<AiJobData>) {
           this.logger.log(`AI job ${job.id} completed`);
         }

         @OnWorkerEvent('failed')
         onFailed(job: Job<AiJobData>, error: Error) {
           this.logger.error(`AI job ${job.id} failed after ${job.attemptsMade} attempts: ${error.message}`);
         }
       }
       ```

    3. Create `apps/backend/src/modules/jobs/processors/email.processor.ts`:
       ```typescript
       import { Processor, WorkerHost, OnWorkerEvent } from '@nestjs/bullmq';
       import { Logger } from '@nestjs/common';
       import { Job } from 'bullmq';
       import { EMAIL_QUEUE_NAME } from '../queues/email.queue';
       import { EmailJobData } from '../types/job-data.types';

       @Processor(EMAIL_QUEUE_NAME, { concurrency: 10 })
       export class EmailProcessor extends WorkerHost {
         private readonly logger = new Logger(EmailProcessor.name);

         async process(job: Job<EmailJobData>): Promise<{ messageId: string }> {
           this.logger.log(`Processing email job ${job.id}: template=${job.data.templateId}`);

           // Placeholder - actual email service integration in Phase 7
           const recipients = Array.isArray(job.data.to) ? job.data.to : [job.data.to];
           this.logger.log(`Would send to: ${recipients.join(', ')}`);

           return { messageId: `msg-${job.id}` };
         }

         @OnWorkerEvent('failed')
         onFailed(job: Job<EmailJobData>, error: Error) {
           this.logger.error(`Email job ${job.id} failed: ${error.message}`);
         }
       }
       ```

    4. Create `apps/backend/src/modules/jobs/processors/indexing.processor.ts`:
       ```typescript
       import { Processor, WorkerHost, OnWorkerEvent } from '@nestjs/bullmq';
       import { Logger } from '@nestjs/common';
       import { Job } from 'bullmq';
       import { INDEXING_QUEUE_NAME } from '../queues/indexing.queue';
       import { IndexingJobData } from '../types/job-data.types';

       @Processor(INDEXING_QUEUE_NAME, { concurrency: 20 })
       export class IndexingProcessor extends WorkerHost {
         private readonly logger = new Logger(IndexingProcessor.name);

         async process(job: Job<IndexingJobData>): Promise<void> {
           this.logger.log(`Processing indexing job ${job.id}: ${job.data.operation} ${job.data.entityType}:${job.data.entityId}`);

           // Placeholder - actual Elasticsearch integration in Plan 06
           switch (job.data.operation) {
             case 'create':
             case 'update':
               this.logger.log(`Would index ${job.data.entityType}:${job.data.entityId}`);
               break;
             case 'delete':
               this.logger.log(`Would delete ${job.data.entityType}:${job.data.entityId} from index`);
               break;
             case 'reindex':
               this.logger.log(`Would reindex ${job.data.entityType}:${job.data.entityId}`);
               break;
           }
         }

         @OnWorkerEvent('failed')
         onFailed(job: Job<IndexingJobData>, error: Error) {
           this.logger.error(`Indexing job ${job.id} failed: ${error.message}`);
         }
       }
       ```

    5. Create `apps/backend/src/modules/jobs/processors/index.ts` barrel export.

    6. Update `apps/backend/src/app.module.ts`:
       - Import JobsModule from './modules/jobs/jobs.module'
       - Add JobsModule to imports array (after EventsModule)

    **NOTE:** Processors are placeholders at this stage - they log job activity but don't perform real work:
       - AI processor: Actual AI service integration happens in Phase 5 (AI Infrastructure)
       - Email processor: Actual email delivery happens in Phase 7 (Notifications & Email)
       - Indexing processor: Actual Elasticsearch indexing happens in Plan 06 (this phase)
  </action>
  <verify>
    - App compiles: `cd apps/backend && npm run build`
    - Start Redis: `docker-compose up -d redis`
    - App starts without errors: `cd apps/backend && npm run start:dev` (verify no connection errors)
    - Bull Board accessible at http://localhost:3000/admin/queues (check in browser)
  </verify>
  <done>Three job processors created with logging, error handling, and Bull Board admin mounted</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build succeeds: `cd apps/backend && npm run build`
2. Redis running: `docker-compose up -d redis && docker-compose ps` (should show redis healthy)
3. App starts: `cd apps/backend && npm run start:dev` (no Redis connection errors)
4. Bull Board loads: Visit http://localhost:3000/admin/queues in browser - should show 3 queues
5. Test job: Can manually add a job via Bull Board UI and see it process
</verification>

<success_criteria>
- BullMQ and Bull Board packages installed
- Redis configured in docker-compose with persistence
- Three queues registered: ai-processing, email, indexing
- Each queue has different retry/backoff configuration per CONTEXT.md
- Bull Board admin accessible at /admin/queues
- Processors log job activity and handle failures gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md`
</output>
