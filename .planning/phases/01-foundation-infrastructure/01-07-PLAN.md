---
phase: 01-foundation-infrastructure
plan: 07
type: execute
wave: 3
depends_on: ["01-01"]
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/forms/forms.module.ts
  - apps/backend/src/modules/forms/form-schema.service.ts
  - apps/backend/src/modules/forms/form-validation.service.ts
  - apps/backend/src/modules/forms/form-submission.service.ts
  - apps/backend/src/modules/forms/dto/create-form-definition.dto.ts
  - apps/backend/src/modules/forms/dto/form-submission.dto.ts
  - apps/backend/src/modules/forms/forms.controller.ts
  - apps/backend/src/app.module.ts
  - apps/backend/package.json
autonomous: true

must_haves:
  truths:
    - "Forms are defined by JSON Schema stored in database"
    - "Form submissions are validated against their schema"
    - "Forms support conditionals, repeating sections, and required fields"
    - "Same form engine is used for intake, disclosures, and workflow tasks"
    - "Form definitions are versioned for historical accuracy"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "FormDefinition and FormSubmission models"
      contains: "FormDefinition"
    - path: "apps/backend/src/modules/forms/form-validation.service.ts"
      provides: "Ajv-based JSON Schema validation"
      contains: "Ajv"
    - path: "apps/backend/src/modules/forms/form-schema.service.ts"
      provides: "Form definition CRUD and versioning"
      exports: ["FormSchemaService"]
  key_links:
    - from: "apps/backend/src/modules/forms/form-submission.service.ts"
      to: "form-validation.service"
      via: "validateSubmission"
      pattern: "validateSubmission"
---

<objective>
Build the form/schema engine that powers dynamic forms for intake, disclosures, workflow tasks, and custom data collection.

Purpose: Multiple modules need configurable forms (web forms, disclosures, workflow tasks). A unified form engine ensures consistency and reduces duplication.

Output: FormDefinition model, JSON Schema validation service, and form submission API.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
@apps/backend/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Form Prisma models and install Ajv</name>
  <files>
    apps/backend/prisma/schema.prisma
    apps/backend/package.json
  </files>
  <action>
    1. Install Ajv for JSON Schema validation:
       ```bash
       cd apps/backend && npm install ajv ajv-formats ajv-errors
       npm install -D @types/json-schema
       ```

    2. Add FormDefinition model to schema.prisma:
       ```prisma
       /// FormDefinition stores JSON Schema definitions for dynamic forms.
       /// Used for intake forms, disclosure forms, workflow tasks, surveys.
       /// Definitions are versioned - version increments on publish.
       model FormDefinition {
         id             String @id @default(uuid())
         organizationId String @map("organization_id")

         // Identity
         name        String
         description String?
         formType    FormType @map("form_type")
         version     Int      @default(1)
         isActive    Boolean  @default(true) @map("is_active")
         isPublished Boolean  @default(false) @map("is_published")

         // JSON Schema
         schema       Json  // JSON Schema definition
         uiSchema     Json? @map("ui_schema")  // UI hints (ordering, widgets, conditionals)
         defaultValues Json? @map("default_values")

         // Behavior
         allowAnonymous    Boolean @default(false) @map("allow_anonymous")
         requiresApproval  Boolean @default(false) @map("requires_approval")
         notifyOnSubmit    String[] @default([]) @map("notify_on_submit")  // User IDs

         // Category linkage (optional)
         categoryId String? @map("category_id")

         // Metadata
         tags String[] @default([])

         // Audit
         createdAt   DateTime @default(now()) @map("created_at")
         updatedAt   DateTime @updatedAt @map("updated_at")
         createdById String?  @map("created_by_id")
         publishedAt DateTime? @map("published_at")

         // Relations
         organization Organization     @relation(fields: [organizationId], references: [id], onDelete: Cascade)
         submissions  FormSubmission[]

         @@unique([organizationId, name, version])
         @@index([organizationId])
         @@index([organizationId, formType])
         @@index([organizationId, isActive])
         @@map("form_definitions")
       }

       enum FormType {
         INTAKE           // Anonymous/identified report intake
         DISCLOSURE       // COI, gifts, outside employment
         ATTESTATION      // Policy acknowledgment
         SURVEY           // Compliance surveys
         WORKFLOW_TASK    // Embedded workflow step form
         CUSTOM           // General purpose

         @@map("form_type")
       }
       ```

    3. Add FormSubmission model:
       ```prisma
       /// FormSubmission stores completed form submissions.
       /// Links to FormDefinition by version for historical accuracy.
       model FormSubmission {
         id                  String @id @default(uuid())
         organizationId      String @map("organization_id")
         formDefinitionId    String @map("form_definition_id")
         formDefinitionVersion Int  @map("form_definition_version")

         // Submission Data
         data          Json  // Submitted form data
         status        FormSubmissionStatus @default(SUBMITTED)
         validationErrors Json? @map("validation_errors")

         // Entity linkage (optional - links to what this form is for)
         entityType String? @map("entity_type")  // 'CASE', 'RIU', 'CAMPAIGN_ASSIGNMENT'
         entityId   String? @map("entity_id")

         // Submitter
         submittedById   String?   @map("submitted_by_id")  // Null for anonymous
         submittedAt     DateTime  @default(now()) @map("submitted_at")
         submitterIp     String?   @map("submitter_ip")
         submitterAgent  String?   @map("submitter_agent")

         // Anonymous support
         anonymousAccessCode String? @map("anonymous_access_code")

         // Audit
         createdAt DateTime @default(now()) @map("created_at")
         updatedAt DateTime @updatedAt @map("updated_at")

         // Relations
         organization   Organization   @relation(fields: [organizationId], references: [id], onDelete: Cascade)
         formDefinition FormDefinition @relation(fields: [formDefinitionId], references: [id])

         @@index([organizationId])
         @@index([organizationId, formDefinitionId])
         @@index([organizationId, entityType, entityId])
         @@index([anonymousAccessCode])
         @@map("form_submissions")
       }

       enum FormSubmissionStatus {
         DRAFT
         SUBMITTED
         APPROVED
         REJECTED
         PROCESSED

         @@map("form_submission_status")
       }
       ```

    4. Add relations to Organization:
       ```prisma
       // In Organization model
       formDefinitions FormDefinition[]
       formSubmissions FormSubmission[]
       ```

    5. Run migration:
       ```bash
       cd apps/backend && npx prisma migrate dev --name add_forms
       ```
  </action>
  <verify>
    - Schema valid: `cd apps/backend && npx prisma validate`
    - Migration runs successfully
    - Ajv installed: grep ajv apps/backend/package.json
  </verify>
  <done>FormDefinition and FormSubmission models created with versioning support</done>
</task>

<task type="auto">
  <name>Task 2: Create form validation and schema services</name>
  <files>
    apps/backend/src/modules/forms/form-validation.service.ts
    apps/backend/src/modules/forms/form-schema.service.ts
    apps/backend/src/modules/forms/types/form.types.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/forms/types/form.types.ts`:
       ```typescript
       import { JSONSchema7 } from 'json-schema';

       export interface FormSchema extends JSONSchema7 {
         // Extended for our needs
       }

       export interface UiSchema {
         order?: string[];
         fields?: Record<string, UiFieldConfig>;
         conditionals?: ConditionalRule[];
       }

       export interface UiFieldConfig {
         widget?: 'text' | 'textarea' | 'select' | 'radio' | 'checkbox' | 'date' | 'file' | 'rich-text';
         placeholder?: string;
         helpText?: string;
         hidden?: boolean;
         disabled?: boolean;
         className?: string;
       }

       export interface ConditionalRule {
         if: { field: string; value: unknown };
         then: { show?: string[]; hide?: string[]; require?: string[] };
       }

       export interface ValidationResult {
         valid: boolean;
         errors: ValidationError[];
       }

       export interface ValidationError {
         field: string;
         message: string;
         keyword: string;
       }
       ```

    2. Create `apps/backend/src/modules/forms/form-validation.service.ts`:
       ```typescript
       import { Injectable, Logger } from '@nestjs/common';
       import Ajv from 'ajv';
       import addFormats from 'ajv-formats';
       import addErrors from 'ajv-errors';
       import { FormSchema, ValidationResult, ValidationError } from './types/form.types';

       @Injectable()
       export class FormValidationService {
         private readonly logger = new Logger(FormValidationService.name);
         private readonly ajv: Ajv;

         constructor() {
           this.ajv = new Ajv({
             allErrors: true,
             coerceTypes: true,
             removeAdditional: 'all',
             useDefaults: true,
             messages: true,
           });

           addFormats(this.ajv);
           addErrors(this.ajv);

           // Add custom formats
           this.ajv.addFormat('phone', /^\+?[\d\s\-()]+$/);
           this.ajv.addFormat('currency', /^\d+(\.\d{1,2})?$/);
         }

         /**
          * Validate submission data against a JSON Schema
          */
         validate(schema: FormSchema, data: Record<string, unknown>): ValidationResult {
           const validate = this.ajv.compile(schema);
           const valid = validate(data);

           if (valid) {
             return { valid: true, errors: [] };
           }

           const errors: ValidationError[] = (validate.errors || []).map(error => ({
             field: error.instancePath.replace(/^\//, '').replace(/\//g, '.') || error.params?.missingProperty || 'unknown',
             message: error.message || 'Validation failed',
             keyword: error.keyword,
           }));

           return { valid: false, errors };
         }

         /**
          * Validate the schema itself (meta-validation)
          */
         validateSchema(schema: FormSchema): ValidationResult {
           try {
             this.ajv.compile(schema);
             return { valid: true, errors: [] };
           } catch (error) {
             return {
               valid: false,
               errors: [{ field: 'schema', message: error.message, keyword: 'schema' }],
             };
           }
         }

         /**
          * Apply conditionals to determine required fields
          */
         applyConditionals(
           schema: FormSchema,
           data: Record<string, unknown>,
           conditionals: Array<{ if: { field: string; value: unknown }; then: { require?: string[] } }>,
         ): FormSchema {
           const modified = JSON.parse(JSON.stringify(schema)) as FormSchema;
           const required = new Set(modified.required || []);

           for (const rule of conditionals) {
             if (data[rule.if.field] === rule.if.value) {
               for (const field of rule.then.require || []) {
                 required.add(field);
               }
             }
           }

           modified.required = Array.from(required);
           return modified;
         }
       }
       ```

    3. Create `apps/backend/src/modules/forms/form-schema.service.ts`:
       ```typescript
       import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';
       import { PrismaService } from '../prisma/prisma.service';
       import { FormType, Prisma } from '@prisma/client';
       import { FormValidationService } from './form-validation.service';
       import { FormSchema, UiSchema } from './types/form.types';

       export interface CreateFormDefinitionDto {
         name: string;
         description?: string;
         formType: FormType;
         schema: FormSchema;
         uiSchema?: UiSchema;
         defaultValues?: Record<string, unknown>;
         allowAnonymous?: boolean;
         requiresApproval?: boolean;
         categoryId?: string;
         tags?: string[];
       }

       @Injectable()
       export class FormSchemaService {
         private readonly logger = new Logger(FormSchemaService.name);

         constructor(
           private prisma: PrismaService,
           private validationService: FormValidationService,
         ) {}

         async create(
           organizationId: string,
           dto: CreateFormDefinitionDto,
           createdById?: string,
         ) {
           // Validate schema first
           const schemaValidation = this.validationService.validateSchema(dto.schema);
           if (!schemaValidation.valid) {
             throw new BadRequestException(`Invalid schema: ${schemaValidation.errors[0]?.message}`);
           }

           return this.prisma.formDefinition.create({
             data: {
               organizationId,
               name: dto.name,
               description: dto.description,
               formType: dto.formType,
               schema: dto.schema as Prisma.InputJsonValue,
               uiSchema: dto.uiSchema as Prisma.InputJsonValue,
               defaultValues: dto.defaultValues as Prisma.InputJsonValue,
               allowAnonymous: dto.allowAnonymous,
               requiresApproval: dto.requiresApproval,
               categoryId: dto.categoryId,
               tags: dto.tags,
               createdById,
             },
           });
         }

         async findById(organizationId: string, id: string) {
           const form = await this.prisma.formDefinition.findFirst({
             where: { id, organizationId },
           });

           if (!form) {
             throw new NotFoundException(`Form definition ${id} not found`);
           }

           return form;
         }

         async findByType(organizationId: string, formType: FormType) {
           return this.prisma.formDefinition.findMany({
             where: { organizationId, formType, isActive: true },
             orderBy: { name: 'asc' },
           });
         }

         async publish(organizationId: string, id: string): Promise<void> {
           const form = await this.findById(organizationId, id);

           // If already published with submissions, create new version
           if (form.isPublished) {
             const hasSubmissions = await this.prisma.formSubmission.count({
               where: { formDefinitionId: id },
             });

             if (hasSubmissions > 0) {
               // Create new version
               await this.prisma.formDefinition.create({
                 data: {
                   ...form,
                   id: undefined,
                   version: form.version + 1,
                   isPublished: true,
                   publishedAt: new Date(),
                   createdAt: undefined,
                   updatedAt: undefined,
                 },
               });

               // Mark old version as inactive
               await this.prisma.formDefinition.update({
                 where: { id },
                 data: { isActive: false },
               });

               return;
             }
           }

           // Just publish current version
           await this.prisma.formDefinition.update({
             where: { id },
             data: { isPublished: true, publishedAt: new Date() },
           });
         }

         async getPublishedForm(organizationId: string, name: string) {
           return this.prisma.formDefinition.findFirst({
             where: {
               organizationId,
               name,
               isPublished: true,
               isActive: true,
             },
             orderBy: { version: 'desc' },
           });
         }
       }
       ```
  </action>
  <verify>
    - Files compile: `cd apps/backend && npx tsc --noEmit`
    - Ajv configured correctly
  </verify>
  <done>FormValidationService with Ajv and FormSchemaService with versioning created</done>
</task>

<task type="auto">
  <name>Task 3: Create form submission service and controller</name>
  <files>
    apps/backend/src/modules/forms/form-submission.service.ts
    apps/backend/src/modules/forms/dto/submit-form.dto.ts
    apps/backend/src/modules/forms/dto/index.ts
    apps/backend/src/modules/forms/forms.controller.ts
    apps/backend/src/modules/forms/forms.module.ts
    apps/backend/src/app.module.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/forms/dto/submit-form.dto.ts`:
       ```typescript
       import { IsObject, IsOptional, IsString } from 'class-validator';

       export class SubmitFormDto {
         @IsObject()
         data: Record<string, unknown>;

         @IsOptional()
         @IsString()
         entityType?: string;

         @IsOptional()
         @IsString()
         entityId?: string;
       }
       ```

    2. Create `apps/backend/src/modules/forms/form-submission.service.ts`:
       ```typescript
       import { Injectable, Logger, BadRequestException, NotFoundException } from '@nestjs/common';
       import { EventEmitter2 } from '@nestjs/event-emitter';
       import { PrismaService } from '../prisma/prisma.service';
       import { FormSubmissionStatus, Prisma } from '@prisma/client';
       import { FormSchemaService } from './form-schema.service';
       import { FormValidationService } from './form-validation.service';
       import { FormSchema, UiSchema } from './types/form.types';
       import { nanoid } from 'nanoid';  // Install: npm install nanoid

       export interface FormSubmittedEvent {
         organizationId: string;
         submissionId: string;
         formDefinitionId: string;
         formType: string;
         entityType?: string;
         entityId?: string;
         submittedById?: string;
         isAnonymous: boolean;
       }

       @Injectable()
       export class FormSubmissionService {
         private readonly logger = new Logger(FormSubmissionService.name);

         constructor(
           private prisma: PrismaService,
           private schemaService: FormSchemaService,
           private validationService: FormValidationService,
           private eventEmitter: EventEmitter2,
         ) {}

         async submit(params: {
           organizationId: string;
           formDefinitionId: string;
           data: Record<string, unknown>;
           entityType?: string;
           entityId?: string;
           submittedById?: string;
           ipAddress?: string;
           userAgent?: string;
         }) {
           const form = await this.schemaService.findById(
             params.organizationId,
             params.formDefinitionId,
           );

           if (!form.isPublished) {
             throw new BadRequestException('Form is not published');
           }

           const schema = form.schema as unknown as FormSchema;
           const uiSchema = form.uiSchema as unknown as UiSchema;

           // Apply conditionals if any
           const effectiveSchema = uiSchema?.conditionals
             ? this.validationService.applyConditionals(schema, params.data, uiSchema.conditionals)
             : schema;

           // Validate submission
           const validation = this.validationService.validate(effectiveSchema, params.data);

           if (!validation.valid) {
             throw new BadRequestException({
               message: 'Validation failed',
               errors: validation.errors,
             });
           }

           // Generate anonymous access code if anonymous
           const isAnonymous = !params.submittedById && form.allowAnonymous;
           const anonymousAccessCode = isAnonymous ? nanoid(12) : null;

           // Create submission
           const submission = await this.prisma.formSubmission.create({
             data: {
               organizationId: params.organizationId,
               formDefinitionId: params.formDefinitionId,
               formDefinitionVersion: form.version,
               data: params.data as Prisma.InputJsonValue,
               status: FormSubmissionStatus.SUBMITTED,
               entityType: params.entityType,
               entityId: params.entityId,
               submittedById: params.submittedById,
               submitterIp: params.ipAddress,
               submitterAgent: params.userAgent,
               anonymousAccessCode,
             },
           });

           // Emit event for downstream processing
           this.eventEmitter.emit('form.submitted', {
             organizationId: params.organizationId,
             submissionId: submission.id,
             formDefinitionId: params.formDefinitionId,
             formType: form.formType,
             entityType: params.entityType,
             entityId: params.entityId,
             submittedById: params.submittedById,
             isAnonymous,
           } as FormSubmittedEvent);

           return {
             id: submission.id,
             status: submission.status,
             accessCode: anonymousAccessCode,
           };
         }

         async findById(organizationId: string, id: string) {
           const submission = await this.prisma.formSubmission.findFirst({
             where: { id, organizationId },
             include: { formDefinition: true },
           });

           if (!submission) {
             throw new NotFoundException(`Submission ${id} not found`);
           }

           return submission;
         }

         async findByAccessCode(accessCode: string) {
           const submission = await this.prisma.formSubmission.findFirst({
             where: { anonymousAccessCode: accessCode },
             include: { formDefinition: { select: { name: true, formType: true } } },
           });

           if (!submission) {
             throw new NotFoundException('Submission not found');
           }

           return {
             id: submission.id,
             formName: submission.formDefinition.name,
             status: submission.status,
             submittedAt: submission.submittedAt,
           };
         }
       }
       ```

    3. Install nanoid:
       ```bash
       cd apps/backend && npm install nanoid
       ```

    4. Create `apps/backend/src/modules/forms/forms.controller.ts`:
       ```typescript
       import { Controller, Get, Post, Patch, Body, Param, Query, UseGuards, Req, Ip, Headers } from '@nestjs/common';
       import { JwtAuthGuard } from '../../common/guards/jwt-auth.guard';
       import { TenantGuard } from '../../common/guards/tenant.guard';
       import { RolesGuard } from '../../common/guards/roles.guard';
       import { Roles } from '../../common/decorators/roles.decorator';
       import { CurrentUser } from '../../common/decorators/current-user.decorator';
       import { TenantId } from '../../common/decorators/tenant-id.decorator';
       import { FormSchemaService, CreateFormDefinitionDto } from './form-schema.service';
       import { FormSubmissionService } from './form-submission.service';
       import { SubmitFormDto } from './dto/submit-form.dto';
       import { FormType, UserRole } from '@prisma/client';

       @Controller('api/v1/forms')
       export class FormsController {
         constructor(
           private schemaService: FormSchemaService,
           private submissionService: FormSubmissionService,
         ) {}

         // --- Form Definition Endpoints ---

         @Post('definitions')
         @UseGuards(JwtAuthGuard, TenantGuard, RolesGuard)
         @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
         async createDefinition(
           @TenantId() orgId: string,
           @CurrentUser() user: { id: string },
           @Body() dto: CreateFormDefinitionDto,
         ) {
           return this.schemaService.create(orgId, dto, user.id);
         }

         @Get('definitions')
         @UseGuards(JwtAuthGuard, TenantGuard)
         async listDefinitions(
           @TenantId() orgId: string,
           @Query('type') formType?: FormType,
         ) {
           if (formType) {
             return this.schemaService.findByType(orgId, formType);
           }
           // List all active forms
           return this.schemaService.findByType(orgId, FormType.CUSTOM);
         }

         @Get('definitions/:id')
         @UseGuards(JwtAuthGuard, TenantGuard)
         async getDefinition(
           @TenantId() orgId: string,
           @Param('id') id: string,
         ) {
           return this.schemaService.findById(orgId, id);
         }

         @Post('definitions/:id/publish')
         @UseGuards(JwtAuthGuard, TenantGuard, RolesGuard)
         @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
         async publishDefinition(
           @TenantId() orgId: string,
           @Param('id') id: string,
         ) {
           await this.schemaService.publish(orgId, id);
           return { message: 'Form published successfully' };
         }

         // --- Submission Endpoints ---

         @Post('definitions/:id/submit')
         @UseGuards(JwtAuthGuard, TenantGuard)
         async submitForm(
           @TenantId() orgId: string,
           @Param('id') formId: string,
           @CurrentUser() user: { id: string },
           @Body() dto: SubmitFormDto,
           @Ip() ip: string,
           @Headers('user-agent') userAgent: string,
         ) {
           return this.submissionService.submit({
             organizationId: orgId,
             formDefinitionId: formId,
             data: dto.data,
             entityType: dto.entityType,
             entityId: dto.entityId,
             submittedById: user.id,
             ipAddress: ip,
             userAgent,
           });
         }

         // Anonymous submission endpoint (no auth guard for form itself)
         @Post('public/:formName/submit')
         async submitAnonymous(
           @Param('formName') formName: string,
           @Query('org') orgSlug: string,
           @Body() dto: SubmitFormDto,
           @Ip() ip: string,
           @Headers('user-agent') userAgent: string,
         ) {
           // This would need org lookup by slug - simplified for now
           throw new Error('Anonymous submission requires org resolution - implement in Portal phase');
         }

         @Get('submissions/:id')
         @UseGuards(JwtAuthGuard, TenantGuard)
         async getSubmission(
           @TenantId() orgId: string,
           @Param('id') id: string,
         ) {
           return this.submissionService.findById(orgId, id);
         }

         // Anonymous status check
         @Get('public/status/:accessCode')
         async checkStatus(@Param('accessCode') accessCode: string) {
           return this.submissionService.findByAccessCode(accessCode);
         }
       }
       ```

    5. Create `apps/backend/src/modules/forms/forms.module.ts`:
       ```typescript
       import { Module } from '@nestjs/common';
       import { FormSchemaService } from './form-schema.service';
       import { FormValidationService } from './form-validation.service';
       import { FormSubmissionService } from './form-submission.service';
       import { FormsController } from './forms.controller';

       @Module({
         providers: [FormSchemaService, FormValidationService, FormSubmissionService],
         controllers: [FormsController],
         exports: [FormSchemaService, FormValidationService, FormSubmissionService],
       })
       export class FormsModule {}
       ```

    6. Update `apps/backend/src/app.module.ts`:
       - Import FormsModule
       - Add to imports array
  </action>
  <verify>
    - App builds: `cd apps/backend && npm run build`
    - App starts: `cd apps/backend && npm run start:dev`
    - Create form definition via API
    - Submit form and verify validation works
  </verify>
  <done>FormsModule with schema validation, submission service, and API endpoints created</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build succeeds: `cd apps/backend && npm run build`
2. Database has form_definitions and form_submissions tables
3. Create a form definition: POST /api/v1/forms/definitions
4. Publish it: POST /api/v1/forms/definitions/:id/publish
5. Submit data: POST /api/v1/forms/definitions/:id/submit
6. Verify validation rejects invalid data
7. Verify form.submitted event is emitted
</verification>

<success_criteria>
- FormDefinition stores JSON Schema definitions
- FormValidation validates submissions with Ajv
- Conditionals can dynamically require fields
- Form versions are preserved for historical accuracy
- Anonymous submissions supported with access codes
- form.submitted event enables downstream processing
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-07-SUMMARY.md`
</output>
