---
phase: 01-foundation-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - apps/backend/src/modules/audit/audit.module.ts
  - apps/backend/src/modules/audit/audit.service.ts
  - apps/backend/src/modules/audit/audit-description.service.ts
  - apps/backend/src/modules/audit/handlers/case-audit.handler.ts
  - apps/backend/src/modules/audit/handlers/investigation-audit.handler.ts
  - apps/backend/src/modules/audit/dto/audit-log-query.dto.ts
  - apps/backend/src/modules/audit/audit.controller.ts
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "All mutations log to AUDIT_LOG with natural language descriptions"
    - "Audit entries include both structured fields AND human-readable description"
    - "Audit log is queryable by entity type, entity ID, and actor"
    - "Event handlers automatically capture audit entries when events fire"
    - "Sensitive reads (Case views, RIU views) are also logged"
  artifacts:
    - path: "apps/backend/src/modules/audit/audit.service.ts"
      provides: "Unified audit logging service"
      contains: "buildDescription"
    - path: "apps/backend/src/modules/audit/handlers/case-audit.handler.ts"
      provides: "Event handlers for Case audit logging"
      contains: "@OnEvent"
    - path: "apps/backend/prisma/schema.prisma"
      provides: "AUDIT_LOG table with partitioning indexes"
      contains: "audit_logs"
  key_links:
    - from: "apps/backend/src/modules/audit/handlers/case-audit.handler.ts"
      to: "CaseCreatedEvent"
      via: "@OnEvent decorator"
      pattern: "case\\.created"
---

<objective>
Implement the unified AUDIT_LOG service that captures all mutations with natural language descriptions, enabling comprehensive audit trails for compliance and AI context.

Purpose: Compliance requires complete audit trails. AI features need historical context. This service subscribes to domain events and logs both structured data and human-readable descriptions.

Output: AuditModule with service, event handlers, and query API.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
@apps/backend/prisma/schema.prisma
@apps/backend/src/modules/events/events/case.events.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance AuditLog schema with partitioning indexes</name>
  <files>
    apps/backend/prisma/schema.prisma
  </files>
  <action>
    1. The AuditLog model already exists in schema.prisma. Verify it has all required fields:
       - id, organizationId
       - entityType (AuditEntityType enum), entityId
       - action (string), actionCategory (AuditActionCategory enum)
       - actionDescription (natural language string) - THIS IS CRITICAL
       - actorUserId, actorType (ActorType enum), actorName (denormalized)
       - changes (Json), context (Json)
       - ipAddress, userAgent, requestId
       - createdAt (NO updatedAt - append-only)

    2. Verify the indexes exist for query patterns from CONTEXT.md:
       - [organizationId, createdAt] - time-based queries
       - [organizationId, entityType, entityId, createdAt] - entity timeline
       - [organizationId, actorUserId, createdAt] - user activity
       - [organizationId, actionCategory, createdAt] - category filtering

    3. Add a comment about partitioning strategy (actual partitioning is DB-level):
       ```prisma
       /// AuditLog provides unified activity tracking across all entities.
       /// This is an append-only table - records are never updated or deleted.
       /// PARTITIONING: Partition by created_at in production (monthly partitions)
       /// RETENTION: 7 years per CONTEXT.md compliance requirements
       ```

    4. Run migration if any changes:
       ```bash
       cd apps/backend && npx prisma migrate dev --name enhance_audit_log
       ```
  </action>
  <verify>
    - Schema valid: `cd apps/backend && npx prisma validate`
    - Prisma client generated: `cd apps/backend && npx prisma generate`
  </verify>
  <done>AuditLog schema verified with all fields, indexes, and documentation for partitioning</done>
</task>

<task type="auto">
  <name>Task 2: Create AuditService with description builder</name>
  <files>
    apps/backend/src/modules/audit/audit.module.ts
    apps/backend/src/modules/audit/audit.service.ts
    apps/backend/src/modules/audit/audit-description.service.ts
    apps/backend/src/modules/audit/dto/audit-log-query.dto.ts
    apps/backend/src/modules/audit/dto/audit-log-response.dto.ts
    apps/backend/src/modules/audit/dto/index.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/audit/dto/audit-log-query.dto.ts`:
       ```typescript
       import { IsOptional, IsString, IsEnum, IsDateString, IsInt, Min, Max } from 'class-validator';
       import { Type } from 'class-transformer';
       import { AuditEntityType, AuditActionCategory } from '@prisma/client';

       export class AuditLogQueryDto {
         @IsOptional()
         @IsEnum(AuditEntityType)
         entityType?: AuditEntityType;

         @IsOptional()
         @IsString()
         entityId?: string;

         @IsOptional()
         @IsString()
         actorUserId?: string;

         @IsOptional()
         @IsEnum(AuditActionCategory)
         actionCategory?: AuditActionCategory;

         @IsOptional()
         @IsDateString()
         startDate?: string;

         @IsOptional()
         @IsDateString()
         endDate?: string;

         @IsOptional()
         @Type(() => Number)
         @IsInt()
         @Min(1)
         @Max(100)
         limit?: number = 50;

         @IsOptional()
         @Type(() => Number)
         @IsInt()
         @Min(0)
         offset?: number = 0;
       }
       ```

    2. Create `apps/backend/src/modules/audit/dto/audit-log-response.dto.ts` with response shape.

    3. Create `apps/backend/src/modules/audit/audit-description.service.ts`:
       ```typescript
       import { Injectable } from '@nestjs/common';
       import { PrismaService } from '../prisma/prisma.service';

       @Injectable()
       export class AuditDescriptionService {
         constructor(private prisma: PrismaService) {}

         async buildCaseCreatedDescription(event: {
           actorUserId: string;
           caseId: string;
           referenceNumber: string;
           sourceChannel: string;
         }): Promise<string> {
           const actor = await this.getActorName(event.actorUserId);
           return `${actor} created case ${event.referenceNumber} via ${event.sourceChannel}`;
         }

         async buildCaseAssignedDescription(event: {
           actorUserId: string;
           caseId: string;
           previousAssigneeId: string | null;
           newAssigneeId: string;
         }): Promise<string> {
           const actor = await this.getActorName(event.actorUserId);
           const newAssignee = await this.getActorName(event.newAssigneeId);

           if (event.previousAssigneeId) {
             const previousAssignee = await this.getActorName(event.previousAssigneeId);
             return `${actor} reassigned case from ${previousAssignee} to ${newAssignee}`;
           }
           return `${actor} assigned case to ${newAssignee}`;
         }

         async buildCaseStatusChangedDescription(event: {
           actorUserId: string;
           referenceNumber?: string;
           previousStatus: string;
           newStatus: string;
           rationale?: string;
         }): Promise<string> {
           const actor = await this.getActorName(event.actorUserId);
           const base = `${actor} changed case status from ${event.previousStatus} to ${event.newStatus}`;
           return event.rationale ? `${base}: "${event.rationale}"` : base;
         }

         async buildCaseUpdatedDescription(event: {
           actorUserId: string;
           changes: Record<string, { old: any; new: any }>;
         }): Promise<string> {
           const actor = await this.getActorName(event.actorUserId);
           const fields = Object.keys(event.changes).join(', ');
           return `${actor} updated case fields: ${fields}`;
         }

         async buildCaseViewedDescription(event: {
           actorUserId: string;
           referenceNumber: string;
         }): Promise<string> {
           const actor = await this.getActorName(event.actorUserId);
           return `${actor} viewed case ${event.referenceNumber}`;
         }

         private async getActorName(userId: string | null): Promise<string> {
           if (!userId) return 'System';

           const user = await this.prisma.user.findUnique({
             where: { id: userId },
             select: { firstName: true, lastName: true },
           });

           return user ? `${user.firstName} ${user.lastName}` : 'Unknown User';
         }
       }
       ```

    4. Create `apps/backend/src/modules/audit/audit.service.ts`:
       ```typescript
       import { Injectable, Logger } from '@nestjs/common';
       import { PrismaService } from '../prisma/prisma.service';
       import { AuditEntityType, AuditActionCategory, ActorType, Prisma } from '@prisma/client';
       import { AuditLogQueryDto } from './dto/audit-log-query.dto';

       export interface CreateAuditLogDto {
         organizationId: string;
         entityType: AuditEntityType;
         entityId: string;
         action: string;
         actionCategory: AuditActionCategory;
         actionDescription: string;
         actorUserId?: string;
         actorType: ActorType;
         actorName?: string;
         changes?: Record<string, { old: unknown; new: unknown }>;
         context?: Record<string, unknown>;
         ipAddress?: string;
         userAgent?: string;
         requestId?: string;
       }

       @Injectable()
       export class AuditService {
         private readonly logger = new Logger(AuditService.name);

         constructor(private prisma: PrismaService) {}

         async log(dto: CreateAuditLogDto): Promise<void> {
           try {
             await this.prisma.auditLog.create({
               data: {
                 organizationId: dto.organizationId,
                 entityType: dto.entityType,
                 entityId: dto.entityId,
                 action: dto.action,
                 actionCategory: dto.actionCategory,
                 actionDescription: dto.actionDescription,
                 actorUserId: dto.actorUserId,
                 actorType: dto.actorType,
                 actorName: dto.actorName,
                 changes: dto.changes as Prisma.InputJsonValue,
                 context: dto.context as Prisma.InputJsonValue,
                 ipAddress: dto.ipAddress,
                 userAgent: dto.userAgent,
                 requestId: dto.requestId,
               },
             });
           } catch (error) {
             // Log error but don't throw - audit failures shouldn't break operations
             this.logger.error(`Failed to create audit log: ${error.message}`, error);
           }
         }

         async findByEntity(
           organizationId: string,
           entityType: AuditEntityType,
           entityId: string,
           limit = 50,
         ) {
           return this.prisma.auditLog.findMany({
             where: { organizationId, entityType, entityId },
             orderBy: { createdAt: 'desc' },
             take: limit,
           });
         }

         async query(organizationId: string, query: AuditLogQueryDto) {
           const where: Prisma.AuditLogWhereInput = {
             organizationId,
             ...(query.entityType && { entityType: query.entityType }),
             ...(query.entityId && { entityId: query.entityId }),
             ...(query.actorUserId && { actorUserId: query.actorUserId }),
             ...(query.actionCategory && { actionCategory: query.actionCategory }),
             ...(query.startDate || query.endDate) && {
               createdAt: {
                 ...(query.startDate && { gte: new Date(query.startDate) }),
                 ...(query.endDate && { lte: new Date(query.endDate) }),
               },
             },
           };

           const [data, total] = await Promise.all([
             this.prisma.auditLog.findMany({
               where,
               orderBy: { createdAt: 'desc' },
               take: query.limit,
               skip: query.offset,
             }),
             this.prisma.auditLog.count({ where }),
           ]);

           return { data, total, limit: query.limit, offset: query.offset };
         }
       }
       ```

    5. Create `apps/backend/src/modules/audit/audit.module.ts`:
       ```typescript
       import { Module, Global } from '@nestjs/common';
       import { AuditService } from './audit.service';
       import { AuditDescriptionService } from './audit-description.service';
       import { CaseAuditHandler } from './handlers/case-audit.handler';
       import { InvestigationAuditHandler } from './handlers/investigation-audit.handler';
       import { AuditController } from './audit.controller';

       @Global()
       @Module({
         providers: [
           AuditService,
           AuditDescriptionService,
           CaseAuditHandler,
           InvestigationAuditHandler,
         ],
         controllers: [AuditController],
         exports: [AuditService, AuditDescriptionService],
       })
       export class AuditModule {}
       ```
  </action>
  <verify>
    - All files compile: `cd apps/backend && npx tsc --noEmit`
    - Prisma client available for imports
  </verify>
  <done>AuditService with description builder and query methods created</done>
</task>

<task type="auto">
  <name>Task 3: Create event handlers and controller</name>
  <files>
    apps/backend/src/modules/audit/handlers/case-audit.handler.ts
    apps/backend/src/modules/audit/handlers/investigation-audit.handler.ts
    apps/backend/src/modules/audit/handlers/index.ts
    apps/backend/src/modules/audit/audit.controller.ts
    apps/backend/src/app.module.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/audit/handlers/case-audit.handler.ts`:
       ```typescript
       import { Injectable } from '@nestjs/common';
       import { OnEvent } from '@nestjs/event-emitter';
       import { AuditService } from '../audit.service';
       import { AuditDescriptionService } from '../audit-description.service';
       import {
         CaseCreatedEvent,
         CaseUpdatedEvent,
         CaseStatusChangedEvent,
         CaseAssignedEvent,
       } from '../../events/events';
       import { AuditEntityType, AuditActionCategory, ActorType } from '@prisma/client';

       @Injectable()
       export class CaseAuditHandler {
         constructor(
           private auditService: AuditService,
           private descriptionService: AuditDescriptionService,
         ) {}

         @OnEvent('case.created', { async: true })
         async handleCaseCreated(event: CaseCreatedEvent): Promise<void> {
           const description = await this.descriptionService.buildCaseCreatedDescription({
             actorUserId: event.actorUserId,
             caseId: event.caseId,
             referenceNumber: event.referenceNumber,
             sourceChannel: event.sourceChannel,
           });

           await this.auditService.log({
             organizationId: event.organizationId,
             entityType: AuditEntityType.CASE,
             entityId: event.caseId,
             action: 'created',
             actionCategory: AuditActionCategory.CREATE,
             actionDescription: description,
             actorUserId: event.actorUserId,
             actorType: this.mapActorType(event.actorType),
             context: {
               referenceNumber: event.referenceNumber,
               sourceChannel: event.sourceChannel,
               categoryId: event.categoryId,
               severity: event.severity,
             },
           });
         }

         @OnEvent('case.updated', { async: true })
         async handleCaseUpdated(event: CaseUpdatedEvent): Promise<void> {
           const description = await this.descriptionService.buildCaseUpdatedDescription({
             actorUserId: event.actorUserId,
             changes: event.changes,
           });

           await this.auditService.log({
             organizationId: event.organizationId,
             entityType: AuditEntityType.CASE,
             entityId: event.caseId,
             action: 'updated',
             actionCategory: AuditActionCategory.UPDATE,
             actionDescription: description,
             actorUserId: event.actorUserId,
             actorType: this.mapActorType(event.actorType),
             changes: event.changes,
           });
         }

         @OnEvent('case.status_changed', { async: true })
         async handleCaseStatusChanged(event: CaseStatusChangedEvent): Promise<void> {
           const description = await this.descriptionService.buildCaseStatusChangedDescription({
             actorUserId: event.actorUserId,
             previousStatus: event.previousStatus,
             newStatus: event.newStatus,
             rationale: event.rationale,
           });

           await this.auditService.log({
             organizationId: event.organizationId,
             entityType: AuditEntityType.CASE,
             entityId: event.caseId,
             action: 'status_changed',
             actionCategory: AuditActionCategory.UPDATE,
             actionDescription: description,
             actorUserId: event.actorUserId,
             actorType: this.mapActorType(event.actorType),
             changes: {
               status: { old: event.previousStatus, new: event.newStatus },
             },
             context: { rationale: event.rationale },
           });
         }

         @OnEvent('case.assigned', { async: true })
         async handleCaseAssigned(event: CaseAssignedEvent): Promise<void> {
           const description = await this.descriptionService.buildCaseAssignedDescription({
             actorUserId: event.actorUserId,
             caseId: event.caseId,
             previousAssigneeId: event.previousAssigneeId,
             newAssigneeId: event.newAssigneeId,
           });

           await this.auditService.log({
             organizationId: event.organizationId,
             entityType: AuditEntityType.CASE,
             entityId: event.caseId,
             action: 'assigned',
             actionCategory: AuditActionCategory.UPDATE,
             actionDescription: description,
             actorUserId: event.actorUserId,
             actorType: this.mapActorType(event.actorType),
             changes: {
               assignedTo: { old: event.previousAssigneeId, new: event.newAssigneeId },
             },
           });
         }

         private mapActorType(type: string): ActorType {
           const mapping: Record<string, ActorType> = {
             USER: ActorType.USER,
             SYSTEM: ActorType.SYSTEM,
             AI: ActorType.AI,
             INTEGRATION: ActorType.INTEGRATION,
             ANONYMOUS: ActorType.ANONYMOUS,
           };
           return mapping[type] || ActorType.SYSTEM;
         }
       }
       ```

    2. Create `apps/backend/src/modules/audit/handlers/investigation-audit.handler.ts`:
       Similar pattern for Investigation events (created, status_changed, assigned).

    3. Create `apps/backend/src/modules/audit/handlers/index.ts` barrel export.

    4. Create `apps/backend/src/modules/audit/audit.controller.ts`:
       ```typescript
       import { Controller, Get, Query, Param, UseGuards } from '@nestjs/common';
       import { JwtAuthGuard } from '../../common/guards/jwt-auth.guard';
       import { TenantGuard } from '../../common/guards/tenant.guard';
       import { RolesGuard } from '../../common/guards/roles.guard';
       import { Roles } from '../../common/decorators/roles.decorator';
       import { TenantId } from '../../common/decorators/tenant-id.decorator';
       import { AuditService } from './audit.service';
       import { AuditLogQueryDto } from './dto/audit-log-query.dto';
       import { AuditEntityType, UserRole } from '@prisma/client';

       @Controller('api/v1/audit')
       @UseGuards(JwtAuthGuard, TenantGuard, RolesGuard)
       export class AuditController {
         constructor(private auditService: AuditService) {}

         @Get()
         @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
         async query(
           @TenantId() orgId: string,
           @Query() query: AuditLogQueryDto,
         ) {
           return this.auditService.query(orgId, query);
         }

         @Get('entity/:entityType/:entityId')
         @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
         async getByEntity(
           @TenantId() orgId: string,
           @Param('entityType') entityType: AuditEntityType,
           @Param('entityId') entityId: string,
           @Query('limit') limit?: number,
         ) {
           return this.auditService.findByEntity(orgId, entityType, entityId, limit);
         }
       }
       ```

    5. Update `apps/backend/src/app.module.ts`:
       - Import AuditModule from './modules/audit/audit.module'
       - Add AuditModule to imports (after EventsModule)
  </action>
  <verify>
    - App compiles: `cd apps/backend && npm run build`
    - App starts: `cd apps/backend && npm run start:dev`
    - Create a case via API (POST /api/v1/cases) and verify audit log entry created
    - Query audit logs via GET /api/v1/audit?entityType=CASE
  </verify>
  <done>Event handlers capture Case/Investigation mutations, controller exposes query API</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build succeeds: `cd apps/backend && npm run build`
2. Create a test case via API
3. Query audit logs: `GET /api/v1/audit?entityType=CASE`
4. Verify audit entry has:
   - Natural language actionDescription (e.g., "John Smith created case CASE-2026-001 via HOTLINE")
   - Structured fields (entityType, entityId, action, changes)
   - Actor information (actorUserId, actorName)
</verification>

<success_criteria>
- AuditLog schema has all required fields per CONTEXT.md
- AuditService logs entries with both natural language AND structured data
- Event handlers automatically capture Case and Investigation mutations
- Audit log query API restricts access by role (System Admin, Compliance Officer)
- Audit failures don't crash the main operation (error is logged, not thrown)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-03-SUMMARY.md`
</output>
