---
phase: 21-project-management
plan: 08
type: execute
wave: 7
depends_on: ["21-02", "21-06"]
files_modified:
  - apps/backend/src/modules/projects/services/mention.service.ts
  - apps/backend/src/modules/projects/listeners/project-event.listener.ts
  - apps/backend/src/modules/projects/gateways/project.gateway.ts
  - apps/frontend/src/components/projects/MentionInput.tsx
  - apps/frontend/src/hooks/use-project-websocket.ts
autonomous: true

must_haves:
  truths:
    - "@mention extraction parses user references from rich text content"
    - "5 event types dispatch notifications: task assignment, @mention, comment, status change, completion"
    - "Notifications are preference-aware using existing NotificationService"
    - "WebSocket project rooms enable real-time updates for collaborators"
    - "Task subscribers receive notifications for all changes on their watched tasks"
    - "MentionInput is keyboard accessible with ARIA labels"
  artifacts:
    - path: "apps/backend/src/modules/projects/services/mention.service.ts"
      provides: "Extracts @mentions from rich text and resolves user IDs"
    - path: "apps/backend/src/modules/projects/listeners/project-event.listener.ts"
      provides: "Event handlers dispatching notifications for 5 event types"
    - path: "apps/backend/src/modules/projects/gateways/project.gateway.ts"
      provides: "WebSocket gateway for real-time project collaboration"
  key_links:
    - from: "project-event.listener.ts"
      to: "notification.service.ts"
      via: "NotificationService.notify() for preference-aware dispatch"
      pattern: "notificationService\\.notify"
    - from: "project.gateway.ts"
      to: "notification.gateway.ts"
      via: "Extends existing WebSocket infrastructure"
      pattern: "WebSocketGateway|SubscribeMessage"
---

<objective>
Harden the @mention extraction, build the full notification dispatch system for project events, and enable real-time WebSocket collaboration within projects. This plan bridges the conversation system (Plan 06) with the platform's existing notification infrastructure (Phase 7), ensuring that @mentions, assignments, status changes, and comments all reach the right people.

Purpose: Collaboration without notifications is useless. Users need to be notified when they're mentioned, assigned, or when tasks they watch change. Real-time updates keep the project board live.
Output: Mention extraction service, 5 event handlers with notification dispatch, WebSocket project rooms.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-project-management/21-06-SUMMARY.md
@apps/backend/src/modules/notifications/services/notification.service.ts
@apps/backend/src/modules/notifications/gateways/notification.gateway.ts
@apps/backend/src/modules/projects/listeners/project-event.listener.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build MentionService and harden event listener with 5 notification handlers</name>
  <files>
    apps/backend/src/modules/projects/services/mention.service.ts
    apps/backend/src/modules/projects/listeners/project-event.listener.ts
    apps/backend/src/modules/projects/projects.module.ts
  </files>
  <action>
**MentionService** (`services/mention.service.ts`):

Injectable service that extracts @mentions from rich text content:

```typescript
@Injectable()
export class MentionService {
  constructor(private prisma: PrismaService) {}

  /**
   * Extract user IDs from content containing @mention spans.
   * Supports two formats:
   * 1. HTML: <span data-mention-id="userId">@Name</span>
   * 2. Plaintext: @[Name](userId) (Markdown-style fallback)
   */
  extractMentions(content: string): string[] {
    const mentions: Set<string> = new Set();

    // HTML data attribute pattern
    const htmlPattern = /data-mention-id="([a-f0-9-]+)"/g;
    let match;
    while ((match = htmlPattern.exec(content)) !== null) {
      mentions.add(match[1]);
    }

    // Markdown-style fallback pattern
    const mdPattern = /@\[([^\]]+)\]\(([a-f0-9-]+)\)/g;
    while ((match = mdPattern.exec(content)) !== null) {
      mentions.add(match[2]);
    }

    return Array.from(mentions);
  }

  /**
   * Validate that mentioned user IDs exist in the organization.
   * Returns only valid user IDs (filters out invalid/deleted users).
   */
  async validateMentions(
    userIds: string[],
    organizationId: string,
  ): Promise<string[]> {
    if (userIds.length === 0) return [];
    const users = await this.prisma.user.findMany({
      where: { id: { in: userIds }, organizationId },
      select: { id: true },
    });
    return users.map((u) => u.id);
  }
}
```

**Enhance project-event.listener.ts** with 5 event handlers:

The listener from Plan 02 may have basic structure. Expand to handle all 5 event types with full notification dispatch:

**Event 1: Task Assignment** (`@OnEvent('project.task.assigned')`)

- Payload: `{ taskId, projectId, assigneeId, assignedById, organizationId }`
- Action:
  - Notify the assignee via NotificationService.notify()
  - Type: `NotificationType.TASK_ASSIGNED` (add to enum if needed)
  - Title: "You were assigned to '{taskTitle}' in {projectName}"
  - Link: `/projects/${projectId}?task=${taskId}`
  - Auto-subscribe the assignee to the task (upsert ProjectTaskSubscriber)
  - Skip if assignee === assignedBy (self-assignment)

**Event 2: @Mention** (`@OnEvent('project.task.mentioned')`)

- Payload: `{ taskId, projectId, updateId, mentionedUserIds, mentionedById, organizationId }`
- Action:
  - For each mentioned user: NotificationService.notify()
  - Type: `NotificationType.MENTION` (already exists in the system)
  - Title: "{mentioner} mentioned you in '{taskTitle}'"
  - Link: `/projects/${projectId}?task=${taskId}&tab=updates`
  - Auto-subscribe mentioned users to the task
  - Skip if mentionedUser === mentionedBy (self-mention)

**Event 3: Comment/Update Added** (`@OnEvent('project.task.update.created')`)

- Payload: `{ taskId, projectId, updateId, authorId, organizationId }`
- Action:
  - Get all task subscribers (ProjectTaskSubscriber where taskId)
  - Notify each subscriber (except the author)
  - Type: `NotificationType.COMMENT` (add to enum if needed)
  - Title: "{author} posted an update on '{taskTitle}'"
  - Link: `/projects/${projectId}?task=${taskId}&tab=updates`

**Event 4: Task Status Change** (`@OnEvent('project.task.status.changed')`)

- Payload: `{ taskId, projectId, oldStatus, newStatus, changedById, organizationId }`
- Action:
  - Get all task subscribers
  - Notify each subscriber (except the changer)
  - Type: `NotificationType.STATUS_CHANGED` (add to enum if needed)
  - Title: "'{taskTitle}' status changed to {newStatus}"
  - Link: `/projects/${projectId}?task=${taskId}`
  - If newStatus === 'DONE': also notify project owner

**Event 5: Task Completed** (`@OnEvent('project.task.completed')`)

- Payload: `{ taskId, projectId, completedById, organizationId }`
- Action:
  - Notify project owner
  - Check if all tasks in project are done — if so, emit `project.completed` event
  - Type: `NotificationType.TASK_COMPLETED` (add to enum if needed)
  - Title: "'{taskTitle}' was completed in {projectName}"

All handlers:

- Use `NotificationService.notify()` which handles dual-channel (in-app + email) and respects user preferences
- Log via `ActivityService.log()` for audit trail
- Use try-catch with error logging — never throw (non-blocking)
- Batch notifications where possible (e.g., mention 5 people = 5 notifications, but sent efficiently)

**Update projects.module.ts**:

- Add MentionService to providers
- Ensure ProjectEventListener has NotificationService and ActivityService injected
  </action>
  <verify>
  `cd apps/backend && npx tsc --noEmit` passes.
  MentionService extracts user IDs from HTML and markdown content.
  Event listener handles all 5 event types.
  </verify>
  <done>MentionService extracts and validates @mentions. 5 event handlers dispatch notifications for assignments, @mentions, comments, status changes, and completion. All notifications are preference-aware via existing NotificationService.</done>
  </task>

<task type="auto">
  <name>Task 2: Build WebSocket project gateway and frontend real-time hook</name>
  <files>
    apps/backend/src/modules/projects/gateways/project.gateway.ts
    apps/frontend/src/hooks/use-project-websocket.ts
    apps/frontend/src/components/projects/MentionInput.tsx
  </files>
  <action>
**ProjectGateway** (`gateways/project.gateway.ts`):

WebSocket gateway for real-time project collaboration. Extends the existing WebSocket infrastructure pattern from notification.gateway.ts:

```typescript
@WebSocketGateway({
  namespace: "/projects",
  cors: { origin: "*" },
})
export class ProjectGateway
  implements OnGatewayConnection, OnGatewayDisconnect
{
  @WebSocketServer() server: Server;

  constructor(
    private jwtService: JwtService,
    private prisma: PrismaService,
  ) {}

  async handleConnection(client: Socket) {
    // Authenticate via JWT token (same pattern as notification gateway)
    const token =
      client.handshake.auth?.token ||
      client.handshake.headers?.authorization?.split(" ")[1];
    try {
      const payload = await this.jwtService.verify(token);
      client.data.userId = payload.sub;
      client.data.organizationId = payload.organizationId;
    } catch {
      client.disconnect();
    }
  }

  handleDisconnect(client: Socket) {
    // Clean up room memberships (automatic by Socket.io)
  }

  @SubscribeMessage("join-project")
  handleJoinProject(client: Socket, projectId: string) {
    // Verify user has access to this project (same org)
    const room = `project:${client.data.organizationId}:${projectId}`;
    client.join(room);
    // Broadcast presence: "user joined"
    this.server.to(room).emit("user-joined", {
      userId: client.data.userId,
      projectId,
    });
  }

  @SubscribeMessage("leave-project")
  handleLeaveProject(client: Socket, projectId: string) {
    const room = `project:${client.data.organizationId}:${projectId}`;
    client.leave(room);
    this.server.to(room).emit("user-left", {
      userId: client.data.userId,
      projectId,
    });
  }

  // Methods called by services to broadcast changes:

  broadcastTaskUpdate(
    organizationId: string,
    projectId: string,
    event: string,
    data: any,
  ) {
    const room = `project:${organizationId}:${projectId}`;
    this.server.to(room).emit(event, data);
  }

  broadcastTaskCreated(orgId: string, projectId: string, task: any) {
    this.broadcastTaskUpdate(orgId, projectId, "task-created", task);
  }

  broadcastTaskUpdated(orgId: string, projectId: string, task: any) {
    this.broadcastTaskUpdate(orgId, projectId, "task-updated", task);
  }

  broadcastTaskDeleted(orgId: string, projectId: string, taskId: string) {
    this.broadcastTaskUpdate(orgId, projectId, "task-deleted", { taskId });
  }

  broadcastUpdateCreated(orgId: string, projectId: string, update: any) {
    this.broadcastTaskUpdate(orgId, projectId, "update-created", update);
  }

  broadcastTaskMoved(
    orgId: string,
    projectId: string,
    data: { taskId: string; oldStatus: string; newStatus: string },
  ) {
    this.broadcastTaskUpdate(orgId, projectId, "task-moved", data);
  }
}
```

Wire the gateway into project services: When task CRUD operations happen, call the gateway's broadcast methods so all connected clients see updates in real-time.

**use-project-websocket.ts** — Frontend hook for WebSocket connection:

```typescript
export function useProjectWebSocket(projectId: string | undefined) {
  const { token } = useAuth(); // or however auth token is accessed
  const queryClient = useQueryClient();

  useEffect(() => {
    if (!projectId || !token) return;

    const socket = io("/projects", {
      auth: { token },
      transports: ["websocket"],
    });

    socket.emit("join-project", projectId);

    // Listen for real-time events and invalidate React Query cache:
    socket.on("task-created", () => {
      queryClient.invalidateQueries(["project", projectId, "tasks"]);
    });

    socket.on("task-updated", (task) => {
      // Optimistic: update task in cache directly
      queryClient.setQueryData(["project", projectId, "tasks"], (old) => {
        // Update the specific task in the list
      });
    });

    socket.on("task-deleted", ({ taskId }) => {
      queryClient.invalidateQueries(["project", projectId, "tasks"]);
    });

    socket.on("update-created", () => {
      queryClient.invalidateQueries(["project", projectId, "updates"]);
    });

    socket.on("task-moved", () => {
      queryClient.invalidateQueries(["project", projectId, "tasks"]);
    });

    socket.on("user-joined", ({ userId }) => {
      // Update presence indicator (show active users)
    });

    return () => {
      socket.emit("leave-project", projectId);
      socket.disconnect();
    };
  }, [projectId, token]);
}
```

Use this hook in the project detail page to enable real-time updates.

**Enhance MentionInput.tsx** for accessibility:

- ARIA attributes:
  - `role="textbox"` on the input area
  - `aria-label="Write an update. Type @ to mention someone."`
  - `aria-expanded` on the autocomplete popover
  - `aria-activedescendant` pointing to the currently highlighted option
  - `role="listbox"` on the autocomplete list
  - `role="option"` on each autocomplete item
- Keyboard navigation:
  - Arrow Up/Down to navigate autocomplete options
  - Enter to select highlighted option
  - Escape to close autocomplete
  - Tab to move focus to Submit button
  - Ctrl+Enter to submit from anywhere in the input
- Screen reader announcements:
  - "X results found" when autocomplete opens
  - "Selected @Name" when a mention is inserted
    </action>
    <verify>
    `cd apps/backend && npx tsc --noEmit` passes.
    `cd apps/frontend && npx tsc --noEmit` passes.
    WebSocket gateway handles join/leave and broadcasts events.
    Frontend hook connects and invalidates queries on events.
    MentionInput passes basic accessibility checks.
    </verify>
    <done>WebSocket project gateway with room-based real-time updates. Frontend hook connects to project room and invalidates React Query cache on events. MentionInput enhanced with full ARIA attributes and keyboard navigation.</done>
    </task>

</tasks>

<verification>
- `npx tsc --noEmit` passes from both apps/backend and apps/frontend
- MentionService correctly extracts user IDs from HTML and markdown @mention formats
- All 5 event handlers dispatch notifications via NotificationService
- WebSocket project rooms work (join, leave, broadcast)
- Frontend receives real-time updates and refreshes data
- MentionInput is keyboard accessible with ARIA labels
</verification>

<success_criteria>

- @mention extraction works for both HTML spans and markdown-style mentions
- Mentioned users validated against organization before notification
- 5 event types trigger appropriate notifications
- Notifications are preference-aware (use existing NotificationService.notify)
- Auto-subscription on mention and assignment
- WebSocket rooms scoped by organization and project
- Real-time task updates visible to all project collaborators
- MentionInput meets WCAG 2.1 AA accessibility requirements
  </success_criteria>

<output>
After completion, create `.planning/phases/21-project-management/21-08-SUMMARY.md`
</output>
