# Phase 14.2: Case Creation & Search Fixes - Research

**Researched:** 2026-02-09
**Domain:** React forms (category dropdowns), Elasticsearch/PostgreSQL search
**Confidence:** HIGH

## Summary

This phase addresses two issues discovered during Phase 14.1 human verification:

1. **Category/Subcategory dropdowns missing from case creation form** - The backend DTO already supports `primaryCategoryId` and `secondaryCategoryId`, but the frontend form lacks the dropdowns and the Zod schema doesn't include these fields. An authenticated categories endpoint is needed.

2. **Unified search returning empty results** - The search uses Elasticsearch, but the indices are likely empty for the demo tenant. Cases have PostgreSQL `search_vector` populated but haven't been indexed to Elasticsearch. The search gracefully returns empty (200 OK) when indices don't exist.

**Primary recommendation:** Add the missing category form fields using the existing `useAuthenticatedCategories` hook pattern, and either populate Elasticsearch or add a PostgreSQL FTS fallback to the unified search.

## Standard Stack

The established libraries/tools for this domain:

### Core

| Library               | Version | Purpose               | Why Standard                                  |
| --------------------- | ------- | --------------------- | --------------------------------------------- |
| react-hook-form       | Latest  | Form state management | Already used in case-creation-form.tsx        |
| zod                   | Latest  | Schema validation     | Already used in case-schema.ts                |
| @tanstack/react-query | Latest  | Data fetching         | Already used in useAuthenticatedCategories.ts |
| @nestjs/elasticsearch | 10.x    | Elasticsearch client  | Already configured in search module           |

### Supporting

| Library          | Version | Purpose      | When to Use                                |
| ---------------- | ------- | ------------ | ------------------------------------------ |
| shadcn/ui Select | N/A     | Dropdown UI  | Already used for source/severity dropdowns |
| Prisma           | 5.x     | Database ORM | Raw SQL for PostgreSQL FTS                 |

## Architecture Patterns

### Issue 1: Category Dropdown Pattern

The codebase already has a pattern for category fetching in `useAuthenticatedCategories.ts`:

```typescript
// Source: apps/frontend/src/hooks/useAuthenticatedCategories.ts
export function useAuthenticatedCategories(): UseAuthenticatedCategoriesResult {
  const {
    data: flatCategories,
    isLoading,
    error,
    refetch,
  } = useQuery({
    queryKey: ["authenticated-categories"],
    queryFn: async () => {
      const response = await apiClient.get<{ categories: Category[] }>(
        "/categories",
      );
      return response.categories || [];
    },
    staleTime: 5 * 60 * 1000,
    gcTime: 10 * 60 * 1000,
  });

  const categories = flatCategories
    ? buildCategoryTree(flatCategories.filter((c) => c.isEnabled))
    : [];

  return {
    categories,
    flatCategories: flatCategories || [],
    isLoading,
    error,
    refetch,
  };
}
```

**Problem:** The `/api/v1/categories` endpoint does NOT exist in the backend. The hook calls a non-existent endpoint.

**Required Pattern - Backend Categories Controller:**

```typescript
// Source: Pattern derived from existing controllers
@Controller("categories")
@ApiTags("Categories")
@ApiBearerAuth()
@UseGuards(JwtAuthGuard, TenantGuard)
export class CategoriesController {
  @Get()
  @ApiOperation({ summary: "Get all categories for the tenant" })
  async getCategories(
    @TenantId() organizationId: string,
    @Query("module") module?: CategoryModule,
  ): Promise<{ categories: Category[] }> {
    const categories = await this.prisma.category.findMany({
      where: {
        organizationId,
        isActive: true,
        ...(module ? { module } : {}),
      },
      orderBy: [{ level: "asc" }, { sortOrder: "asc" }],
    });
    return { categories };
  }
}
```

### Cascading Dropdown Pattern (Parent/Child Categories)

The Category model has a hierarchical structure:

- `level: 0` = Top-level categories (e.g., "Harassment", "Fraud")
- `level: 1` = Subcategories with `parentCategoryId` set

```typescript
// Frontend pattern for cascading dropdowns
const { categories } = useAuthenticatedCategories();

// Get level-0 categories only
const topLevelCategories = categories.filter((c) => c.level === 0);

// Get subcategories for selected parent
const subcategories = categories.filter(
  (c) => c.parentCategoryId === selectedCategoryId,
);
```

### Issue 2: Search Architecture Analysis

**Current Search Flow:**

```
Frontend -> GET /api/v1/search/unified?q=harassment
         -> SearchController.unifiedSearch()
         -> UnifiedSearchService.search()
         -> ElasticsearchService.search() against org_{orgId}_cases
         -> Index not found (404) -> Returns empty results
```

**Index Naming Convention:**

```typescript
// Source: apps/backend/src/modules/search/indexing/indexing.service.ts:57
getIndexName(organizationId: string, entityType: string): string {
  return `org_${organizationId}_${entityType}`.toLowerCase();
}
// Example: org_abc123_cases
```

**Empty Results Root Cause:**

```typescript
// Source: apps/backend/src/modules/search/unified-search.service.ts:239-245
} catch (error) {
  // Handle index not found (no data yet for this tenant/type)
  if (this.isIndexNotFoundError(error)) {
    this.logger.debug(`Index ${indexName} not found - returning empty results`);
    return { entityType, count: 0, hits: [] };
  }
```

This means if Elasticsearch indices don't exist or are empty, the search silently returns no results.

### PostgreSQL FTS Already Exists (Fallback Option)

```typescript
// Source: apps/backend/src/modules/cases/cases.service.ts:273-283
conditions.push(`c.search_vector @@ to_tsquery('english', $${paramIndex})`);
params.push(tsQuery);
// ...
SELECT c.*,
       ts_rank(c.search_vector, to_tsquery('english', $${tsQueryParamIndex})) as search_rank
FROM cases c
WHERE ${whereClause}
```

The `search_vector` column is populated (context confirms 4,500 cases have it), but it's only used by the CasesService, not the UnifiedSearchService.

## Don't Hand-Roll

| Problem                | Don't Build         | Use Instead                    | Why                                        |
| ---------------------- | ------------------- | ------------------------------ | ------------------------------------------ |
| Category tree building | Manual recursion    | Existing `buildCategoryTree()` | Already handles sorting and tree structure |
| Form validation        | Manual checks       | Zod schema extension           | Consistent with existing patterns          |
| Search fallback        | Custom search logic | PostgreSQL FTS or index sync   | Both already exist in codebase             |

**Key insight:** Both Category fetching patterns and PostgreSQL FTS already exist - we just need to connect the pieces.

## Common Pitfalls

### Pitfall 1: Missing Backend Endpoint

**What goes wrong:** Frontend hook `useAuthenticatedCategories` calls `/categories` endpoint that doesn't exist
**Why it happens:** The public ethics portal has categories at `/public/ethics/:slug/categories`, but no authenticated endpoint exists
**How to avoid:** Create `CategoriesController` in a new or existing module
**Warning signs:** 404 errors in network tab when loading case creation form

### Pitfall 2: Category Filter for CASE Module

**What goes wrong:** All categories returned instead of just CASE module categories
**Why it happens:** Categories have a `module` field (CASE, DISCLOSURE, etc.)
**How to avoid:** Filter by `module: 'CASE'` when fetching for case creation
**Warning signs:** Seeing disclosure-specific categories in case creation dropdown

### Pitfall 3: Empty Elasticsearch Indices

**What goes wrong:** Search returns empty despite database having data
**Why it happens:** Elasticsearch indices not created/populated for tenant
**How to avoid:** Either populate indices on tenant creation or add PostgreSQL FTS fallback
**Warning signs:** Search works for some tenants but not demo tenant

### Pitfall 4: Raw SQL Table/Column Names

**What goes wrong:** Prisma query fails with "relation does not exist"
**Why it happens:** Per decision 14.1-04, must use `@@map` names (snake_case)
**How to avoid:** Use `cases` not `Case`, `organization_id` not `organizationId`
**Warning signs:** SQL errors mentioning table names

## Code Examples

### Adding Category Fields to Zod Schema

```typescript
// Source: apps/frontend/src/lib/validations/case-schema.ts (to modify)
export const caseCreationSchema = z.object({
  // ... existing fields

  // Add category fields
  primaryCategoryId: z.string().uuid().optional(),
  secondaryCategoryId: z.string().uuid().optional(),
});
```

### Category Dropdown in BasicInfoSection

```typescript
// Source: Pattern from existing dropdowns in basic-info-section.tsx
{/* Primary Category */}
<div className="space-y-2">
  <Label htmlFor="primaryCategoryId">Category</Label>
  <Select
    value={watch('primaryCategoryId') || undefined}
    onValueChange={(value) => {
      setValue('primaryCategoryId', value);
      setValue('secondaryCategoryId', undefined); // Reset subcategory
    }}
  >
    <SelectTrigger id="primaryCategoryId">
      <SelectValue placeholder="Select category..." />
    </SelectTrigger>
    <SelectContent>
      {categories
        .filter((c) => c.level === 0)
        .map((category) => (
          <SelectItem key={category.id} value={category.id}>
            {category.name}
          </SelectItem>
        ))}
    </SelectContent>
  </Select>
</div>

{/* Subcategory - only show if primary selected */}
{primaryCategoryId && (
  <div className="space-y-2">
    <Label htmlFor="secondaryCategoryId">Subcategory</Label>
    <Select
      value={watch('secondaryCategoryId') || undefined}
      onValueChange={(value) => setValue('secondaryCategoryId', value)}
    >
      <SelectTrigger id="secondaryCategoryId">
        <SelectValue placeholder="Select subcategory..." />
      </SelectTrigger>
      <SelectContent>
        {categories
          .filter((c) => c.parentCategoryId === primaryCategoryId)
          .map((category) => (
            <SelectItem key={category.id} value={category.id}>
              {category.name}
            </SelectItem>
          ))}
      </SelectContent>
    </Select>
  </div>
)}
```

### PostgreSQL FTS Fallback for Unified Search

```typescript
// Pattern for adding PostgreSQL FTS to UnifiedSearchService
async searchCasesWithFts(
  organizationId: string,
  query: string,
  limit: number,
): Promise<EntityTypeResult> {
  const searchWords = query
    .split(/\s+/)
    .filter((word) => word.length > 0)
    .map((word) => word.replace(/[^\w]/g, ''))
    .filter((word) => word.length > 0);

  if (searchWords.length === 0) {
    return { entityType: 'cases', count: 0, hits: [] };
  }

  const tsQuery = searchWords.map((word) => `${word}:*`).join(' & ');

  const results = await this.prisma.$queryRaw<CaseSearchResult[]>`
    SELECT id, reference_number, details, summary, status, severity,
           ts_rank(search_vector, to_tsquery('english', ${tsQuery})) as score
    FROM cases
    WHERE organization_id = ${organizationId}
      AND search_vector @@ to_tsquery('english', ${tsQuery})
    ORDER BY score DESC, created_at DESC
    LIMIT ${limit}
  `;

  return {
    entityType: 'cases',
    count: results.length,
    hits: results.map((r) => ({
      id: r.id,
      entityType: 'cases',
      score: r.score,
      document: { referenceNumber: r.reference_number, details: r.details, ... },
    })),
  };
}
```

## State of the Art

| Old Approach           | Current Approach                   | When Changed | Impact                              |
| ---------------------- | ---------------------------------- | ------------ | ----------------------------------- |
| Single search endpoint | Unified search across entity types | Phase 6      | Users can search everything at once |
| Manual pagination      | Offset-based pagination            | Phase 14.1   | Fixed 400 errors on list pages      |

**Current state:**

- Elasticsearch is the primary search backend for unified search
- PostgreSQL FTS exists for the cases module but isn't exposed to unified search
- Categories endpoint exists for public portal but not authenticated users

## Open Questions

### 1. Should we populate Elasticsearch or add PostgreSQL FTS fallback?

**What we know:**

- PostgreSQL FTS is already working and has data
- Elasticsearch requires index creation and document syncing
- Demo environments may not have Elasticsearch running

**What's unclear:**

- Is Elasticsearch available in the demo environment?
- Should we add a fallback or require Elasticsearch?

**Recommendation:** Add PostgreSQL FTS fallback when ES indices don't exist. This provides immediate results without requiring ES infrastructure.

### 2. Where should the CategoriesController live?

**What we know:**

- Could be a new module `categories/`
- Could be added to `organization/` module
- Ethics portal already has category fetching in `ethics-portal.service.ts`

**Recommendation:** Create a minimal `CategoriesController` in the organization module since categories are tenant-scoped settings.

## Sources

### Primary (HIGH confidence)

- `apps/backend/src/modules/cases/dto/create-case.dto.ts` - Backend DTO already has category fields
- `apps/frontend/src/hooks/useAuthenticatedCategories.ts` - Hook exists but endpoint missing
- `apps/backend/src/modules/search/unified-search.service.ts` - Elasticsearch search implementation
- `apps/backend/src/modules/cases/cases.service.ts` - PostgreSQL FTS implementation

### Secondary (MEDIUM confidence)

- `apps/backend/prisma/schema.prisma` - Category model structure
- `apps/backend/src/modules/search/indexing/indexing.service.ts` - Index naming convention

### Tertiary (LOW confidence)

- None - all findings directly from codebase analysis

## Metadata

**Confidence breakdown:**

- Standard stack: HIGH - All libraries already in use in codebase
- Architecture: HIGH - Patterns directly observed in existing code
- Pitfalls: HIGH - Issues identified through code analysis

**Research date:** 2026-02-09
**Valid until:** 60 days (stable existing codebase patterns)
