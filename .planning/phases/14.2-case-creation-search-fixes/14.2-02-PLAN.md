---
phase: 14.2-case-creation-search-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/src/modules/search/unified-search.service.ts
  - apps/backend/src/modules/search/search.module.ts
autonomous: true

must_haves:
  truths:
    - "Unified search returns results for case content (e.g., 'harassment')"
    - "Unified search returns results for case reference numbers (e.g., 'CASE-2025')"
    - "Search works even when Elasticsearch indices don't exist"
  artifacts:
    - path: "apps/backend/src/modules/search/unified-search.service.ts"
      provides: "PostgreSQL FTS fallback for cases when ES unavailable"
      contains: "searchCasesWithFts"
  key_links:
    - from: "apps/backend/src/modules/search/unified-search.service.ts"
      to: "prisma.cases"
      via: "raw SQL with search_vector"
      pattern: "search_vector.*to_tsquery"
---

<objective>
Fix unified search to return results when Elasticsearch indices are empty or unavailable.

Purpose: The demo environment has 4,500 cases with populated search_vector columns, but unified search returns empty because Elasticsearch indices don't exist. Adding a PostgreSQL FTS fallback ensures search works out of the box without requiring Elasticsearch setup.

Output: Unified search returns case results using PostgreSQL full-text search when ES is unavailable.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14.2-case-creation-search-fixes/14.2-RESEARCH.md
@apps/backend/src/modules/search/unified-search.service.ts
@apps/backend/src/modules/cases/cases.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PostgreSQL FTS Fallback to Unified Search</name>
  <files>
    apps/backend/src/modules/search/unified-search.service.ts
    apps/backend/src/modules/search/search.module.ts
  </files>
  <action>
Modify `UnifiedSearchService` to use PostgreSQL full-text search as a fallback when Elasticsearch returns empty (index not found).

**Step 1: Inject PrismaService**
In the constructor, add PrismaService injection:

```typescript
constructor(
  private readonly esService: ElasticsearchService,
  private readonly indexingService: IndexingService,
  private readonly permissionService: PermissionFilterService,
  private readonly prisma: PrismaService,  // Add this
) {}
```

**Step 2: Create PostgreSQL FTS method for cases**
Add a new private method after `searchEntityType`:

```typescript
/**
 * PostgreSQL FTS fallback for cases when ES is unavailable.
 * Uses the search_vector column that's already populated.
 */
private async searchCasesWithFts(
  ctx: PermissionContext,
  query: string,
  limit: number,
): Promise<EntityTypeResult> {
  if (!query || !query.trim()) {
    return { entityType: 'cases', count: 0, hits: [] };
  }

  // Build tsquery from search terms
  const searchWords = query
    .trim()
    .split(/\s+/)
    .filter((word) => word.length > 0)
    .map((word) => word.replace(/[^\w-]/g, ''))
    .filter((word) => word.length > 0);

  if (searchWords.length === 0) {
    return { entityType: 'cases', count: 0, hits: [] };
  }

  // Use prefix matching for partial words: "harass" matches "harassment"
  const tsQuery = searchWords.map((word) => `${word}:*`).join(' & ');

  try {
    // Per decision 14.1-04: Raw SQL must use @@map table names (cases, not Case)
    // and snake_case column names (organization_id, reference_number, etc.)
    const results = await this.prisma.$queryRawUnsafe<Array<{
      id: string;
      reference_number: string;
      details: string | null;
      summary: string | null;
      status: string;
      severity: string;
      created_at: Date;
      score: number;
    }>>(
      `SELECT
        id,
        reference_number,
        details,
        summary,
        status,
        severity,
        created_at,
        ts_rank(search_vector, to_tsquery('english', $1)) as score
      FROM cases
      WHERE organization_id = $2
        AND search_vector @@ to_tsquery('english', $1)
      ORDER BY score DESC, created_at DESC
      LIMIT $3`,
      tsQuery,
      ctx.organizationId,
      limit,
    );

    return {
      entityType: 'cases',
      count: results.length,
      hits: results.map((r) => ({
        id: r.id,
        entityType: 'cases',
        score: Number(r.score) || 0,
        document: {
          referenceNumber: r.reference_number,
          details: r.details,
          summary: r.summary,
          status: r.status,
          severity: r.severity,
          createdAt: r.created_at,
        },
      })),
    };
  } catch (error) {
    this.logger.error(`PostgreSQL FTS failed for cases: ${error instanceof Error ? error.message : 'Unknown error'}`);
    return { entityType: 'cases', count: 0, hits: [] };
  }
}
```

**Step 3: Modify searchEntityType to use FTS fallback**
In the `searchEntityType` method, when ES returns empty for 'cases' entity type (specifically due to index not found), try FTS fallback:

Replace the catch block (around line 239-254) with:

```typescript
} catch (error) {
  // Handle index not found (no data yet for this tenant/type)
  if (this.isIndexNotFoundError(error)) {
    this.logger.debug(
      `Index ${indexName} not found - trying PostgreSQL FTS fallback for ${entityType}`,
    );

    // For cases, use PostgreSQL FTS fallback
    if (entityType === 'cases') {
      return this.searchCasesWithFts(ctx, query, limit);
    }

    return { entityType, count: 0, hits: [] };
  }

  this.logger.error(
    `Unified search failed for ${entityType}: ${error instanceof Error ? error.message : 'Unknown error'}`,
  );

  // For cases, try FTS fallback even on other ES errors
  if (entityType === 'cases') {
    return this.searchCasesWithFts(ctx, query, limit);
  }

  // Return empty results rather than failing the entire search
  return { entityType, count: 0, hits: [] };
}
```

**Step 4: Also try FTS when ES returns 0 results for cases**
After the try block succeeds but returns 0 hits for cases, try FTS:

```typescript
// After transformHits and getTotalHits calls, before the return:
// If ES returned 0 hits for cases, try PostgreSQL FTS as backup
if (entityType === "cases" && total === 0 && query && query.trim()) {
  this.logger.debug(`ES returned 0 hits for cases - trying PostgreSQL FTS`);
  const ftsResult = await this.searchCasesWithFts(ctx, query, limit);
  if (ftsResult.count > 0) {
    return ftsResult;
  }
}

return {
  entityType,
  count: total,
  hits,
};
```

**Step 5: Update search.module.ts if needed**
Ensure PrismaModule is imported in SearchModule (likely already is).
</action>
<verify>

1. Run TypeScript check: `cd apps/backend && npm run typecheck`
2. Start backend and test with curl:

   ```bash
   # Search for content
   curl -H "Authorization: Bearer $TOKEN" "http://localhost:3001/api/v1/search/unified?q=harassment"

   # Search for case number
   curl -H "Authorization: Bearer $TOKEN" "http://localhost:3001/api/v1/search/unified?q=CASE-2025"
   ```

3. Verify results are returned with case data
   </verify>
   <done>
   Unified search returns case results from PostgreSQL FTS when Elasticsearch indices are unavailable. Search for "harassment" returns relevant cases. Search for case numbers like "CASE-2025" returns matching cases.
   </done>
   </task>

</tasks>

<verification>
1. Unit test:
   - Mock ES to throw index not found error
   - Verify FTS fallback is called
   - Verify results match expected format

2. Integration test:
   - Search for common term ("harassment") returns results
   - Search for partial term ("harass") returns results
   - Search for case number prefix ("CASE-2025") returns results
   - Results include referenceNumber, details, summary, status

3. End-to-end test:
   - Frontend search bar query for "harassment" shows case results
   - Clicking a result navigates to case detail page
     </verification>

<success_criteria>

1. Search for "harassment" returns cases containing that word
2. Search for "CASE-2025" returns cases with matching reference numbers
3. Search works without requiring Elasticsearch to be running
4. No errors in backend logs when ES indices don't exist
   </success_criteria>

<output>
After completion, create `.planning/phases/14.2-case-creation-search-fixes/14.2-02-SUMMARY.md`
</output>
