---
phase: 11-analytics-reporting
plan: 08
type: execute
wave: 2
depends_on: []
files_modified:
  - apps/backend/src/modules/analytics/ai-query/ai-query.service.ts
  - apps/backend/src/modules/analytics/ai-query/query-to-prisma.service.ts
  - apps/backend/src/modules/analytics/ai-query/dto/ai-query.dto.ts
autonomous: true

must_haves:
  truths:
    - "Natural language queries are converted to structured data requests"
    - "AI selects appropriate visualization based on result type"
    - "Query results include interpretedQuery for transparency"
  artifacts:
    - path: "apps/backend/src/modules/analytics/ai-query/ai-query.service.ts"
      provides: "AI natural language query processor"
      min_lines: 150
    - path: "apps/backend/src/modules/analytics/ai-query/query-to-prisma.service.ts"
      provides: "Converts AI output to safe Prisma queries"
      min_lines: 100
  key_links:
    - from: "ai-query.service.ts"
      to: "claude provider"
      via: "structured output"
      pattern: "aiProvider\\.generateStructured"
---

<objective>
Build the AI natural language query service for dashboard analytics.

Purpose: Enable users to query compliance data using natural language like "show me harassment cases from Q4 in EMEA" (ANAL-07).
Output: AiQueryService with structured output parsing and QueryToPrismaService for safe query execution
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/11-analytics-reporting/11-CONTEXT.md
@.planning/phases/11-analytics-reporting/11-RESEARCH.md
@apps/backend/src/modules/ai/ai.module.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AI Query DTOs</name>
  <files>apps/backend/src/modules/analytics/ai-query/dto/ai-query.dto.ts</files>
  <action>
Create DTOs for AI query requests and responses:

```typescript
export class AiQueryRequestDto {
  @IsString()
  @MinLength(3)
  @MaxLength(500)
  query: string;

  @IsOptional()
  @IsString()
  context?: string;  // Entity context (e.g., "viewing harassment cases")

  @IsOptional()
  @ValidateNested()
  @Type(() => DateRangeDto)
  dateRange?: DateRangeDto;

  @IsOptional()
  @IsBoolean()
  includeSuggestions?: boolean = true;
}

export class AiQueryResponseDto {
  requestId: string;
  query: string;
  interpretedQuery: string;
  summary: string;
  visualizationType: VisualizationType;
  data: QueryResultData;
  alternateFormats: VisualizationType[];
  canSaveToDashboard: boolean;
  suggestions?: string[];
  executionTimeMs: number;
}

export enum VisualizationType {
  KPI = 'kpi',
  TABLE = 'table',
  LINE_CHART = 'line',
  BAR_CHART = 'bar',
  PIE_CHART = 'pie',
  TEXT = 'text',
}

export type QueryResultData =
  | KpiResultData
  | TableResultData
  | ChartResultData
  | TextResultData;

export interface KpiResultData {
  type: 'kpi';
  value: number | string;
  label: string;
  comparison?: { value: number | string; period: string; change: number };
}

export interface TableResultData {
  type: 'table';
  columns: { key: string; label: string; type: string }[];
  rows: Record<string, unknown>[];
  total: number;
  hasMore: boolean;
}

export interface ChartResultData {
  type: 'chart';
  chartType: 'line' | 'bar' | 'pie';
  labels: string[];
  datasets: { label: string; data: number[] }[];
}

export interface TextResultData {
  type: 'text';
  answer: string;
}

// AI structured output schema
export interface ParsedQuery {
  intent: 'count' | 'list' | 'aggregate' | 'trend' | 'compare' | 'find';
  entityType: 'case' | 'riu' | 'campaign' | 'person' | 'disclosure';
  filters: QueryFilter[];
  aggregation?: {
    function: 'count' | 'sum' | 'avg' | 'min' | 'max';
    field?: string;
    groupBy?: string[];
  };
  timeRange?: {
    preset?: 'today' | 'last_7_days' | 'last_30_days' | 'last_quarter' | 'ytd' | 'custom';
    start?: string;
    end?: string;
  };
  limit?: number;
  orderBy?: { field: string; direction: 'asc' | 'desc' };
  visualizationHint?: VisualizationType;
}

export interface QueryFilter {
  field: string;
  operator: 'eq' | 'neq' | 'gt' | 'gte' | 'lt' | 'lte' | 'contains' | 'in' | 'notIn';
  value: unknown;
}

export class SaveQueryDto {
  @IsString()
  name: string;

  @IsOptional()
  @IsString()
  description?: string;

  @IsOptional()
  @IsBoolean()
  addToDashboard?: boolean;

  @IsOptional()
  @IsUUID()
  dashboardId?: string;
}
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>AI Query DTOs with structured output schema and response types created</done>
</task>

<task type="auto">
  <name>Task 2: Implement QueryToPrismaService</name>
  <files>apps/backend/src/modules/analytics/ai-query/query-to-prisma.service.ts</files>
  <action>
Create service that converts AI-parsed queries to safe Prisma queries:

```typescript
@Injectable()
export class QueryToPrismaService {
  private readonly logger = new Logger(QueryToPrismaService.name);

  // Whitelist of allowed fields per entity type (security)
  private readonly ALLOWED_FIELDS: Record<string, string[]> = {
    case: [
      'status', 'priority', 'categoryId', 'category.name', 'createdAt', 'closedAt',
      'assigneeId', 'assignee.name', 'businessUnitId', 'businessUnit.name',
      'locationId', 'location.name', 'location.region', 'outcome', 'severity',
    ],
    riu: [
      'type', 'status', 'sourceChannel', 'categoryId', 'createdAt',
      'isAnonymous', 'severity',
    ],
    campaign: [
      'type', 'status', 'createdAt', 'dueDate', 'totalAssignments',
      'completedAssignments', 'overdueAssignments',
    ],
    person: [
      'type', 'status', 'businessUnitId', 'locationId', 'createdAt',
    ],
    disclosure: [
      'type', 'status', 'createdAt', 'reviewStatus',
    ],
  };

  /**
   * Convert parsed query to Prisma where clause.
   * Returns null if query contains invalid/disallowed fields.
   */
  buildWhereClause(
    entityType: string,
    filters: QueryFilter[],
    orgId: string,
  ): Record<string, unknown> | null {
    const allowedFields = this.ALLOWED_FIELDS[entityType];
    if (!allowedFields) {
      this.logger.warn(`Unknown entity type: ${entityType}`);
      return null;
    }

    const where: Record<string, unknown> = {
      organizationId: orgId, // Always filter by org (RLS)
    };

    for (const filter of filters) {
      // Validate field is allowed
      if (!this.isFieldAllowed(filter.field, allowedFields)) {
        this.logger.warn(`Disallowed field in query: ${filter.field}`);
        return null;
      }

      const prismaCondition = this.toPrismaCondition(filter);
      if (prismaCondition === null) {
        return null; // Invalid condition
      }

      // Handle nested fields (e.g., category.name)
      if (filter.field.includes('.')) {
        const [relation, field] = filter.field.split('.');
        where[relation] = { [field]: prismaCondition };
      } else {
        where[filter.field] = prismaCondition;
      }
    }

    return where;
  }

  /**
   * Build Prisma orderBy from parsed query.
   */
  buildOrderBy(
    entityType: string,
    orderBy?: { field: string; direction: 'asc' | 'desc' },
  ): Record<string, 'asc' | 'desc'> | undefined {
    if (!orderBy) return { createdAt: 'desc' }; // Default

    const allowedFields = this.ALLOWED_FIELDS[entityType];
    if (!this.isFieldAllowed(orderBy.field, allowedFields)) {
      return { createdAt: 'desc' };
    }

    return { [orderBy.field]: orderBy.direction };
  }

  /**
   * Build Prisma groupBy for aggregations.
   */
  buildGroupBy(
    entityType: string,
    groupBy?: string[],
  ): string[] | undefined {
    if (!groupBy?.length) return undefined;

    const allowedFields = this.ALLOWED_FIELDS[entityType];
    return groupBy.filter(field => this.isFieldAllowed(field, allowedFields));
  }

  /**
   * Parse time range to date filter.
   */
  parseTimeRange(
    timeRange?: ParsedQuery['timeRange'],
  ): { gte?: Date; lte?: Date } | undefined {
    if (!timeRange) return undefined;

    const now = new Date();
    let start: Date | undefined;
    let end: Date | undefined;

    switch (timeRange.preset) {
      case 'today':
        start = startOfDay(now);
        end = endOfDay(now);
        break;
      case 'last_7_days':
        start = subDays(now, 7);
        break;
      case 'last_30_days':
        start = subDays(now, 30);
        break;
      case 'last_quarter':
        start = subQuarters(now, 1);
        break;
      case 'ytd':
        start = startOfYear(now);
        break;
      case 'custom':
        if (timeRange.start) start = new Date(timeRange.start);
        if (timeRange.end) end = new Date(timeRange.end);
        break;
    }

    if (!start && !end) return undefined;
    return { gte: start, lte: end };
  }

  private isFieldAllowed(field: string, allowedFields: string[]): boolean {
    return allowedFields.includes(field) || allowedFields.includes(field.split('.')[0]);
  }

  private toPrismaCondition(filter: QueryFilter): unknown {
    switch (filter.operator) {
      case 'eq': return filter.value;
      case 'neq': return { not: filter.value };
      case 'gt': return { gt: filter.value };
      case 'gte': return { gte: filter.value };
      case 'lt': return { lt: filter.value };
      case 'lte': return { lte: filter.value };
      case 'contains': return { contains: filter.value, mode: 'insensitive' };
      case 'in': return { in: filter.value };
      case 'notIn': return { notIn: filter.value };
      default:
        this.logger.warn(`Unknown operator: ${filter.operator}`);
        return null;
    }
  }
}
```
  </action>
  <verify>npm run lint passes for the service file</verify>
  <done>QueryToPrismaService converts AI output to safe, parameterized Prisma queries with field whitelisting</done>
</task>

<task type="auto">
  <name>Task 3: Implement AiQueryService</name>
  <files>apps/backend/src/modules/analytics/ai-query/ai-query.service.ts</files>
  <action>
Create the main AI query service:

```typescript
@Injectable()
export class AiQueryService {
  private readonly logger = new Logger(AiQueryService.name);

  constructor(
    private prisma: PrismaService,
    private aiService: AiService,
    private queryToPrisma: QueryToPrismaService,
    private promptService: PromptService,
  ) {}

  async executeQuery(
    orgId: string,
    userId: string,
    dto: AiQueryRequestDto,
  ): Promise<AiQueryResponseDto> {
    const startTime = Date.now();
    const requestId = nanoid();

    this.logger.log(`Processing AI query: "${dto.query}" for org ${orgId}`);

    // 1. Get schema context for AI
    const schemaContext = await this.getSchemaContext(orgId);

    // 2. Parse query using Claude structured output
    const parsedQuery = await this.parseQueryWithAi(dto.query, schemaContext, dto.context);

    // 3. Validate and build Prisma query
    const where = this.queryToPrisma.buildWhereClause(
      parsedQuery.entityType,
      parsedQuery.filters,
      orgId,
    );

    if (where === null) {
      return this.buildErrorResponse(requestId, dto.query, 'Query contains invalid or restricted fields', startTime);
    }

    // Add time range filter
    const timeRange = this.queryToPrisma.parseTimeRange(parsedQuery.timeRange);
    if (timeRange) {
      where.createdAt = timeRange;
    }

    // 4. Execute query
    const result = await this.executeQueryByIntent(parsedQuery, where, orgId);

    // 5. Select visualization type
    const visualizationType = this.selectVisualization(parsedQuery, result);

    // 6. Format result for selected visualization
    const formattedData = this.formatResult(result, visualizationType, parsedQuery);

    // 7. Generate summary
    const summary = await this.generateSummary(parsedQuery, result);

    // 8. Log query for history
    await this.logQuery(orgId, userId, requestId, dto.query, parsedQuery, result);

    return {
      requestId,
      query: dto.query,
      interpretedQuery: this.buildInterpretedQuery(parsedQuery),
      summary,
      visualizationType,
      data: formattedData,
      alternateFormats: this.getAlternateFormats(visualizationType, result),
      canSaveToDashboard: this.canSaveToDashboard(parsedQuery),
      suggestions: dto.includeSuggestions ? await this.getSuggestions(parsedQuery, orgId) : undefined,
      executionTimeMs: Date.now() - startTime,
    };
  }

  private async parseQueryWithAi(
    query: string,
    schemaContext: string,
    userContext?: string,
  ): Promise<ParsedQuery> {
    const prompt = this.promptService.render('ai-query-parser', {
      query,
      schemaContext,
      userContext,
    });

    const response = await this.aiService.generateStructured<ParsedQuery>(
      prompt,
      PARSED_QUERY_SCHEMA,
      { maxTokens: 1000 },
    );

    return response;
  }

  private async executeQueryByIntent(
    parsedQuery: ParsedQuery,
    where: Record<string, unknown>,
    orgId: string,
  ): Promise<QueryExecutionResult> {
    const delegate = this.getPrismaDelegate(parsedQuery.entityType);

    switch (parsedQuery.intent) {
      case 'count':
        const count = await delegate.count({ where });
        return { type: 'count', value: count };

      case 'list':
        const items = await delegate.findMany({
          where,
          orderBy: this.queryToPrisma.buildOrderBy(parsedQuery.entityType, parsedQuery.orderBy),
          take: parsedQuery.limit || 20,
          include: this.getDefaultIncludes(parsedQuery.entityType),
        });
        return { type: 'list', items, total: items.length };

      case 'aggregate':
        const groupBy = this.queryToPrisma.buildGroupBy(parsedQuery.entityType, parsedQuery.aggregation?.groupBy);
        const aggregation = await delegate.groupBy({
          by: groupBy || ['status'],
          where,
          _count: true,
        });
        return { type: 'aggregate', groups: aggregation };

      case 'trend':
        // Group by date
        const trends = await this.executeTrendQuery(delegate, where, parsedQuery);
        return { type: 'trend', dataPoints: trends };

      default:
        throw new BadRequestException(`Unknown query intent: ${parsedQuery.intent}`);
    }
  }

  private selectVisualization(parsedQuery: ParsedQuery, result: QueryExecutionResult): VisualizationType {
    // Honor AI hint if provided
    if (parsedQuery.visualizationHint) {
      return parsedQuery.visualizationHint;
    }

    // Auto-select based on result type
    switch (result.type) {
      case 'count':
        return VisualizationType.KPI;
      case 'list':
        return result.items.length <= 20 ? VisualizationType.TABLE : VisualizationType.TABLE;
      case 'aggregate':
        return result.groups.length <= 10 ? VisualizationType.PIE_CHART : VisualizationType.BAR_CHART;
      case 'trend':
        return VisualizationType.LINE_CHART;
      default:
        return VisualizationType.TABLE;
    }
  }

  private buildInterpretedQuery(parsedQuery: ParsedQuery): string {
    // Generate human-readable interpretation
    const parts: string[] = [];

    parts.push(`${parsedQuery.intent} ${parsedQuery.entityType}s`);

    if (parsedQuery.filters.length > 0) {
      const filterDescs = parsedQuery.filters.map(f =>
        `${f.field} ${f.operator} ${JSON.stringify(f.value)}`
      );
      parts.push(`where ${filterDescs.join(' and ')}`);
    }

    if (parsedQuery.timeRange) {
      parts.push(`for ${parsedQuery.timeRange.preset || 'custom period'}`);
    }

    if (parsedQuery.aggregation?.groupBy) {
      parts.push(`grouped by ${parsedQuery.aggregation.groupBy.join(', ')}`);
    }

    return parts.join(' ');
  }

  private getPrismaDelegate(entityType: string) {
    switch (entityType) {
      case 'case': return this.prisma.case;
      case 'riu': return this.prisma.riskIntelligenceUnit;
      case 'campaign': return this.prisma.campaign;
      case 'person': return this.prisma.person;
      default: throw new BadRequestException(`Unknown entity type: ${entityType}`);
    }
  }
}

// JSON Schema for Claude structured output
const PARSED_QUERY_SCHEMA = {
  type: 'object',
  properties: {
    intent: { type: 'string', enum: ['count', 'list', 'aggregate', 'trend', 'compare', 'find'] },
    entityType: { type: 'string', enum: ['case', 'riu', 'campaign', 'person', 'disclosure'] },
    filters: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          field: { type: 'string' },
          operator: { type: 'string', enum: ['eq', 'neq', 'gt', 'gte', 'lt', 'lte', 'contains', 'in', 'notIn'] },
          value: {},
        },
        required: ['field', 'operator', 'value'],
      },
    },
    // ... rest of schema
  },
  required: ['intent', 'entityType', 'filters'],
};
```
  </action>
  <verify>npm run lint && npm run typecheck passes</verify>
  <done>AiQueryService processes natural language queries with structured AI output and safe query execution</done>
</task>

</tasks>

<verification>
```bash
cd apps/backend
npm run lint -- --fix
npm run typecheck
```
</verification>

<success_criteria>
- Natural language queries parsed via Claude structured output
- QueryToPrismaService whitelists fields for security (no SQL injection)
- Auto-visualization selection based on result type
- interpretedQuery shows what AI understood for transparency
- Rate limiting and logging integrated
</success_criteria>

<output>
After completion, create `.planning/phases/11-analytics-reporting/11-08-SUMMARY.md`
</output>
