---
phase: 11-analytics-reporting
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/src/modules/analytics/my-work/task-aggregator.service.ts
  - apps/backend/src/modules/analytics/my-work/my-work.controller.ts
  - apps/backend/src/modules/analytics/my-work/dto/my-work.dto.ts
  - apps/backend/src/modules/analytics/my-work/entities/unified-task.entity.ts
autonomous: true

must_haves:
  truths:
    - "Tasks from Cases, Investigations, Disclosures aggregate into unified queue"
    - "Tasks are sorted by priority-weighted due date (overdue first)"
    - "Users see both assigned tasks and claimable available tasks"
  artifacts:
    - path: "apps/backend/src/modules/analytics/my-work/task-aggregator.service.ts"
      provides: "Aggregates tasks from multiple entity types"
      min_lines: 150
    - path: "apps/backend/src/modules/analytics/my-work/my-work.controller.ts"
      provides: "REST endpoints for My Work queue"
      exports: ["MyWorkController"]
  key_links:
    - from: "task-aggregator.service.ts"
      to: "prisma.case"
      via: "fetch case assignments"
      pattern: "prisma\\.case\\.findMany"
---

<objective>
Build the unified "My Work" task aggregation service that combines tasks from Cases, Investigations, Disclosures, and other modules.

Purpose: Enable users to see all their actionable work in a single priority-ordered queue (PROJ-01, PROJ-02, PROJ-03).
Output: TaskAggregatorService and MyWorkController with unified task queue
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/11-analytics-reporting/11-CONTEXT.md
@.planning/phases/11-analytics-reporting/11-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UnifiedTask entity and DTOs</name>
  <files>
    apps/backend/src/modules/analytics/my-work/entities/unified-task.entity.ts
    apps/backend/src/modules/analytics/my-work/dto/my-work.dto.ts
  </files>
  <action>
1. Create UnifiedTask entity in `entities/unified-task.entity.ts`:

```typescript
export enum TaskType {
  CASE_ASSIGNMENT = 'case_assignment',
  INVESTIGATION_STEP = 'investigation_step',
  REMEDIATION_TASK = 'remediation_task',
  DISCLOSURE_REVIEW = 'disclosure_review',
  CAMPAIGN_RESPONSE = 'campaign_response',
  APPROVAL_REQUEST = 'approval_request',
}

export enum TaskPriority {
  HIGH = 'high',
  MEDIUM = 'medium',
  LOW = 'low',
}

export enum TaskStatus {
  PENDING = 'pending',
  IN_PROGRESS = 'in_progress',
  OVERDUE = 'overdue',
}

export interface UnifiedTask {
  id: string;                    // Composite: {type}-{sourceId}
  type: TaskType;
  entityType: string;            // 'Case', 'Investigation', etc.
  entityId: string;
  title: string;
  description?: string;
  dueDate: Date | null;
  priority: TaskPriority;
  status: TaskStatus;
  assignedAt: Date;
  assigneeId?: string;
  metadata: Record<string, unknown>;

  // Navigation
  url: string;                   // Deep link to entity

  // Context
  caseNumber?: string;
  categoryName?: string;
}

export interface TaskSection {
  title: string;
  tasks: UnifiedTask[];
  count: number;
}
```

2. Create DTOs in `dto/my-work.dto.ts`:
- MyWorkQueryDto: pagination, filters (type[], priority[], dateRange, status[]), sortBy, groupBy
- TaskFiltersDto: type?, priority?, dueDateStart?, dueDateEnd?, status?
- MarkCompleteDto: taskId, notes?
- SnoozeTaskDto: taskId, until (Date)
- ReassignTaskDto: taskId, newAssigneeId
- MyWorkResponseDto: sections (MyTasks, Available), total, hasMore
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>UnifiedTask entity and My Work DTOs exist with proper types</done>
</task>

<task type="auto">
  <name>Task 2: Implement TaskAggregatorService</name>
  <files>apps/backend/src/modules/analytics/my-work/task-aggregator.service.ts</files>
  <action>
Create TaskAggregatorService:

```typescript
@Injectable()
export class TaskAggregatorService {
  constructor(private prisma: PrismaService) {}

  async getMyTasks(params: {
    organizationId: string;
    userId: string;
    filters?: TaskFiltersDto;
    sortBy?: 'priority_due_date' | 'due_date' | 'created_at';
    limit?: number;
    offset?: number;
  }): Promise<{ tasks: UnifiedTask[]; total: number; hasMore: boolean }> {
    // Fetch from multiple sources in parallel
    const [cases, investigations, remediations, disclosures, approvals] = await Promise.all([
      this.fetchCaseAssignments(params),
      this.fetchInvestigationSteps(params),
      this.fetchRemediationTasks(params),
      this.fetchDisclosureReviews(params),
      this.fetchApprovalRequests(params),
    ]);

    // Transform and merge
    const allTasks: UnifiedTask[] = [
      ...cases.map(c => this.caseToTask(c)),
      ...investigations.map(i => this.investigationStepToTask(i)),
      ...remediations.map(r => this.remediationToTask(r)),
      ...disclosures.map(d => this.disclosureToTask(d)),
      ...approvals.map(a => this.approvalToTask(a)),
    ];

    // Apply sorting
    const sorted = this.sortByPriorityDueDate(allTasks);

    // Paginate
    const paginated = sorted.slice(params.offset || 0, (params.offset || 0) + (params.limit || 50));

    return {
      tasks: paginated,
      total: sorted.length,
      hasMore: (params.offset || 0) + paginated.length < sorted.length,
    };
  }

  async getAvailableTasks(params: {
    organizationId: string;
    userId: string;
    userRole: string;
    userRegion?: string;
    // ... filters
  }): Promise<{ tasks: UnifiedTask[]; total: number }> {
    // Tasks user can claim based on role/region
    // Unassigned cases, available investigation steps, etc.
  }

  private sortByPriorityDueDate(tasks: UnifiedTask[]): UnifiedTask[] {
    const priorityWeight = { high: 3, medium: 2, low: 1 };
    const now = new Date();

    return tasks.sort((a, b) => {
      // Overdue items always first
      const aOverdue = a.dueDate && a.dueDate < now;
      const bOverdue = b.dueDate && b.dueDate < now;
      if (aOverdue && !bOverdue) return -1;
      if (!aOverdue && bOverdue) return 1;

      // Priority-weighted score (lower = more urgent)
      const aScore = a.dueDate
        ? (a.dueDate.getTime() - now.getTime()) / priorityWeight[a.priority]
        : Infinity;
      const bScore = b.dueDate
        ? (b.dueDate.getTime() - now.getTime()) / priorityWeight[b.priority]
        : Infinity;

      return aScore - bScore;
    });
  }

  // Individual fetch methods for each task type
  private async fetchCaseAssignments(params): Promise<CaseWithRelations[]>
  private async fetchInvestigationSteps(params): Promise<InvestigationStepWithRelations[]>
  private async fetchRemediationTasks(params): Promise<RemediationStepWithRelations[]>
  private async fetchDisclosureReviews(params): Promise<ConflictAlertWithRelations[]>
  private async fetchApprovalRequests(params): Promise<WorkflowStepWithRelations[]>

  // Transform methods
  private caseToTask(case: Case): UnifiedTask
  private investigationStepToTask(step): UnifiedTask
  private remediationToTask(step): UnifiedTask
  private disclosureToTask(disclosure): UnifiedTask
  private approvalToTask(approval): UnifiedTask
}
```

Key implementation details:
- Parallel fetching with Promise.all for performance
- Individual transform methods for type safety
- Priority-weighted due date sorting per CONTEXT.md
- Support for both assigned ("My Tasks") and claimable ("Available") queues
  </action>
  <verify>npm run lint passes for the service file</verify>
  <done>TaskAggregatorService aggregates tasks from all modules with priority-weighted sorting</done>
</task>

<task type="auto">
  <name>Task 3: Create MyWorkController</name>
  <files>apps/backend/src/modules/analytics/my-work/my-work.controller.ts</files>
  <action>
Create MyWorkController with endpoints:

```typescript
@Controller('api/v1/my-work')
@UseGuards(JwtAuthGuard)
@ApiTags('my-work')
export class MyWorkController {
  constructor(private taskAggregator: TaskAggregatorService) {}

  @Get()
  @ApiOperation({ summary: 'Get unified task queue' })
  async getMyWork(
    @CurrentUser() user: User,
    @Query() query: MyWorkQueryDto,
  ): Promise<MyWorkResponseDto> {
    const [myTasks, available] = await Promise.all([
      this.taskAggregator.getMyTasks({
        organizationId: user.organizationId,
        userId: user.id,
        filters: query,
        sortBy: query.sortBy,
        limit: query.limit,
        offset: query.offset,
      }),
      query.includeAvailable
        ? this.taskAggregator.getAvailableTasks({
            organizationId: user.organizationId,
            userId: user.id,
            userRole: user.role,
          })
        : { tasks: [], total: 0 },
    ]);

    return {
      sections: [
        { title: 'My Tasks', tasks: myTasks.tasks, count: myTasks.total },
        { title: 'Available', tasks: available.tasks, count: available.total },
      ],
      total: myTasks.total + available.total,
      hasMore: myTasks.hasMore,
    };
  }

  @Get('counts')
  @ApiOperation({ summary: 'Get task counts by type' })
  async getTaskCounts(@CurrentUser() user: User): Promise<Record<TaskType, number>>

  @Post(':taskId/complete')
  @ApiOperation({ summary: 'Mark task as complete' })
  async markComplete(
    @Param('taskId') taskId: string,
    @Body() dto: MarkCompleteDto,
    @CurrentUser() user: User,
  ): Promise<void>

  @Post(':taskId/snooze')
  @ApiOperation({ summary: 'Snooze task until later' })
  async snoozeTask(
    @Param('taskId') taskId: string,
    @Body() dto: SnoozeTaskDto,
    @CurrentUser() user: User,
  ): Promise<void>

  @Post(':taskId/claim')
  @ApiOperation({ summary: 'Claim an available task' })
  async claimTask(
    @Param('taskId') taskId: string,
    @CurrentUser() user: User,
  ): Promise<UnifiedTask>
}
```

Task ID format: `{type}-{sourceId}` (e.g., `case_assignment-abc123`)
Parse task ID to route to correct service for actions.
  </action>
  <verify>npm run lint && npm run typecheck passes</verify>
  <done>MyWorkController provides unified task queue endpoints with filtering, sorting, and actions</done>
</task>

</tasks>

<verification>
```bash
cd apps/backend
npm run lint -- --fix
npm run typecheck
npm test -- --testPathPattern="my-work"
```
</verification>

<success_criteria>
- TaskAggregatorService fetches from Cases, Investigations, Remediation, Disclosures
- Priority-weighted due date sorting implemented per CONTEXT.md
- MyWorkController exposes /api/v1/my-work endpoints
- Task actions (complete, snooze, claim) route to correct services
- Both "My Tasks" and "Available" sections returned
</success_criteria>

<output>
After completion, create `.planning/phases/11-analytics-reporting/11-02-SUMMARY.md`
</output>
