---
phase: 11-analytics-reporting
plan: 17
type: execute
wave: 4
depends_on: ["11-04", "11-15"]
files_modified:
  - apps/backend/src/modules/analytics/migration/connectors/navex.connector.ts
  - apps/backend/src/modules/analytics/migration/connectors/base.connector.ts
autonomous: true

must_haves:
  truths:
    - "NAVEX export files can be parsed and mapped to platform entities"
    - "NAVEX-specific field patterns are correctly mapped"
    - "Import handles NAVEX case statuses and categories"
  artifacts:
    - path: "apps/backend/src/modules/analytics/migration/connectors/navex.connector.ts"
      provides: "NAVEX-specific import connector"
      min_lines: 150
    - path: "apps/backend/src/modules/analytics/migration/connectors/base.connector.ts"
      provides: "Base connector interface"
      min_lines: 80
  key_links:
    - from: "navex.connector.ts"
      to: "base.connector"
      via: "extends BaseMigrationConnector"
      pattern: "extends BaseMigrationConnector"
---

<objective>
Build NAVEX EthicsPoint import connector for data migration.

Purpose: Enable one-click migration from NAVEX EthicsPoint systems (MIG-04).
Output: NavexConnector with field mapping and data transformation
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/11-analytics-reporting/11-CONTEXT.md
@.planning/phases/11-analytics-reporting/11-04-SUMMARY.md
@.planning/phases/11-analytics-reporting/11-15-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BaseMigrationConnector</name>
  <files>apps/backend/src/modules/analytics/migration/connectors/base.connector.ts</files>
  <action>
Create abstract base connector:

```typescript
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../../../common/prisma/prisma.service';
import { MigrationSourceType } from '@prisma/client';
import { FieldMappingDto } from '../dto/migration.dto';

export interface TransformedRow {
  riu?: {
    type: string;
    sourceChannel: string;
    details: string;
    reporterType: string;
    categoryName?: string;
    severity?: string;
    sourceRecordId: string;
    incidentDate?: Date;
    locationName?: string;
    businessUnitName?: string;
    aiSummary?: string;
  };
  case?: {
    referenceNumber?: string;
    status: string;
    assignedToEmail?: string;
    closedAt?: Date;
    resolution?: string;
    outcomeNotes?: string;
  };
  person?: {
    firstName?: string;
    lastName?: string;
    email?: string;
    phone?: string;
    role: 'reporter' | 'subject' | 'witness';
  };
  investigation?: {
    status: string;
    findings?: string;
    assignedToEmail?: string;
  };
}

export interface MigrationResult {
  success: boolean;
  riusCreated: number;
  casesCreated: number;
  personsCreated: number;
  investigationsCreated: number;
  errors: { row: number; field: string; error: string }[];
  warnings: string[];
}

export interface ConnectorCapabilities {
  supportedFields: string[];
  defaultMappings: FieldMappingDto[];
  statusMappings: Record<string, string>;
  categoryMappings: Record<string, string>;
}

@Injectable()
export abstract class BaseMigrationConnector {
  protected abstract sourceType: MigrationSourceType;

  constructor(protected prisma: PrismaService) {}

  /**
   * Get connector capabilities for this source type.
   */
  abstract getCapabilities(): ConnectorCapabilities;

  /**
   * Transform a source row to platform entities.
   */
  abstract transformRow(
    row: Record<string, unknown>,
    mappings: FieldMappingDto[],
    orgId: string,
  ): TransformedRow;

  /**
   * Validate a row before import.
   */
  abstract validateRow(
    row: Record<string, unknown>,
    rowNumber: number,
  ): { isValid: boolean; errors: string[] };

  /**
   * Apply field mapping to get target value.
   */
  protected applyMapping(
    row: Record<string, unknown>,
    mappings: FieldMappingDto[],
    targetField: string,
  ): unknown {
    const mapping = mappings.find(m => m.targetField === targetField);
    if (!mapping) return undefined;

    const sourceValue = row[mapping.sourceField];
    if (sourceValue === undefined || sourceValue === null || sourceValue === '') {
      return mapping.defaultValue;
    }

    if (mapping.transformFunction) {
      return this.applyTransform(sourceValue, mapping.transformFunction);
    }

    return sourceValue;
  }

  /**
   * Apply transformation function to value.
   */
  protected applyTransform(value: unknown, transform: string): unknown {
    const strValue = String(value);

    switch (transform) {
      case 'uppercase':
        return strValue.toUpperCase();

      case 'lowercase':
        return strValue.toLowerCase();

      case 'trim':
        return strValue.trim();

      case 'parseDate':
        const date = new Date(strValue);
        return isNaN(date.getTime()) ? undefined : date;

      case 'parseNumber':
        const num = parseFloat(strValue);
        return isNaN(num) ? undefined : num;

      case 'parseBoolean':
        return ['true', 'yes', '1', 'y'].includes(strValue.toLowerCase());

      case 'mapCategory':
        return this.mapCategory(strValue);

      case 'mapStatus':
        return this.mapStatus(strValue);

      case 'mapSeverity':
        return this.mapSeverity(strValue);

      case 'extractName':
        // Split "Last, First" into { first, last }
        const parts = strValue.split(',').map(s => s.trim());
        return parts.length === 2
          ? { lastName: parts[0], firstName: parts[1] }
          : { firstName: strValue, lastName: '' };

      default:
        return value;
    }
  }

  /**
   * Map source category to platform category (override in subclass).
   */
  protected mapCategory(value: string): string {
    return value;
  }

  /**
   * Map source status to platform status (override in subclass).
   */
  protected mapStatus(value: string): string {
    return value;
  }

  /**
   * Map source severity to platform severity.
   */
  protected mapSeverity(value: string): string {
    const severityMap: Record<string, string> = {
      'high': 'HIGH',
      'critical': 'HIGH',
      'urgent': 'HIGH',
      'medium': 'MEDIUM',
      'moderate': 'MEDIUM',
      'normal': 'MEDIUM',
      'low': 'LOW',
      'minor': 'LOW',
    };
    return severityMap[value.toLowerCase()] || 'MEDIUM';
  }

  /**
   * Generate reference number if not provided.
   */
  protected generateReferenceNumber(prefix: string, sourceId: string): string {
    const date = new Date();
    const year = date.getFullYear().toString().slice(-2);
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    return `${prefix}-${year}${month}-${sourceId}`;
  }

  /**
   * Parse date with multiple format support.
   */
  protected parseDate(value: unknown): Date | undefined {
    if (!value) return undefined;
    if (value instanceof Date) return value;

    const strValue = String(value);

    // Try common formats
    const formats = [
      // ISO
      /^\d{4}-\d{2}-\d{2}/,
      // US MM/DD/YYYY
      /^(\d{1,2})\/(\d{1,2})\/(\d{4})/,
      // EU DD/MM/YYYY
      /^(\d{1,2})-(\d{1,2})-(\d{4})/,
    ];

    for (const format of formats) {
      const match = strValue.match(format);
      if (match) {
        const date = new Date(strValue);
        if (!isNaN(date.getTime())) return date;
      }
    }

    // Last resort: let Date parse it
    const date = new Date(strValue);
    return isNaN(date.getTime()) ? undefined : date;
  }
}
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>BaseMigrationConnector with common transformation logic created</done>
</task>

<task type="auto">
  <name>Task 2: Implement NavexConnector</name>
  <files>apps/backend/src/modules/analytics/migration/connectors/navex.connector.ts</files>
  <action>
Create NAVEX-specific connector:

```typescript
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../../../common/prisma/prisma.service';
import { MigrationSourceType } from '@prisma/client';
import {
  BaseMigrationConnector,
  ConnectorCapabilities,
  TransformedRow,
} from './base.connector';
import { FieldMappingDto, TargetEntityType } from '../dto/migration.dto';

// NAVEX EthicsPoint field names (common in exports)
const NAVEX_FIELDS = [
  'case_number', 'case_id', 'incident_id',
  'incident_type', 'issue_type', 'category', 'sub_category',
  'incident_date', 'report_date', 'created_date', 'closed_date',
  'reporter_type', 'reporter_relationship', 'anonymous',
  'location', 'location_name', 'country', 'region',
  'business_unit', 'department', 'division',
  'description', 'allegation', 'incident_description', 'details',
  'status', 'case_status', 'resolution_status',
  'assigned_to', 'investigator', 'handler',
  'subject_name', 'accused_name', 'involved_parties',
  'resolution', 'outcome', 'findings',
  'severity', 'priority', 'risk_level',
];

// NAVEX status to platform status mapping
const NAVEX_STATUS_MAP: Record<string, string> = {
  'new': 'OPEN',
  'open': 'OPEN',
  'in progress': 'IN_PROGRESS',
  'investigating': 'IN_PROGRESS',
  'under investigation': 'IN_PROGRESS',
  'pending': 'PENDING_INFO',
  'awaiting info': 'PENDING_INFO',
  'closed': 'CLOSED',
  'resolved': 'CLOSED',
  'substantiated': 'CLOSED',
  'unsubstantiated': 'CLOSED',
  'inconclusive': 'CLOSED',
};

// NAVEX category to platform category mapping
const NAVEX_CATEGORY_MAP: Record<string, string> = {
  'harassment': 'HARASSMENT',
  'sexual harassment': 'HARASSMENT',
  'discrimination': 'DISCRIMINATION',
  'fraud': 'FRAUD',
  'theft': 'THEFT',
  'conflict of interest': 'CONFLICT_OF_INTEREST',
  'coi': 'CONFLICT_OF_INTEREST',
  'policy violation': 'POLICY_VIOLATION',
  'safety': 'SAFETY',
  'workplace safety': 'SAFETY',
  'retaliation': 'RETALIATION',
  'ethics': 'ETHICS_VIOLATION',
  'other': 'OTHER',
};

@Injectable()
export class NavexConnector extends BaseMigrationConnector {
  protected sourceType = MigrationSourceType.NAVEX;

  constructor(prisma: PrismaService) {
    super(prisma);
  }

  getCapabilities(): ConnectorCapabilities {
    return {
      supportedFields: NAVEX_FIELDS,
      defaultMappings: this.getDefaultMappings(),
      statusMappings: NAVEX_STATUS_MAP,
      categoryMappings: NAVEX_CATEGORY_MAP,
    };
  }

  private getDefaultMappings(): FieldMappingDto[] {
    return [
      // RIU fields
      {
        sourceField: 'case_number',
        targetField: 'sourceRecordId',
        targetEntity: TargetEntityType.RIU,
        isRequired: true,
      },
      {
        sourceField: 'incident_type',
        targetField: 'categoryName',
        targetEntity: TargetEntityType.RIU,
        transformFunction: 'mapCategory',
        isRequired: false,
      },
      {
        sourceField: 'incident_date',
        targetField: 'incidentDate',
        targetEntity: TargetEntityType.RIU,
        transformFunction: 'parseDate',
        isRequired: false,
      },
      {
        sourceField: 'description',
        targetField: 'details',
        targetEntity: TargetEntityType.RIU,
        isRequired: true,
      },
      {
        sourceField: 'reporter_type',
        targetField: 'reporterType',
        targetEntity: TargetEntityType.RIU,
        defaultValue: 'anonymous',
        isRequired: false,
      },
      {
        sourceField: 'location',
        targetField: 'locationName',
        targetEntity: TargetEntityType.RIU,
        isRequired: false,
      },
      {
        sourceField: 'business_unit',
        targetField: 'businessUnitName',
        targetEntity: TargetEntityType.RIU,
        isRequired: false,
      },
      {
        sourceField: 'severity',
        targetField: 'severity',
        targetEntity: TargetEntityType.RIU,
        transformFunction: 'mapSeverity',
        defaultValue: 'MEDIUM',
        isRequired: false,
      },

      // Case fields
      {
        sourceField: 'case_number',
        targetField: 'referenceNumber',
        targetEntity: TargetEntityType.CASE,
        isRequired: false,
      },
      {
        sourceField: 'status',
        targetField: 'status',
        targetEntity: TargetEntityType.CASE,
        transformFunction: 'mapStatus',
        defaultValue: 'OPEN',
        isRequired: false,
      },
      {
        sourceField: 'assigned_to',
        targetField: 'assignedToEmail',
        targetEntity: TargetEntityType.CASE,
        isRequired: false,
      },
      {
        sourceField: 'closed_date',
        targetField: 'closedAt',
        targetEntity: TargetEntityType.CASE,
        transformFunction: 'parseDate',
        isRequired: false,
      },
      {
        sourceField: 'resolution',
        targetField: 'resolution',
        targetEntity: TargetEntityType.CASE,
        isRequired: false,
      },

      // Person fields (subject)
      {
        sourceField: 'subject_name',
        targetField: 'fullName',
        targetEntity: TargetEntityType.PERSON,
        transformFunction: 'extractName',
        isRequired: false,
      },
    ];
  }

  validateRow(
    row: Record<string, unknown>,
    rowNumber: number,
  ): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Check for case identifier
    const caseId = row['case_number'] || row['case_id'] || row['incident_id'];
    if (!caseId) {
      errors.push('Missing case identifier (case_number, case_id, or incident_id)');
    }

    // Check for description
    const description = row['description'] || row['allegation'] || row['incident_description'];
    if (!description) {
      errors.push('Missing description (description, allegation, or incident_description)');
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  transformRow(
    row: Record<string, unknown>,
    mappings: FieldMappingDto[],
    orgId: string,
  ): TransformedRow {
    // Merge default mappings with provided mappings (provided takes precedence)
    const allMappings = [...this.getDefaultMappings()];
    for (const mapping of mappings) {
      const existingIndex = allMappings.findIndex(
        m => m.targetField === mapping.targetField && m.targetEntity === mapping.targetEntity,
      );
      if (existingIndex >= 0) {
        allMappings[existingIndex] = mapping;
      } else {
        allMappings.push(mapping);
      }
    }

    // Get case identifier
    const caseNumber = String(
      row['case_number'] || row['case_id'] || row['incident_id'] || '',
    );

    // Get description from any common field
    const description = String(
      row['description'] || row['allegation'] || row['incident_description'] || row['details'] || '',
    );

    // Build RIU
    const riu: TransformedRow['riu'] = {
      type: 'hotline_report',
      sourceChannel: 'migration',
      details: description,
      reporterType: this.mapReporterType(row['reporter_type'] || row['anonymous']),
      sourceRecordId: caseNumber,
      categoryName: this.mapCategory(String(row['incident_type'] || row['category'] || '')),
      severity: this.mapSeverity(String(row['severity'] || row['priority'] || 'medium')),
      incidentDate: this.parseDate(row['incident_date'] || row['report_date']),
      locationName: String(row['location'] || row['location_name'] || ''),
      businessUnitName: String(row['business_unit'] || row['department'] || ''),
    };

    // Build Case
    const caseData: TransformedRow['case'] = {
      referenceNumber: caseNumber || this.generateReferenceNumber('NAV', caseNumber),
      status: this.mapStatus(String(row['status'] || row['case_status'] || 'open')),
      assignedToEmail: String(row['assigned_to'] || row['investigator'] || ''),
      closedAt: this.parseDate(row['closed_date']),
      resolution: String(row['resolution'] || row['outcome'] || ''),
    };

    // Build Person (subject) if present
    let person: TransformedRow['person'] | undefined;
    const subjectName = row['subject_name'] || row['accused_name'];
    if (subjectName) {
      const nameData = this.applyTransform(subjectName, 'extractName') as {
        firstName?: string;
        lastName?: string;
      };
      person = {
        firstName: nameData.firstName,
        lastName: nameData.lastName,
        role: 'subject',
      };
    }

    return {
      riu,
      case: caseData,
      person,
    };
  }

  protected mapCategory(value: string): string {
    if (!value) return 'OTHER';
    const normalized = value.toLowerCase().trim();
    return NAVEX_CATEGORY_MAP[normalized] || 'OTHER';
  }

  protected mapStatus(value: string): string {
    if (!value) return 'OPEN';
    const normalized = value.toLowerCase().trim();
    return NAVEX_STATUS_MAP[normalized] || 'OPEN';
  }

  private mapReporterType(value: unknown): string {
    if (!value) return 'anonymous';

    const strValue = String(value).toLowerCase();
    if (['true', 'yes', '1', 'anonymous'].includes(strValue)) {
      return 'anonymous';
    }
    if (['employee', 'internal'].includes(strValue)) {
      return 'confidential';
    }
    return 'identified';
  }
}
```
  </action>
  <verify>npm run lint passes for the connector file</verify>
  <done>NavexConnector with NAVEX-specific mappings implemented</done>
</task>

</tasks>

<verification>
```bash
cd apps/backend
npm run lint -- --fix
npm run typecheck
```
</verification>

<success_criteria>
- NavexConnector extends BaseMigrationConnector properly
- NAVEX field patterns correctly mapped to platform entities
- Status and category mappings handle common NAVEX values
- Validation ensures required fields present
- Date parsing handles multiple NAVEX date formats
</success_criteria>

<output>
After completion, create `.planning/phases/11-analytics-reporting/11-17-SUMMARY.md`
</output>
