---
phase: 11-analytics-reporting
plan: 18
type: execute
wave: 4
depends_on: ["11-04", "11-15", "11-17"]
files_modified:
  - apps/backend/src/modules/analytics/migration/connectors/eqs.connector.ts
autonomous: true

must_haves:
  truths:
    - "EQS/Conversant export files can be parsed and mapped to platform entities"
    - "EQS-specific field patterns are correctly mapped"
    - "Import handles EQS case statuses and categories"
  artifacts:
    - path: "apps/backend/src/modules/analytics/migration/connectors/eqs.connector.ts"
      provides: "EQS-specific import connector"
      min_lines: 140
  key_links:
    - from: "eqs.connector.ts"
      to: "base.connector"
      via: "extends BaseMigrationConnector"
      pattern: "extends BaseMigrationConnector"
---

<objective>
Build EQS/Conversant import connector for data migration.

Purpose: Enable one-click migration from EQS/Conversant systems (MIG-04).
Output: EqsConnector with field mapping and data transformation
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/11-analytics-reporting/11-CONTEXT.md
@.planning/phases/11-analytics-reporting/11-04-SUMMARY.md
@.planning/phases/11-analytics-reporting/11-15-SUMMARY.md
@.planning/phases/11-analytics-reporting/11-17-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement EqsConnector</name>
  <files>apps/backend/src/modules/analytics/migration/connectors/eqs.connector.ts</files>
  <action>
Create EQS/Conversant-specific connector:

```typescript
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../../../common/prisma/prisma.service';
import { MigrationSourceType } from '@prisma/client';
import {
  BaseMigrationConnector,
  ConnectorCapabilities,
  TransformedRow,
} from './base.connector';
import { FieldMappingDto, TargetEntityType } from '../dto/migration.dto';

// EQS/Conversant field names (common in exports)
const EQS_FIELDS = [
  'report_id', 'case_ref', 'reference_number',
  'category', 'subcategory', 'issue_type',
  'report_date', 'created_at', 'submitted_date', 'closed_date',
  'reporter_relationship', 'anonymous_flag', 'is_anonymous',
  'country', 'location_country', 'region', 'location_region',
  'company', 'entity', 'business_area',
  'description', 'detailed_description', 'report_text', 'summary',
  'status', 'state', 'case_state',
  'handler', 'assigned_user', 'case_manager',
  'persons_involved', 'accused', 'subjects',
  'outcome', 'resolution_type', 'final_outcome',
  'severity_level', 'risk_rating',
  'attachments_count', 'has_documents',
];

// EQS status to platform status mapping
const EQS_STATUS_MAP: Record<string, string> = {
  'new': 'OPEN',
  'received': 'OPEN',
  'open': 'OPEN',
  'in_progress': 'IN_PROGRESS',
  'processing': 'IN_PROGRESS',
  'investigation': 'IN_PROGRESS',
  'under_review': 'IN_PROGRESS',
  'waiting': 'PENDING_INFO',
  'on_hold': 'PENDING_INFO',
  'closed': 'CLOSED',
  'completed': 'CLOSED',
  'resolved': 'CLOSED',
  'archived': 'CLOSED',
};

// EQS category to platform category mapping
const EQS_CATEGORY_MAP: Record<string, string> = {
  'harassment': 'HARASSMENT',
  'bullying': 'HARASSMENT',
  'discrimination': 'DISCRIMINATION',
  'unfair_treatment': 'DISCRIMINATION',
  'fraud': 'FRAUD',
  'corruption': 'FRAUD',
  'bribery': 'FRAUD',
  'theft': 'THEFT',
  'misappropriation': 'THEFT',
  'conflict_of_interest': 'CONFLICT_OF_INTEREST',
  'policy': 'POLICY_VIOLATION',
  'compliance': 'POLICY_VIOLATION',
  'health_safety': 'SAFETY',
  'environment': 'SAFETY',
  'retaliation': 'RETALIATION',
  'whistleblower': 'RETALIATION',
  'data_protection': 'DATA_BREACH',
  'privacy': 'DATA_BREACH',
  'other': 'OTHER',
  'general': 'OTHER',
};

@Injectable()
export class EqsConnector extends BaseMigrationConnector {
  protected sourceType = MigrationSourceType.EQS;

  constructor(prisma: PrismaService) {
    super(prisma);
  }

  getCapabilities(): ConnectorCapabilities {
    return {
      supportedFields: EQS_FIELDS,
      defaultMappings: this.getDefaultMappings(),
      statusMappings: EQS_STATUS_MAP,
      categoryMappings: EQS_CATEGORY_MAP,
    };
  }

  private getDefaultMappings(): FieldMappingDto[] {
    return [
      // RIU fields
      {
        sourceField: 'report_id',
        targetField: 'sourceRecordId',
        targetEntity: TargetEntityType.RIU,
        isRequired: true,
      },
      {
        sourceField: 'category',
        targetField: 'categoryName',
        targetEntity: TargetEntityType.RIU,
        transformFunction: 'mapCategory',
        isRequired: false,
      },
      {
        sourceField: 'report_date',
        targetField: 'incidentDate',
        targetEntity: TargetEntityType.RIU,
        transformFunction: 'parseDate',
        isRequired: false,
      },
      {
        sourceField: 'detailed_description',
        targetField: 'details',
        targetEntity: TargetEntityType.RIU,
        isRequired: true,
      },
      {
        sourceField: 'reporter_relationship',
        targetField: 'reporterType',
        targetEntity: TargetEntityType.RIU,
        defaultValue: 'anonymous',
        isRequired: false,
      },
      {
        sourceField: 'location_country',
        targetField: 'locationName',
        targetEntity: TargetEntityType.RIU,
        isRequired: false,
      },
      {
        sourceField: 'business_area',
        targetField: 'businessUnitName',
        targetEntity: TargetEntityType.RIU,
        isRequired: false,
      },
      {
        sourceField: 'severity_level',
        targetField: 'severity',
        targetEntity: TargetEntityType.RIU,
        transformFunction: 'mapSeverity',
        defaultValue: 'MEDIUM',
        isRequired: false,
      },

      // Case fields
      {
        sourceField: 'case_ref',
        targetField: 'referenceNumber',
        targetEntity: TargetEntityType.CASE,
        isRequired: false,
      },
      {
        sourceField: 'status',
        targetField: 'status',
        targetEntity: TargetEntityType.CASE,
        transformFunction: 'mapStatus',
        defaultValue: 'OPEN',
        isRequired: false,
      },
      {
        sourceField: 'handler',
        targetField: 'assignedToEmail',
        targetEntity: TargetEntityType.CASE,
        isRequired: false,
      },
      {
        sourceField: 'closed_date',
        targetField: 'closedAt',
        targetEntity: TargetEntityType.CASE,
        transformFunction: 'parseDate',
        isRequired: false,
      },
      {
        sourceField: 'final_outcome',
        targetField: 'resolution',
        targetEntity: TargetEntityType.CASE,
        isRequired: false,
      },

      // Person fields (subject)
      {
        sourceField: 'persons_involved',
        targetField: 'fullName',
        targetEntity: TargetEntityType.PERSON,
        isRequired: false,
      },
    ];
  }

  validateRow(
    row: Record<string, unknown>,
    rowNumber: number,
  ): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Check for report identifier
    const reportId = row['report_id'] || row['case_ref'] || row['reference_number'];
    if (!reportId) {
      errors.push('Missing report identifier (report_id, case_ref, or reference_number)');
    }

    // Check for description
    const description = row['detailed_description'] || row['description'] || row['report_text'];
    if (!description) {
      errors.push('Missing description (detailed_description, description, or report_text)');
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  transformRow(
    row: Record<string, unknown>,
    mappings: FieldMappingDto[],
    orgId: string,
  ): TransformedRow {
    // Merge default mappings with provided mappings
    const allMappings = [...this.getDefaultMappings()];
    for (const mapping of mappings) {
      const existingIndex = allMappings.findIndex(
        m => m.targetField === mapping.targetField && m.targetEntity === mapping.targetEntity,
      );
      if (existingIndex >= 0) {
        allMappings[existingIndex] = mapping;
      } else {
        allMappings.push(mapping);
      }
    }

    // Get report identifier
    const reportId = String(
      row['report_id'] || row['case_ref'] || row['reference_number'] || '',
    );

    // Get description from any common field
    const description = String(
      row['detailed_description'] ||
      row['description'] ||
      row['report_text'] ||
      row['summary'] ||
      '',
    );

    // Build RIU
    const riu: TransformedRow['riu'] = {
      type: 'web_form_submission',
      sourceChannel: 'migration',
      details: description,
      reporterType: this.mapReporterType(row['reporter_relationship'], row['anonymous_flag']),
      sourceRecordId: reportId,
      categoryName: this.mapCategory(String(row['category'] || row['subcategory'] || '')),
      severity: this.mapSeverity(String(row['severity_level'] || row['risk_rating'] || 'medium')),
      incidentDate: this.parseDate(row['report_date'] || row['created_at']),
      locationName: this.buildLocation(row),
      businessUnitName: String(row['business_area'] || row['entity'] || row['company'] || ''),
    };

    // Build Case
    const caseData: TransformedRow['case'] = {
      referenceNumber: String(row['case_ref'] || '') || this.generateReferenceNumber('EQS', reportId),
      status: this.mapStatus(String(row['status'] || row['state'] || row['case_state'] || 'open')),
      assignedToEmail: String(row['handler'] || row['assigned_user'] || row['case_manager'] || ''),
      closedAt: this.parseDate(row['closed_date']),
      resolution: this.mapOutcome(row['final_outcome'] || row['outcome'] || row['resolution_type']),
    };

    // Build Person (subject) if present
    let person: TransformedRow['person'] | undefined;
    const personsInvolved = row['persons_involved'] || row['accused'] || row['subjects'];
    if (personsInvolved) {
      const nameStr = String(personsInvolved);
      // EQS often stores as comma-separated list, take first
      const firstName = nameStr.split(',')[0]?.trim() || nameStr;
      person = {
        firstName,
        lastName: '',
        role: 'subject',
      };
    }

    return {
      riu,
      case: caseData,
      person,
    };
  }

  protected mapCategory(value: string): string {
    if (!value) return 'OTHER';
    // EQS uses snake_case or lowercase
    const normalized = value.toLowerCase().replace(/[\s-]/g, '_').trim();
    return EQS_CATEGORY_MAP[normalized] || 'OTHER';
  }

  protected mapStatus(value: string): string {
    if (!value) return 'OPEN';
    const normalized = value.toLowerCase().replace(/[\s-]/g, '_').trim();
    return EQS_STATUS_MAP[normalized] || 'OPEN';
  }

  private mapReporterType(relationship: unknown, anonymousFlag: unknown): string {
    // Check anonymous flag first
    if (anonymousFlag !== undefined) {
      const flagStr = String(anonymousFlag).toLowerCase();
      if (['true', 'yes', '1', 'y'].includes(flagStr)) {
        return 'anonymous';
      }
    }

    // Map relationship
    if (!relationship) return 'anonymous';

    const relStr = String(relationship).toLowerCase();
    const anonymousRelations = ['anonymous', 'external', 'unknown', 'third_party'];
    const confidentialRelations = ['employee', 'staff', 'contractor', 'supplier'];

    if (anonymousRelations.some(r => relStr.includes(r))) {
      return 'anonymous';
    }
    if (confidentialRelations.some(r => relStr.includes(r))) {
      return 'confidential';
    }

    return 'identified';
  }

  private buildLocation(row: Record<string, unknown>): string {
    const parts: string[] = [];

    if (row['location_region']) parts.push(String(row['location_region']));
    if (row['region'] && !row['location_region']) parts.push(String(row['region']));
    if (row['location_country']) parts.push(String(row['location_country']));
    if (row['country'] && !row['location_country']) parts.push(String(row['country']));

    return parts.join(', ');
  }

  private mapOutcome(value: unknown): string {
    if (!value) return '';

    const strValue = String(value).toLowerCase();
    const outcomeMap: Record<string, string> = {
      'substantiated': 'Substantiated - Allegation confirmed',
      'unsubstantiated': 'Unsubstantiated - Insufficient evidence',
      'inconclusive': 'Inconclusive - Unable to determine',
      'partially_substantiated': 'Partially Substantiated',
      'no_violation': 'No Violation Found',
      'policy_updated': 'Policy Updated',
      'training_provided': 'Training Provided',
      'terminated': 'Termination',
      'warning': 'Warning Issued',
      'no_action': 'No Action Taken',
    };

    for (const [key, mapped] of Object.entries(outcomeMap)) {
      if (strValue.includes(key)) {
        return mapped;
      }
    }

    return String(value);
  }
}
```
  </action>
  <verify>npm run lint && npm run typecheck passes</verify>
  <done>EqsConnector with EQS-specific mappings implemented</done>
</task>

</tasks>

<verification>
```bash
cd apps/backend
npm run lint -- --fix
npm run typecheck
```
</verification>

<success_criteria>
- EqsConnector extends BaseMigrationConnector properly
- EQS field patterns correctly mapped to platform entities
- Status and category mappings handle common EQS values
- Location building combines country and region fields
- Outcome mapping translates EQS resolution types
</success_criteria>

<output>
After completion, create `.planning/phases/11-analytics-reporting/11-18-SUMMARY.md`
</output>
