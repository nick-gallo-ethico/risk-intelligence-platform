---
phase: 11-analytics-reporting
plan: 16
type: execute
wave: 3
depends_on: ["11-04", "11-08"]
files_modified:
  - apps/backend/src/modules/analytics/migration/screenshot-to-form.service.ts
  - apps/backend/src/modules/analytics/migration/dto/screenshot.dto.ts
autonomous: true

must_haves:
  truths:
    - "Screenshots can be analyzed to extract form field definitions"
    - "AI identifies field names, types, and validation rules from images"
    - "Competitor-specific hints improve extraction accuracy"
  artifacts:
    - path: "apps/backend/src/modules/analytics/migration/screenshot-to-form.service.ts"
      provides: "Vision API integration for form extraction"
      min_lines: 120
  key_links:
    - from: "screenshot-to-form.service.ts"
      to: "ai.service"
      via: "Claude vision API"
      pattern: "aiService\\."
---

<objective>
Build screenshot-to-form AI assistant for migration and form building.

Purpose: Enable users to extract form definitions from competitor screenshots (MIG-03).
Output: ScreenshotToFormService using Claude vision API
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/11-analytics-reporting/11-CONTEXT.md
@.planning/phases/11-analytics-reporting/11-04-SUMMARY.md
@.planning/phases/11-analytics-reporting/11-08-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create screenshot DTOs</name>
  <files>apps/backend/src/modules/analytics/migration/dto/screenshot.dto.ts</files>
  <action>
Create DTOs for screenshot analysis:

```typescript
import { IsString, IsOptional, IsEnum, IsArray, ValidateNested, IsBoolean } from 'class-validator';
import { Type } from 'class-transformer';

export enum ScreenshotContext {
  MIGRATION = 'migration',       // Analyzing competitor forms
  FORM_BUILDER = 'form_builder', // Creating new forms
}

export enum CompetitorHint {
  NAVEX = 'navex',
  EQS = 'eqs',
  ONETRUST = 'onetrust',
  STAR = 'star',
  UNKNOWN = 'unknown',
}

export class AnalyzeScreenshotDto {
  @IsEnum(ScreenshotContext)
  context: ScreenshotContext;

  @IsOptional()
  @IsEnum(CompetitorHint)
  competitorHint?: CompetitorHint;

  @IsOptional()
  @IsString()
  additionalInstructions?: string;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  existingFieldNames?: string[];  // Avoid duplicates in form builder
}

export class ExtractedField {
  name: string;
  label: string;
  type: ExtractedFieldType;
  isRequired: boolean;
  placeholder?: string;
  helpText?: string;
  options?: string[];           // For select/radio/checkbox
  validationRules?: ValidationRule[];
  position: {
    section?: string;
    order: number;
  };
  confidence: number;           // 0-100
}

export enum ExtractedFieldType {
  TEXT = 'text',
  TEXTAREA = 'textarea',
  NUMBER = 'number',
  EMAIL = 'email',
  PHONE = 'phone',
  DATE = 'date',
  DATETIME = 'datetime',
  SELECT = 'select',
  MULTISELECT = 'multiselect',
  RADIO = 'radio',
  CHECKBOX = 'checkbox',
  FILE = 'file',
  CURRENCY = 'currency',
  PERCENTAGE = 'percentage',
  URL = 'url',
}

export interface ValidationRule {
  type: 'required' | 'min' | 'max' | 'minLength' | 'maxLength' | 'pattern' | 'custom';
  value?: string | number;
  message?: string;
}

export class ScreenshotAnalysisResult {
  fields: ExtractedField[];
  sections: ExtractedSection[];
  formTitle?: string;
  formDescription?: string;
  confidenceOverall: number;
  warnings: string[];
  competitorDetected?: CompetitorHint;
  rawAnalysis: string;          // AI's full response for transparency
}

export class ExtractedSection {
  name: string;
  description?: string;
  order: number;
  fieldCount: number;
}

// Competitor-specific field patterns
export const COMPETITOR_FIELD_PATTERNS: Record<CompetitorHint, Record<string, ExtractedFieldType>> = {
  [CompetitorHint.NAVEX]: {
    'incident type': ExtractedFieldType.SELECT,
    'date of incident': ExtractedFieldType.DATE,
    'location': ExtractedFieldType.SELECT,
    'business unit': ExtractedFieldType.SELECT,
    'description': ExtractedFieldType.TEXTAREA,
    'anonymous': ExtractedFieldType.RADIO,
    'contact information': ExtractedFieldType.TEXT,
  },
  [CompetitorHint.EQS]: {
    'category': ExtractedFieldType.SELECT,
    'subcategory': ExtractedFieldType.SELECT,
    'when did this happen': ExtractedFieldType.DATE,
    'country': ExtractedFieldType.SELECT,
    'detailed description': ExtractedFieldType.TEXTAREA,
    'relationship to company': ExtractedFieldType.SELECT,
  },
  [CompetitorHint.ONETRUST]: {
    'incident type': ExtractedFieldType.SELECT,
    'severity': ExtractedFieldType.SELECT,
    'department': ExtractedFieldType.SELECT,
    'details': ExtractedFieldType.TEXTAREA,
    'evidence': ExtractedFieldType.FILE,
  },
  [CompetitorHint.STAR]: {
    'matter type': ExtractedFieldType.SELECT,
    'report date': ExtractedFieldType.DATE,
    'business area': ExtractedFieldType.SELECT,
    'narrative': ExtractedFieldType.TEXTAREA,
  },
  [CompetitorHint.UNKNOWN]: {},
};
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>Screenshot DTOs with competitor patterns created</done>
</task>

<task type="auto">
  <name>Task 2: Implement ScreenshotToFormService</name>
  <files>apps/backend/src/modules/analytics/migration/screenshot-to-form.service.ts</files>
  <action>
Create service for screenshot analysis:

```typescript
import { Injectable, BadRequestException, Logger } from '@nestjs/common';
import { AiService } from '../../ai/ai.service';
import { StorageService } from '../../storage/storage.service';
import { AuditService } from '../../audit/audit.service';
import {
  AnalyzeScreenshotDto,
  ScreenshotAnalysisResult,
  ExtractedField,
  ExtractedFieldType,
  ExtractedSection,
  CompetitorHint,
  COMPETITOR_FIELD_PATTERNS,
  ScreenshotContext,
} from './dto/screenshot.dto';
import { nanoid } from 'nanoid';

const SUPPORTED_MIME_TYPES = ['image/png', 'image/jpeg', 'image/webp', 'image/gif', 'application/pdf'];
const MAX_IMAGE_SIZE = 20 * 1024 * 1024; // 20MB

@Injectable()
export class ScreenshotToFormService {
  private readonly logger = new Logger(ScreenshotToFormService.name);

  constructor(
    private aiService: AiService,
    private storageService: StorageService,
    private auditService: AuditService,
  ) {}

  /**
   * Analyze screenshot to extract form fields.
   */
  async analyzeScreenshot(
    orgId: string,
    userId: string,
    file: Express.Multer.File,
    dto: AnalyzeScreenshotDto,
  ): Promise<ScreenshotAnalysisResult> {
    // Validate file
    if (!file) {
      throw new BadRequestException('No file provided');
    }
    if (!SUPPORTED_MIME_TYPES.includes(file.mimetype)) {
      throw new BadRequestException(
        `Unsupported file type. Supported: ${SUPPORTED_MIME_TYPES.join(', ')}`,
      );
    }
    if (file.size > MAX_IMAGE_SIZE) {
      throw new BadRequestException(`File too large. Maximum size is ${MAX_IMAGE_SIZE / 1024 / 1024}MB`);
    }

    // Upload screenshot for audit trail
    const blobKey = `screenshots/${orgId}/${nanoid()}-${file.originalname}`;
    await this.storageService.upload(blobKey, file.buffer, file.mimetype);

    // Build AI prompt
    const prompt = this.buildAnalysisPrompt(dto);

    // Call Claude vision API
    const aiResponse = await this.aiService.analyzeImage(orgId, userId, {
      image: file.buffer.toString('base64'),
      mimeType: file.mimetype,
      prompt,
    });

    // Parse AI response
    const result = this.parseAiResponse(aiResponse, dto);

    // Log audit
    await this.auditService.log({
      entityType: 'SCREENSHOT_ANALYSIS',
      entityId: nanoid(),
      action: 'analyzed',
      actionDescription: `Analyzed ${dto.context === 'migration' ? 'migration' : 'form builder'} screenshot, extracted ${result.fields.length} fields`,
      organizationId: orgId,
      actorUserId: userId,
      metadata: {
        context: dto.context,
        competitorHint: dto.competitorHint,
        fieldsExtracted: result.fields.length,
        confidence: result.confidenceOverall,
      },
    });

    this.logger.log(
      `Screenshot analyzed: ${result.fields.length} fields extracted with ${result.confidenceOverall}% confidence`,
    );

    return result;
  }

  /**
   * Build analysis prompt based on context.
   */
  private buildAnalysisPrompt(dto: AnalyzeScreenshotDto): string {
    const basePrompt = `Analyze this screenshot of a form and extract all visible form fields.

For each field, identify:
1. Field label/name
2. Field type (text, textarea, select, checkbox, radio, date, email, phone, number, file, etc.)
3. Whether it appears to be required (look for asterisks or "required" text)
4. Placeholder text if visible
5. Help text or description if present
6. Options/choices for select, radio, or checkbox fields
7. Any visible validation rules

Also identify:
- Form sections/groups and their titles
- Overall form title and description
- The approximate order/position of fields

Return your analysis as JSON with this structure:
{
  "formTitle": "string or null",
  "formDescription": "string or null",
  "sections": [
    { "name": "string", "description": "string or null", "order": number }
  ],
  "fields": [
    {
      "name": "camelCase field name",
      "label": "Display Label",
      "type": "text|textarea|select|...",
      "isRequired": boolean,
      "placeholder": "string or null",
      "helpText": "string or null",
      "options": ["for select/radio/checkbox"],
      "validationRules": [{ "type": "required|min|max|...", "value": "..." }],
      "section": "section name or null",
      "order": number,
      "confidence": 0-100
    }
  ]
}`;

    // Add competitor-specific hints
    let competitorContext = '';
    if (dto.competitorHint && dto.competitorHint !== 'unknown') {
      const patterns = COMPETITOR_FIELD_PATTERNS[dto.competitorHint];
      const patternList = Object.entries(patterns)
        .map(([field, type]) => `- "${field}" is typically a ${type}`)
        .join('\n');

      competitorContext = `

This appears to be from ${dto.competitorHint.toUpperCase()}. Common field patterns:
${patternList}

Use these patterns to improve field type detection.`;
    }

    // Add context-specific instructions
    let contextInstructions = '';
    if (dto.context === 'migration') {
      contextInstructions = `

MIGRATION CONTEXT:
Focus on extracting fields that would map to a case/incident reporting system:
- Incident details (type, date, location)
- Reporter information
- Subject/person involved
- Categories and classifications
- Status and workflow fields`;
    } else {
      contextInstructions = `

FORM BUILDER CONTEXT:
Focus on creating a clean, usable form definition:
- Suggest appropriate field types for data collection
- Identify logical groupings into sections
- Note any conditional logic visible (field shown based on another)`;
    }

    // Add existing field names to avoid duplicates
    let existingFieldsNote = '';
    if (dto.existingFieldNames && dto.existingFieldNames.length > 0) {
      existingFieldsNote = `

EXISTING FIELDS (avoid these names):
${dto.existingFieldNames.join(', ')}

Generate unique names that don't conflict with existing fields.`;
    }

    // Add custom instructions
    const customInstructions = dto.additionalInstructions
      ? `\n\nADDITIONAL INSTRUCTIONS:\n${dto.additionalInstructions}`
      : '';

    return basePrompt + competitorContext + contextInstructions + existingFieldsNote + customInstructions;
  }

  /**
   * Parse AI response into structured result.
   */
  private parseAiResponse(
    aiResponse: string,
    dto: AnalyzeScreenshotDto,
  ): ScreenshotAnalysisResult {
    const warnings: string[] = [];
    let parsed: any;

    try {
      // Extract JSON from response (may be wrapped in markdown code blocks)
      const jsonMatch = aiResponse.match(/```json\s*([\s\S]*?)\s*```/) ||
                        aiResponse.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error('No JSON found in response');
      }

      const jsonStr = jsonMatch[1] || jsonMatch[0];
      parsed = JSON.parse(jsonStr);
    } catch (error) {
      warnings.push('Failed to parse AI response. Using fallback extraction.');
      return {
        fields: [],
        sections: [],
        confidenceOverall: 0,
        warnings: [...warnings, 'Could not extract form structure from image'],
        rawAnalysis: aiResponse,
      };
    }

    // Process fields
    const fields: ExtractedField[] = (parsed.fields || []).map((f: any, index: number) => ({
      name: this.sanitizeFieldName(f.name || `field_${index}`),
      label: f.label || f.name || `Field ${index + 1}`,
      type: this.mapFieldType(f.type),
      isRequired: f.isRequired === true,
      placeholder: f.placeholder || undefined,
      helpText: f.helpText || undefined,
      options: Array.isArray(f.options) ? f.options : undefined,
      validationRules: f.validationRules || [],
      position: {
        section: f.section || undefined,
        order: f.order || index,
      },
      confidence: typeof f.confidence === 'number' ? f.confidence : 70,
    }));

    // Process sections
    const sections: ExtractedSection[] = (parsed.sections || []).map((s: any, index: number) => ({
      name: s.name || `Section ${index + 1}`,
      description: s.description || undefined,
      order: s.order || index,
      fieldCount: fields.filter(f => f.position.section === s.name).length,
    }));

    // Calculate overall confidence
    const avgConfidence = fields.length > 0
      ? Math.round(fields.reduce((sum, f) => sum + f.confidence, 0) / fields.length)
      : 50;

    // Detect competitor from extracted fields
    const competitorDetected = this.detectCompetitor(fields);
    if (competitorDetected !== dto.competitorHint && dto.competitorHint !== 'unknown') {
      warnings.push(
        `Detected competitor (${competitorDetected}) differs from hint (${dto.competitorHint})`,
      );
    }

    // Add warnings for low-confidence fields
    const lowConfidenceFields = fields.filter(f => f.confidence < 50);
    if (lowConfidenceFields.length > 0) {
      warnings.push(
        `${lowConfidenceFields.length} field(s) have low confidence and may need manual review`,
      );
    }

    return {
      fields,
      sections,
      formTitle: parsed.formTitle || undefined,
      formDescription: parsed.formDescription || undefined,
      confidenceOverall: avgConfidence,
      warnings,
      competitorDetected,
      rawAnalysis: aiResponse,
    };
  }

  /**
   * Map AI-detected type to ExtractedFieldType.
   */
  private mapFieldType(type: string): ExtractedFieldType {
    const typeMap: Record<string, ExtractedFieldType> = {
      'text': ExtractedFieldType.TEXT,
      'string': ExtractedFieldType.TEXT,
      'textarea': ExtractedFieldType.TEXTAREA,
      'long text': ExtractedFieldType.TEXTAREA,
      'multiline': ExtractedFieldType.TEXTAREA,
      'number': ExtractedFieldType.NUMBER,
      'integer': ExtractedFieldType.NUMBER,
      'email': ExtractedFieldType.EMAIL,
      'phone': ExtractedFieldType.PHONE,
      'telephone': ExtractedFieldType.PHONE,
      'date': ExtractedFieldType.DATE,
      'datetime': ExtractedFieldType.DATETIME,
      'select': ExtractedFieldType.SELECT,
      'dropdown': ExtractedFieldType.SELECT,
      'multiselect': ExtractedFieldType.MULTISELECT,
      'multi-select': ExtractedFieldType.MULTISELECT,
      'radio': ExtractedFieldType.RADIO,
      'checkbox': ExtractedFieldType.CHECKBOX,
      'boolean': ExtractedFieldType.CHECKBOX,
      'file': ExtractedFieldType.FILE,
      'upload': ExtractedFieldType.FILE,
      'attachment': ExtractedFieldType.FILE,
      'currency': ExtractedFieldType.CURRENCY,
      'money': ExtractedFieldType.CURRENCY,
      'percentage': ExtractedFieldType.PERCENTAGE,
      'percent': ExtractedFieldType.PERCENTAGE,
      'url': ExtractedFieldType.URL,
      'link': ExtractedFieldType.URL,
    };

    const normalized = (type || '').toLowerCase().trim();
    return typeMap[normalized] || ExtractedFieldType.TEXT;
  }

  /**
   * Sanitize field name to camelCase.
   */
  private sanitizeFieldName(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, ' ')
      .trim()
      .split(' ')
      .map((word, index) =>
        index === 0 ? word : word.charAt(0).toUpperCase() + word.slice(1),
      )
      .join('');
  }

  /**
   * Detect competitor from extracted fields.
   */
  private detectCompetitor(fields: ExtractedField[]): CompetitorHint {
    const labels = fields.map(f => f.label.toLowerCase());

    for (const [competitor, patterns] of Object.entries(COMPETITOR_FIELD_PATTERNS)) {
      if (competitor === 'unknown') continue;

      const patternLabels = Object.keys(patterns);
      const matchCount = patternLabels.filter(p =>
        labels.some(l => l.includes(p)),
      ).length;

      if (matchCount >= 2) {
        return competitor as CompetitorHint;
      }
    }

    return CompetitorHint.UNKNOWN;
  }
}
```
  </action>
  <verify>npm run lint && npm run typecheck passes</verify>
  <done>ScreenshotToFormService with vision API integration implemented</done>
</task>

</tasks>

<verification>
```bash
cd apps/backend
npm run lint -- --fix
npm run typecheck
```
</verification>

<success_criteria>
- Screenshot analysis extracts field names, types, and validation rules
- Competitor-specific hints improve extraction accuracy for NAVEX, EQS, OneTrust, STAR
- Both migration and form builder contexts supported
- Results include confidence scores and warnings
- Audit trail tracks all screenshot analyses
</success_criteria>

<output>
After completion, create `.planning/phases/11-analytics-reporting/11-16-SUMMARY.md`
</output>
