---
phase: 11-analytics-reporting
plan: 11
type: execute
wave: 3
depends_on: ["11-04", "11-09"]
files_modified:
  - apps/backend/src/modules/analytics/migration/migration.controller.ts
  - apps/backend/src/modules/analytics/migration/processors/migration.processor.ts
  - apps/backend/src/modules/analytics/migration/screenshot-to-form.service.ts
autonomous: true

must_haves:
  truths:
    - "Migration jobs can be managed via REST API"
    - "Imports execute asynchronously with progress tracking"
    - "Screenshot-to-form AI extracts fields from images"
  artifacts:
    - path: "apps/backend/src/modules/analytics/migration/migration.controller.ts"
      provides: "REST endpoints for migration management"
      min_lines: 100
    - path: "apps/backend/src/modules/analytics/migration/processors/migration.processor.ts"
      provides: "BullMQ processor for async imports"
      min_lines: 100
  key_links:
    - from: "migration.controller.ts"
      to: "migration.service"
      via: "job management"
      pattern: "migrationService\\."
---

<objective>
Create the migration REST controller, async processor, and screenshot-to-form AI service.

Purpose: Complete migration infrastructure with API endpoints and background processing (MIG-02, MIG-06, MIG-07).
Output: MigrationController, MigrationProcessor, and ScreenshotToFormService
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/11-analytics-reporting/11-CONTEXT.md
@.planning/phases/11-analytics-reporting/11-04-SUMMARY.md
@.planning/phases/11-analytics-reporting/11-09-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement MigrationController</name>
  <files>apps/backend/src/modules/analytics/migration/migration.controller.ts</files>
  <action>
Create migration REST controller:

```typescript
@Controller('api/v1/migrations')
@UseGuards(JwtAuthGuard)
@Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER)
@ApiTags('migrations')
export class MigrationController {
  constructor(
    private migrationService: MigrationService,
    private screenshotService: ScreenshotToFormService,
    @InjectQueue(MIGRATION_QUEUE_NAME) private migrationQueue: Queue,
  ) {}

  // ==================== Job Management ====================

  @Post('upload')
  @UseInterceptors(FileInterceptor('file'))
  @ApiOperation({ summary: 'Upload migration file' })
  @ApiConsumes('multipart/form-data')
  async uploadFile(
    @CurrentUser() user: User,
    @UploadedFile() file: Express.Multer.File,
    @Body('sourceType') sourceType?: MigrationSourceType,
  ): Promise<CreateMigrationJobResponseDto> {
    // Upload to Azure Blob
    const fileKey = `migrations/${user.organizationId}/${nanoid()}-${file.originalname}`;
    const fileUrl = await this.storageService.upload(fileKey, file.buffer, file.mimetype);

    // Create job
    const job = await this.migrationService.createJob(user.organizationId, user.id, {
      sourceType: sourceType || MigrationSourceType.GENERIC_CSV,
      fileName: file.originalname,
      fileUrl,
      fileSizeBytes: file.size,
    });

    return {
      jobId: job.id,
      status: job.status,
      fileName: job.fileName,
    };
  }

  @Get()
  @ApiOperation({ summary: 'List migration jobs' })
  async listJobs(
    @CurrentUser() user: User,
    @Query() query: PaginationDto,
  ): Promise<PaginatedResult<MigrationJobSummaryDto>> {
    return this.migrationService.listJobs(user.organizationId, query);
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get migration job details' })
  async getJob(
    @CurrentUser() user: User,
    @Param('id') id: string,
  ): Promise<MigrationJobResponseDto> {
    return this.migrationService.getJob(user.organizationId, id);
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Cancel pending migration' })
  async cancelJob(
    @CurrentUser() user: User,
    @Param('id') id: string,
  ): Promise<void> {
    return this.migrationService.cancelJob(user.organizationId, id);
  }

  // ==================== Format Detection & Mapping ====================

  @Post(':id/detect')
  @ApiOperation({ summary: 'Detect file format and suggest mappings' })
  async detectFormat(
    @CurrentUser() user: User,
    @Param('id') id: string,
  ): Promise<FormatDetectionResponseDto> {
    const job = await this.migrationService.getJob(user.organizationId, id);
    const result = await this.migrationService.detectFormat(id);

    return {
      sourceType: result.sourceType,
      confidence: result.confidence,
      detectedFields: result.detectedFields,
      sampleRows: result.sampleRows,
      suggestedMappings: await this.migrationService.getSuggestedMappings(id),
    };
  }

  @Post(':id/mappings')
  @ApiOperation({ summary: 'Save field mappings' })
  async saveMappings(
    @CurrentUser() user: User,
    @Param('id') id: string,
    @Body() dto: SaveFieldMappingsDto,
  ): Promise<void> {
    return this.migrationService.saveMappings(user.organizationId, id, dto);
  }

  @Get(':id/templates')
  @ApiOperation({ summary: 'Get saved mapping templates for source type' })
  async getMappingTemplates(
    @CurrentUser() user: User,
    @Param('id') id: string,
  ): Promise<MigrationFieldTemplate[]> {
    const job = await this.migrationService.getJob(user.organizationId, id);
    return this.migrationService.loadTemplateMapping(user.organizationId, job.sourceType);
  }

  // ==================== Validation & Preview ====================

  @Post(':id/validate')
  @ApiOperation({ summary: 'Validate data with current mappings' })
  async validate(
    @CurrentUser() user: User,
    @Param('id') id: string,
  ): Promise<ValidationResultDto> {
    return this.migrationService.validate(id);
  }

  @Get(':id/preview')
  @ApiOperation({ summary: 'Preview transformed data' })
  async getPreview(
    @CurrentUser() user: User,
    @Param('id') id: string,
    @Query('limit', new DefaultValuePipe(10), ParseIntPipe) limit: number,
  ): Promise<PreviewRow[]> {
    return this.migrationService.generatePreview(id, limit);
  }

  // ==================== Import Execution ====================

  @Post(':id/import')
  @ApiOperation({ summary: 'Start import' })
  async startImport(
    @CurrentUser() user: User,
    @Param('id') id: string,
    @Body() dto: StartImportDto,
  ): Promise<{ jobId: string; status: string }> {
    if (!dto.confirmed) {
      throw new BadRequestException('Import must be confirmed');
    }

    // Queue for async processing
    await this.migrationQueue.add('import', {
      jobId: id,
      organizationId: user.organizationId,
      userId: user.id,
    }, {
      attempts: 1, // No retries for imports
    });

    return { jobId: id, status: 'IMPORTING' };
  }

  // ==================== Rollback ====================

  @Get(':id/rollback-status')
  @ApiOperation({ summary: 'Check if rollback is available' })
  async getRollbackStatus(
    @CurrentUser() user: User,
    @Param('id') id: string,
  ): Promise<RollbackStatusDto> {
    return this.migrationService.canRollback(id);
  }

  @Post(':id/rollback')
  @ApiOperation({ summary: 'Rollback import' })
  async rollback(
    @CurrentUser() user: User,
    @Param('id') id: string,
    @Body() dto: RollbackDto,
  ): Promise<RollbackResultDto> {
    if (dto.confirmText !== 'ROLLBACK') {
      throw new BadRequestException('Confirmation text must be "ROLLBACK"');
    }

    return this.migrationService.rollback(user.organizationId, user.id, id);
  }

  // ==================== Screenshot to Form ====================

  @Post('screenshot-to-form')
  @UseInterceptors(FileInterceptor('image'))
  @ApiOperation({ summary: 'Extract form fields from screenshot' })
  @ApiConsumes('multipart/form-data')
  async screenshotToForm(
    @CurrentUser() user: User,
    @UploadedFile() file: Express.Multer.File,
    @Body('context') context?: string,
  ): Promise<ExtractedFormDefinition> {
    return this.screenshotService.extractFormFields(
      user.organizationId,
      file.buffer,
      file.mimetype,
      context,
    );
  }
}
```
  </action>
  <verify>npm run lint passes for the controller file</verify>
  <done>MigrationController exposes full migration lifecycle via REST endpoints</done>
</task>

<task type="auto">
  <name>Task 2: Implement MigrationProcessor</name>
  <files>apps/backend/src/modules/analytics/migration/processors/migration.processor.ts</files>
  <action>
Create BullMQ processor for async imports:

```typescript
export const MIGRATION_QUEUE_NAME = 'migrations';

interface MigrationJobData {
  jobId: string;
  organizationId: string;
  userId: string;
}

@Processor(MIGRATION_QUEUE_NAME, { concurrency: 1 })
@Injectable()
export class MigrationProcessor extends WorkerHost {
  private readonly logger = new Logger(MigrationProcessor.name);

  constructor(
    private prisma: PrismaService,
    private migrationService: MigrationService,
    private storage: StorageService,
    private auditService: AuditService,
    private navexConnector: NavexConnector,
    private eqsConnector: EqsConnector,
    private csvConnector: CsvConnector,
  ) {
    super();
  }

  async process(job: Job<MigrationJobData>): Promise<MigrationResult> {
    const { jobId, organizationId, userId } = job.data;

    this.logger.log(`Starting import for job ${jobId}`);

    // Load job
    const migrationJob = await this.prisma.migrationJob.findUnique({
      where: { id: jobId },
    });

    if (!migrationJob) {
      throw new Error(`Migration job ${jobId} not found`);
    }

    // Update status
    await this.prisma.migrationJob.update({
      where: { id: jobId },
      data: { status: 'IMPORTING', progress: 0 },
    });

    try {
      // Download file
      const buffer = await this.storage.download(migrationJob.fileUrl);

      // Get connector
      const connector = this.getConnector(migrationJob.sourceType);
      const mappings = migrationJob.fieldMappings as FieldMapping[];

      // Process rows
      let importedCount = 0;
      let errorCount = 0;
      const errors: { row: number; error: string }[] = [];

      let rowNumber = 0;
      for await (const row of connector.createRowStream(buffer)) {
        rowNumber++;

        try {
          // Validate
          const validation = connector.validateRow(row, mappings);
          if (!validation.isValid) {
            errors.push({ row: rowNumber, error: validation.errors.map(e => e.message).join('; ') });
            errorCount++;
            continue;
          }

          // Transform
          const transformed = connector.transformRow(row, mappings);

          // Create entities
          await this.createEntities(organizationId, userId, transformed, migrationJob.id, rowNumber, row);
          importedCount++;

          // Update progress
          if (rowNumber % 100 === 0) {
            const progress = Math.round((rowNumber / (migrationJob.totalRows || rowNumber)) * 100);
            await job.updateProgress(progress);
            await this.prisma.migrationJob.update({
              where: { id: jobId },
              data: { progress, processedRows: importedCount },
            });
          }
        } catch (error) {
          errors.push({ row: rowNumber, error: error.message });
          errorCount++;
        }
      }

      // Complete
      await this.prisma.migrationJob.update({
        where: { id: jobId },
        data: {
          status: 'COMPLETED',
          progress: 100,
          importedRows: importedCount,
          errorRows: errorCount,
          validationErrors: errors.length > 0 ? errors.slice(0, 100) : null, // Limit stored errors
          completedAt: new Date(),
          rollbackAvailableUntil: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
        },
      });

      // Audit log
      await this.auditService.log({
        entityType: 'MIGRATION',
        entityId: jobId,
        action: 'completed',
        actionDescription: `Migration completed: ${importedCount} records imported, ${errorCount} errors`,
        organizationId,
        actorUserId: userId,
      });

      this.logger.log(`Import completed for job ${jobId}: ${importedCount} imported, ${errorCount} errors`);

      return { importedCount, errorCount, errors };

    } catch (error) {
      this.logger.error(`Import failed for job ${jobId}: ${error.message}`);

      await this.prisma.migrationJob.update({
        where: { id: jobId },
        data: {
          status: 'FAILED',
          errorMessage: error.message,
          errorDetails: { stack: error.stack },
        },
      });

      throw error;
    }
  }

  private getConnector(sourceType: MigrationSourceType): MigrationConnector {
    switch (sourceType) {
      case MigrationSourceType.NAVEX: return this.navexConnector;
      case MigrationSourceType.EQS: return this.eqsConnector;
      default: return this.csvConnector;
    }
  }

  private async createEntities(
    orgId: string,
    userId: string,
    transformed: TransformedRow,
    migrationJobId: string,
    rowNumber: number,
    sourceData: Record<string, string>,
  ): Promise<void> {
    // Create within transaction
    await this.prisma.$transaction(async (tx) => {
      let caseId: string | undefined;
      let riuId: string | undefined;
      let personId: string | undefined;

      // Create Person if needed
      if (transformed.person && Object.keys(transformed.person).length > 0) {
        const person = await tx.person.create({
          data: {
            organizationId: orgId,
            ...transformed.person,
            sourceSystem: 'MIGRATION',
            sourceRecordId: transformed.case?.sourceRecordId,
            migratedAt: new Date(),
            createdById: userId,
          },
        });
        personId = person.id;
      }

      // Create RIU
      if (transformed.riu && Object.keys(transformed.riu).length > 0) {
        const riu = await tx.riskIntelligenceUnit.create({
          data: {
            organizationId: orgId,
            ...transformed.riu,
            type: 'MIGRATED',
            sourceChannel: 'MIGRATION',
            sourceSystem: 'MIGRATION',
            sourceRecordId: transformed.case?.sourceRecordId,
            migratedAt: new Date(),
            createdById: userId,
          },
        });
        riuId = riu.id;
      }

      // Create Case
      if (transformed.case && Object.keys(transformed.case).length > 0) {
        const case_ = await tx.case.create({
          data: {
            organizationId: orgId,
            ...transformed.case,
            sourceSystem: 'MIGRATION',
            migratedAt: new Date(),
            createdById: userId,
          },
        });
        caseId = case_.id;

        // Link RIU to Case if both created
        if (riuId) {
          await tx.riuCaseAssociation.create({
            data: {
              riuId,
              caseId: case_.id,
              associationType: 'PRIMARY',
              createdById: userId,
            },
          });
        }
      }

      // Track imported record for rollback
      await tx.migrationRecord.create({
        data: {
          migrationJobId,
          entityType: caseId ? 'Case' : riuId ? 'RIU' : 'Person',
          entityId: caseId || riuId || personId!,
          sourceRowNumber: rowNumber,
          sourceData,
        },
      });
    });
  }
}

interface MigrationResult {
  importedCount: number;
  errorCount: number;
  errors: { row: number; error: string }[];
}
```
  </action>
  <verify>npm run lint passes for the processor file</verify>
  <done>MigrationProcessor executes async imports with progress tracking and rollback support</done>
</task>

<task type="auto">
  <name>Task 3: Implement ScreenshotToFormService</name>
  <files>apps/backend/src/modules/analytics/migration/screenshot-to-form.service.ts</files>
  <action>
Create AI-powered screenshot-to-form extraction service:

```typescript
@Injectable()
export class ScreenshotToFormService {
  private readonly logger = new Logger(ScreenshotToFormService.name);

  constructor(
    private aiService: AiService,
    private promptService: PromptService,
  ) {}

  /**
   * Extract form field definitions from screenshot/image.
   * Used for both migration (recreating competitor forms) and general form building.
   */
  async extractFormFields(
    orgId: string,
    imageBuffer: Buffer,
    mimeType: string,
    context?: string,
  ): Promise<ExtractedFormDefinition> {
    this.logger.log(`Extracting form fields from image (${mimeType})`);

    // Convert image to base64
    const imageBase64 = imageBuffer.toString('base64');
    const imageData = `data:${mimeType};base64,${imageBase64}`;

    // Build prompt
    const systemPrompt = this.promptService.render('screenshot-to-form-system', {
      context: context || 'general',
    });

    const userPrompt = `Analyze this form image and extract all form fields.
Return a structured JSON definition that can be used to recreate the form.

For each field, identify:
- Field type (text, number, date, select, checkbox, radio, textarea, etc.)
- Label text
- Whether it appears required (asterisk, "required" text)
- Placeholder text if visible
- Options for select/radio/checkbox fields
- Any validation hints (min/max, patterns)
- Section groupings

${context ? `Context: ${context}` : ''}`;

    // Call Claude with vision
    const response = await this.aiService.generateWithImage(
      orgId,
      systemPrompt,
      userPrompt,
      imageData,
      { maxTokens: 4000 },
    );

    // Parse response
    const extracted = this.parseExtractedFields(response);

    return extracted;
  }

  private parseExtractedFields(response: string): ExtractedFormDefinition {
    // Extract JSON from response
    const jsonMatch = response.match(/```json\n?([\s\S]*?)\n?```/);
    if (jsonMatch) {
      try {
        return JSON.parse(jsonMatch[1]);
      } catch (error) {
        this.logger.error('Failed to parse extracted JSON', error);
      }
    }

    // Try direct JSON parse
    try {
      return JSON.parse(response);
    } catch {
      // Return basic structure if parsing fails
      return {
        title: 'Extracted Form',
        sections: [{
          title: 'Fields',
          fields: [],
        }],
        extractionConfidence: 0,
        rawResponse: response,
      };
    }
  }
}

export interface ExtractedFormDefinition {
  title: string;
  description?: string;
  sections: ExtractedFormSection[];
  extractionConfidence: number;
  rawResponse?: string;
}

export interface ExtractedFormSection {
  title: string;
  description?: string;
  fields: ExtractedFormField[];
}

export interface ExtractedFormField {
  key: string;           // Generated from label
  label: string;
  type: 'text' | 'number' | 'date' | 'datetime' | 'select' | 'multiselect' |
        'checkbox' | 'radio' | 'textarea' | 'email' | 'phone' | 'currency';
  required: boolean;
  placeholder?: string;
  helpText?: string;
  options?: { label: string; value: string }[];
  validation?: {
    min?: number;
    max?: number;
    minLength?: number;
    maxLength?: number;
    pattern?: string;
  };
  confidence: number;    // 0-1 confidence in extraction accuracy
}
```

Also create the prompt template at `apps/backend/src/modules/ai/prompts/screenshot-to-form-system.hbs`:

```handlebars
You are an AI assistant specialized in analyzing form images and extracting form field definitions.

Your task is to:
1. Identify all form fields in the image
2. Determine the field type based on visual appearance
3. Extract labels, placeholders, and validation requirements
4. Group fields into logical sections

{{#if (eq context "migration")}}
This is a migration context - the form is from a competitor system.
Common compliance form fields include:
- Report type/category selection
- Date fields (incident date, report date)
- Location/department selectors
- Description/narrative text areas
- Reporter information (optional if anonymous)
- Severity/priority selectors
{{/if}}

Return a JSON object with this structure:
{
  "title": "Form title if visible",
  "sections": [
    {
      "title": "Section title or 'Main'",
      "fields": [
        {
          "key": "field_key_generated_from_label",
          "label": "Field Label",
          "type": "text|number|date|select|checkbox|textarea|etc",
          "required": true|false,
          "placeholder": "if visible",
          "options": [{"label": "Option", "value": "option"}], // for select/radio
          "confidence": 0.95
        }
      ]
    }
  ],
  "extractionConfidence": 0.85
}

Be thorough but conservative - only include fields you can clearly identify.
```
  </action>
  <verify>npm run lint && npm run typecheck passes</verify>
  <done>ScreenshotToFormService uses Claude vision to extract form fields from images</done>
</task>

</tasks>

<verification>
```bash
cd apps/backend
npm run lint -- --fix
npm run typecheck
```
</verification>

<success_criteria>
- MigrationController exposes upload, detect, validate, preview, import, rollback endpoints
- MigrationProcessor handles async import with transaction-safe entity creation
- ScreenshotToFormService extracts form fields using Claude vision API
- Rollback tracks imported records and respects 7-day window
</success_criteria>

<output>
After completion, create `.planning/phases/11-analytics-reporting/11-11-SUMMARY.md`
</output>
