---
phase: 11-analytics-reporting
plan: 20
type: execute
wave: 5
depends_on: ["11-04", "11-17", "11-18", "11-19"]
files_modified:
  - apps/backend/src/modules/analytics/migration/migration.processor.ts
  - apps/backend/src/modules/analytics/migration/migration.controller.ts
autonomous: true

must_haves:
  truths:
    - "Import preview shows transformed data before commit"
    - "Rollback removes all imported records within 7-day window"
    - "Records modified after import are skipped during rollback"
  artifacts:
    - path: "apps/backend/src/modules/analytics/migration/migration.processor.ts"
      provides: "BullMQ processor for import jobs"
      min_lines: 200
    - path: "apps/backend/src/modules/analytics/migration/migration.controller.ts"
      provides: "REST API for migration operations"
      min_lines: 120
  key_links:
    - from: "migration.processor.ts"
      to: "connectors"
      via: "connector factory"
      pattern: "getConnector"
---

<objective>
Build import preview, execution, and rollback functionality.

Purpose: Enable safe data migration with preview and rollback (MIG-06, MIG-07).
Output: MigrationProcessor and MigrationController with full import lifecycle
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/11-analytics-reporting/11-CONTEXT.md
@.planning/phases/11-analytics-reporting/11-04-SUMMARY.md
@.planning/phases/11-analytics-reporting/11-17-SUMMARY.md
@.planning/phases/11-analytics-reporting/11-18-SUMMARY.md
@.planning/phases/11-analytics-reporting/11-19-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement MigrationProcessor</name>
  <files>apps/backend/src/modules/analytics/migration/migration.processor.ts</files>
  <action>
Create BullMQ processor for import jobs:

```typescript
import { Processor, WorkerHost, OnWorkerEvent } from '@nestjs/bullmq';
import { Injectable, Logger } from '@nestjs/common';
import { Job } from 'bullmq';
import { PrismaService } from '../../../common/prisma/prisma.service';
import { StorageService } from '../../storage/storage.service';
import { AuditService } from '../../audit/audit.service';
import { MigrationSourceType, MigrationJobStatus } from '@prisma/client';
import { BaseMigrationConnector, TransformedRow } from './connectors/base.connector';
import { NavexConnector } from './connectors/navex.connector';
import { EqsConnector } from './connectors/eqs.connector';
import { CsvConnector } from './connectors/csv.connector';
import { FieldMappingDto } from './dto/migration.dto';
import { parse as csvParse } from 'csv-parse';
import * as xlsx from 'xlsx';
import { Readable } from 'stream';
import { addDays } from 'date-fns';

const QUEUE_NAME = 'migration';
const BATCH_SIZE = 100;

interface MigrationJobData {
  jobId: string;
  orgId: string;
  userId: string;
  action: 'validate' | 'preview' | 'import' | 'rollback';
}

@Processor(QUEUE_NAME)
@Injectable()
export class MigrationProcessor extends WorkerHost {
  private readonly logger = new Logger(MigrationProcessor.name);

  constructor(
    private prisma: PrismaService,
    private storageService: StorageService,
    private auditService: AuditService,
    private navexConnector: NavexConnector,
    private eqsConnector: EqsConnector,
    private csvConnector: CsvConnector,
  ) {
    super();
  }

  async process(job: Job<MigrationJobData>): Promise<void> {
    const { jobId, orgId, userId, action } = job.data;

    this.logger.log(`Processing migration job ${jobId}: ${action}`);

    try {
      switch (action) {
        case 'validate':
          await this.validateJob(jobId, job);
          break;
        case 'preview':
          await this.generatePreview(jobId, job);
          break;
        case 'import':
          await this.executeImport(jobId, orgId, userId, job);
          break;
        case 'rollback':
          await this.executeRollback(jobId, orgId, userId, job);
          break;
      }
    } catch (error) {
      this.logger.error(`Migration job ${jobId} failed: ${error.message}`);
      await this.updateJobStatus(jobId, 'FAILED', error.message);
      throw error;
    }
  }

  // ==================== Validation ====================

  private async validateJob(jobId: string, queueJob: Job): Promise<void> {
    await this.updateJobStatus(jobId, 'VALIDATING');

    const job = await this.prisma.migrationJob.findUnique({
      where: { id: jobId },
    });

    if (!job) throw new Error('Job not found');

    const connector = this.getConnector(job.sourceType);
    const rows = await this.loadRows(job.fileUrl, job.fileName);

    let validRows = 0;
    let errorRows = 0;
    const errors: { row: number; field: string; error: string }[] = [];

    for (let i = 0; i < rows.length; i++) {
      const validation = connector.validateRow(rows[i], i + 1);
      if (validation.isValid) {
        validRows++;
      } else {
        errorRows++;
        for (const error of validation.errors) {
          errors.push({ row: i + 1, field: '', error });
        }
      }

      // Update progress
      if (i % 100 === 0) {
        await queueJob.updateProgress(Math.round((i / rows.length) * 100));
      }
    }

    await this.prisma.migrationJob.update({
      where: { id: jobId },
      data: {
        status: 'MAPPING',
        totalRows: rows.length,
        validRows,
        errorRows,
        validationErrors: errors,
        progress: 100,
        currentStep: 'Validation complete',
      },
    });
  }

  // ==================== Preview ====================

  private async generatePreview(jobId: string, queueJob: Job): Promise<void> {
    const job = await this.prisma.migrationJob.findUnique({
      where: { id: jobId },
    });

    if (!job) throw new Error('Job not found');

    const connector = this.getConnector(job.sourceType);
    const rows = await this.loadRows(job.fileUrl, job.fileName);
    const mappings = (job.fieldMappings as unknown as FieldMappingDto[]) || [];

    // Generate preview for first 20 rows
    const previewData: {
      rowNumber: number;
      sourceData: Record<string, unknown>;
      transformedData: TransformedRow;
      issues: string[];
    }[] = [];

    const previewCount = Math.min(rows.length, 20);
    for (let i = 0; i < previewCount; i++) {
      const row = rows[i];
      const validation = connector.validateRow(row, i + 1);
      const transformed = connector.transformRow(row, mappings, job.organizationId);

      previewData.push({
        rowNumber: i + 1,
        sourceData: row,
        transformedData: transformed,
        issues: validation.errors,
      });
    }

    await this.prisma.migrationJob.update({
      where: { id: jobId },
      data: {
        status: 'PREVIEW',
        previewData,
        currentStep: 'Preview ready',
      },
    });
  }

  // ==================== Import ====================

  private async executeImport(
    jobId: string,
    orgId: string,
    userId: string,
    queueJob: Job,
  ): Promise<void> {
    await this.updateJobStatus(jobId, 'IMPORTING');

    const job = await this.prisma.migrationJob.findUnique({
      where: { id: jobId },
    });

    if (!job) throw new Error('Job not found');

    const connector = this.getConnector(job.sourceType);
    const rows = await this.loadRows(job.fileUrl, job.fileName);
    const mappings = (job.fieldMappings as unknown as FieldMappingDto[]) || [];

    let importedRows = 0;
    const errors: { row: number; error: string }[] = [];

    // Process in batches
    for (let i = 0; i < rows.length; i += BATCH_SIZE) {
      const batch = rows.slice(i, i + BATCH_SIZE);

      await this.prisma.$transaction(async (tx) => {
        for (let j = 0; j < batch.length; j++) {
          const rowNumber = i + j + 1;
          const row = batch[j];

          try {
            const validation = connector.validateRow(row, rowNumber);
            if (!validation.isValid) {
              errors.push({ row: rowNumber, error: validation.errors.join('; ') });
              continue;
            }

            const transformed = connector.transformRow(row, mappings, orgId);

            // Create entities
            const createdEntities = await this.createEntities(
              tx,
              orgId,
              userId,
              transformed,
              rowNumber,
              jobId,
              row,
            );

            if (createdEntities) {
              importedRows++;
            }
          } catch (error) {
            errors.push({ row: rowNumber, error: error.message });
          }
        }
      });

      // Update progress
      const progress = Math.round(((i + batch.length) / rows.length) * 100);
      await queueJob.updateProgress(progress);
      await this.prisma.migrationJob.update({
        where: { id: jobId },
        data: {
          importedRows,
          progress,
          currentStep: `Importing rows ${i + 1}-${i + batch.length}`,
        },
      });
    }

    // Mark complete
    await this.prisma.migrationJob.update({
      where: { id: jobId },
      data: {
        status: 'COMPLETED',
        completedAt: new Date(),
        importedRows,
        errorRows: errors.length,
        validationErrors: errors,
        rollbackAvailableUntil: addDays(new Date(), 7),
        currentStep: 'Import complete',
        progress: 100,
      },
    });

    await this.auditService.log({
      entityType: 'MIGRATION_JOB',
      entityId: jobId,
      action: 'completed',
      actionDescription: `Migration completed: ${importedRows} records imported, ${errors.length} errors`,
      organizationId: orgId,
      actorUserId: userId,
    });
  }

  private async createEntities(
    tx: any,
    orgId: string,
    userId: string,
    transformed: TransformedRow,
    rowNumber: number,
    jobId: string,
    sourceData: Record<string, unknown>,
  ): Promise<boolean> {
    // Create Person first if present
    let personId: string | undefined;
    if (transformed.person) {
      const person = await tx.person.create({
        data: {
          organizationId: orgId,
          firstName: transformed.person.firstName || '',
          lastName: transformed.person.lastName || '',
          email: transformed.person.email,
          phone: transformed.person.phone,
          type: 'EXTERNAL',
          sourceSystem: 'MIGRATION',
          createdById: userId,
        },
      });
      personId = person.id;

      await tx.migrationRecord.create({
        data: {
          migrationJobId: jobId,
          entityType: 'Person',
          entityId: person.id,
          sourceRowNumber: rowNumber,
          sourceData,
        },
      });
    }

    // Create RIU
    let riuId: string | undefined;
    if (transformed.riu) {
      // Resolve category
      const category = await this.resolveCategory(tx, orgId, transformed.riu.categoryName);

      // Resolve business unit
      const businessUnit = await this.resolveBusinessUnit(tx, orgId, transformed.riu.businessUnitName);

      const riu = await tx.riskIntelligenceUnit.create({
        data: {
          organizationId: orgId,
          type: transformed.riu.type,
          sourceChannel: 'migration',
          details: transformed.riu.details,
          reporterType: transformed.riu.reporterType,
          categoryId: category?.id,
          severity: transformed.riu.severity,
          incidentDate: transformed.riu.incidentDate,
          businessUnitId: businessUnit?.id,
          status: 'RELEASED',
          sourceSystem: 'MIGRATION',
          sourceRecordId: transformed.riu.sourceRecordId,
          createdById: userId,
        },
      });
      riuId = riu.id;

      await tx.migrationRecord.create({
        data: {
          migrationJobId: jobId,
          entityType: 'RIU',
          entityId: riu.id,
          sourceRowNumber: rowNumber,
          sourceData,
        },
      });
    }

    // Create Case if RIU created
    if (riuId && transformed.case) {
      // Resolve assignee
      const assignee = transformed.case.assignedToEmail
        ? await tx.user.findFirst({
            where: { organizationId: orgId, email: transformed.case.assignedToEmail },
          })
        : null;

      const caseRecord = await tx.case.create({
        data: {
          organizationId: orgId,
          referenceNumber: transformed.case.referenceNumber || undefined,
          status: transformed.case.status,
          assignedToId: assignee?.id,
          closedAt: transformed.case.closedAt,
          resolution: transformed.case.resolution,
          sourceSystem: 'MIGRATION',
          sourceRecordId: transformed.riu?.sourceRecordId,
          createdById: userId,
        },
      });

      // Link RIU to Case
      await tx.riuCaseAssociation.create({
        data: {
          riuId,
          caseId: caseRecord.id,
          associationType: 'PRIMARY',
          createdById: userId,
        },
      });

      // Link Person to Case if present
      if (personId) {
        await tx.personCaseAssociation.create({
          data: {
            personId,
            caseId: caseRecord.id,
            role: transformed.person?.role || 'subject',
            createdById: userId,
          },
        });
      }

      await tx.migrationRecord.create({
        data: {
          migrationJobId: jobId,
          entityType: 'Case',
          entityId: caseRecord.id,
          sourceRowNumber: rowNumber,
          sourceData,
        },
      });
    }

    return true;
  }

  // ==================== Rollback ====================

  private async executeRollback(
    jobId: string,
    orgId: string,
    userId: string,
    queueJob: Job,
  ): Promise<void> {
    const job = await this.prisma.migrationJob.findUnique({
      where: { id: jobId },
      include: { records: true },
    });

    if (!job) throw new Error('Job not found');

    if (job.rollbackAvailableUntil && job.rollbackAvailableUntil < new Date()) {
      throw new Error('Rollback window has expired');
    }

    let rolledBackCount = 0;
    let skippedCount = 0;
    const skippedReasons: string[] = [];

    // Group records by entity type (delete in reverse dependency order)
    const entityOrder = ['Case', 'RIU', 'Person', 'Investigation'];

    for (const entityType of entityOrder) {
      const records = job.records.filter(r => r.entityType === entityType);

      for (const record of records) {
        // Check if modified after import
        if (record.modifiedAfterImport) {
          skippedCount++;
          skippedReasons.push(`${entityType} ${record.entityId}: Modified after import`);
          continue;
        }

        try {
          // Delete based on entity type
          switch (entityType) {
            case 'Case':
              // Delete associations first
              await this.prisma.riuCaseAssociation.deleteMany({
                where: { caseId: record.entityId },
              });
              await this.prisma.personCaseAssociation.deleteMany({
                where: { caseId: record.entityId },
              });
              await this.prisma.case.delete({
                where: { id: record.entityId },
              });
              break;

            case 'RIU':
              await this.prisma.riskIntelligenceUnit.delete({
                where: { id: record.entityId },
              });
              break;

            case 'Person':
              await this.prisma.person.delete({
                where: { id: record.entityId },
              });
              break;
          }

          rolledBackCount++;
        } catch (error) {
          skippedCount++;
          skippedReasons.push(`${entityType} ${record.entityId}: ${error.message}`);
        }

        // Update progress
        const processed = rolledBackCount + skippedCount;
        await queueJob.updateProgress(Math.round((processed / job.records.length) * 100));
      }
    }

    // Update job status
    await this.prisma.migrationJob.update({
      where: { id: jobId },
      data: {
        status: 'ROLLED_BACK',
        rolledBackAt: new Date(),
        rolledBackById: userId,
        currentStep: `Rolled back ${rolledBackCount} records, skipped ${skippedCount}`,
      },
    });

    await this.auditService.log({
      entityType: 'MIGRATION_JOB',
      entityId: jobId,
      action: 'rolled_back',
      actionDescription: `Migration rolled back: ${rolledBackCount} records removed, ${skippedCount} skipped`,
      organizationId: orgId,
      actorUserId: userId,
      metadata: { skippedReasons },
    });
  }

  // ==================== Helpers ====================

  private getConnector(sourceType: MigrationSourceType): BaseMigrationConnector {
    switch (sourceType) {
      case 'NAVEX':
        return this.navexConnector;
      case 'EQS':
        return this.eqsConnector;
      default:
        return this.csvConnector;
    }
  }

  private async loadRows(fileUrl: string, fileName: string): Promise<Record<string, unknown>[]> {
    const buffer = await this.storageService.download(fileUrl);
    const extension = fileName.split('.').pop()?.toLowerCase();

    if (extension === 'csv') {
      return this.parseCsv(buffer);
    } else {
      return this.parseExcel(buffer);
    }
  }

  private async parseCsv(buffer: Buffer): Promise<Record<string, unknown>[]> {
    return new Promise((resolve, reject) => {
      const rows: Record<string, unknown>[] = [];

      const parser = csvParse({
        columns: true,
        skip_empty_lines: true,
        trim: true,
      });

      parser.on('readable', () => {
        let record;
        while ((record = parser.read()) !== null) {
          rows.push(record);
        }
      });

      parser.on('error', reject);
      parser.on('end', () => resolve(rows));

      Readable.from(buffer).pipe(parser);
    });
  }

  private parseExcel(buffer: Buffer): Record<string, unknown>[] {
    const workbook = xlsx.read(buffer, { type: 'buffer' });
    const sheet = workbook.Sheets[workbook.SheetNames[0]];
    return xlsx.utils.sheet_to_json(sheet) as Record<string, unknown>[];
  }

  private async updateJobStatus(
    jobId: string,
    status: MigrationJobStatus,
    errorMessage?: string,
  ): Promise<void> {
    await this.prisma.migrationJob.update({
      where: { id: jobId },
      data: {
        status,
        ...(errorMessage && { errorMessage }),
        currentStep: status,
      },
    });
  }

  private async resolveCategory(tx: any, orgId: string, categoryName?: string) {
    if (!categoryName) return null;
    return tx.category.findFirst({
      where: {
        organizationId: orgId,
        OR: [
          { name: { equals: categoryName, mode: 'insensitive' } },
          { code: { equals: categoryName, mode: 'insensitive' } },
        ],
      },
    });
  }

  private async resolveBusinessUnit(tx: any, orgId: string, unitName?: string) {
    if (!unitName) return null;
    return tx.businessUnit.findFirst({
      where: {
        organizationId: orgId,
        name: { equals: unitName, mode: 'insensitive' },
      },
    });
  }

  @OnWorkerEvent('failed')
  onFailed(job: Job<MigrationJobData>, error: Error) {
    this.logger.error(`Migration job ${job.data.jobId} failed: ${error.message}`);
  }
}
```
  </action>
  <verify>npm run lint passes for the processor file</verify>
  <done>MigrationProcessor with validate, preview, import, and rollback implemented</done>
</task>

<task type="auto">
  <name>Task 2: Implement MigrationController</name>
  <files>apps/backend/src/modules/analytics/migration/migration.controller.ts</files>
  <action>
Create REST API controller:

```typescript
import {
  Controller,
  Get,
  Post,
  Delete,
  Param,
  Body,
  Query,
  UseGuards,
} from '@nestjs/common';
import { InjectQueue } from '@nestjs/bullmq';
import { Queue } from 'bullmq';
import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../../auth/guards/roles.guard';
import { Roles } from '../../auth/decorators/roles.decorator';
import { TenantId } from '../../auth/decorators/tenant.decorator';
import { CurrentUser } from '../../auth/decorators/current-user.decorator';
import { MigrationService } from './migration.service';
import { MappingSuggestionService } from './mapping-suggestion.service';
import {
  SaveFieldMappingsDto,
  StartImportDto,
  RollbackDto,
  MigrationJobResponseDto,
  FieldMappingDto,
} from './dto/migration.dto';
import { PrismaService } from '../../../common/prisma/prisma.service';

const QUEUE_NAME = 'migration';

@Controller('api/v1/migrations')
@UseGuards(JwtAuthGuard, RolesGuard)
export class MigrationController {
  constructor(
    private migrationService: MigrationService,
    private mappingSuggestionService: MappingSuggestionService,
    private prisma: PrismaService,
    @InjectQueue(QUEUE_NAME) private migrationQueue: Queue,
  ) {}

  /**
   * List migration jobs.
   */
  @Get()
  @Roles('SYSTEM_ADMIN', 'COMPLIANCE_OFFICER')
  async listJobs(
    @TenantId() orgId: string,
    @Query('offset') offset?: string,
    @Query('limit') limit?: string,
  ): Promise<{ items: MigrationJobResponseDto[]; total: number }> {
    return this.migrationService.listJobs(orgId, {
      offset: offset ? parseInt(offset, 10) : 0,
      limit: limit ? parseInt(limit, 10) : 20,
    });
  }

  /**
   * Get migration job details.
   */
  @Get(':jobId')
  @Roles('SYSTEM_ADMIN', 'COMPLIANCE_OFFICER')
  async getJob(
    @TenantId() orgId: string,
    @Param('jobId') jobId: string,
  ): Promise<MigrationJobResponseDto> {
    const job = await this.migrationService.getJob(orgId, jobId);
    if (!job) throw new Error('Job not found');
    return job as MigrationJobResponseDto;
  }

  /**
   * Start validation for a job.
   */
  @Post(':jobId/validate')
  @Roles('SYSTEM_ADMIN', 'COMPLIANCE_OFFICER')
  async validateJob(
    @TenantId() orgId: string,
    @CurrentUser('id') userId: string,
    @Param('jobId') jobId: string,
  ): Promise<{ queued: boolean; queueJobId: string }> {
    const queueJob = await this.migrationQueue.add('validate', {
      jobId,
      orgId,
      userId,
      action: 'validate',
    });

    return { queued: true, queueJobId: queueJob.id as string };
  }

  /**
   * Get suggested field mappings.
   */
  @Get(':jobId/mappings/suggestions')
  @Roles('SYSTEM_ADMIN', 'COMPLIANCE_OFFICER')
  async getSuggestedMappings(
    @TenantId() orgId: string,
    @Param('jobId') jobId: string,
  ): Promise<{ mappings: FieldMappingDto[]; targetFields: any[] }> {
    const job = await this.migrationService.getJob(orgId, jobId);
    if (!job) throw new Error('Job not found');

    // Get sample data
    const sampleData = job.previewData as Record<string, unknown>[] || [];
    const sourceFields = sampleData.length > 0 ? Object.keys(sampleData[0]) : [];

    const mappings = await this.mappingSuggestionService.suggestMappings(
      orgId,
      sourceFields,
      sampleData,
    );

    return {
      mappings,
      targetFields: this.mappingSuggestionService.getTargetFields(),
    };
  }

  /**
   * Save field mappings.
   */
  @Post(':jobId/mappings')
  @Roles('SYSTEM_ADMIN', 'COMPLIANCE_OFFICER')
  async saveMappings(
    @TenantId() orgId: string,
    @CurrentUser('id') userId: string,
    @Param('jobId') jobId: string,
    @Body() dto: SaveFieldMappingsDto,
  ): Promise<{ saved: boolean }> {
    await this.migrationService.saveMappings(orgId, jobId, dto);

    // Optionally save as template
    if (dto.saveAsTemplate && dto.templateName) {
      await this.mappingSuggestionService.saveTemplate(
        orgId,
        userId,
        dto.templateName,
        dto.mappings,
      );
    }

    return { saved: true };
  }

  /**
   * Generate import preview.
   */
  @Post(':jobId/preview')
  @Roles('SYSTEM_ADMIN', 'COMPLIANCE_OFFICER')
  async generatePreview(
    @TenantId() orgId: string,
    @CurrentUser('id') userId: string,
    @Param('jobId') jobId: string,
  ): Promise<{ queued: boolean; queueJobId: string }> {
    const queueJob = await this.migrationQueue.add('preview', {
      jobId,
      orgId,
      userId,
      action: 'preview',
    });

    return { queued: true, queueJobId: queueJob.id as string };
  }

  /**
   * Get preview data.
   */
  @Get(':jobId/preview')
  @Roles('SYSTEM_ADMIN', 'COMPLIANCE_OFFICER')
  async getPreview(
    @TenantId() orgId: string,
    @Param('jobId') jobId: string,
  ): Promise<{ previewData: any[]; status: string }> {
    const job = await this.prisma.migrationJob.findFirst({
      where: { id: jobId, organizationId: orgId },
      select: { previewData: true, status: true },
    });

    if (!job) throw new Error('Job not found');

    return {
      previewData: job.previewData as any[] || [],
      status: job.status,
    };
  }

  /**
   * Start import execution.
   */
  @Post(':jobId/import')
  @Roles('SYSTEM_ADMIN', 'COMPLIANCE_OFFICER')
  async startImport(
    @TenantId() orgId: string,
    @CurrentUser('id') userId: string,
    @Param('jobId') jobId: string,
    @Body() dto: StartImportDto,
  ): Promise<{ queued: boolean; queueJobId: string }> {
    if (!dto.confirmed) {
      throw new Error('Import must be confirmed');
    }

    const queueJob = await this.migrationQueue.add('import', {
      jobId,
      orgId,
      userId,
      action: 'import',
    });

    return { queued: true, queueJobId: queueJob.id as string };
  }

  /**
   * Check rollback availability.
   */
  @Get(':jobId/rollback')
  @Roles('SYSTEM_ADMIN', 'COMPLIANCE_OFFICER')
  async checkRollback(
    @TenantId() orgId: string,
    @Param('jobId') jobId: string,
  ): Promise<{ canRollback: boolean; reason?: string; modifiedCount?: number }> {
    return this.migrationService.canRollback(jobId);
  }

  /**
   * Execute rollback.
   */
  @Post(':jobId/rollback')
  @Roles('SYSTEM_ADMIN')
  async rollback(
    @TenantId() orgId: string,
    @CurrentUser('id') userId: string,
    @Param('jobId') jobId: string,
    @Body() dto: RollbackDto,
  ): Promise<{ queued: boolean; queueJobId: string }> {
    if (dto.confirmText !== 'ROLLBACK') {
      throw new Error('Confirmation text must be "ROLLBACK"');
    }

    const canRollback = await this.migrationService.canRollback(jobId);
    if (!canRollback.canRollback) {
      throw new Error(canRollback.reason || 'Rollback not available');
    }

    const queueJob = await this.migrationQueue.add('rollback', {
      jobId,
      orgId,
      userId,
      action: 'rollback',
    });

    return { queued: true, queueJobId: queueJob.id as string };
  }

  /**
   * Delete a migration job (only if not started).
   */
  @Delete(':jobId')
  @Roles('SYSTEM_ADMIN', 'COMPLIANCE_OFFICER')
  async deleteJob(
    @TenantId() orgId: string,
    @Param('jobId') jobId: string,
  ): Promise<{ deleted: boolean }> {
    const job = await this.prisma.migrationJob.findFirst({
      where: { id: jobId, organizationId: orgId },
    });

    if (!job) throw new Error('Job not found');

    if (!['PENDING', 'MAPPING', 'PREVIEW', 'FAILED'].includes(job.status)) {
      throw new Error('Cannot delete job that has started importing');
    }

    await this.prisma.migrationJob.delete({ where: { id: jobId } });

    return { deleted: true };
  }

  /**
   * List saved mapping templates.
   */
  @Get('templates/list')
  @Roles('SYSTEM_ADMIN', 'COMPLIANCE_OFFICER')
  async listTemplates(
    @TenantId() orgId: string,
  ): Promise<{ templates: { name: string; fieldCount: number }[] }> {
    const templates = await this.mappingSuggestionService.listTemplates(orgId);
    return { templates };
  }
}
```
  </action>
  <verify>npm run lint && npm run typecheck passes</verify>
  <done>MigrationController with full REST API implemented</done>
</task>

</tasks>

<verification>
```bash
cd apps/backend
npm run lint -- --fix
npm run typecheck
```
</verification>

<success_criteria>
- Validation step checks all rows and reports errors
- Preview shows first 20 rows with transformation results
- Import processes rows in batches with progress tracking
- Rollback removes all records created in 7-day window
- Modified records are skipped during rollback with reasons
- Queue-based processing enables progress monitoring
</success_criteria>

<output>
After completion, create `.planning/phases/11-analytics-reporting/11-20-SUMMARY.md`
</output>
