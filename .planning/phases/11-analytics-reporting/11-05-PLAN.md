---
phase: 11-analytics-reporting
plan: 05
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - apps/backend/src/modules/analytics/dashboard/widget-data.service.ts
  - apps/backend/src/modules/analytics/dashboard/dto/widget-data.dto.ts
  - apps/backend/src/modules/analytics/dashboard/prebuilt/prebuilt-widgets.ts
autonomous: true

must_haves:
  truths:
    - "Widget data service fetches data for all widget types"
    - "Pre-built widgets are defined for CCO, Investigator, and Campaign Manager dashboards"
    - "Data is cached with configurable TTL per widget type"
  artifacts:
    - path: "apps/backend/src/modules/analytics/dashboard/widget-data.service.ts"
      provides: "Fetches data for all widget types"
      min_lines: 200
    - path: "apps/backend/src/modules/analytics/dashboard/prebuilt/prebuilt-widgets.ts"
      provides: "Pre-built widget definitions"
      exports: ["CCO_WIDGETS", "INVESTIGATOR_WIDGETS", "CAMPAIGN_MANAGER_WIDGETS"]
  key_links:
    - from: "widget-data.service.ts"
      to: "prisma.case"
      via: "aggregate queries"
      pattern: "prisma\\.case\\.groupBy"
---

<objective>
Build the widget data service and define pre-built dashboard widgets.

Purpose: Enable dashboards to display real-time data from Cases, RIUs, Campaigns with proper caching.
Output: WidgetDataService with data fetchers and pre-built widget definitions
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/11-analytics-reporting/11-CONTEXT.md
@.planning/phases/11-analytics-reporting/11-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define pre-built widget configurations</name>
  <files>apps/backend/src/modules/analytics/dashboard/prebuilt/prebuilt-widgets.ts</files>
  <action>
Create pre-built widget definitions per CONTEXT.md:

```typescript
import { WidgetType, ChartType } from '@prisma/client';

export interface PrebuiltWidget {
  id: string;
  widgetType: WidgetType;
  title: string;
  dataSource: string;
  queryConfig: WidgetQueryConfig;
  layoutItem: { w: number; h: number; minW?: number; minH?: number };
  chartType?: ChartType;
  displayConfig?: Record<string, unknown>;
}

export interface WidgetQueryConfig {
  entity: string;
  aggregation?: 'count' | 'sum' | 'avg';
  aggregateField?: string;
  groupBy?: string[];
  filters?: Record<string, unknown>;
  orderBy?: { field: string; direction: 'asc' | 'desc' };
  limit?: number;
}

// CCO Dashboard widgets
export const CCO_WIDGETS: PrebuiltWidget[] = [
  {
    id: 'cco-compliance-health',
    widgetType: 'KPI_CARD',
    title: 'Compliance Health Score',
    dataSource: 'compliance_health',
    queryConfig: { entity: 'computed', aggregation: 'avg' },
    layoutItem: { w: 2, h: 2, minW: 1, minH: 1 },
  },
  {
    id: 'cco-riu-trends',
    widgetType: 'LINE_CHART',
    title: 'RIU Intake Trends',
    dataSource: 'rius',
    queryConfig: { entity: 'riu', aggregation: 'count', groupBy: ['date'] },
    layoutItem: { w: 4, h: 2, minW: 2, minH: 2 },
    chartType: 'LINE',
  },
  {
    id: 'cco-case-pipeline',
    widgetType: 'BAR_CHART',
    title: 'Case Pipeline',
    dataSource: 'cases',
    queryConfig: { entity: 'case', aggregation: 'count', groupBy: ['status'] },
    layoutItem: { w: 4, h: 2, minW: 2, minH: 2 },
    chartType: 'BAR',
  },
  {
    id: 'cco-campaign-completion',
    widgetType: 'DONUT_CHART',
    title: 'Campaign Completion',
    dataSource: 'campaigns',
    queryConfig: { entity: 'campaignAssignment', aggregation: 'count', groupBy: ['status'] },
    layoutItem: { w: 4, h: 2, minW: 2, minH: 2 },
    chartType: 'DONUT',
  },
  // ... SLA Performance, Top Risk Categories, Recent High-Severity, Board Report Quick Gen
];

// Investigator Dashboard widgets
export const INVESTIGATOR_WIDGETS: PrebuiltWidget[] = [
  {
    id: 'inv-my-assignments',
    widgetType: 'TABLE',
    title: 'My Assignments',
    dataSource: 'my_cases',
    queryConfig: { entity: 'case', filters: { assignedToMe: true }, limit: 10 },
    layoutItem: { w: 4, h: 4, minW: 2, minH: 2 },
  },
  {
    id: 'inv-case-pipeline',
    widgetType: 'BAR_CHART',
    title: 'Case Pipeline',
    dataSource: 'cases',
    queryConfig: { entity: 'case', aggregation: 'count', groupBy: ['status'], filters: { assignedToMe: true } },
    layoutItem: { w: 4, h: 2, minW: 2, minH: 2 },
    chartType: 'BAR',
  },
  // ... SLA Alerts, Recent Activity, Unassigned Queue, Investigation Progress, Quick Actions
];

// Campaign Manager Dashboard widgets
export const CAMPAIGN_MANAGER_WIDGETS: PrebuiltWidget[] = [
  {
    id: 'camp-active-campaigns',
    widgetType: 'TABLE',
    title: 'Active Campaigns',
    dataSource: 'campaigns',
    queryConfig: { entity: 'campaign', filters: { status: 'ACTIVE' }, limit: 10 },
    layoutItem: { w: 4, h: 4, minW: 2, minH: 2 },
  },
  {
    id: 'camp-disclosure-trends',
    widgetType: 'LINE_CHART',
    title: 'Disclosure Trends',
    dataSource: 'disclosures',
    queryConfig: { entity: 'disclosure', aggregation: 'count', groupBy: ['date', 'type'] },
    layoutItem: { w: 4, h: 2, minW: 2, minH: 2 },
    chartType: 'LINE',
  },
  // ... Non-Responders, Conflict Alerts, Campaign Calendar, Attestation Completion, Quick Launch
];

export const DASHBOARD_DEFAULTS = {
  CCO: { widgets: CCO_WIDGETS, roles: ['COMPLIANCE_OFFICER', 'SYSTEM_ADMIN'] },
  INVESTIGATOR: { widgets: INVESTIGATOR_WIDGETS, roles: ['INVESTIGATOR', 'TRIAGE_LEAD'] },
  CAMPAIGN_MANAGER: { widgets: CAMPAIGN_MANAGER_WIDGETS, roles: ['DEPARTMENT_ADMIN', 'MANAGER'] },
};
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>Pre-built widget configurations defined for all three dashboard types</done>
</task>

<task type="auto">
  <name>Task 2: Create widget data DTOs</name>
  <files>apps/backend/src/modules/analytics/dashboard/dto/widget-data.dto.ts</files>
  <action>
Create DTOs for widget data requests and responses:

```typescript
export class WidgetDataRequestDto {
  @IsUUID()
  widgetId: string;

  @IsOptional()
  @ValidateNested()
  @Type(() => DateRangeDto)
  dateRange?: DateRangeDto;

  @IsOptional()
  @IsBoolean()
  forceRefresh?: boolean;
}

export class BatchWidgetDataRequestDto {
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => WidgetDataRequestDto)
  widgets: WidgetDataRequestDto[];
}

export interface WidgetDataResponse {
  widgetId: string;
  data: WidgetData;
  updatedAt: Date;
  nextRefreshAt?: Date;
}

export type WidgetData =
  | KpiData
  | ChartData
  | TableData
  | ListData;

export interface KpiData {
  type: 'kpi';
  value: number | string;
  label: string;
  trend?: { value: number; direction: 'up' | 'down' | 'flat' };
  comparison?: { value: number | string; period: string };
}

export interface ChartData {
  type: 'chart';
  chartType: ChartType;
  series: ChartSeries[];
  categories?: string[];
  config?: ChartConfig;
}

export interface ChartSeries {
  name: string;
  data: (number | null)[];
  color?: string;
}

export interface TableData {
  type: 'table';
  columns: TableColumn[];
  rows: Record<string, unknown>[];
  total: number;
  hasMore: boolean;
}

export interface TableColumn {
  key: string;
  label: string;
  type: 'string' | 'number' | 'date' | 'status' | 'link';
  sortable?: boolean;
}

export interface ListData {
  type: 'list';
  items: ListItem[];
  total: number;
}

export interface ListItem {
  id: string;
  title: string;
  subtitle?: string;
  status?: string;
  url: string;
  metadata?: Record<string, unknown>;
}
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>Widget data DTOs with typed responses for all widget types</done>
</task>

<task type="auto">
  <name>Task 3: Implement WidgetDataService</name>
  <files>apps/backend/src/modules/analytics/dashboard/widget-data.service.ts</files>
  <action>
Create WidgetDataService with data fetchers:

```typescript
@Injectable()
export class WidgetDataService {
  private readonly CACHE_TTL_SECONDS = {
    KPI_CARD: 60,
    LINE_CHART: 300,
    BAR_CHART: 300,
    TABLE: 120,
    default: 300,
  };

  constructor(
    private prisma: PrismaService,
    @Inject(CACHE_MANAGER) private cacheManager: Cache,
  ) {}

  async getWidgetData(
    orgId: string,
    userId: string,
    widget: DashboardWidget,
    dateRange: DateRange,
    forceRefresh = false,
  ): Promise<WidgetDataResponse> {
    const cacheKey = `widget:${orgId}:${widget.id}:${JSON.stringify(dateRange)}`;

    if (!forceRefresh) {
      const cached = await this.cacheManager.get<WidgetDataResponse>(cacheKey);
      if (cached) return cached;
    }

    const data = await this.fetchWidgetData(orgId, userId, widget, dateRange);
    const response: WidgetDataResponse = {
      widgetId: widget.id,
      data,
      updatedAt: new Date(),
      nextRefreshAt: new Date(Date.now() + this.getTtl(widget.widgetType) * 1000),
    };

    await this.cacheManager.set(cacheKey, response, this.getTtl(widget.widgetType));
    return response;
  }

  async getBatchWidgetData(
    orgId: string,
    userId: string,
    widgets: DashboardWidget[],
    dateRange: DateRange,
  ): Promise<WidgetDataResponse[]> {
    // Parallel fetch for performance
    return Promise.all(
      widgets.map(w => this.getWidgetData(orgId, userId, w, dateRange))
    );
  }

  private async fetchWidgetData(
    orgId: string,
    userId: string,
    widget: DashboardWidget,
    dateRange: DateRange,
  ): Promise<WidgetData> {
    const { dataSource, queryConfig } = widget;

    switch (dataSource) {
      case 'cases':
        return this.fetchCaseData(orgId, userId, queryConfig as WidgetQueryConfig, dateRange);
      case 'rius':
        return this.fetchRiuData(orgId, queryConfig as WidgetQueryConfig, dateRange);
      case 'campaigns':
        return this.fetchCampaignData(orgId, queryConfig as WidgetQueryConfig, dateRange);
      case 'disclosures':
        return this.fetchDisclosureData(orgId, queryConfig as WidgetQueryConfig, dateRange);
      case 'compliance_health':
        return this.computeComplianceHealth(orgId, dateRange);
      case 'my_cases':
        return this.fetchMyCases(orgId, userId, queryConfig as WidgetQueryConfig, dateRange);
      default:
        throw new BadRequestException(`Unknown data source: ${dataSource}`);
    }
  }

  // Data fetchers
  private async fetchCaseData(orgId, userId, config, dateRange): Promise<ChartData | TableData>
  private async fetchRiuData(orgId, config, dateRange): Promise<ChartData>
  private async fetchCampaignData(orgId, config, dateRange): Promise<ChartData | TableData>
  private async fetchDisclosureData(orgId, config, dateRange): Promise<ChartData>
  private async computeComplianceHealth(orgId, dateRange): Promise<KpiData>
  private async fetchMyCases(orgId, userId, config, dateRange): Promise<TableData>

  private getTtl(widgetType: WidgetType): number {
    return this.CACHE_TTL_SECONDS[widgetType] || this.CACHE_TTL_SECONDS.default;
  }
}
```

Data fetcher implementation patterns:
- Use Prisma groupBy for aggregations
- Apply dateRange filter to createdAt/closedAt
- Transform results to ChartData/TableData format
- Handle "assignedToMe" filter by checking userId
  </action>
  <verify>npm run lint passes for the service file</verify>
  <done>WidgetDataService fetches data for all widget types with caching</done>
</task>

</tasks>

<verification>
```bash
cd apps/backend
npm run lint -- --fix
npm run typecheck
```
</verification>

<success_criteria>
- Pre-built widgets defined for CCO, Investigator, Campaign Manager dashboards
- WidgetDataService fetches data for cases, RIUs, campaigns, disclosures
- Widget data cached with configurable TTL per widget type
- Batch widget data fetching for dashboard performance
- Response types match frontend chart library expectations (Recharts)
</success_criteria>

<output>
After completion, create `.planning/phases/11-analytics-reporting/11-05-SUMMARY.md`
</output>
