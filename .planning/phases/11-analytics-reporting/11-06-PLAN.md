---
phase: 11-analytics-reporting
plan: 06
type: execute
wave: 2
depends_on: ["11-03"]
files_modified:
  - apps/backend/src/modules/analytics/exports/pdf-generator.service.ts
  - apps/backend/src/modules/analytics/exports/pptx-generator.service.ts
  - apps/backend/src/modules/analytics/exports/board-report.service.ts
autonomous: true

must_haves:
  truths:
    - "PDF reports can be generated from HTML templates using Puppeteer"
    - "PowerPoint presentations can be generated for board reports"
    - "Board reports include AI-generated executive summaries"
  artifacts:
    - path: "apps/backend/src/modules/analytics/exports/pdf-generator.service.ts"
      provides: "Puppeteer-based PDF generation"
      min_lines: 100
    - path: "apps/backend/src/modules/analytics/exports/pptx-generator.service.ts"
      provides: "pptxgenjs-based PPTX generation"
      min_lines: 100
  key_links:
    - from: "board-report.service.ts"
      to: "ai.service"
      via: "executive summary generation"
      pattern: "aiService\\.generate"
---

<objective>
Build PDF and PowerPoint export services for board reports.

Purpose: Enable compliance officers to generate professional board reports with charts and AI summaries (ANAL-04, ANAL-06).
Output: PdfGeneratorService, PptxGeneratorService, and BoardReportService
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/11-analytics-reporting/11-CONTEXT.md
@.planning/phases/11-analytics-reporting/11-RESEARCH.md
@.planning/phases/11-analytics-reporting/11-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PdfGeneratorService with Puppeteer</name>
  <files>apps/backend/src/modules/analytics/exports/pdf-generator.service.ts</files>
  <action>
Create PdfGeneratorService using Puppeteer:

```typescript
import puppeteer, { Browser, Page, PDFOptions } from 'puppeteer';
import { Injectable, OnModuleInit, OnModuleDestroy, Logger } from '@nestjs/common';

@Injectable()
export class PdfGeneratorService implements OnModuleInit, OnModuleDestroy {
  private readonly logger = new Logger(PdfGeneratorService.name);
  private browser: Browser | null = null;
  private readonly MAX_CONCURRENT_PAGES = 3;
  private activePagesCount = 0;

  async onModuleInit() {
    try {
      this.browser = await puppeteer.launch({
        headless: true,
        args: [
          '--disable-dev-shm-usage',
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-gpu',
        ],
      });
      this.logger.log('Puppeteer browser initialized');
    } catch (error) {
      this.logger.error('Failed to initialize Puppeteer browser', error);
      // Allow service to start without browser for non-PDF functionality
    }
  }

  async onModuleDestroy() {
    if (this.browser) {
      await this.browser.close();
      this.logger.log('Puppeteer browser closed');
    }
  }

  async generatePdf(html: string, options?: PdfGenerationOptions): Promise<Buffer> {
    if (!this.browser) {
      throw new Error('PDF generation not available: Puppeteer not initialized');
    }

    // Wait for available slot
    while (this.activePagesCount >= this.MAX_CONCURRENT_PAGES) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    this.activePagesCount++;
    const page = await this.browser.newPage();

    try {
      // Set viewport for consistent rendering
      await page.setViewport({ width: 1200, height: 800 });

      // Set content with base styles
      await page.setContent(this.wrapWithStyles(html, options?.theme), {
        waitUntil: 'networkidle0',
      });

      // Wait for charts to render (Recharts)
      await page.waitForFunction(() => {
        const charts = document.querySelectorAll('.recharts-wrapper');
        return charts.length === 0 ||
          Array.from(charts).every(c => c.querySelector('svg'));
      }, { timeout: 10000 });

      // Generate PDF
      const pdfOptions: PDFOptions = {
        format: options?.format || 'A4',
        landscape: options?.landscape || false,
        margin: options?.margin || {
          top: '0.75in',
          right: '0.5in',
          bottom: '0.75in',
          left: '0.5in',
        },
        printBackground: true,
        displayHeaderFooter: options?.showPageNumbers ?? true,
        headerTemplate: options?.headerHtml || '<span></span>',
        footerTemplate: `
          <div style="width: 100%; font-size: 9px; color: #666; padding: 0 20px; display: flex; justify-content: space-between;">
            <span>${options?.footerText || 'Confidential'}</span>
            <span>Page <span class="pageNumber"></span> of <span class="totalPages"></span></span>
          </div>
        `,
      };

      const pdfBuffer = await page.pdf(pdfOptions);
      return Buffer.from(pdfBuffer);

    } finally {
      await page.close();
      this.activePagesCount--;
    }
  }

  private wrapWithStyles(html: string, theme?: 'light' | 'dark'): string {
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <style>
          @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
          body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 20px;
            color: ${theme === 'dark' ? '#fff' : '#1a1a1a'};
            background: ${theme === 'dark' ? '#1a1a1a' : '#fff'};
          }
          .page-break { page-break-after: always; }
          table { border-collapse: collapse; width: 100%; }
          th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
          th { background: #f5f5f5; font-weight: 600; }
        </style>
      </head>
      <body>${html}</body>
      </html>
    `;
  }
}

export interface PdfGenerationOptions {
  format?: 'A4' | 'Letter' | 'Legal';
  landscape?: boolean;
  margin?: { top: string; right: string; bottom: string; left: string };
  showPageNumbers?: boolean;
  headerHtml?: string;
  footerText?: string;
  theme?: 'light' | 'dark';
}
```

Key implementation details:
- Single browser instance, reused across requests
- Max concurrent pages limit (3) to prevent memory issues
- Wait for Recharts SVGs to render before PDF generation
- Configurable page format, margins, headers/footers
  </action>
  <verify>npm run lint passes for the service file</verify>
  <done>PdfGeneratorService generates PDFs with Puppeteer, handles charts, manages browser lifecycle</done>
</task>

<task type="auto">
  <name>Task 2: Implement PptxGeneratorService</name>
  <files>apps/backend/src/modules/analytics/exports/pptx-generator.service.ts</files>
  <action>
Create PptxGeneratorService using pptxgenjs:

```typescript
import PptxGenJS from 'pptxgenjs';
import { Injectable, Logger } from '@nestjs/common';

@Injectable()
export class PptxGeneratorService {
  private readonly logger = new Logger(PptxGeneratorService.name);

  async generatePresentation(data: BoardReportData): Promise<Buffer> {
    const pptx = new PptxGenJS();

    pptx.author = 'Ethico Risk Intelligence Platform';
    pptx.title = data.title;
    pptx.subject = 'Board Report';
    pptx.layout = 'LAYOUT_16x9';

    // Define master slide
    pptx.defineSlideMaster({
      title: 'ETHICO_MASTER',
      background: { color: 'FFFFFF' },
      objects: [
        { rect: { x: 0, y: 0, w: '100%', h: 0.5, fill: { color: '0F172A' } } },
        { text: { text: 'Ethico', options: { x: 0.3, y: 0.1, color: 'FFFFFF', fontSize: 14, bold: true } } },
      ],
    });

    // Title slide
    this.addTitleSlide(pptx, data);

    // Executive Summary slide (AI-generated)
    if (data.executiveSummary) {
      this.addExecutiveSummarySlide(pptx, data.executiveSummary);
    }

    // KPIs slide
    if (data.kpis?.length) {
      this.addKpisSlide(pptx, data.kpis);
    }

    // Trend charts slide
    if (data.trends?.length) {
      this.addTrendChartsSlide(pptx, data.trends);
    }

    // Case breakdown slide
    if (data.caseBreakdown) {
      this.addCaseBreakdownSlide(pptx, data.caseBreakdown);
    }

    // Generate buffer
    const buffer = await pptx.write({ outputType: 'nodebuffer' });
    return buffer as Buffer;
  }

  private addTitleSlide(pptx: PptxGenJS, data: BoardReportData): void {
    const slide = pptx.addSlide({ masterName: 'ETHICO_MASTER' });

    slide.addText(data.title, {
      x: 0.5, y: 2, w: '90%',
      fontSize: 36, bold: true, color: '0F172A',
    });

    slide.addText(data.period, {
      x: 0.5, y: 3, w: '90%',
      fontSize: 18, color: '64748B',
    });

    slide.addText(`Generated: ${new Date().toLocaleDateString()}`, {
      x: 0.5, y: 4.5, w: '90%',
      fontSize: 12, color: '94A3B8',
    });
  }

  private addExecutiveSummarySlide(pptx: PptxGenJS, summary: string): void {
    const slide = pptx.addSlide({ masterName: 'ETHICO_MASTER' });

    slide.addText('Executive Summary', {
      x: 0.5, y: 0.7, fontSize: 24, bold: true, color: '0F172A',
    });

    slide.addText(summary, {
      x: 0.5, y: 1.3, w: 9, h: 4,
      fontSize: 14, color: '334155', valign: 'top',
      bullet: { type: 'bullet' },
    });
  }

  private addKpisSlide(pptx: PptxGenJS, kpis: KpiItem[]): void {
    const slide = pptx.addSlide({ masterName: 'ETHICO_MASTER' });

    slide.addText('Key Metrics', {
      x: 0.5, y: 0.7, fontSize: 24, bold: true, color: '0F172A',
    });

    kpis.forEach((kpi, i) => {
      const col = i % 3;
      const row = Math.floor(i / 3);
      const x = 0.5 + col * 3.2;
      const y = 1.5 + row * 2;

      slide.addText(kpi.label, {
        x, y, fontSize: 12, color: '64748B',
      });
      slide.addText(String(kpi.value), {
        x, y: y + 0.4, fontSize: 32, bold: true, color: '0F172A',
      });
      if (kpi.trend) {
        const trendColor = kpi.trend.direction === 'up' ? '22C55E' : kpi.trend.direction === 'down' ? 'EF4444' : '64748B';
        slide.addText(`${kpi.trend.direction === 'up' ? '+' : ''}${kpi.trend.value}%`, {
          x, y: y + 0.9, fontSize: 14, color: trendColor,
        });
      }
    });
  }

  private addTrendChartsSlide(pptx: PptxGenJS, trends: TrendData[]): void {
    const slide = pptx.addSlide({ masterName: 'ETHICO_MASTER' });

    slide.addText('Trends', {
      x: 0.5, y: 0.7, fontSize: 24, bold: true, color: '0F172A',
    });

    // Add line chart
    const chartData = trends.map(t => ({
      name: t.name,
      labels: t.labels,
      values: t.values,
    }));

    slide.addChart(pptx.ChartType.line, chartData, {
      x: 0.5, y: 1.3, w: 9, h: 4,
      showLegend: true, legendPos: 'b',
      lineDataSymbol: 'circle',
      lineSmooth: true,
    });
  }

  private addCaseBreakdownSlide(pptx: PptxGenJS, breakdown: CaseBreakdown): void {
    // Pie chart for category distribution
    // Bar chart for status distribution
  }
}

export interface BoardReportData {
  title: string;
  period: string;
  executiveSummary?: string;
  kpis?: KpiItem[];
  trends?: TrendData[];
  caseBreakdown?: CaseBreakdown;
}

export interface KpiItem {
  label: string;
  value: number | string;
  trend?: { value: number; direction: 'up' | 'down' | 'flat' };
}

export interface TrendData {
  name: string;
  labels: string[];
  values: number[];
}
```
  </action>
  <verify>npm run lint passes for the service file</verify>
  <done>PptxGeneratorService generates PowerPoint presentations with slides for KPIs, trends, and breakdown charts</done>
</task>

<task type="auto">
  <name>Task 3: Implement BoardReportService</name>
  <files>apps/backend/src/modules/analytics/exports/board-report.service.ts</files>
  <action>
Create BoardReportService that orchestrates report generation:

```typescript
@Injectable()
export class BoardReportService {
  constructor(
    private prisma: PrismaService,
    private pdfGenerator: PdfGeneratorService,
    private pptxGenerator: PptxGeneratorService,
    private aiService: AiService,
    private widgetDataService: WidgetDataService,
    private storage: StorageService,
  ) {}

  async generateBoardReport(
    orgId: string,
    userId: string,
    config: BoardReportConfig,
  ): Promise<{ pdfUrl: string; pptxUrl?: string }> {
    // 1. Gather data
    const reportData = await this.gatherReportData(orgId, config);

    // 2. Generate AI executive summary
    const executiveSummary = await this.generateExecutiveSummary(orgId, reportData);

    // 3. Render HTML template
    const html = await this.renderBoardReportHtml({
      ...reportData,
      executiveSummary,
      title: config.title || 'Compliance Board Report',
      period: `${formatDate(config.dateRange.start)} - ${formatDate(config.dateRange.end)}`,
    });

    // 4. Generate PDF
    const pdfBuffer = await this.pdfGenerator.generatePdf(html, {
      format: 'Letter',
      landscape: false,
      footerText: 'Confidential - Board Report',
    });

    // 5. Upload PDF
    const pdfKey = `reports/${orgId}/board-report-${Date.now()}.pdf`;
    const pdfUrl = await this.storage.upload(pdfKey, pdfBuffer, 'application/pdf');

    // 6. Optionally generate PPTX
    let pptxUrl: string | undefined;
    if (config.includePptx) {
      const pptxData: BoardReportData = {
        title: config.title || 'Compliance Board Report',
        period: `${formatDate(config.dateRange.start)} - ${formatDate(config.dateRange.end)}`,
        executiveSummary,
        kpis: reportData.kpis,
        trends: reportData.trends,
        caseBreakdown: reportData.caseBreakdown,
      };

      const pptxBuffer = await this.pptxGenerator.generatePresentation(pptxData);
      const pptxKey = `reports/${orgId}/board-report-${Date.now()}.pptx`;
      pptxUrl = await this.storage.upload(pptxKey, pptxBuffer, 'application/vnd.openxmlformats-officedocument.presentationml.presentation');
    }

    // 7. Log to audit
    await this.auditService.log({
      entityType: 'REPORT',
      entityId: pdfKey,
      action: 'generated',
      actionDescription: `Board report generated for ${config.dateRange.start} to ${config.dateRange.end}`,
      organizationId: orgId,
      actorUserId: userId,
    });

    return { pdfUrl, pptxUrl };
  }

  private async gatherReportData(orgId: string, config: BoardReportConfig): Promise<ReportData> {
    const dateRange = config.dateRange;

    // Parallel data fetching
    const [
      caseCounts,
      categoryBreakdown,
      statusBreakdown,
      trends,
      slaMetrics,
      campaignMetrics,
    ] = await Promise.all([
      this.getCaseCounts(orgId, dateRange),
      this.getCategoryBreakdown(orgId, dateRange),
      this.getStatusBreakdown(orgId, dateRange),
      this.getTrends(orgId, dateRange),
      this.getSlaMetrics(orgId, dateRange),
      this.getCampaignMetrics(orgId, dateRange),
    ]);

    return {
      kpis: [
        { label: 'Total Cases', value: caseCounts.total, trend: caseCounts.trend },
        { label: 'Open Cases', value: caseCounts.open },
        { label: 'Avg Days to Close', value: caseCounts.avgDaysToClose },
        { label: 'SLA Compliance', value: `${slaMetrics.compliance}%`, trend: slaMetrics.trend },
        { label: 'Campaign Completion', value: `${campaignMetrics.completion}%` },
        { label: 'Substantiation Rate', value: `${caseCounts.substantiationRate}%` },
      ],
      trends: [
        { name: 'Cases Opened', labels: trends.labels, values: trends.casesOpened },
        { name: 'Cases Closed', labels: trends.labels, values: trends.casesClosed },
      ],
      caseBreakdown: { byCategory: categoryBreakdown, byStatus: statusBreakdown },
    };
  }

  private async generateExecutiveSummary(orgId: string, data: ReportData): Promise<string> {
    const prompt = `Generate a concise executive summary (3-4 bullet points) for a compliance board report...`;
    return this.aiService.generateText(orgId, prompt, { maxTokens: 500 });
  }

  private async renderBoardReportHtml(data: FullReportData): Promise<string> {
    // Use Handlebars template for HTML rendering
  }
}
```
  </action>
  <verify>npm run lint && npm run typecheck passes</verify>
  <done>BoardReportService orchestrates data gathering, AI summary, PDF and PPTX generation</done>
</task>

</tasks>

<verification>
```bash
cd apps/backend
npm run lint -- --fix
npm run typecheck
```
</verification>

<success_criteria>
- PdfGeneratorService generates PDFs with Puppeteer, handles chart rendering
- PptxGeneratorService creates professional PowerPoint presentations
- BoardReportService orchestrates full report generation workflow
- AI-generated executive summaries included in reports
- Both PDF and PPTX formats supported for board reports
</success_criteria>

<output>
After completion, create `.planning/phases/11-analytics-reporting/11-06-SUMMARY.md`
</output>
