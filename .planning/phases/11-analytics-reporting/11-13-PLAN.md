---
phase: 11-analytics-reporting
plan: 13
type: execute
wave: 4
depends_on: ["11-01", "11-02"]
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/projects/project.service.ts
  - apps/backend/src/modules/projects/milestone.service.ts
  - apps/backend/src/modules/projects/dto/milestone.dto.ts
autonomous: true

must_haves:
  truths:
    - "Project milestones track key deliverables with target dates"
    - "Milestones can be linked to cases, investigations, and campaigns"
    - "Progress tracking shows percentage complete based on linked items"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "Milestone and MilestoneItem models"
      contains: "model Milestone"
    - path: "apps/backend/src/modules/projects/milestone.service.ts"
      provides: "Milestone management service"
      min_lines: 120
  key_links:
    - from: "milestone.service.ts"
      to: "prisma.milestone"
      via: "milestone tracking"
      pattern: "prisma\\.milestone"
---

<objective>
Build project milestone infrastructure for tracking key compliance deliverables.

Purpose: Enable compliance officers to track project milestones with linked items (PROJ-04).
Output: Milestone, MilestoneItem models and MilestoneService
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/11-analytics-reporting/11-CONTEXT.md
@.planning/phases/11-analytics-reporting/11-01-SUMMARY.md
@.planning/phases/11-analytics-reporting/11-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Milestone Prisma models</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
Add milestone tracking models:

```prisma
// Project milestone tracking
model Milestone {
  id              String   @id @default(uuid())
  organizationId  String
  organization    Organization @relation(fields: [organizationId], references: [id])

  // Basic info
  name            String
  description     String?
  category        MilestoneCategory   // AUDIT, INVESTIGATION, CAMPAIGN, PROJECT, TRAINING, OTHER

  // Timeline
  targetDate      DateTime
  completedAt     DateTime?
  status          MilestoneStatus     // NOT_STARTED, IN_PROGRESS, AT_RISK, COMPLETED, CANCELLED

  // Progress (calculated from linked items)
  totalItems      Int @default(0)
  completedItems  Int @default(0)
  progressPercent Int @default(0)     // 0-100

  // Owner
  ownerId         String?
  owner           User? @relation(fields: [ownerId], references: [id])

  // Linked items
  items           MilestoneItem[]

  // Notes and updates
  notes           String?
  lastStatusUpdate String?

  // Metadata
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  createdById     String
  createdBy       User @relation("MilestoneCreatedBy", fields: [createdById], references: [id])

  @@index([organizationId, status])
  @@index([organizationId, targetDate])
  @@index([ownerId])
}

enum MilestoneCategory {
  AUDIT
  INVESTIGATION
  CAMPAIGN
  PROJECT
  TRAINING
  REMEDIATION
  OTHER
}

enum MilestoneStatus {
  NOT_STARTED
  IN_PROGRESS
  AT_RISK         // Behind schedule
  COMPLETED
  CANCELLED
}

// Links milestones to other entities
model MilestoneItem {
  id              String   @id @default(uuid())
  milestoneId     String
  milestone       Milestone @relation(fields: [milestoneId], references: [id], onDelete: Cascade)

  // Linked entity (polymorphic)
  entityType      MilestoneItemType   // CASE, INVESTIGATION, CAMPAIGN, TASK, CUSTOM
  entityId        String?             // ID for CASE, INVESTIGATION, CAMPAIGN
  customTitle     String?             // For CUSTOM type

  // Status
  isCompleted     Boolean @default(false)
  completedAt     DateTime?
  dueDate         DateTime?

  // Weight (for progress calculation)
  weight          Int @default(1)     // Higher weight = more impact on progress

  // Ordering
  sortOrder       Int @default(0)

  // Metadata
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([milestoneId])
  @@index([entityType, entityId])
}

enum MilestoneItemType {
  CASE
  INVESTIGATION
  CAMPAIGN
  TASK
  CUSTOM          // Free-text item
}
```

Run `npx prisma format` and `npx prisma generate`.
  </action>
  <verify>npx prisma format && npx prisma generate succeeds</verify>
  <done>Milestone and MilestoneItem models added to schema</done>
</task>

<task type="auto">
  <name>Task 2: Create Milestone DTOs</name>
  <files>apps/backend/src/modules/projects/dto/milestone.dto.ts</files>
  <action>
Create DTOs:

```typescript
import { IsString, IsOptional, IsEnum, IsUUID, IsDate, IsInt, Min, Max, IsArray, ValidateNested, IsBoolean } from 'class-validator';
import { Type, Transform } from 'class-transformer';
import { MilestoneCategory, MilestoneStatus, MilestoneItemType } from '@prisma/client';

export class CreateMilestoneDto {
  @IsString()
  name: string;

  @IsOptional()
  @IsString()
  description?: string;

  @IsEnum(MilestoneCategory)
  category: MilestoneCategory;

  @Type(() => Date)
  @IsDate()
  targetDate: Date;

  @IsOptional()
  @IsUUID()
  ownerId?: string;

  @IsOptional()
  @IsString()
  notes?: string;

  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => CreateMilestoneItemDto)
  items?: CreateMilestoneItemDto[];
}

export class UpdateMilestoneDto {
  @IsOptional()
  @IsString()
  name?: string;

  @IsOptional()
  @IsString()
  description?: string;

  @IsOptional()
  @IsEnum(MilestoneCategory)
  category?: MilestoneCategory;

  @IsOptional()
  @Type(() => Date)
  @IsDate()
  targetDate?: Date;

  @IsOptional()
  @IsEnum(MilestoneStatus)
  status?: MilestoneStatus;

  @IsOptional()
  @IsUUID()
  ownerId?: string;

  @IsOptional()
  @IsString()
  notes?: string;

  @IsOptional()
  @IsString()
  lastStatusUpdate?: string;
}

export class CreateMilestoneItemDto {
  @IsEnum(MilestoneItemType)
  entityType: MilestoneItemType;

  @IsOptional()
  @IsUUID()
  entityId?: string;

  @IsOptional()
  @IsString()
  customTitle?: string;

  @IsOptional()
  @Type(() => Date)
  @IsDate()
  dueDate?: Date;

  @IsOptional()
  @IsInt()
  @Min(1)
  @Max(10)
  weight?: number;
}

export class UpdateMilestoneItemDto {
  @IsOptional()
  @IsBoolean()
  isCompleted?: boolean;

  @IsOptional()
  @Type(() => Date)
  @IsDate()
  dueDate?: Date;

  @IsOptional()
  @IsInt()
  @Min(1)
  @Max(10)
  weight?: number;

  @IsOptional()
  @IsString()
  customTitle?: string;
}

export class MilestoneQueryDto {
  @IsOptional()
  @IsEnum(MilestoneStatus)
  status?: MilestoneStatus;

  @IsOptional()
  @IsEnum(MilestoneCategory)
  category?: MilestoneCategory;

  @IsOptional()
  @IsUUID()
  ownerId?: string;

  @IsOptional()
  @Type(() => Date)
  @IsDate()
  targetDateFrom?: Date;

  @IsOptional()
  @Type(() => Date)
  @IsDate()
  targetDateTo?: Date;

  @IsOptional()
  @Transform(({ value }) => parseInt(value, 10))
  @IsInt()
  @Min(0)
  offset?: number = 0;

  @IsOptional()
  @Transform(({ value }) => parseInt(value, 10))
  @IsInt()
  @Min(1)
  @Max(100)
  limit?: number = 20;
}

export class MilestoneResponseDto {
  id: string;
  name: string;
  description?: string;
  category: MilestoneCategory;
  targetDate: Date;
  completedAt?: Date;
  status: MilestoneStatus;
  totalItems: number;
  completedItems: number;
  progressPercent: number;
  owner?: {
    id: string;
    name: string;
  };
  items: MilestoneItemResponseDto[];
  notes?: string;
  lastStatusUpdate?: string;
  daysUntilTarget: number;
  isOverdue: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export class MilestoneItemResponseDto {
  id: string;
  entityType: MilestoneItemType;
  entityId?: string;
  customTitle?: string;
  isCompleted: boolean;
  completedAt?: Date;
  dueDate?: Date;
  weight: number;
  // Resolved entity info (for linked items)
  resolvedEntity?: {
    title: string;
    status: string;
    url: string;
  };
}
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>Milestone DTOs with validation created</done>
</task>

<task type="auto">
  <name>Task 3: Implement MilestoneService</name>
  <files>apps/backend/src/modules/projects/milestone.service.ts</files>
  <action>
Create MilestoneService:

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../../common/prisma/prisma.service';
import { AuditService } from '../audit/audit.service';
import { Milestone, MilestoneStatus, MilestoneItem, Prisma } from '@prisma/client';
import { differenceInDays, isPast } from 'date-fns';
import {
  CreateMilestoneDto,
  UpdateMilestoneDto,
  CreateMilestoneItemDto,
  UpdateMilestoneItemDto,
  MilestoneQueryDto,
  MilestoneResponseDto,
} from './dto/milestone.dto';
import { PaginatedResult } from '../../common/types';

@Injectable()
export class MilestoneService {
  constructor(
    private prisma: PrismaService,
    private auditService: AuditService,
  ) {}

  // ==================== CRUD ====================

  async create(
    orgId: string,
    userId: string,
    dto: CreateMilestoneDto,
  ): Promise<Milestone> {
    const milestone = await this.prisma.milestone.create({
      data: {
        organizationId: orgId,
        name: dto.name,
        description: dto.description,
        category: dto.category,
        targetDate: dto.targetDate,
        status: 'NOT_STARTED',
        ownerId: dto.ownerId,
        notes: dto.notes,
        createdById: userId,
        items: dto.items ? {
          create: dto.items.map((item, index) => ({
            entityType: item.entityType,
            entityId: item.entityId,
            customTitle: item.customTitle,
            dueDate: item.dueDate,
            weight: item.weight || 1,
            sortOrder: index,
          })),
        } : undefined,
      },
      include: { items: true },
    });

    // Calculate initial progress
    await this.recalculateProgress(milestone.id);

    await this.auditService.log({
      entityType: 'MILESTONE',
      entityId: milestone.id,
      action: 'created',
      actionDescription: `Milestone "${dto.name}" created with target date ${dto.targetDate.toISOString().split('T')[0]}`,
      organizationId: orgId,
      actorUserId: userId,
    });

    return milestone;
  }

  async update(
    orgId: string,
    milestoneId: string,
    dto: UpdateMilestoneDto,
  ): Promise<Milestone> {
    const existing = await this.prisma.milestone.findFirst({
      where: { id: milestoneId, organizationId: orgId },
    });

    if (!existing) {
      throw new NotFoundException('Milestone not found');
    }

    // Auto-complete if status changed to COMPLETED
    const completedAt = dto.status === 'COMPLETED' && existing.status !== 'COMPLETED'
      ? new Date()
      : existing.completedAt;

    return this.prisma.milestone.update({
      where: { id: milestoneId },
      data: {
        ...dto,
        completedAt,
      },
      include: { items: true, owner: { select: { id: true, name: true } } },
    });
  }

  async delete(orgId: string, milestoneId: string): Promise<void> {
    await this.prisma.milestone.deleteMany({
      where: { id: milestoneId, organizationId: orgId },
    });
  }

  async get(orgId: string, milestoneId: string): Promise<MilestoneResponseDto | null> {
    const milestone = await this.prisma.milestone.findFirst({
      where: { id: milestoneId, organizationId: orgId },
      include: {
        items: { orderBy: { sortOrder: 'asc' } },
        owner: { select: { id: true, name: true } },
      },
    });

    if (!milestone) return null;

    return this.toResponseDto(milestone);
  }

  async list(
    orgId: string,
    query: MilestoneQueryDto,
  ): Promise<PaginatedResult<MilestoneResponseDto>> {
    const where: Prisma.MilestoneWhereInput = {
      organizationId: orgId,
      ...(query.status && { status: query.status }),
      ...(query.category && { category: query.category }),
      ...(query.ownerId && { ownerId: query.ownerId }),
      ...(query.targetDateFrom || query.targetDateTo) && {
        targetDate: {
          ...(query.targetDateFrom && { gte: query.targetDateFrom }),
          ...(query.targetDateTo && { lte: query.targetDateTo }),
        },
      },
    };

    const [milestones, total] = await Promise.all([
      this.prisma.milestone.findMany({
        where,
        skip: query.offset,
        take: query.limit,
        orderBy: { targetDate: 'asc' },
        include: {
          items: { orderBy: { sortOrder: 'asc' } },
          owner: { select: { id: true, name: true } },
        },
      }),
      this.prisma.milestone.count({ where }),
    ]);

    const items = milestones.map(m => this.toResponseDto(m));

    return { items, total, offset: query.offset || 0, limit: query.limit || 20 };
  }

  // ==================== Milestone Items ====================

  async addItem(
    orgId: string,
    milestoneId: string,
    dto: CreateMilestoneItemDto,
  ): Promise<MilestoneItem> {
    // Verify milestone belongs to org
    const milestone = await this.prisma.milestone.findFirst({
      where: { id: milestoneId, organizationId: orgId },
      include: { items: true },
    });

    if (!milestone) {
      throw new NotFoundException('Milestone not found');
    }

    const maxSort = Math.max(...milestone.items.map(i => i.sortOrder), -1);

    const item = await this.prisma.milestoneItem.create({
      data: {
        milestoneId,
        entityType: dto.entityType,
        entityId: dto.entityId,
        customTitle: dto.customTitle,
        dueDate: dto.dueDate,
        weight: dto.weight || 1,
        sortOrder: maxSort + 1,
      },
    });

    await this.recalculateProgress(milestoneId);

    return item;
  }

  async updateItem(
    orgId: string,
    itemId: string,
    dto: UpdateMilestoneItemDto,
  ): Promise<MilestoneItem> {
    // Verify item belongs to org's milestone
    const item = await this.prisma.milestoneItem.findFirst({
      where: { id: itemId },
      include: { milestone: true },
    });

    if (!item || item.milestone.organizationId !== orgId) {
      throw new NotFoundException('Milestone item not found');
    }

    const completedAt = dto.isCompleted && !item.isCompleted
      ? new Date()
      : item.isCompleted && dto.isCompleted === false
        ? null
        : item.completedAt;

    const updated = await this.prisma.milestoneItem.update({
      where: { id: itemId },
      data: {
        ...dto,
        completedAt,
      },
    });

    await this.recalculateProgress(item.milestoneId);

    return updated;
  }

  async removeItem(orgId: string, itemId: string): Promise<void> {
    const item = await this.prisma.milestoneItem.findFirst({
      where: { id: itemId },
      include: { milestone: true },
    });

    if (!item || item.milestone.organizationId !== orgId) {
      throw new NotFoundException('Milestone item not found');
    }

    await this.prisma.milestoneItem.delete({ where: { id: itemId } });
    await this.recalculateProgress(item.milestoneId);
  }

  // ==================== Progress Calculation ====================

  async recalculateProgress(milestoneId: string): Promise<void> {
    const items = await this.prisma.milestoneItem.findMany({
      where: { milestoneId },
    });

    const totalWeight = items.reduce((sum, item) => sum + item.weight, 0);
    const completedWeight = items
      .filter(item => item.isCompleted)
      .reduce((sum, item) => sum + item.weight, 0);

    const progressPercent = totalWeight > 0
      ? Math.round((completedWeight / totalWeight) * 100)
      : 0;

    const milestone = await this.prisma.milestone.findUnique({
      where: { id: milestoneId },
    });

    // Determine status based on progress and target date
    let status = milestone?.status || 'NOT_STARTED';
    if (progressPercent === 100) {
      status = 'COMPLETED';
    } else if (progressPercent > 0) {
      status = milestone?.targetDate && isPast(milestone.targetDate) ? 'AT_RISK' : 'IN_PROGRESS';
    }

    await this.prisma.milestone.update({
      where: { id: milestoneId },
      data: {
        totalItems: items.length,
        completedItems: items.filter(i => i.isCompleted).length,
        progressPercent,
        status: status as MilestoneStatus,
        completedAt: progressPercent === 100 ? new Date() : null,
      },
    });
  }

  // ==================== Helper Methods ====================

  private toResponseDto(milestone: any): MilestoneResponseDto {
    const daysUntilTarget = differenceInDays(milestone.targetDate, new Date());
    const isOverdue = isPast(milestone.targetDate) && milestone.status !== 'COMPLETED';

    return {
      id: milestone.id,
      name: milestone.name,
      description: milestone.description,
      category: milestone.category,
      targetDate: milestone.targetDate,
      completedAt: milestone.completedAt,
      status: milestone.status,
      totalItems: milestone.totalItems,
      completedItems: milestone.completedItems,
      progressPercent: milestone.progressPercent,
      owner: milestone.owner,
      items: milestone.items?.map((item: any) => ({
        id: item.id,
        entityType: item.entityType,
        entityId: item.entityId,
        customTitle: item.customTitle,
        isCompleted: item.isCompleted,
        completedAt: item.completedAt,
        dueDate: item.dueDate,
        weight: item.weight,
      })) || [],
      notes: milestone.notes,
      lastStatusUpdate: milestone.lastStatusUpdate,
      daysUntilTarget,
      isOverdue,
      createdAt: milestone.createdAt,
      updatedAt: milestone.updatedAt,
    };
  }

  // Link entity completion to milestone items
  async syncEntityCompletion(entityType: string, entityId: string, isCompleted: boolean): Promise<void> {
    const items = await this.prisma.milestoneItem.findMany({
      where: { entityType: entityType as any, entityId },
    });

    for (const item of items) {
      if (item.isCompleted !== isCompleted) {
        await this.prisma.milestoneItem.update({
          where: { id: item.id },
          data: {
            isCompleted,
            completedAt: isCompleted ? new Date() : null,
          },
        });
        await this.recalculateProgress(item.milestoneId);
      }
    }
  }
}
```
  </action>
  <verify>npm run lint passes for the service file</verify>
  <done>MilestoneService implements full milestone lifecycle with progress calculation</done>
</task>

</tasks>

<verification>
```bash
cd apps/backend
npx prisma format
npx prisma generate
npm run lint -- --fix
npm run typecheck
```
</verification>

<success_criteria>
- Milestone and MilestoneItem models support all milestone types
- Progress calculation respects item weights
- Status auto-updates based on progress and target date
- Items can link to Cases, Investigations, Campaigns, or be custom text
- Entity completion syncs to linked milestone items
</success_criteria>

<output>
After completion, create `.planning/phases/11-analytics-reporting/11-13-SUMMARY.md`
</output>
