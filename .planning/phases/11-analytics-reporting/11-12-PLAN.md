---
phase: 11-analytics-reporting
plan: 12
type: execute
wave: 3
depends_on: ["11-06", "11-07"]
files_modified:
  - apps/backend/src/modules/analytics/exports/scheduled-export.service.ts
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/analytics/exports/processors/scheduled-export.processor.ts
autonomous: true

must_haves:
  truths:
    - "Reports can be scheduled for periodic delivery"
    - "Scheduled exports send via email to configured recipients"
    - "Schedules support daily, weekly, and monthly intervals"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "ScheduledExport model"
      contains: "model ScheduledExport"
    - path: "apps/backend/src/modules/analytics/exports/scheduled-export.service.ts"
      provides: "Scheduled export management"
      min_lines: 100
  key_links:
    - from: "scheduled-export.processor.ts"
      to: "flat-file.service"
      via: "export generation"
      pattern: "flatFileService\\."
---

<objective>
Build scheduled export delivery system for automated report distribution.

Purpose: Enable compliance officers to schedule recurring exports sent via email (ANAL-08).
Output: ScheduledExport model, ScheduledExportService, and ScheduledExportProcessor
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/11-analytics-reporting/11-CONTEXT.md
@.planning/phases/11-analytics-reporting/11-06-SUMMARY.md
@.planning/phases/11-analytics-reporting/11-07-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ScheduledExport Prisma model</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
Add scheduled export model:

```prisma
// Scheduled export configuration
model ScheduledExport {
  id              String   @id @default(uuid())
  organizationId  String
  organization    Organization @relation(fields: [organizationId], references: [id])

  // Export configuration
  name            String
  description     String?
  exportType      ExportType        // FLAT_FILE, CASES_ONLY, etc.
  format          ExportFormat      // CSV, XLSX, PDF
  filters         Json              // Query filters
  columnConfig    Json              // Column configuration

  // Schedule configuration
  scheduleType    ScheduleType      // DAILY, WEEKLY, MONTHLY
  scheduleConfig  Json              // Day of week, day of month, time
  timezone        String @default("America/New_York")

  // Delivery configuration
  deliveryMethod  DeliveryMethod    // EMAIL, STORAGE
  recipients      String[]          // Email addresses
  storageLocation String?           // Azure blob path if STORAGE

  // Status
  isActive        Boolean @default(true)
  lastRunAt       DateTime?
  lastRunStatus   ScheduleRunStatus?
  nextRunAt       DateTime?

  // Metadata
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  createdById     String
  createdBy       User @relation(fields: [createdById], references: [id])

  // History
  runs            ScheduledExportRun[]

  @@index([organizationId, isActive])
  @@index([nextRunAt])
}

enum ScheduleType {
  DAILY
  WEEKLY
  MONTHLY
}

enum DeliveryMethod {
  EMAIL
  STORAGE
}

enum ScheduleRunStatus {
  SUCCESS
  FAILED
  SKIPPED
}

// Execution history
model ScheduledExportRun {
  id                  String   @id @default(uuid())
  scheduledExportId   String
  scheduledExport     ScheduledExport @relation(fields: [scheduledExportId], references: [id], onDelete: Cascade)

  // Run details
  startedAt           DateTime @default(now())
  completedAt         DateTime?
  status              ScheduleRunStatus

  // Output
  fileUrl             String?
  fileSizeBytes       Int?
  rowCount            Int?

  // Delivery
  deliveredTo         String[]
  deliveryStatus      Json?     // Per-recipient status

  // Error tracking
  errorMessage        String?
  errorDetails        Json?

  @@index([scheduledExportId, startedAt])
}
```

Run `npx prisma format` and `npx prisma generate`.
  </action>
  <verify>npx prisma format && npx prisma generate succeeds</verify>
  <done>ScheduledExport and ScheduledExportRun models added to schema</done>
</task>

<task type="auto">
  <name>Task 2: Implement ScheduledExportService</name>
  <files>apps/backend/src/modules/analytics/exports/scheduled-export.service.ts</files>
  <action>
Create service for managing scheduled exports:

```typescript
@Injectable()
export class ScheduledExportService {
  constructor(
    private prisma: PrismaService,
    private auditService: AuditService,
  ) {}

  // ==================== CRUD ====================

  async createSchedule(
    orgId: string,
    userId: string,
    dto: CreateScheduledExportDto,
  ): Promise<ScheduledExport> {
    const nextRunAt = this.calculateNextRun(dto.scheduleType, dto.scheduleConfig, dto.timezone);

    const schedule = await this.prisma.scheduledExport.create({
      data: {
        organizationId: orgId,
        name: dto.name,
        description: dto.description,
        exportType: dto.exportType,
        format: dto.format,
        filters: dto.filters,
        columnConfig: dto.columnConfig,
        scheduleType: dto.scheduleType,
        scheduleConfig: dto.scheduleConfig,
        timezone: dto.timezone,
        deliveryMethod: dto.deliveryMethod,
        recipients: dto.recipients,
        storageLocation: dto.storageLocation,
        nextRunAt,
        createdById: userId,
      },
    });

    await this.auditService.log({
      entityType: 'SCHEDULED_EXPORT',
      entityId: schedule.id,
      action: 'created',
      actionDescription: `Scheduled export "${dto.name}" created with ${dto.scheduleType} schedule`,
      organizationId: orgId,
      actorUserId: userId,
    });

    return schedule;
  }

  async updateSchedule(
    orgId: string,
    scheduleId: string,
    dto: UpdateScheduledExportDto,
  ): Promise<ScheduledExport> {
    const existing = await this.prisma.scheduledExport.findFirst({
      where: { id: scheduleId, organizationId: orgId },
    });

    if (!existing) {
      throw new NotFoundException('Scheduled export not found');
    }

    const nextRunAt = dto.scheduleType || dto.scheduleConfig
      ? this.calculateNextRun(
          dto.scheduleType || existing.scheduleType,
          dto.scheduleConfig || existing.scheduleConfig as ScheduleConfig,
          dto.timezone || existing.timezone,
        )
      : existing.nextRunAt;

    return this.prisma.scheduledExport.update({
      where: { id: scheduleId },
      data: {
        ...dto,
        nextRunAt,
      },
    });
  }

  async deleteSchedule(orgId: string, scheduleId: string): Promise<void> {
    await this.prisma.scheduledExport.deleteMany({
      where: { id: scheduleId, organizationId: orgId },
    });
  }

  async getSchedule(orgId: string, scheduleId: string): Promise<ScheduledExport | null> {
    return this.prisma.scheduledExport.findFirst({
      where: { id: scheduleId, organizationId: orgId },
      include: {
        runs: {
          orderBy: { startedAt: 'desc' },
          take: 10,
        },
      },
    });
  }

  async listSchedules(
    orgId: string,
    query: { isActive?: boolean } & PaginationDto,
  ): Promise<PaginatedResult<ScheduledExport>> {
    const where = {
      organizationId: orgId,
      ...(query.isActive !== undefined && { isActive: query.isActive }),
    };

    const [items, total] = await Promise.all([
      this.prisma.scheduledExport.findMany({
        where,
        skip: query.offset,
        take: query.limit,
        orderBy: { createdAt: 'desc' },
      }),
      this.prisma.scheduledExport.count({ where }),
    ]);

    return { items, total, offset: query.offset, limit: query.limit };
  }

  // ==================== Status Management ====================

  async pauseSchedule(orgId: string, scheduleId: string): Promise<void> {
    await this.prisma.scheduledExport.updateMany({
      where: { id: scheduleId, organizationId: orgId },
      data: { isActive: false },
    });
  }

  async resumeSchedule(orgId: string, scheduleId: string): Promise<void> {
    const schedule = await this.getSchedule(orgId, scheduleId);
    if (!schedule) throw new NotFoundException('Schedule not found');

    const nextRunAt = this.calculateNextRun(
      schedule.scheduleType,
      schedule.scheduleConfig as ScheduleConfig,
      schedule.timezone,
    );

    await this.prisma.scheduledExport.updateMany({
      where: { id: scheduleId, organizationId: orgId },
      data: { isActive: true, nextRunAt },
    });
  }

  async runNow(orgId: string, scheduleId: string): Promise<string> {
    // Trigger immediate run via queue
    // Return run ID
    const run = await this.prisma.scheduledExportRun.create({
      data: {
        scheduledExportId: scheduleId,
        status: 'SUCCESS', // Will be updated by processor
      },
    });
    return run.id;
  }

  // ==================== Run History ====================

  async getRunHistory(
    orgId: string,
    scheduleId: string,
    query: PaginationDto,
  ): Promise<PaginatedResult<ScheduledExportRun>> {
    // Verify schedule belongs to org
    const schedule = await this.prisma.scheduledExport.findFirst({
      where: { id: scheduleId, organizationId: orgId },
    });

    if (!schedule) throw new NotFoundException('Schedule not found');

    const [items, total] = await Promise.all([
      this.prisma.scheduledExportRun.findMany({
        where: { scheduledExportId: scheduleId },
        skip: query.offset,
        take: query.limit,
        orderBy: { startedAt: 'desc' },
      }),
      this.prisma.scheduledExportRun.count({ where: { scheduledExportId: scheduleId } }),
    ]);

    return { items, total, offset: query.offset, limit: query.limit };
  }

  // ==================== Scheduling Logic ====================

  async getDueSchedules(): Promise<ScheduledExport[]> {
    return this.prisma.scheduledExport.findMany({
      where: {
        isActive: true,
        nextRunAt: { lte: new Date() },
      },
      include: {
        organization: true,
        createdBy: true,
      },
    });
  }

  async updateAfterRun(
    scheduleId: string,
    status: ScheduleRunStatus,
    runId: string,
  ): Promise<void> {
    const schedule = await this.prisma.scheduledExport.findUnique({
      where: { id: scheduleId },
    });

    if (!schedule) return;

    const nextRunAt = this.calculateNextRun(
      schedule.scheduleType,
      schedule.scheduleConfig as ScheduleConfig,
      schedule.timezone,
    );

    await this.prisma.scheduledExport.update({
      where: { id: scheduleId },
      data: {
        lastRunAt: new Date(),
        lastRunStatus: status,
        nextRunAt,
      },
    });
  }

  calculateNextRun(
    scheduleType: ScheduleType,
    config: ScheduleConfig,
    timezone: string,
  ): Date {
    const now = new Date();
    const tz = timezone || 'America/New_York';

    // Parse time from config (e.g., "08:00")
    const [hours, minutes] = (config.time || '08:00').split(':').map(Number);

    switch (scheduleType) {
      case 'DAILY': {
        let next = set(now, { hours, minutes, seconds: 0, milliseconds: 0 });
        if (next <= now) next = addDays(next, 1);
        return next;
      }

      case 'WEEKLY': {
        const dayOfWeek = config.dayOfWeek || 1; // Monday default
        let next = set(now, { hours, minutes, seconds: 0, milliseconds: 0 });
        next = setDay(next, dayOfWeek);
        if (next <= now) next = addWeeks(next, 1);
        return next;
      }

      case 'MONTHLY': {
        const dayOfMonth = config.dayOfMonth || 1;
        let next = set(now, { date: dayOfMonth, hours, minutes, seconds: 0, milliseconds: 0 });
        if (next <= now) next = addMonths(next, 1);
        return next;
      }

      default:
        return addDays(now, 1);
    }
  }
}

interface ScheduleConfig {
  time: string;           // "08:00"
  dayOfWeek?: number;     // 0-6 for weekly
  dayOfMonth?: number;    // 1-31 for monthly
}
```
  </action>
  <verify>npm run lint passes for the service file</verify>
  <done>ScheduledExportService manages schedule CRUD, status, and next-run calculation</done>
</task>

<task type="auto">
  <name>Task 3: Implement ScheduledExportProcessor</name>
  <files>apps/backend/src/modules/analytics/exports/processors/scheduled-export.processor.ts</files>
  <action>
Create cron-based processor for scheduled exports:

```typescript
@Injectable()
export class ScheduledExportProcessor {
  private readonly logger = new Logger(ScheduledExportProcessor.name);

  constructor(
    private scheduledExportService: ScheduledExportService,
    private flatFileService: FlatFileService,
    private boardReportService: BoardReportService,
    private excelExportService: ExcelExportService,
    private storage: StorageService,
    private emailService: EmailService,
    private prisma: PrismaService,
  ) {}

  /**
   * Check for due schedules every minute.
   */
  @Cron(CronExpression.EVERY_MINUTE)
  async processScheduledExports() {
    const dueSchedules = await this.scheduledExportService.getDueSchedules();

    if (dueSchedules.length === 0) return;

    this.logger.log(`Processing ${dueSchedules.length} due scheduled exports`);

    for (const schedule of dueSchedules) {
      await this.processSchedule(schedule);
    }
  }

  private async processSchedule(schedule: ScheduledExport): Promise<void> {
    const run = await this.prisma.scheduledExportRun.create({
      data: {
        scheduledExportId: schedule.id,
        status: 'SUCCESS', // Will update if fails
      },
    });

    try {
      this.logger.log(`Processing scheduled export: ${schedule.name} (${schedule.id})`);

      // Generate export
      const { fileBuffer, fileName, rowCount } = await this.generateExport(schedule);

      // Upload to storage
      const fileKey = `scheduled-exports/${schedule.organizationId}/${schedule.id}/${nanoid()}-${fileName}`;
      const fileUrl = await this.storage.upload(fileKey, fileBuffer, this.getMimeType(schedule.format));

      // Deliver
      const deliveryResults = await this.deliver(schedule, fileBuffer, fileName, fileUrl);

      // Update run record
      await this.prisma.scheduledExportRun.update({
        where: { id: run.id },
        data: {
          completedAt: new Date(),
          status: 'SUCCESS',
          fileUrl,
          fileSizeBytes: fileBuffer.length,
          rowCount,
          deliveredTo: schedule.recipients,
          deliveryStatus: deliveryResults,
        },
      });

      // Update schedule
      await this.scheduledExportService.updateAfterRun(schedule.id, 'SUCCESS', run.id);

      this.logger.log(`Completed scheduled export: ${schedule.name}`);

    } catch (error) {
      this.logger.error(`Failed scheduled export ${schedule.name}: ${error.message}`);

      await this.prisma.scheduledExportRun.update({
        where: { id: run.id },
        data: {
          completedAt: new Date(),
          status: 'FAILED',
          errorMessage: error.message,
          errorDetails: { stack: error.stack },
        },
      });

      await this.scheduledExportService.updateAfterRun(schedule.id, 'FAILED', run.id);
    }
  }

  private async generateExport(schedule: ScheduledExport): Promise<{
    fileBuffer: Buffer;
    fileName: string;
    rowCount: number;
  }> {
    const config = schedule.columnConfig as ColumnConfig;
    const filters = schedule.filters as Record<string, unknown>;
    const columns = await this.flatFileService.buildColumns(schedule.organizationId, config);

    // Create data stream
    const dataStream = this.flatFileService.createDataStream(
      schedule.organizationId,
      schedule.exportType,
      filters,
      columns,
    );

    let rowCount = 0;
    let fileBuffer: Buffer;

    switch (schedule.format) {
      case 'XLSX': {
        const rows: Record<string, unknown>[] = [];
        for await (const row of dataStream) {
          rows.push(row);
          rowCount++;
        }
        fileBuffer = await this.excelExportService.generateBuffer(rows, columns);
        break;
      }

      case 'CSV': {
        const rows: string[] = [];
        rows.push(columns.map(c => c.label).join(','));
        for await (const row of dataStream) {
          rows.push(columns.map(c => this.escapeCsv(row[c.field])).join(','));
          rowCount++;
        }
        fileBuffer = Buffer.from(rows.join('\n'), 'utf-8');
        break;
      }

      case 'PDF': {
        // Use board report service for PDF
        const { pdfUrl } = await this.boardReportService.generateBoardReport(
          schedule.organizationId,
          schedule.createdById,
          {
            title: schedule.name,
            dateRange: this.getDateRange(filters),
            includePptx: false,
          },
        );
        // Download the generated PDF
        fileBuffer = await this.storage.download(pdfUrl);
        rowCount = 1; // PDF is a single document
        break;
      }

      default:
        throw new Error(`Unsupported format: ${schedule.format}`);
    }

    const dateSuffix = format(new Date(), 'yyyy-MM-dd');
    const fileName = `${schedule.name.replace(/[^a-z0-9]/gi, '-')}-${dateSuffix}.${schedule.format.toLowerCase()}`;

    return { fileBuffer, fileName, rowCount };
  }

  private async deliver(
    schedule: ScheduledExport,
    fileBuffer: Buffer,
    fileName: string,
    fileUrl: string,
  ): Promise<Record<string, string>> {
    const results: Record<string, string> = {};

    if (schedule.deliveryMethod === 'EMAIL') {
      for (const recipient of schedule.recipients) {
        try {
          await this.emailService.send({
            to: recipient,
            subject: `Scheduled Report: ${schedule.name}`,
            template: 'scheduled-export',
            context: {
              reportName: schedule.name,
              downloadUrl: fileUrl,
              generatedAt: format(new Date(), 'PPpp'),
            },
            attachments: [
              {
                filename: fileName,
                content: fileBuffer,
              },
            ],
          });
          results[recipient] = 'sent';
        } catch (error) {
          results[recipient] = `failed: ${error.message}`;
        }
      }
    }

    return results;
  }

  private getMimeType(format: ExportFormat): string {
    switch (format) {
      case 'XLSX': return 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
      case 'CSV': return 'text/csv';
      case 'PDF': return 'application/pdf';
      default: return 'application/octet-stream';
    }
  }

  private escapeCsv(value: unknown): string {
    if (value === null || value === undefined) return '';
    const str = String(value);
    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
      return `"${str.replace(/"/g, '""')}"`;
    }
    return str;
  }

  private getDateRange(filters: Record<string, unknown>): { start: Date; end: Date } {
    if (filters.dateRange) {
      const range = filters.dateRange as { start: string; end: string };
      return { start: new Date(range.start), end: new Date(range.end) };
    }
    return { start: subDays(new Date(), 30), end: new Date() };
  }
}

interface ColumnConfig {
  includeInvestigations: boolean;
  maxInvestigations: number;
  includeTaggedFields: boolean;
  includeOverflow: boolean;
}
```
  </action>
  <verify>npm run lint && npm run typecheck passes</verify>
  <done>ScheduledExportProcessor runs due exports and delivers via email or storage</done>
</task>

</tasks>

<verification>
```bash
cd apps/backend
npx prisma format
npx prisma generate
npm run lint -- --fix
npm run typecheck
```
</verification>

<success_criteria>
- ScheduledExport model supports daily, weekly, monthly schedules
- ScheduledExportService calculates next run time correctly for all schedule types
- ScheduledExportProcessor checks due schedules every minute
- Email delivery includes file attachment and download link
- Run history tracks success/failure and delivery status
</success_criteria>

<output>
After completion, create `.planning/phases/11-analytics-reporting/11-12-SUMMARY.md`
</output>
