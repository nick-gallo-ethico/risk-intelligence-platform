---
phase: 11-analytics-reporting
plan: 21
type: execute
wave: 5
depends_on: ["11-03", "11-07"]
files_modified:
  - apps/backend/src/modules/analytics/exports/tagged-field.service.ts
  - apps/backend/src/modules/analytics/exports/flat-export.controller.ts
  - apps/frontend/src/components/exports/TaggedFieldConfig.tsx
  - apps/frontend/src/components/exports/FlatExportBuilder.tsx
autonomous: true

must_haves:
  truths:
    - "Flat file export includes all case data in denormalized format"
    - "Field tags (AUDIT, PII, BOARD) control field inclusion"
    - "Export supports both normalized (multi-sheet) and denormalized (single-sheet) formats"
  artifacts:
    - path: "apps/backend/src/modules/analytics/exports/tagged-field.service.ts"
      provides: "Tag-based field filtering service"
      min_lines: 100
    - path: "apps/frontend/src/components/exports/FlatExportBuilder.tsx"
      provides: "Export configuration UI"
      min_lines: 150
  key_links:
    - from: "flat-export.controller.ts"
      to: "tagged-field.service"
      via: "tag filtering"
      pattern: "taggedFieldService\\."
---

<objective>
Build flat file export with tagged field system for comprehensive data export.

Purpose: Enable auditors to export full case data with configurable field inclusion (FLAT-01).
Output: TaggedFieldService, FlatExportController, and frontend configuration UI
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/11-analytics-reporting/11-CONTEXT.md
@.planning/phases/11-analytics-reporting/11-03-SUMMARY.md
@.planning/phases/11-analytics-reporting/11-07-SUMMARY.md
@01-SHARED-INFRASTRUCTURE/TECH-SPEC-FLAT-FILE-EXPORT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TaggedFieldService</name>
  <files>apps/backend/src/modules/analytics/exports/tagged-field.service.ts</files>
  <action>
Create service for tag-based field management:

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../../../common/prisma/prisma.service';

// Field tag types
export enum FieldTag {
  AUDIT = 'AUDIT',           // Required for compliance audits
  BOARD = 'BOARD',           // Included in board reports
  PII = 'PII',               // Contains personal information
  SENSITIVE = 'SENSITIVE',   // Restricted access data
  EXTERNAL = 'EXTERNAL',     // Safe for external sharing
  MIGRATION = 'MIGRATION',   // Included in migration exports
}

// Platform fields with their default tags
export interface TaggedField {
  entity: string;
  field: string;
  label: string;
  path: string;              // Dot-notation path (e.g., 'case.assignedTo.name')
  type: 'string' | 'number' | 'date' | 'boolean' | 'json';
  tags: FieldTag[];
  description?: string;
}

// Default field definitions
const PLATFORM_FIELDS: TaggedField[] = [
  // Case fields
  { entity: 'Case', field: 'id', label: 'Case ID', path: 'case.id', type: 'string', tags: [FieldTag.AUDIT, FieldTag.BOARD, FieldTag.MIGRATION] },
  { entity: 'Case', field: 'referenceNumber', label: 'Reference #', path: 'case.referenceNumber', type: 'string', tags: [FieldTag.AUDIT, FieldTag.BOARD, FieldTag.EXTERNAL, FieldTag.MIGRATION] },
  { entity: 'Case', field: 'status', label: 'Status', path: 'case.status', type: 'string', tags: [FieldTag.AUDIT, FieldTag.BOARD, FieldTag.EXTERNAL, FieldTag.MIGRATION] },
  { entity: 'Case', field: 'createdAt', label: 'Created Date', path: 'case.createdAt', type: 'date', tags: [FieldTag.AUDIT, FieldTag.BOARD, FieldTag.MIGRATION] },
  { entity: 'Case', field: 'closedAt', label: 'Closed Date', path: 'case.closedAt', type: 'date', tags: [FieldTag.AUDIT, FieldTag.BOARD, FieldTag.MIGRATION] },
  { entity: 'Case', field: 'resolution', label: 'Resolution', path: 'case.resolution', type: 'string', tags: [FieldTag.AUDIT, FieldTag.BOARD] },
  { entity: 'Case', field: 'assignedTo', label: 'Assigned To', path: 'case.assignedTo.name', type: 'string', tags: [FieldTag.AUDIT] },

  // RIU fields
  { entity: 'RIU', field: 'id', label: 'RIU ID', path: 'riu.id', type: 'string', tags: [FieldTag.AUDIT, FieldTag.MIGRATION] },
  { entity: 'RIU', field: 'type', label: 'RIU Type', path: 'riu.type', type: 'string', tags: [FieldTag.AUDIT, FieldTag.BOARD, FieldTag.MIGRATION] },
  { entity: 'RIU', field: 'details', label: 'Description', path: 'riu.details', type: 'string', tags: [FieldTag.AUDIT, FieldTag.SENSITIVE, FieldTag.MIGRATION] },
  { entity: 'RIU', field: 'reporterType', label: 'Reporter Type', path: 'riu.reporterType', type: 'string', tags: [FieldTag.AUDIT, FieldTag.BOARD, FieldTag.MIGRATION] },
  { entity: 'RIU', field: 'categoryName', label: 'Category', path: 'riu.category.name', type: 'string', tags: [FieldTag.AUDIT, FieldTag.BOARD, FieldTag.EXTERNAL, FieldTag.MIGRATION] },
  { entity: 'RIU', field: 'severity', label: 'Severity', path: 'riu.severity', type: 'string', tags: [FieldTag.AUDIT, FieldTag.BOARD, FieldTag.MIGRATION] },
  { entity: 'RIU', field: 'incidentDate', label: 'Incident Date', path: 'riu.incidentDate', type: 'date', tags: [FieldTag.AUDIT, FieldTag.BOARD, FieldTag.MIGRATION] },
  { entity: 'RIU', field: 'sourceChannel', label: 'Source Channel', path: 'riu.sourceChannel', type: 'string', tags: [FieldTag.AUDIT, FieldTag.BOARD] },
  { entity: 'RIU', field: 'aiSummary', label: 'AI Summary', path: 'riu.aiSummary', type: 'string', tags: [FieldTag.BOARD] },

  // Location fields
  { entity: 'Location', field: 'name', label: 'Location', path: 'riu.location.name', type: 'string', tags: [FieldTag.AUDIT, FieldTag.BOARD, FieldTag.EXTERNAL] },
  { entity: 'Location', field: 'country', label: 'Country', path: 'riu.location.country', type: 'string', tags: [FieldTag.AUDIT, FieldTag.BOARD, FieldTag.EXTERNAL] },

  // Business Unit fields
  { entity: 'BusinessUnit', field: 'name', label: 'Business Unit', path: 'riu.businessUnit.name', type: 'string', tags: [FieldTag.AUDIT, FieldTag.BOARD, FieldTag.EXTERNAL] },

  // Investigation fields
  { entity: 'Investigation', field: 'id', label: 'Investigation ID', path: 'investigations[].id', type: 'string', tags: [FieldTag.AUDIT] },
  { entity: 'Investigation', field: 'status', label: 'Investigation Status', path: 'investigations[].status', type: 'string', tags: [FieldTag.AUDIT, FieldTag.BOARD] },
  { entity: 'Investigation', field: 'findings', label: 'Findings', path: 'investigations[].findings', type: 'string', tags: [FieldTag.AUDIT, FieldTag.SENSITIVE] },
  { entity: 'Investigation', field: 'assignedTo', label: 'Investigator', path: 'investigations[].assignedTo.name', type: 'string', tags: [FieldTag.AUDIT] },

  // Person fields (PII)
  { entity: 'Person', field: 'firstName', label: 'First Name', path: 'subjects[].firstName', type: 'string', tags: [FieldTag.PII, FieldTag.SENSITIVE] },
  { entity: 'Person', field: 'lastName', label: 'Last Name', path: 'subjects[].lastName', type: 'string', tags: [FieldTag.PII, FieldTag.SENSITIVE] },
  { entity: 'Person', field: 'email', label: 'Email', path: 'subjects[].email', type: 'string', tags: [FieldTag.PII, FieldTag.SENSITIVE] },
  { entity: 'Person', field: 'role', label: 'Role', path: 'subjects[].role', type: 'string', tags: [FieldTag.AUDIT] },

  // Remediation fields
  { entity: 'Remediation', field: 'status', label: 'Remediation Status', path: 'remediation.status', type: 'string', tags: [FieldTag.AUDIT, FieldTag.BOARD] },
  { entity: 'Remediation', field: 'completedSteps', label: 'Completed Steps', path: 'remediation.completedSteps', type: 'number', tags: [FieldTag.AUDIT] },
  { entity: 'Remediation', field: 'totalSteps', label: 'Total Steps', path: 'remediation.totalSteps', type: 'number', tags: [FieldTag.AUDIT] },

  // SLA fields
  { entity: 'SLA', field: 'dueAt', label: 'SLA Due Date', path: 'sla.dueAt', type: 'date', tags: [FieldTag.AUDIT, FieldTag.BOARD] },
  { entity: 'SLA', field: 'breached', label: 'SLA Breached', path: 'sla.breached', type: 'boolean', tags: [FieldTag.AUDIT, FieldTag.BOARD] },
];

@Injectable()
export class TaggedFieldService {
  private readonly logger = new Logger(TaggedFieldService.name);

  constructor(private prisma: PrismaService) {}

  /**
   * Get all platform fields.
   */
  getAllFields(): TaggedField[] {
    return PLATFORM_FIELDS;
  }

  /**
   * Get fields by tag inclusion/exclusion.
   */
  getFieldsByTags(config: {
    includeTags?: FieldTag[];
    excludeTags?: FieldTag[];
    entities?: string[];
  }): TaggedField[] {
    let fields = [...PLATFORM_FIELDS];

    // Filter by entity if specified
    if (config.entities && config.entities.length > 0) {
      fields = fields.filter(f => config.entities!.includes(f.entity));
    }

    // Include fields with any of includeTags
    if (config.includeTags && config.includeTags.length > 0) {
      fields = fields.filter(f =>
        f.tags.some(t => config.includeTags!.includes(t)),
      );
    }

    // Exclude fields with any of excludeTags
    if (config.excludeTags && config.excludeTags.length > 0) {
      fields = fields.filter(f =>
        !f.tags.some(t => config.excludeTags!.includes(t)),
      );
    }

    return fields;
  }

  /**
   * Get org-specific field tag overrides.
   */
  async getOrgFieldTags(orgId: string): Promise<Map<string, FieldTag[]>> {
    const overrides = await this.prisma.reportFieldTag.findMany({
      where: { organizationId: orgId },
    });

    const map = new Map<string, FieldTag[]>();
    for (const override of overrides) {
      map.set(`${override.entityType}.${override.fieldName}`, override.tags as FieldTag[]);
    }

    return map;
  }

  /**
   * Get fields with org overrides applied.
   */
  async getFieldsWithOverrides(
    orgId: string,
    config?: { includeTags?: FieldTag[]; excludeTags?: FieldTag[] },
  ): Promise<TaggedField[]> {
    const baseFields = this.getFieldsByTags(config || {});
    const overrides = await this.getOrgFieldTags(orgId);

    return baseFields.map(field => {
      const key = `${field.entity}.${field.field}`;
      if (overrides.has(key)) {
        return { ...field, tags: overrides.get(key)! };
      }
      return field;
    });
  }

  /**
   * Update org-specific field tags.
   */
  async updateFieldTags(
    orgId: string,
    userId: string,
    updates: { entity: string; field: string; tags: FieldTag[] }[],
  ): Promise<void> {
    for (const update of updates) {
      await this.prisma.reportFieldTag.upsert({
        where: {
          organizationId_entityType_fieldName: {
            organizationId: orgId,
            entityType: update.entity,
            fieldName: update.field,
          },
        },
        create: {
          organizationId: orgId,
          entityType: update.entity,
          fieldName: update.field,
          tags: update.tags,
          createdById: userId,
        },
        update: {
          tags: update.tags,
        },
      });
    }
  }

  /**
   * Build column definitions from fields.
   */
  buildColumns(fields: TaggedField[]): {
    field: string;
    label: string;
    path: string;
    type: string;
  }[] {
    return fields.map(f => ({
      field: `${f.entity}_${f.field}`,
      label: f.label,
      path: f.path,
      type: f.type,
    }));
  }

  /**
   * Get preset export configurations.
   */
  getPresets(): { name: string; description: string; tags: { include: FieldTag[]; exclude: FieldTag[] } }[] {
    return [
      {
        name: 'Audit Export',
        description: 'All fields required for compliance audits',
        tags: { include: [FieldTag.AUDIT], exclude: [] },
      },
      {
        name: 'Board Report Data',
        description: 'Fields suitable for board-level reporting',
        tags: { include: [FieldTag.BOARD], exclude: [FieldTag.PII, FieldTag.SENSITIVE] },
      },
      {
        name: 'External Sharing',
        description: 'Safe for external parties (no PII or sensitive data)',
        tags: { include: [FieldTag.EXTERNAL], exclude: [FieldTag.PII, FieldTag.SENSITIVE] },
      },
      {
        name: 'Migration Export',
        description: 'All data needed for system migration',
        tags: { include: [FieldTag.MIGRATION], exclude: [] },
      },
      {
        name: 'Full Export (Admin)',
        description: 'All fields including PII and sensitive data',
        tags: { include: [], exclude: [] },
      },
    ];
  }
}
```
  </action>
  <verify>npm run lint passes for the service file</verify>
  <done>TaggedFieldService with field definitions and tag filtering implemented</done>
</task>

<task type="auto">
  <name>Task 2: Implement FlatExportController</name>
  <files>apps/backend/src/modules/analytics/exports/flat-export.controller.ts</files>
  <action>
Create controller for flat file exports:

```typescript
import {
  Controller,
  Get,
  Post,
  Body,
  Query,
  UseGuards,
  StreamableFile,
  Header,
} from '@nestjs/common';
import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../../auth/guards/roles.guard';
import { Roles } from '../../auth/decorators/roles.decorator';
import { TenantId } from '../../auth/decorators/tenant.decorator';
import { CurrentUser } from '../../auth/decorators/current-user.decorator';
import { TaggedFieldService, FieldTag, TaggedField } from './tagged-field.service';
import { FlatFileService } from './flat-file.service';
import { AuditService } from '../../audit/audit.service';
import { format } from 'date-fns';

export class FlatExportConfigDto {
  includeTags?: FieldTag[];
  excludeTags?: FieldTag[];
  entities?: string[];
  customFields?: string[];  // Specific fields to include
  format: 'csv' | 'xlsx';
  mode: 'normalized' | 'denormalized';
  filters?: {
    dateRange?: { start: string; end: string };
    statuses?: string[];
    categories?: string[];
    businessUnits?: string[];
  };
  reason?: string;  // For audit trail
}

@Controller('api/v1/exports/flat')
@UseGuards(JwtAuthGuard, RolesGuard)
export class FlatExportController {
  constructor(
    private taggedFieldService: TaggedFieldService,
    private flatFileService: FlatFileService,
    private auditService: AuditService,
  ) {}

  /**
   * Get available fields with their tags.
   */
  @Get('fields')
  @Roles('SYSTEM_ADMIN', 'COMPLIANCE_OFFICER')
  async getFields(
    @TenantId() orgId: string,
  ): Promise<{ fields: TaggedField[] }> {
    const fields = await this.taggedFieldService.getFieldsWithOverrides(orgId);
    return { fields };
  }

  /**
   * Get preset export configurations.
   */
  @Get('presets')
  @Roles('SYSTEM_ADMIN', 'COMPLIANCE_OFFICER')
  getPresets(): { presets: { name: string; description: string; tags: any }[] } {
    return { presets: this.taggedFieldService.getPresets() };
  }

  /**
   * Get available tags.
   */
  @Get('tags')
  @Roles('SYSTEM_ADMIN', 'COMPLIANCE_OFFICER')
  getTags(): { tags: { value: FieldTag; label: string; description: string }[] } {
    return {
      tags: [
        { value: FieldTag.AUDIT, label: 'Audit', description: 'Required for compliance audits' },
        { value: FieldTag.BOARD, label: 'Board', description: 'Included in board reports' },
        { value: FieldTag.PII, label: 'PII', description: 'Contains personal information' },
        { value: FieldTag.SENSITIVE, label: 'Sensitive', description: 'Restricted access data' },
        { value: FieldTag.EXTERNAL, label: 'External', description: 'Safe for external sharing' },
        { value: FieldTag.MIGRATION, label: 'Migration', description: 'Included in migration exports' },
      ],
    };
  }

  /**
   * Preview export configuration.
   */
  @Post('preview')
  @Roles('SYSTEM_ADMIN', 'COMPLIANCE_OFFICER')
  async previewExport(
    @TenantId() orgId: string,
    @Body() config: FlatExportConfigDto,
  ): Promise<{
    fields: { field: string; label: string }[];
    rowCount: number;
    sampleData: Record<string, unknown>[];
  }> {
    // Get fields based on config
    const fields = await this.taggedFieldService.getFieldsWithOverrides(orgId, {
      includeTags: config.includeTags,
      excludeTags: config.excludeTags,
    });

    // Filter by entities if specified
    const filteredFields = config.entities?.length
      ? fields.filter(f => config.entities!.includes(f.entity))
      : fields;

    // Get sample data
    const { data, totalCount } = await this.flatFileService.queryData(
      orgId,
      config.filters,
      5, // Sample limit
    );

    // Transform to flat format
    const columns = this.taggedFieldService.buildColumns(filteredFields);
    const sampleData = data.map(row =>
      this.flatFileService.flattenRow(row, columns, config.mode === 'denormalized'),
    );

    return {
      fields: columns.map(c => ({ field: c.field, label: c.label })),
      rowCount: totalCount,
      sampleData,
    };
  }

  /**
   * Execute flat file export.
   */
  @Post('export')
  @Roles('SYSTEM_ADMIN', 'COMPLIANCE_OFFICER')
  @Header('Content-Type', 'application/octet-stream')
  async executeExport(
    @TenantId() orgId: string,
    @CurrentUser('id') userId: string,
    @CurrentUser('name') userName: string,
    @Body() config: FlatExportConfigDto,
  ): Promise<StreamableFile> {
    // Get fields
    const fields = await this.taggedFieldService.getFieldsWithOverrides(orgId, {
      includeTags: config.includeTags,
      excludeTags: config.excludeTags,
    });

    const filteredFields = config.entities?.length
      ? fields.filter(f => config.entities!.includes(f.entity))
      : fields;

    const columns = this.taggedFieldService.buildColumns(filteredFields);

    // Generate export
    const buffer = await this.flatFileService.generateExport(
      orgId,
      columns,
      config.filters,
      config.format,
      config.mode,
    );

    // Audit log
    await this.auditService.log({
      entityType: 'FLAT_EXPORT',
      entityId: `export-${Date.now()}`,
      action: 'exported',
      actionDescription: `${userName} exported ${filteredFields.length} fields in ${config.format} format`,
      organizationId: orgId,
      actorUserId: userId,
      metadata: {
        fieldCount: filteredFields.length,
        format: config.format,
        mode: config.mode,
        includeTags: config.includeTags,
        excludeTags: config.excludeTags,
        reason: config.reason,
        includesPii: filteredFields.some(f => f.tags.includes(FieldTag.PII)),
      },
    });

    const timestamp = format(new Date(), 'yyyy-MM-dd-HHmm');
    const filename = `case-export-${timestamp}.${config.format}`;

    return new StreamableFile(buffer, {
      type: config.format === 'xlsx'
        ? 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        : 'text/csv',
      disposition: `attachment; filename="${filename}"`,
    });
  }

  /**
   * Update field tags for org.
   */
  @Post('fields/tags')
  @Roles('SYSTEM_ADMIN')
  async updateFieldTags(
    @TenantId() orgId: string,
    @CurrentUser('id') userId: string,
    @Body() updates: { entity: string; field: string; tags: FieldTag[] }[],
  ): Promise<{ updated: number }> {
    await this.taggedFieldService.updateFieldTags(orgId, userId, updates);
    return { updated: updates.length };
  }
}
```
  </action>
  <verify>npm run lint && npm run typecheck passes</verify>
  <done>FlatExportController with preview and export endpoints implemented</done>
</task>

<task type="auto">
  <name>Task 3: Create TaggedFieldConfig component</name>
  <files>apps/frontend/src/components/exports/TaggedFieldConfig.tsx</files>
  <action>
Create field tag configuration UI:

```typescript
'use client';

import { useState, useMemo } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { api } from '@/lib/api';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Checkbox } from '@/components/ui/checkbox';
import { Input } from '@/components/ui/input';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { toast } from '@/hooks/use-toast';
import { Search, Save, RotateCcw } from 'lucide-react';

interface TaggedField {
  entity: string;
  field: string;
  label: string;
  path: string;
  type: string;
  tags: string[];
}

interface FieldTag {
  value: string;
  label: string;
  description: string;
}

const tagColors: Record<string, string> = {
  AUDIT: 'bg-blue-100 text-blue-800',
  BOARD: 'bg-purple-100 text-purple-800',
  PII: 'bg-red-100 text-red-800',
  SENSITIVE: 'bg-orange-100 text-orange-800',
  EXTERNAL: 'bg-green-100 text-green-800',
  MIGRATION: 'bg-gray-100 text-gray-800',
};

export function TaggedFieldConfig() {
  const queryClient = useQueryClient();
  const [search, setSearch] = useState('');
  const [entityFilter, setEntityFilter] = useState<string>('all');
  const [pendingChanges, setPendingChanges] = useState<Map<string, string[]>>(new Map());

  // Fetch fields and tags
  const { data: fieldsData } = useQuery({
    queryKey: ['export-fields'],
    queryFn: async () => {
      const response = await api.get<{ fields: TaggedField[] }>('/api/v1/exports/flat/fields');
      return response.data;
    },
  });

  const { data: tagsData } = useQuery({
    queryKey: ['export-tags'],
    queryFn: async () => {
      const response = await api.get<{ tags: FieldTag[] }>('/api/v1/exports/flat/tags');
      return response.data;
    },
  });

  // Save mutation
  const saveMutation = useMutation({
    mutationFn: async (updates: { entity: string; field: string; tags: string[] }[]) => {
      await api.post('/api/v1/exports/flat/fields/tags', updates);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['export-fields'] });
      setPendingChanges(new Map());
      toast({ title: 'Field tags updated successfully' });
    },
  });

  // Get unique entities
  const entities = useMemo(() => {
    if (!fieldsData?.fields) return [];
    return [...new Set(fieldsData.fields.map(f => f.entity))];
  }, [fieldsData]);

  // Filter fields
  const filteredFields = useMemo(() => {
    if (!fieldsData?.fields) return [];
    return fieldsData.fields.filter(field => {
      const matchesSearch = search === '' ||
        field.label.toLowerCase().includes(search.toLowerCase()) ||
        field.field.toLowerCase().includes(search.toLowerCase());
      const matchesEntity = entityFilter === 'all' || field.entity === entityFilter;
      return matchesSearch && matchesEntity;
    });
  }, [fieldsData, search, entityFilter]);

  // Get current tags for a field (pending or original)
  const getFieldTags = (field: TaggedField): string[] => {
    const key = `${field.entity}.${field.field}`;
    return pendingChanges.get(key) || field.tags;
  };

  // Toggle tag for a field
  const toggleTag = (field: TaggedField, tag: string) => {
    const key = `${field.entity}.${field.field}`;
    const currentTags = getFieldTags(field);
    const newTags = currentTags.includes(tag)
      ? currentTags.filter(t => t !== tag)
      : [...currentTags, tag];

    setPendingChanges(prev => new Map(prev).set(key, newTags));
  };

  // Save changes
  const handleSave = () => {
    const updates = Array.from(pendingChanges.entries()).map(([key, tags]) => {
      const [entity, field] = key.split('.');
      return { entity, field, tags };
    });
    saveMutation.mutate(updates);
  };

  // Reset changes
  const handleReset = () => {
    setPendingChanges(new Map());
  };

  const hasChanges = pendingChanges.size > 0;

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          <div className="relative">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="Search fields..."
              value={search}
              onChange={(e) => setSearch(e.target.value)}
              className="pl-9 w-64"
            />
          </div>
          <Select value={entityFilter} onValueChange={setEntityFilter}>
            <SelectTrigger className="w-40">
              <SelectValue placeholder="All entities" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Entities</SelectItem>
              {entities.map(entity => (
                <SelectItem key={entity} value={entity}>{entity}</SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
        <div className="flex items-center gap-2">
          {hasChanges && (
            <>
              <Button variant="outline" onClick={handleReset}>
                <RotateCcw className="h-4 w-4 mr-2" />
                Reset
              </Button>
              <Button onClick={handleSave} disabled={saveMutation.isPending}>
                <Save className="h-4 w-4 mr-2" />
                Save Changes ({pendingChanges.size})
              </Button>
            </>
          )}
        </div>
      </div>

      <div className="border rounded-lg">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="w-32">Entity</TableHead>
              <TableHead>Field</TableHead>
              <TableHead className="w-64">Tags</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {filteredFields.map(field => {
              const fieldTags = getFieldTags(field);
              const key = `${field.entity}.${field.field}`;
              const isModified = pendingChanges.has(key);

              return (
                <TableRow
                  key={key}
                  className={isModified ? 'bg-yellow-50' : undefined}
                >
                  <TableCell className="font-medium">{field.entity}</TableCell>
                  <TableCell>
                    <div>
                      <span className="font-medium">{field.label}</span>
                      <span className="text-muted-foreground text-xs ml-2">
                        {field.field}
                      </span>
                    </div>
                  </TableCell>
                  <TableCell>
                    <div className="flex flex-wrap gap-1">
                      {tagsData?.tags.map(tag => (
                        <label
                          key={tag.value}
                          className="cursor-pointer"
                          title={tag.description}
                        >
                          <Badge
                            variant="outline"
                            className={`
                              ${fieldTags.includes(tag.value) ? tagColors[tag.value] : 'bg-gray-50 text-gray-400'}
                              transition-colors
                            `}
                            onClick={() => toggleTag(field, tag.value)}
                          >
                            {tag.label}
                          </Badge>
                        </label>
                      ))}
                    </div>
                  </TableCell>
                </TableRow>
              );
            })}
          </TableBody>
        </Table>
      </div>
    </div>
  );
}
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>TaggedFieldConfig component for admin field tag management created</done>
</task>

<task type="auto">
  <name>Task 4: Create FlatExportBuilder component</name>
  <files>apps/frontend/src/components/exports/FlatExportBuilder.tsx</files>
  <action>
Create export configuration UI:

```typescript
'use client';

import { useState, useMemo } from 'react';
import { useQuery, useMutation } from '@tanstack/react-query';
import { api } from '@/lib/api';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Checkbox } from '@/components/ui/checkbox';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { DateRangePicker } from '@/components/ui/date-range-picker';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from '@/components/ui/accordion';
import { toast } from '@/hooks/use-toast';
import { Download, Eye, FileSpreadsheet, FileText, Loader2 } from 'lucide-react';
import { format } from 'date-fns';

interface Preset {
  name: string;
  description: string;
  tags: { include: string[]; exclude: string[] };
}

interface PreviewData {
  fields: { field: string; label: string }[];
  rowCount: number;
  sampleData: Record<string, unknown>[];
}

const tagColors: Record<string, string> = {
  AUDIT: 'bg-blue-100 text-blue-800',
  BOARD: 'bg-purple-100 text-purple-800',
  PII: 'bg-red-100 text-red-800',
  SENSITIVE: 'bg-orange-100 text-orange-800',
  EXTERNAL: 'bg-green-100 text-green-800',
  MIGRATION: 'bg-gray-100 text-gray-800',
};

export function FlatExportBuilder() {
  const [selectedPreset, setSelectedPreset] = useState<string | null>(null);
  const [includeTags, setIncludeTags] = useState<string[]>([]);
  const [excludeTags, setExcludeTags] = useState<string[]>(['PII', 'SENSITIVE']);
  const [exportFormat, setExportFormat] = useState<'csv' | 'xlsx'>('xlsx');
  const [exportMode, setExportMode] = useState<'normalized' | 'denormalized'>('denormalized');
  const [dateRange, setDateRange] = useState<{ from: Date; to: Date } | undefined>();
  const [reason, setReason] = useState('');
  const [preview, setPreview] = useState<PreviewData | null>(null);

  // Fetch presets
  const { data: presetsData } = useQuery({
    queryKey: ['export-presets'],
    queryFn: async () => {
      const response = await api.get<{ presets: Preset[] }>('/api/v1/exports/flat/presets');
      return response.data;
    },
  });

  // Fetch tags
  const { data: tagsData } = useQuery({
    queryKey: ['export-tags'],
    queryFn: async () => {
      const response = await api.get<{ tags: { value: string; label: string; description: string }[] }>(
        '/api/v1/exports/flat/tags',
      );
      return response.data;
    },
  });

  // Preview mutation
  const previewMutation = useMutation({
    mutationFn: async () => {
      const response = await api.post<PreviewData>('/api/v1/exports/flat/preview', {
        includeTags: includeTags.length > 0 ? includeTags : undefined,
        excludeTags: excludeTags.length > 0 ? excludeTags : undefined,
        format: exportFormat,
        mode: exportMode,
        filters: dateRange ? {
          dateRange: {
            start: dateRange.from.toISOString(),
            end: dateRange.to.toISOString(),
          },
        } : undefined,
      });
      return response.data;
    },
    onSuccess: (data) => {
      setPreview(data);
    },
  });

  // Export mutation
  const exportMutation = useMutation({
    mutationFn: async () => {
      const response = await api.post('/api/v1/exports/flat/export', {
        includeTags: includeTags.length > 0 ? includeTags : undefined,
        excludeTags: excludeTags.length > 0 ? excludeTags : undefined,
        format: exportFormat,
        mode: exportMode,
        filters: dateRange ? {
          dateRange: {
            start: dateRange.from.toISOString(),
            end: dateRange.to.toISOString(),
          },
        } : undefined,
        reason,
      }, { responseType: 'blob' });

      // Download file
      const blob = new Blob([response.data]);
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `case-export-${format(new Date(), 'yyyy-MM-dd')}.${exportFormat}`;
      a.click();
      window.URL.revokeObjectURL(url);

      toast({ title: 'Export downloaded successfully' });
    },
  });

  // Apply preset
  const applyPreset = (preset: Preset) => {
    setSelectedPreset(preset.name);
    setIncludeTags(preset.tags.include);
    setExcludeTags(preset.tags.exclude);
    setPreview(null);
  };

  // Toggle tag
  const toggleIncludeTag = (tag: string) => {
    setIncludeTags(prev =>
      prev.includes(tag) ? prev.filter(t => t !== tag) : [...prev, tag],
    );
    setSelectedPreset(null);
    setPreview(null);
  };

  const toggleExcludeTag = (tag: string) => {
    setExcludeTags(prev =>
      prev.includes(tag) ? prev.filter(t => t !== tag) : [...prev, tag],
    );
    setSelectedPreset(null);
    setPreview(null);
  };

  const includesPii = !excludeTags.includes('PII');
  const includesSensitive = !excludeTags.includes('SENSITIVE');

  return (
    <div className="space-y-6">
      {/* Presets */}
      <Card>
        <CardHeader>
          <CardTitle>Quick Export Presets</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-5 gap-3">
            {presetsData?.presets.map(preset => (
              <Button
                key={preset.name}
                variant={selectedPreset === preset.name ? 'default' : 'outline'}
                className="h-auto py-3 flex flex-col items-start"
                onClick={() => applyPreset(preset)}
              >
                <span className="font-medium">{preset.name}</span>
                <span className="text-xs text-muted-foreground font-normal text-left">
                  {preset.description}
                </span>
              </Button>
            ))}
          </div>
        </CardContent>
      </Card>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Tag Selection */}
        <Card className="lg:col-span-2">
          <CardHeader>
            <CardTitle>Field Selection by Tags</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div>
              <Label className="mb-2 block">Include fields with tags:</Label>
              <div className="flex flex-wrap gap-2">
                {tagsData?.tags.map(tag => (
                  <Badge
                    key={tag.value}
                    variant="outline"
                    className={`cursor-pointer ${includeTags.includes(tag.value) ? tagColors[tag.value] : 'bg-gray-50'}`}
                    onClick={() => toggleIncludeTag(tag.value)}
                  >
                    {tag.label}
                  </Badge>
                ))}
              </div>
              <p className="text-xs text-muted-foreground mt-1">
                Leave empty to include all fields (except excluded)
              </p>
            </div>

            <div>
              <Label className="mb-2 block">Exclude fields with tags:</Label>
              <div className="flex flex-wrap gap-2">
                {tagsData?.tags.map(tag => (
                  <Badge
                    key={tag.value}
                    variant="outline"
                    className={`cursor-pointer ${excludeTags.includes(tag.value) ? 'bg-red-100 text-red-800 line-through' : 'bg-gray-50'}`}
                    onClick={() => toggleExcludeTag(tag.value)}
                  >
                    {tag.label}
                  </Badge>
                ))}
              </div>
            </div>

            {(includesPii || includesSensitive) && (
              <div className="p-3 bg-amber-50 border border-amber-200 rounded-lg">
                <p className="text-sm text-amber-800">
                  <strong>Warning:</strong> Export will include{' '}
                  {includesPii && 'PII (Personal Information)'}
                  {includesPii && includesSensitive && ' and '}
                  {includesSensitive && 'Sensitive data'}
                  . This will be logged for audit purposes.
                </p>
              </div>
            )}
          </CardContent>
        </Card>

        {/* Export Options */}
        <Card>
          <CardHeader>
            <CardTitle>Export Options</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div>
              <Label className="mb-2 block">Format</Label>
              <RadioGroup value={exportFormat} onValueChange={(v) => setExportFormat(v as any)}>
                <div className="flex items-center space-x-2">
                  <RadioGroupItem value="xlsx" id="xlsx" />
                  <Label htmlFor="xlsx" className="flex items-center gap-2">
                    <FileSpreadsheet className="h-4 w-4" />
                    Excel (.xlsx)
                  </Label>
                </div>
                <div className="flex items-center space-x-2">
                  <RadioGroupItem value="csv" id="csv" />
                  <Label htmlFor="csv" className="flex items-center gap-2">
                    <FileText className="h-4 w-4" />
                    CSV (.csv)
                  </Label>
                </div>
              </RadioGroup>
            </div>

            <div>
              <Label className="mb-2 block">Structure</Label>
              <RadioGroup value={exportMode} onValueChange={(v) => setExportMode(v as any)}>
                <div className="flex items-center space-x-2">
                  <RadioGroupItem value="denormalized" id="denormalized" />
                  <Label htmlFor="denormalized">Single sheet (flat)</Label>
                </div>
                <div className="flex items-center space-x-2">
                  <RadioGroupItem value="normalized" id="normalized" />
                  <Label htmlFor="normalized">Multi-sheet (related)</Label>
                </div>
              </RadioGroup>
            </div>

            <div>
              <Label className="mb-2 block">Date Range (optional)</Label>
              <DateRangePicker
                value={dateRange}
                onChange={setDateRange}
              />
            </div>

            <div>
              <Label className="mb-2 block">Reason (for audit log)</Label>
              <Textarea
                placeholder="Why are you exporting this data?"
                value={reason}
                onChange={(e) => setReason(e.target.value)}
                rows={2}
              />
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Preview */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between">
          <CardTitle>Preview</CardTitle>
          <Button
            onClick={() => previewMutation.mutate()}
            disabled={previewMutation.isPending}
          >
            {previewMutation.isPending ? (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            ) : (
              <Eye className="h-4 w-4 mr-2" />
            )}
            Generate Preview
          </Button>
        </CardHeader>
        {preview && (
          <CardContent>
            <p className="text-sm text-muted-foreground mb-4">
              {preview.fields.length} columns, {preview.rowCount.toLocaleString()} total rows
            </p>
            <div className="border rounded-lg overflow-x-auto">
              <Table>
                <TableHeader>
                  <TableRow>
                    {preview.fields.map(f => (
                      <TableHead key={f.field} className="whitespace-nowrap">
                        {f.label}
                      </TableHead>
                    ))}
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {preview.sampleData.map((row, i) => (
                    <TableRow key={i}>
                      {preview.fields.map(f => (
                        <TableCell key={f.field} className="max-w-[200px] truncate">
                          {String(row[f.field] ?? '')}
                        </TableCell>
                      ))}
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </div>
          </CardContent>
        )}
      </Card>

      {/* Export Button */}
      <div className="flex justify-end">
        <Button
          size="lg"
          onClick={() => exportMutation.mutate()}
          disabled={exportMutation.isPending}
        >
          {exportMutation.isPending ? (
            <Loader2 className="h-4 w-4 mr-2 animate-spin" />
          ) : (
            <Download className="h-4 w-4 mr-2" />
          )}
          Download Export
        </Button>
      </div>
    </div>
  );
}
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>FlatExportBuilder component with tag selection and preview created</done>
</task>

</tasks>

<verification>
```bash
cd apps/backend
npm run lint -- --fix
npm run typecheck
cd ../frontend
npm run lint -- --fix
npm run typecheck
```
</verification>

<success_criteria>
- TaggedFieldService defines all platform fields with default tags
- Field tags can be customized per organization
- Presets provide quick access to common export configurations
- Preview shows columns and sample data before export
- Export audit log captures user, fields, tags, and reason
- PII/Sensitive data warnings displayed when selected
</success_criteria>

<output>
After completion, create `.planning/phases/11-analytics-reporting/11-21-SUMMARY.md`
</output>
