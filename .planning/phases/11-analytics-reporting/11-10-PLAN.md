---
phase: 11-analytics-reporting
plan: 10
type: execute
wave: 3
depends_on: ["11-01", "11-05"]
files_modified:
  - apps/backend/src/modules/analytics/dashboard/dashboard.controller.ts
  - apps/backend/src/modules/analytics/dashboard/scheduled-refresh.service.ts
autonomous: true

must_haves:
  truths:
    - "Dashboard CRUD endpoints are accessible via REST API"
    - "Widget data endpoints support batch requests"
    - "Dashboard refresh can be scheduled with cron jobs"
  artifacts:
    - path: "apps/backend/src/modules/analytics/dashboard/dashboard.controller.ts"
      provides: "REST endpoints for dashboard management"
      min_lines: 150
    - path: "apps/backend/src/modules/analytics/dashboard/scheduled-refresh.service.ts"
      provides: "Cron-based dashboard refresh"
      min_lines: 50
  key_links:
    - from: "dashboard.controller.ts"
      to: "dashboard-config.service"
      via: "CRUD operations"
      pattern: "dashboardConfigService\\."
---

<objective>
Create the dashboard REST controller and scheduled refresh service.

Purpose: Expose dashboard management and data endpoints via API with scheduled background refresh.
Output: DashboardController with full CRUD and ScheduledRefreshService
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/11-analytics-reporting/11-CONTEXT.md
@.planning/phases/11-analytics-reporting/11-01-SUMMARY.md
@.planning/phases/11-analytics-reporting/11-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DashboardController</name>
  <files>apps/backend/src/modules/analytics/dashboard/dashboard.controller.ts</files>
  <action>
Create comprehensive dashboard controller:

```typescript
@Controller('api/v1/dashboards')
@UseGuards(JwtAuthGuard)
@ApiTags('dashboards')
export class DashboardController {
  constructor(
    private dashboardConfigService: DashboardConfigService,
    private widgetDataService: WidgetDataService,
  ) {}

  // ==================== Dashboard CRUD ====================

  @Get()
  @ApiOperation({ summary: 'List available dashboards' })
  async listDashboards(
    @CurrentUser() user: User,
    @Query() query: DashboardQueryDto,
  ): Promise<PaginatedResult<DashboardSummaryDto>> {
    return this.dashboardConfigService.listDashboards(
      user.organizationId,
      query,
    );
  }

  @Get('types')
  @ApiOperation({ summary: 'Get available dashboard types and defaults' })
  async getDashboardTypes(@CurrentUser() user: User): Promise<DashboardTypeInfo[]> {
    return this.dashboardConfigService.getDashboardTypes(user.organizationId);
  }

  @Post()
  @Roles(Role.COMPLIANCE_OFFICER, Role.SYSTEM_ADMIN)
  @ApiOperation({ summary: 'Create new dashboard' })
  async createDashboard(
    @CurrentUser() user: User,
    @Body() dto: CreateDashboardDto,
  ): Promise<Dashboard> {
    return this.dashboardConfigService.createDashboard(
      user.organizationId,
      user.id,
      dto,
    );
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get dashboard by ID' })
  async getDashboard(
    @CurrentUser() user: User,
    @Param('id') id: string,
  ): Promise<DashboardWithWidgets> {
    return this.dashboardConfigService.getDashboard(user.organizationId, id);
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update dashboard' })
  async updateDashboard(
    @CurrentUser() user: User,
    @Param('id') id: string,
    @Body() dto: UpdateDashboardDto,
  ): Promise<Dashboard> {
    return this.dashboardConfigService.updateDashboard(
      user.organizationId,
      id,
      dto,
    );
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete dashboard' })
  async deleteDashboard(
    @CurrentUser() user: User,
    @Param('id') id: string,
  ): Promise<void> {
    return this.dashboardConfigService.deleteDashboard(user.organizationId, id);
  }

  // ==================== User Config ====================

  @Get('my/home')
  @ApiOperation({ summary: 'Get user home dashboard' })
  async getHomeDashboard(@CurrentUser() user: User): Promise<DashboardWithWidgets | null> {
    return this.dashboardConfigService.getUserHomeDashboard(
      user.organizationId,
      user.id,
    );
  }

  @Post('my/home/:dashboardId')
  @ApiOperation({ summary: 'Set dashboard as home' })
  async setHomeDashboard(
    @CurrentUser() user: User,
    @Param('dashboardId') dashboardId: string,
  ): Promise<void> {
    return this.dashboardConfigService.setHomeDashboard(
      user.organizationId,
      user.id,
      dashboardId,
    );
  }

  @Get('my/config/:dashboardId')
  @ApiOperation({ summary: 'Get user config for dashboard' })
  async getUserConfig(
    @CurrentUser() user: User,
    @Param('dashboardId') dashboardId: string,
  ): Promise<UserDashboardConfig | null> {
    return this.dashboardConfigService.getUserConfig(
      user.organizationId,
      user.id,
      dashboardId,
    );
  }

  @Put('my/config/:dashboardId')
  @ApiOperation({ summary: 'Save user config for dashboard' })
  async saveUserConfig(
    @CurrentUser() user: User,
    @Param('dashboardId') dashboardId: string,
    @Body() dto: SaveUserConfigDto,
  ): Promise<UserDashboardConfig> {
    return this.dashboardConfigService.saveUserConfig(
      user.organizationId,
      user.id,
      dashboardId,
      dto,
    );
  }

  // ==================== Widget Management ====================

  @Post(':dashboardId/widgets')
  @ApiOperation({ summary: 'Add widget to dashboard' })
  async addWidget(
    @CurrentUser() user: User,
    @Param('dashboardId') dashboardId: string,
    @Body() dto: CreateWidgetDto,
  ): Promise<DashboardWidget> {
    return this.dashboardConfigService.addWidget(
      user.organizationId,
      dashboardId,
      dto,
    );
  }

  @Put(':dashboardId/widgets/:widgetId')
  @ApiOperation({ summary: 'Update widget' })
  async updateWidget(
    @CurrentUser() user: User,
    @Param('dashboardId') dashboardId: string,
    @Param('widgetId') widgetId: string,
    @Body() dto: UpdateWidgetDto,
  ): Promise<DashboardWidget> {
    return this.dashboardConfigService.updateWidget(
      user.organizationId,
      dashboardId,
      widgetId,
      dto,
    );
  }

  @Delete(':dashboardId/widgets/:widgetId')
  @ApiOperation({ summary: 'Remove widget from dashboard' })
  async removeWidget(
    @CurrentUser() user: User,
    @Param('dashboardId') dashboardId: string,
    @Param('widgetId') widgetId: string,
  ): Promise<void> {
    return this.dashboardConfigService.removeWidget(
      user.organizationId,
      dashboardId,
      widgetId,
    );
  }

  @Put(':dashboardId/layout')
  @ApiOperation({ summary: 'Update dashboard layout' })
  async updateLayout(
    @CurrentUser() user: User,
    @Param('dashboardId') dashboardId: string,
    @Body() dto: UpdateLayoutDto,
  ): Promise<void> {
    return this.dashboardConfigService.updateLayout(
      user.organizationId,
      dashboardId,
      dto.layouts,
    );
  }

  // ==================== Widget Data ====================

  @Get(':dashboardId/data')
  @ApiOperation({ summary: 'Get data for all widgets in dashboard' })
  async getDashboardData(
    @CurrentUser() user: User,
    @Param('dashboardId') dashboardId: string,
    @Query() query: DashboardDataQueryDto,
  ): Promise<Record<string, WidgetDataResponse>> {
    const dashboard = await this.dashboardConfigService.getDashboard(
      user.organizationId,
      dashboardId,
    );

    const dateRange = this.parseDateRange(query);

    const responses = await this.widgetDataService.getBatchWidgetData(
      user.organizationId,
      user.id,
      dashboard.widgets,
      dateRange,
    );

    // Return as map by widget ID
    return responses.reduce((acc, r) => {
      acc[r.widgetId] = r;
      return acc;
    }, {} as Record<string, WidgetDataResponse>);
  }

  @Post('widgets/data/batch')
  @ApiOperation({ summary: 'Batch fetch widget data' })
  async batchWidgetData(
    @CurrentUser() user: User,
    @Body() dto: BatchWidgetDataRequestDto,
  ): Promise<WidgetDataResponse[]> {
    // Load widget configs
    const widgets = await this.dashboardConfigService.getWidgetsByIds(
      user.organizationId,
      dto.widgets.map(w => w.widgetId),
    );

    return this.widgetDataService.getBatchWidgetData(
      user.organizationId,
      user.id,
      widgets,
      dto.dateRange || { start: subDays(new Date(), 30), end: new Date() },
    );
  }

  @Get('widgets/:widgetId/data')
  @ApiOperation({ summary: 'Get data for single widget' })
  async getWidgetData(
    @CurrentUser() user: User,
    @Param('widgetId') widgetId: string,
    @Query() query: WidgetDataQueryDto,
  ): Promise<WidgetDataResponse> {
    const widget = await this.dashboardConfigService.getWidget(
      user.organizationId,
      widgetId,
    );

    return this.widgetDataService.getWidgetData(
      user.organizationId,
      user.id,
      widget,
      this.parseDateRange(query),
      query.forceRefresh,
    );
  }

  private parseDateRange(query: { dateRangePreset?: DateRangePreset; start?: string; end?: string }): DateRange {
    if (query.start && query.end) {
      return { start: new Date(query.start), end: new Date(query.end) };
    }

    const now = new Date();
    switch (query.dateRangePreset) {
      case 'TODAY': return { start: startOfDay(now), end: endOfDay(now) };
      case 'LAST_7_DAYS': return { start: subDays(now, 7), end: now };
      case 'LAST_90_DAYS': return { start: subDays(now, 90), end: now };
      case 'YEAR_TO_DATE': return { start: startOfYear(now), end: now };
      case 'LAST_30_DAYS':
      default: return { start: subDays(now, 30), end: now };
    }
  }
}
```
  </action>
  <verify>npm run lint passes for the controller file</verify>
  <done>DashboardController exposes full CRUD, user config, widget management, and data endpoints</done>
</task>

<task type="auto">
  <name>Task 2: Implement ScheduledRefreshService</name>
  <files>apps/backend/src/modules/analytics/dashboard/scheduled-refresh.service.ts</files>
  <action>
Create service for background dashboard data refresh:

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Inject } from '@nestjs/common';
import { Cache } from 'cache-manager';

@Injectable()
export class ScheduledRefreshService {
  private readonly logger = new Logger(ScheduledRefreshService.name);

  constructor(
    private prisma: PrismaService,
    private widgetDataService: WidgetDataService,
    @Inject(CACHE_MANAGER) private cacheManager: Cache,
  ) {}

  /**
   * Refresh frequently-accessed dashboard data every 5 minutes.
   * Pre-populates cache for dashboards accessed in last hour.
   */
  @Cron(CronExpression.EVERY_5_MINUTES)
  async refreshPopularDashboards() {
    this.logger.log('Starting scheduled dashboard refresh');

    try {
      // Find dashboards accessed in last hour
      const recentConfigs = await this.prisma.userDashboardConfig.findMany({
        where: {
          updatedAt: { gte: subHours(new Date(), 1) },
        },
        include: {
          dashboard: {
            include: { widgets: true },
          },
          user: true,
        },
        take: 100, // Limit to prevent overload
      });

      this.logger.log(`Refreshing ${recentConfigs.length} recently-accessed dashboards`);

      // Refresh in batches of 10
      const batchSize = 10;
      for (let i = 0; i < recentConfigs.length; i += batchSize) {
        const batch = recentConfigs.slice(i, i + batchSize);

        await Promise.all(
          batch.map(async config => {
            try {
              const dateRange = this.getDateRangeForPreset(config.dateRangePreset);

              await this.widgetDataService.getBatchWidgetData(
                config.organizationId,
                config.userId,
                config.dashboard.widgets,
                dateRange,
              );
            } catch (error) {
              this.logger.error(
                `Failed to refresh dashboard ${config.dashboardId} for user ${config.userId}: ${error.message}`,
              );
            }
          }),
        );

        // Small delay between batches
        await new Promise(resolve => setTimeout(resolve, 100));
      }

      this.logger.log('Completed scheduled dashboard refresh');
    } catch (error) {
      this.logger.error(`Scheduled dashboard refresh failed: ${error.message}`);
    }
  }

  /**
   * Clean up expired cache entries daily.
   */
  @Cron(CronExpression.EVERY_DAY_AT_3AM)
  async cleanupExpiredCache() {
    this.logger.log('Starting cache cleanup');

    // Redis handles TTL automatically, but we can clean up any orphaned keys
    // This is primarily for logging/monitoring purposes

    try {
      // Log cache stats if available
      const stats = await this.getCacheStats();
      this.logger.log(`Cache stats: ${JSON.stringify(stats)}`);
    } catch (error) {
      this.logger.error(`Cache cleanup failed: ${error.message}`);
    }
  }

  /**
   * Invalidate cache for specific dashboard.
   * Called when dashboard config changes.
   */
  async invalidateDashboardCache(orgId: string, dashboardId: string): Promise<void> {
    const pattern = `widget:${orgId}:*:${dashboardId}:*`;
    // Note: Redis SCAN for pattern delete would go here
    // For cache-manager, we need to track keys or use Redis directly

    this.logger.log(`Invalidated cache for dashboard ${dashboardId}`);
  }

  /**
   * Pre-warm cache for new user.
   * Called when user first accesses dashboards.
   */
  async prewarmUserDashboards(orgId: string, userId: string): Promise<void> {
    const userConfigs = await this.prisma.userDashboardConfig.findMany({
      where: { organizationId: orgId, userId },
      include: {
        dashboard: { include: { widgets: true } },
      },
    });

    // Just the home dashboard for initial load
    const homeConfig = userConfigs.find(c => c.isHome);
    if (homeConfig) {
      const dateRange = this.getDateRangeForPreset(homeConfig.dateRangePreset);
      await this.widgetDataService.getBatchWidgetData(
        orgId,
        userId,
        homeConfig.dashboard.widgets,
        dateRange,
      );
    }
  }

  private getDateRangeForPreset(preset: DateRangePreset): DateRange {
    const now = new Date();
    switch (preset) {
      case 'TODAY': return { start: startOfDay(now), end: endOfDay(now) };
      case 'LAST_7_DAYS': return { start: subDays(now, 7), end: now };
      case 'LAST_90_DAYS': return { start: subDays(now, 90), end: now };
      case 'LAST_12_MONTHS': return { start: subMonths(now, 12), end: now };
      case 'YEAR_TO_DATE': return { start: startOfYear(now), end: now };
      case 'LAST_30_DAYS':
      default: return { start: subDays(now, 30), end: now };
    }
  }

  private async getCacheStats(): Promise<Record<string, unknown>> {
    // Implementation depends on cache backend
    return { status: 'ok' };
  }
}
```
  </action>
  <verify>npm run lint passes for the service file</verify>
  <done>ScheduledRefreshService pre-warms cache for popular dashboards and handles cleanup</done>
</task>

<task type="auto">
  <name>Task 3: Register controller and service in module</name>
  <files>apps/backend/src/modules/analytics/analytics.module.ts</files>
  <action>
Update AnalyticsModule to include new services:

```typescript
import { Module } from '@nestjs/common';
import { ScheduleModule } from '@nestjs/schedule';
import { CacheModule } from '@nestjs/cache-manager';
import { BullModule } from '@nestjs/bullmq';

// Dashboard
import { DashboardController } from './dashboard/dashboard.controller';
import { DashboardConfigService } from './dashboard/dashboard-config.service';
import { WidgetDataService } from './dashboard/widget-data.service';
import { ScheduledRefreshService } from './dashboard/scheduled-refresh.service';

// My Work
import { MyWorkController } from './my-work/my-work.controller';
import { TaskAggregatorService } from './my-work/task-aggregator.service';

// Exports
import { ExportsController } from './exports/exports.controller';
import { FlatFileService } from './exports/flat-file.service';
import { ExcelExportService } from './exports/excel-export.service';
import { PdfGeneratorService } from './exports/pdf-generator.service';
import { PptxGeneratorService } from './exports/pptx-generator.service';
import { BoardReportService } from './exports/board-report.service';
import { FlatExportProcessor } from './exports/processors/flat-export.processor';
import { EXPORT_QUEUE_NAME } from './exports/processors/flat-export.processor';

// AI Query
import { AiQueryController } from './ai-query/ai-query.controller';
import { AiQueryService } from './ai-query/ai-query.service';
import { QueryToPrismaService } from './ai-query/query-to-prisma.service';

// Migration
import { MigrationController } from './migration/migration.controller';
import { MigrationService } from './migration/migration.service';
import { NavexConnector } from './migration/connectors/navex.connector';
import { EqsConnector } from './migration/connectors/eqs.connector';
import { CsvConnector } from './migration/connectors/csv.connector';

@Module({
  imports: [
    ScheduleModule.forRoot(),
    CacheModule.register({
      ttl: 300, // 5 minutes default
      max: 1000,
    }),
    BullModule.registerQueue({
      name: EXPORT_QUEUE_NAME,
    }),
  ],
  controllers: [
    DashboardController,
    MyWorkController,
    ExportsController,
    AiQueryController,
    MigrationController,
  ],
  providers: [
    // Dashboard
    DashboardConfigService,
    WidgetDataService,
    ScheduledRefreshService,

    // My Work
    TaskAggregatorService,

    // Exports
    FlatFileService,
    ExcelExportService,
    PdfGeneratorService,
    PptxGeneratorService,
    BoardReportService,
    FlatExportProcessor,

    // AI Query
    AiQueryService,
    QueryToPrismaService,

    // Migration
    MigrationService,
    NavexConnector,
    EqsConnector,
    CsvConnector,
  ],
  exports: [
    DashboardConfigService,
    WidgetDataService,
    TaskAggregatorService,
    FlatFileService,
    AiQueryService,
    MigrationService,
  ],
})
export class AnalyticsModule {}
```
  </action>
  <verify>npm run lint && npm run typecheck passes</verify>
  <done>AnalyticsModule aggregates all dashboard, export, AI query, and migration services</done>
</task>

</tasks>

<verification>
```bash
cd apps/backend
npm run lint -- --fix
npm run typecheck
```
</verification>

<success_criteria>
- DashboardController exposes REST endpoints for all dashboard operations
- Batch widget data endpoints support efficient dashboard loading
- ScheduledRefreshService pre-warms cache for frequently-accessed dashboards
- AnalyticsModule properly aggregates all analytics services
</success_criteria>

<output>
After completion, create `.planning/phases/11-analytics-reporting/11-10-SUMMARY.md`
</output>
