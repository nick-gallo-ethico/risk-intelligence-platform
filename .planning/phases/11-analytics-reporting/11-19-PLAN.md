---
phase: 11-analytics-reporting
plan: 19
type: execute
wave: 4
depends_on: ["11-04", "11-15", "11-17"]
files_modified:
  - apps/backend/src/modules/analytics/migration/connectors/csv.connector.ts
  - apps/backend/src/modules/analytics/migration/mapping-suggestion.service.ts
autonomous: true

must_haves:
  truths:
    - "Generic CSV files can be imported with manual field mapping"
    - "Field mapping UI suggests likely mappings based on column names"
    - "Users can save mapping templates for reuse"
  artifacts:
    - path: "apps/backend/src/modules/analytics/migration/connectors/csv.connector.ts"
      provides: "Generic CSV import connector"
      min_lines: 100
    - path: "apps/backend/src/modules/analytics/migration/mapping-suggestion.service.ts"
      provides: "AI-powered field mapping suggestions"
      min_lines: 80
  key_links:
    - from: "csv.connector.ts"
      to: "base.connector"
      via: "extends BaseMigrationConnector"
      pattern: "extends BaseMigrationConnector"
---

<objective>
Build generic CSV import connector with intelligent field mapping.

Purpose: Enable migration from any CSV source with smart mapping suggestions (MIG-05).
Output: CsvConnector and MappingSuggestionService
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/11-analytics-reporting/11-CONTEXT.md
@.planning/phases/11-analytics-reporting/11-04-SUMMARY.md
@.planning/phases/11-analytics-reporting/11-15-SUMMARY.md
@.planning/phases/11-analytics-reporting/11-17-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MappingSuggestionService</name>
  <files>apps/backend/src/modules/analytics/migration/mapping-suggestion.service.ts</files>
  <action>
Create service for intelligent field mapping:

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../../../common/prisma/prisma.service';
import { FieldMappingDto, TargetEntityType } from './dto/migration.dto';
import { MigrationSourceType } from '@prisma/client';

// Known field synonyms for fuzzy matching
const FIELD_SYNONYMS: Record<string, string[]> = {
  // Case/RIU identifiers
  'sourceRecordId': ['id', 'case_id', 'case_number', 'report_id', 'incident_id', 'reference', 'ref', 'ticket'],
  'referenceNumber': ['case_number', 'case_ref', 'reference', 'ref_number', 'ticket_number'],

  // Dates
  'incidentDate': ['incident_date', 'date_of_incident', 'occurrence_date', 'event_date', 'when'],
  'createdAt': ['created_date', 'report_date', 'submitted_date', 'submission_date', 'opened_date'],
  'closedAt': ['closed_date', 'close_date', 'resolution_date', 'completed_date'],

  // Content
  'details': ['description', 'allegation', 'narrative', 'summary', 'incident_description', 'details', 'report_text', 'content'],
  'categoryName': ['category', 'incident_type', 'issue_type', 'type', 'classification', 'topic'],
  'severity': ['severity', 'priority', 'risk_level', 'urgency', 'criticality'],
  'status': ['status', 'state', 'case_status', 'current_status'],

  // Reporter
  'reporterType': ['reporter_type', 'anonymous', 'is_anonymous', 'reporter_relationship', 'contact_type'],

  // Location
  'locationName': ['location', 'location_name', 'site', 'office', 'country', 'region', 'facility'],
  'businessUnitName': ['business_unit', 'department', 'division', 'team', 'group', 'unit', 'area'],

  // Assignment
  'assignedToEmail': ['assigned_to', 'assignee', 'handler', 'investigator', 'owner', 'case_manager'],

  // Person
  'firstName': ['first_name', 'given_name', 'forename'],
  'lastName': ['last_name', 'surname', 'family_name'],
  'email': ['email', 'email_address', 'e_mail'],
  'phone': ['phone', 'phone_number', 'telephone', 'mobile'],

  // Resolution
  'resolution': ['resolution', 'outcome', 'findings', 'result', 'final_outcome', 'determination'],
};

// Platform target fields with their entity types
const TARGET_FIELDS: { field: string; entity: TargetEntityType; description: string }[] = [
  // RIU fields
  { field: 'sourceRecordId', entity: TargetEntityType.RIU, description: 'Original record identifier' },
  { field: 'details', entity: TargetEntityType.RIU, description: 'Incident description/narrative' },
  { field: 'categoryName', entity: TargetEntityType.RIU, description: 'Category or incident type' },
  { field: 'severity', entity: TargetEntityType.RIU, description: 'Severity or priority level' },
  { field: 'reporterType', entity: TargetEntityType.RIU, description: 'Reporter type (anonymous/confidential/identified)' },
  { field: 'incidentDate', entity: TargetEntityType.RIU, description: 'Date incident occurred' },
  { field: 'locationName', entity: TargetEntityType.RIU, description: 'Location or site name' },
  { field: 'businessUnitName', entity: TargetEntityType.RIU, description: 'Business unit or department' },

  // Case fields
  { field: 'referenceNumber', entity: TargetEntityType.CASE, description: 'Case reference number' },
  { field: 'status', entity: TargetEntityType.CASE, description: 'Current case status' },
  { field: 'assignedToEmail', entity: TargetEntityType.CASE, description: 'Assigned handler email' },
  { field: 'closedAt', entity: TargetEntityType.CASE, description: 'Date case was closed' },
  { field: 'resolution', entity: TargetEntityType.CASE, description: 'Resolution or outcome' },

  // Person fields
  { field: 'firstName', entity: TargetEntityType.PERSON, description: 'First/given name' },
  { field: 'lastName', entity: TargetEntityType.PERSON, description: 'Last/family name' },
  { field: 'email', entity: TargetEntityType.PERSON, description: 'Email address' },
  { field: 'phone', entity: TargetEntityType.PERSON, description: 'Phone number' },
];

export interface SuggestedMapping extends FieldMappingDto {
  confidence: number;
  reason: string;
}

@Injectable()
export class MappingSuggestionService {
  private readonly logger = new Logger(MappingSuggestionService.name);

  constructor(private prisma: PrismaService) {}

  /**
   * Suggest field mappings based on source column names.
   */
  async suggestMappings(
    orgId: string,
    sourceFields: string[],
    sampleData: Record<string, unknown>[],
    existingTemplate?: string,
  ): Promise<SuggestedMapping[]> {
    const suggestions: SuggestedMapping[] = [];

    // Load existing template if specified
    if (existingTemplate) {
      const template = await this.prisma.migrationFieldTemplate.findFirst({
        where: {
          organizationId: orgId,
          name: existingTemplate,
          sourceType: 'GENERIC_CSV',
        },
      });

      if (template) {
        return (template.mappings as unknown as SuggestedMapping[]).map(m => ({
          ...m,
          confidence: 100,
          reason: 'From saved template',
        }));
      }
    }

    for (const sourceField of sourceFields) {
      const suggestion = this.suggestMapping(sourceField, sampleData);
      if (suggestion) {
        suggestions.push(suggestion);
      }
    }

    return suggestions;
  }

  /**
   * Suggest mapping for a single field.
   */
  private suggestMapping(
    sourceField: string,
    sampleData: Record<string, unknown>[],
  ): SuggestedMapping | null {
    const normalized = this.normalizeFieldName(sourceField);

    // Try exact match first
    for (const [targetField, synonyms] of Object.entries(FIELD_SYNONYMS)) {
      if (synonyms.includes(normalized)) {
        const targetInfo = TARGET_FIELDS.find(t => t.field === targetField);
        if (targetInfo) {
          return {
            sourceField,
            targetField,
            targetEntity: targetInfo.entity,
            isRequired: ['sourceRecordId', 'details'].includes(targetField),
            transformFunction: this.inferTransform(targetField, sampleData, sourceField),
            confidence: 90,
            reason: `Exact match for "${sourceField}"`,
          };
        }
      }
    }

    // Try partial match
    for (const [targetField, synonyms] of Object.entries(FIELD_SYNONYMS)) {
      if (synonyms.some(s => normalized.includes(s) || s.includes(normalized))) {
        const targetInfo = TARGET_FIELDS.find(t => t.field === targetField);
        if (targetInfo) {
          return {
            sourceField,
            targetField,
            targetEntity: targetInfo.entity,
            isRequired: false,
            transformFunction: this.inferTransform(targetField, sampleData, sourceField),
            confidence: 70,
            reason: `Partial match for "${sourceField}"`,
          };
        }
      }
    }

    // Try data-type inference
    const inferredTarget = this.inferFromDataType(sourceField, sampleData);
    if (inferredTarget) {
      return inferredTarget;
    }

    return null;
  }

  /**
   * Infer mapping from data values.
   */
  private inferFromDataType(
    sourceField: string,
    sampleData: Record<string, unknown>[],
  ): SuggestedMapping | null {
    const values = sampleData
      .map(row => row[sourceField])
      .filter(v => v !== null && v !== undefined && v !== '');

    if (values.length === 0) return null;

    const sampleValue = String(values[0]);

    // Check for date patterns
    if (this.looksLikeDate(sampleValue)) {
      return {
        sourceField,
        targetField: 'incidentDate',
        targetEntity: TargetEntityType.RIU,
        isRequired: false,
        transformFunction: 'parseDate',
        confidence: 50,
        reason: 'Detected date values',
      };
    }

    // Check for email patterns
    if (this.looksLikeEmail(sampleValue)) {
      return {
        sourceField,
        targetField: 'assignedToEmail',
        targetEntity: TargetEntityType.CASE,
        isRequired: false,
        confidence: 60,
        reason: 'Detected email values',
      };
    }

    // Check for long text (likely description)
    const avgLength = values.reduce((sum, v) => sum + String(v).length, 0) / values.length;
    if (avgLength > 100) {
      return {
        sourceField,
        targetField: 'details',
        targetEntity: TargetEntityType.RIU,
        isRequired: false,
        confidence: 40,
        reason: 'Detected long text values',
      };
    }

    return null;
  }

  /**
   * Infer appropriate transform function.
   */
  private inferTransform(
    targetField: string,
    sampleData: Record<string, unknown>[],
    sourceField: string,
  ): string | undefined {
    const dateFields = ['incidentDate', 'createdAt', 'closedAt'];
    if (dateFields.includes(targetField)) {
      return 'parseDate';
    }

    if (targetField === 'categoryName') {
      return 'mapCategory';
    }

    if (targetField === 'status') {
      return 'mapStatus';
    }

    if (targetField === 'severity') {
      return 'mapSeverity';
    }

    return undefined;
  }

  /**
   * Normalize field name for comparison.
   */
  private normalizeFieldName(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '_')
      .replace(/^_|_$/g, '');
  }

  private looksLikeDate(value: string): boolean {
    return /^\d{4}-\d{2}-\d{2}/.test(value) ||
           /^\d{1,2}\/\d{1,2}\/\d{2,4}/.test(value) ||
           /^\d{1,2}-\d{1,2}-\d{2,4}/.test(value);
  }

  private looksLikeEmail(value: string): boolean {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);
  }

  /**
   * Get all available target fields.
   */
  getTargetFields(): typeof TARGET_FIELDS {
    return TARGET_FIELDS;
  }

  /**
   * Save mapping template for reuse.
   */
  async saveTemplate(
    orgId: string,
    userId: string,
    name: string,
    mappings: FieldMappingDto[],
  ): Promise<void> {
    await this.prisma.migrationFieldTemplate.upsert({
      where: {
        organizationId_sourceType_name: {
          organizationId: orgId,
          sourceType: 'GENERIC_CSV',
          name,
        },
      },
      create: {
        organizationId: orgId,
        name,
        sourceType: 'GENERIC_CSV',
        mappings: mappings as any,
        createdById: userId,
      },
      update: {
        mappings: mappings as any,
      },
    });
  }

  /**
   * List saved templates for org.
   */
  async listTemplates(orgId: string): Promise<{ name: string; fieldCount: number }[]> {
    const templates = await this.prisma.migrationFieldTemplate.findMany({
      where: { organizationId: orgId, sourceType: 'GENERIC_CSV' },
      select: { name: true, mappings: true },
    });

    return templates.map(t => ({
      name: t.name,
      fieldCount: Array.isArray(t.mappings) ? t.mappings.length : 0,
    }));
  }
}
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>MappingSuggestionService with fuzzy matching created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CsvConnector</name>
  <files>apps/backend/src/modules/analytics/migration/connectors/csv.connector.ts</files>
  <action>
Create generic CSV connector:

```typescript
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../../../common/prisma/prisma.service';
import { MigrationSourceType } from '@prisma/client';
import {
  BaseMigrationConnector,
  ConnectorCapabilities,
  TransformedRow,
} from './base.connector';
import { FieldMappingDto, TargetEntityType } from '../dto/migration.dto';

@Injectable()
export class CsvConnector extends BaseMigrationConnector {
  protected sourceType = MigrationSourceType.GENERIC_CSV;

  constructor(prisma: PrismaService) {
    super(prisma);
  }

  getCapabilities(): ConnectorCapabilities {
    // Generic CSV has no predefined fields
    return {
      supportedFields: [],
      defaultMappings: [],
      statusMappings: this.getGenericStatusMappings(),
      categoryMappings: this.getGenericCategoryMappings(),
    };
  }

  private getGenericStatusMappings(): Record<string, string> {
    return {
      'new': 'OPEN',
      'open': 'OPEN',
      'active': 'OPEN',
      'pending': 'PENDING_INFO',
      'in_progress': 'IN_PROGRESS',
      'investigating': 'IN_PROGRESS',
      'closed': 'CLOSED',
      'resolved': 'CLOSED',
      'complete': 'CLOSED',
      'completed': 'CLOSED',
    };
  }

  private getGenericCategoryMappings(): Record<string, string> {
    return {
      'harassment': 'HARASSMENT',
      'discrimination': 'DISCRIMINATION',
      'fraud': 'FRAUD',
      'theft': 'THEFT',
      'safety': 'SAFETY',
      'policy': 'POLICY_VIOLATION',
      'ethics': 'ETHICS_VIOLATION',
      'conflict': 'CONFLICT_OF_INTEREST',
      'retaliation': 'RETALIATION',
      'other': 'OTHER',
    };
  }

  validateRow(
    row: Record<string, unknown>,
    rowNumber: number,
  ): { isValid: boolean; errors: string[] } {
    // Generic CSV validation is minimal - just check row isn't empty
    const hasData = Object.values(row).some(v =>
      v !== null && v !== undefined && v !== '',
    );

    return {
      isValid: hasData,
      errors: hasData ? [] : ['Row appears to be empty'],
    };
  }

  transformRow(
    row: Record<string, unknown>,
    mappings: FieldMappingDto[],
    orgId: string,
  ): TransformedRow {
    const result: TransformedRow = {};

    // Group mappings by target entity
    const riuMappings = mappings.filter(m => m.targetEntity === TargetEntityType.RIU);
    const caseMappings = mappings.filter(m => m.targetEntity === TargetEntityType.CASE);
    const personMappings = mappings.filter(m => m.targetEntity === TargetEntityType.PERSON);
    const investigationMappings = mappings.filter(m => m.targetEntity === TargetEntityType.INVESTIGATION);

    // Build RIU if mappings exist
    if (riuMappings.length > 0) {
      result.riu = {
        type: 'web_form_submission',
        sourceChannel: 'migration',
        details: String(this.applyMapping(row, riuMappings, 'details') || ''),
        reporterType: String(this.applyMapping(row, riuMappings, 'reporterType') || 'anonymous'),
        sourceRecordId: String(this.applyMapping(row, riuMappings, 'sourceRecordId') || this.generateRowId(row)),
        categoryName: this.mapCategory(String(this.applyMapping(row, riuMappings, 'categoryName') || '')),
        severity: this.mapSeverity(String(this.applyMapping(row, riuMappings, 'severity') || 'medium')),
        incidentDate: this.parseDate(this.applyMapping(row, riuMappings, 'incidentDate')),
        locationName: String(this.applyMapping(row, riuMappings, 'locationName') || ''),
        businessUnitName: String(this.applyMapping(row, riuMappings, 'businessUnitName') || ''),
      };
    }

    // Build Case if mappings exist
    if (caseMappings.length > 0) {
      result.case = {
        referenceNumber: String(this.applyMapping(row, caseMappings, 'referenceNumber') || ''),
        status: this.mapStatus(String(this.applyMapping(row, caseMappings, 'status') || 'open')),
        assignedToEmail: String(this.applyMapping(row, caseMappings, 'assignedToEmail') || ''),
        closedAt: this.parseDate(this.applyMapping(row, caseMappings, 'closedAt')),
        resolution: String(this.applyMapping(row, caseMappings, 'resolution') || ''),
      };
    }

    // Build Person if mappings exist
    if (personMappings.length > 0) {
      const firstName = this.applyMapping(row, personMappings, 'firstName');
      const lastName = this.applyMapping(row, personMappings, 'lastName');

      if (firstName || lastName) {
        result.person = {
          firstName: String(firstName || ''),
          lastName: String(lastName || ''),
          email: String(this.applyMapping(row, personMappings, 'email') || ''),
          phone: String(this.applyMapping(row, personMappings, 'phone') || ''),
          role: 'subject',
        };
      }
    }

    // Build Investigation if mappings exist
    if (investigationMappings.length > 0) {
      const status = this.applyMapping(row, investigationMappings, 'status');
      if (status) {
        result.investigation = {
          status: this.mapStatus(String(status)),
          findings: String(this.applyMapping(row, investigationMappings, 'findings') || ''),
          assignedToEmail: String(this.applyMapping(row, investigationMappings, 'assignedToEmail') || ''),
        };
      }
    }

    return result;
  }

  protected mapCategory(value: string): string {
    if (!value) return 'OTHER';
    const normalized = value.toLowerCase().trim();

    // Try exact match
    const mappings = this.getGenericCategoryMappings();
    if (mappings[normalized]) {
      return mappings[normalized];
    }

    // Try partial match
    for (const [key, mapped] of Object.entries(mappings)) {
      if (normalized.includes(key)) {
        return mapped;
      }
    }

    return 'OTHER';
  }

  protected mapStatus(value: string): string {
    if (!value) return 'OPEN';
    const normalized = value.toLowerCase().trim().replace(/[\s-]/g, '_');

    const mappings = this.getGenericStatusMappings();
    if (mappings[normalized]) {
      return mappings[normalized];
    }

    // Try partial match
    for (const [key, mapped] of Object.entries(mappings)) {
      if (normalized.includes(key)) {
        return mapped;
      }
    }

    return 'OPEN';
  }

  /**
   * Generate a unique ID for rows without identifiers.
   */
  private generateRowId(row: Record<string, unknown>): string {
    // Create hash from row content
    const content = JSON.stringify(row);
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return `CSV-${Math.abs(hash).toString(16).toUpperCase()}`;
  }
}
```
  </action>
  <verify>npm run lint && npm run typecheck passes</verify>
  <done>CsvConnector with flexible field mapping implemented</done>
</task>

</tasks>

<verification>
```bash
cd apps/backend
npm run lint -- --fix
npm run typecheck
```
</verification>

<success_criteria>
- MappingSuggestionService suggests mappings with confidence scores
- CsvConnector handles any CSV structure based on user mappings
- Mapping templates can be saved and reused
- Generic category and status mappings cover common values
- Row IDs generated for records without identifiers
</success_criteria>

<output>
After completion, create `.planning/phases/11-analytics-reporting/11-19-SUMMARY.md`
</output>
