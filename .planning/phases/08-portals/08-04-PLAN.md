---
phase: 08-portals
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/src/modules/portals/employee/employee-tasks.service.ts
  - apps/backend/src/modules/portals/employee/employee-portal.controller.ts
  - apps/backend/src/modules/portals/employee/employee-portal.module.ts
  - apps/backend/src/modules/portals/employee/types/employee-task.types.ts
autonomous: true

must_haves:
  truths:
    - "Employee sees all pending tasks in unified list (attestations, disclosures, approvals, follow-ups)"
    - "Overdue tasks appear at top of list with warning indicators"
    - "Employee sees task count badges showing pending and overdue numbers"
    - "Each task shows due date, type icon, and action button"
  artifacts:
    - path: "apps/backend/src/modules/portals/employee/employee-tasks.service.ts"
      provides: "EmployeeTasksService aggregating tasks from multiple sources"
      exports: ["EmployeeTasksService"]
    - path: "apps/backend/src/modules/portals/employee/types/employee-task.types.ts"
      provides: "EmployeeTask interface with source-agnostic structure"
      exports: ["EmployeeTask", "TaskType", "TaskStatus"]
  key_links:
    - from: "EmployeeTasksService"
      to: "CampaignAssignment"
      via: "Prisma query"
      pattern: "prisma\\.campaignAssignment\\.findMany"
    - from: "EmployeeTasksService"
      to: "RemediationStep"
      via: "Prisma query"
      pattern: "prisma\\.remediationStep\\.findMany"
---

<objective>
Create the employee tasks aggregation service that unifies pending tasks from attestations, disclosures, remediation plans, and report follow-ups into a single "My Tasks" view.

Purpose: Employees need one place to see all compliance-related tasks with due dates and priority.
Output: EmployeeTasksService with aggregation, filtering, and task counts.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-portals/08-CONTEXT.md
@.planning/phases/04-core-entities/04-08-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EmployeeTask types and enums</name>
  <files>
    apps/backend/src/modules/portals/employee/types/employee-task.types.ts
  </files>
  <action>
Create types file with:

TaskType enum:
- ATTESTATION: Policy acknowledgment
- DISCLOSURE: COI, gift, or other disclosure form
- APPROVAL: Approval request (e.g., disclosure approval for managers)
- REPORT_FOLLOW_UP: Anonymous reporter communication
- REMEDIATION_STEP: Assigned remediation action

TaskStatus enum:
- PENDING: Not started
- OVERDUE: Past due date
- IN_PROGRESS: Started but not complete
- COMPLETED: Done

EmployeeTask interface:
- id: string (unique across all task types)
- type: TaskType
- status: TaskStatus
- title: string (human-readable task name)
- description?: string (brief context)
- dueDate?: Date
- createdAt: Date
- sourceId: string (ID of underlying entity)
- sourceType: string (e.g., "CampaignAssignment", "RemediationStep")
- metadata?: Record<string, unknown> (type-specific data)
- actionUrl: string (deep link to complete task)

TaskCounts interface:
- total: number
- pending: number
- overdue: number
- completed: number (recent, last 7 days)

TaskFilters interface:
- types?: TaskType[]
- status?: TaskStatus[]
- dueBefore?: Date
- dueAfter?: Date
  </action>
  <verify>npm run build -- --filter=backend</verify>
  <done>Task types compile and define all necessary interfaces</done>
</task>

<task type="auto">
  <name>Task 2: Create EmployeeTasksService with aggregation</name>
  <files>
    apps/backend/src/modules/portals/employee/employee-tasks.service.ts
  </files>
  <action>
Create EmployeeTasksService with methods:

1. getMyTasks(userId: string, organizationId: string, filters?: TaskFilters): Promise<EmployeeTask[]>
   - Aggregate tasks from all sources in parallel:
     a) CampaignAssignments (attestations/disclosures): status IN (PENDING, OVERDUE)
     b) RemediationSteps: assigneeUserId = userId, status IN (NOT_STARTED, IN_PROGRESS)
     c) ApprovalRequests: If user is approver, status = PENDING (build this query based on existing models)
   - Map each source to EmployeeTask interface
   - Merge and sort: overdue first, then by dueDate ASC
   - Apply filters if provided
   - Return unified list

2. getTaskCounts(userId: string, organizationId: string): Promise<TaskCounts>
   - Run count queries in parallel for efficiency
   - Return totals by status

3. markTaskCompleted(userId: string, taskId: string): Promise<void>
   - Parse taskId to determine source type (e.g., "attestation-{id}")
   - Route to appropriate service for completion
   - This is a thin wrapper - actual completion logic in source services

Private mapper methods:
- mapAttestationToTask(assignment: CampaignAssignment): EmployeeTask
- mapDisclosureToTask(assignment: CampaignAssignment): EmployeeTask
- mapRemediationStepToTask(step: RemediationStep): EmployeeTask
- mapApprovalToTask(request: ApprovalRequest): EmployeeTask

Helper:
- calculateStatus(dueDate: Date | null, isComplete: boolean): TaskStatus

Dependencies:
- PrismaService for queries
- No external API calls - all data from database
  </action>
  <verify>npm run build -- --filter=backend</verify>
  <done>EmployeeTasksService compiles with aggregation and count methods</done>
</task>

<task type="auto">
  <name>Task 3: Create EmployeePortalController with task endpoints</name>
  <files>
    apps/backend/src/modules/portals/employee/employee-portal.controller.ts
    apps/backend/src/modules/portals/employee/employee-portal.module.ts
    apps/backend/src/modules/portals/portals.module.ts
  </files>
  <action>
Create EmployeePortalController with endpoints:

1. GET /api/v1/employee/tasks
   - Requires authenticated user
   - Returns paginated EmployeeTask[]
   - Query params: types (comma-separated), status, dueBefore, dueAfter, page, limit

2. GET /api/v1/employee/tasks/counts
   - Requires authenticated user
   - Returns TaskCounts for badge display

3. GET /api/v1/employee/tasks/:taskId
   - Requires authenticated user
   - Returns single task detail with full metadata

4. POST /api/v1/employee/tasks/:taskId/complete
   - Requires authenticated user
   - Marks task as completed (delegates to source service)
   - Returns updated task

Create EmployeePortalModule:
- Import PrismaModule, CampaignsModule (for assignment service)
- Provide EmployeeTasksService
- Register EmployeePortalController
- Export EmployeeTasksService

Create PortalsModule (parent module):
- Import EmployeePortalModule, OperatorPortalModule (from 08-02/03)
- Export both for use by app.module

Register PortalsModule in app.module.ts.
  </action>
  <verify>npm run build -- --filter=backend</verify>
  <done>EmployeePortalController has all endpoints, module hierarchy created</done>
</task>

</tasks>

<verification>
1. Run `npm run build -- --filter=backend` to verify compilation
2. Run `npm test -- --testPathPattern=employee-tasks` to verify unit tests
3. Verify task aggregation includes all source types
4. Verify sorting: overdue first, then by dueDate
</verification>

<success_criteria>
- EmployeeTask interface unifies tasks from multiple sources
- EmployeeTasksService aggregates from campaigns, remediation, approvals
- Tasks sorted with overdue items first
- TaskCounts endpoint returns badge-ready counts
- All endpoints require authentication
</success_criteria>

<output>
After completion, create `.planning/phases/08-portals/08-04-SUMMARY.md`
</output>
