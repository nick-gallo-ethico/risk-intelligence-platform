---
phase: 08-portals
plan: 07
type: execute
wave: 2
depends_on: ["08-02", "08-03"]
files_modified:
  - apps/backend/src/modules/portals/operator/intake.service.ts
  - apps/backend/src/modules/portals/operator/intake.controller.ts
  - apps/backend/src/modules/portals/operator/qa-queue.service.ts
  - apps/backend/src/modules/portals/operator/qa-queue.controller.ts
  - apps/backend/src/modules/portals/operator/dto/intake.dto.ts
autonomous: true

must_haves:
  truths:
    - "Operators can create RIUs from hotline calls"
    - "RIU type can be REPORT, REQUEST_FOR_INFO, or WRONG_NUMBER"
    - "QA queue shows items sorted by severity with high-risk first"
    - "QA reviewers can edit and release RIUs"
    - "Operators can look up existing cases by access code for follow-up calls"
  artifacts:
    - path: "apps/backend/src/modules/portals/operator/intake.service.ts"
      provides: "IntakeService for creating RIUs from calls"
      exports: ["IntakeService"]
    - path: "apps/backend/src/modules/portals/operator/qa-queue.service.ts"
      provides: "QaQueueService for queue management"
      exports: ["QaQueueService"]
  key_links:
    - from: "IntakeService"
      to: "RiusService"
      via: "dependency injection"
      pattern: "riusService\\.create"
    - from: "IntakeService"
      to: "ClientProfileService"
      via: "QA check"
      pattern: "clientProfileService\\.requiresQaReview"
---

<objective>
Create the Operator Console API for hotline intake and QA review workflow - handling call-based RIU creation and quality assurance processing.

Purpose: Operators need to create RIUs from phone calls and QA reviewers need to process high-priority items.
Output: IntakeService for RIU creation and QaQueueService for queue management.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-portals/08-CONTEXT.md
@.planning/phases/04-core-entities/04-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IntakeService for hotline RIU creation</name>
  <files>
    apps/backend/src/modules/portals/operator/intake.service.ts
    apps/backend/src/modules/portals/operator/dto/intake.dto.ts
    apps/backend/src/modules/portals/operator/types/intake.types.ts
  </files>
  <action>
Create IntakeService with methods:

1. createHotlineRiu(operatorId: string, clientId: string, dto: CreateIntakeDto): Promise<IntakeResult>
   - Validate client exists and operator has access
   - Determine RIU type from dto.riuType (REPORT, REQUEST_FOR_INFO, WRONG_NUMBER)
   - Create RIU via RiusService with:
     - source: HOTLINE
     - type: mapped from riuType
     - organizationId: clientId
     - createdById: operatorId
   - Create HotlineRiuExtension with:
     - callerPhoneNumber (optional, for callback)
     - callDuration
     - operatorNotes
   - Check QA requirements via ClientProfileService.requiresQaReview()
   - Set QA status accordingly (PENDING or APPROVED)
   - Generate access code if anonymous
   - Emit hotline.riu_created event
   - Return IntakeResult with riuId, referenceNumber, accessCode?, requiresQa

2. updateIntake(operatorId: string, riuId: string, dto: UpdateIntakeDto): Promise<RIU>
   - Only allowed while QA status is PENDING or IN_REVIEW by same operator
   - Update RIU fields and extension
   - Log update to audit

3. submitToQa(operatorId: string, riuId: string): Promise<void>
   - Mark as ready for QA review
   - Set qaStatus to PENDING
   - Emit hotline.submitted_to_qa event

4. getOperatorQueue(operatorId: string): Promise<IntakeSummary[]>
   - Return RIUs created by operator that are still in progress
   - Include: riuId, clientName, category, createdAt, qaStatus

5. lookupByAccessCode(operatorId: string, accessCode: string): Promise<FollowUpContext>
   - OPER-08: Support operators handling follow-up calls from reporters
   - Validate access code and return RIU context
   - Return: riuId, caseId (if exists), referenceNumber, category, clientName, status, messageCount, lastMessageAt
   - Allow operator to view message thread and add notes
   - Emit hotline.follow_up_accessed event for audit

6. addFollowUpNote(operatorId: string, riuId: string, dto: FollowUpNoteDto): Promise<void>
   - OPER-08: Add operator note during follow-up call
   - Create internal note (not message to reporter)
   - Track call duration and disposition

Create DTOs:
- CreateIntakeDto: clientId, riuType, categoryId?, content, callerPhoneNumber?, anonymityTier, subjectPersonId?, callDuration, urgencyFlag?
- UpdateIntakeDto: Partial<CreateIntakeDto>

Create types:
- IntakeResult: riuId, referenceNumber, accessCode?, requiresQa, qaStatus
- IntakeSummary: riuId, clientName, category, createdAt, qaStatus
- RiuTypeFromCall enum: REPORT, REQUEST_FOR_INFO, WRONG_NUMBER
- FollowUpContext: riuId, caseId?, referenceNumber, category, clientName, status, messageCount, lastMessageAt
- FollowUpNoteDto: content, callDuration, disposition (CALLBACK_SCHEDULED, INFO_PROVIDED, ESCALATED, CLOSED)
  </action>
  <verify>npm run build -- --filter=backend</verify>
  <done>IntakeService compiles with RIU creation and QA submission</done>
</task>

<task type="auto">
  <name>Task 2: Create QaQueueService for review workflow</name>
  <files>
    apps/backend/src/modules/portals/operator/qa-queue.service.ts
    apps/backend/src/modules/portals/operator/types/qa-queue.types.ts
  </files>
  <action>
Create QaQueueService with methods (building on RESEARCH.md pattern):

1. getQaQueue(filters: QaQueueFilters): Promise<PaginatedResult<QaQueueItem>>
   - Query RiuHotlineExtension where qaStatus = PENDING
   - Join RIU for severity, category, client info
   - Sort by: severity DESC, createdAt ASC (high severity, oldest first)
   - Apply filters: clientId, severityMin, operatorId, dateRange
   - Return QaQueueItem with position, flags

2. claimForReview(reviewerId: string, riuId: string): Promise<void>
   - Set qaStatus to IN_REVIEW
   - Set qaReviewerId to reviewer
   - Set qaClaimedAt timestamp
   - Emit qa.claimed event

3. releaseFromQa(reviewerId: string, riuId: string, edits?: QaEditsDto): Promise<void>
   - Apply edits if provided (summary, categoryId, severityScore)
   - Set qaStatus to RELEASED
   - Set qaReviewedAt timestamp
   - Emit qa.released event for downstream Case creation

4. rejectToOperator(reviewerId: string, riuId: string, reason: string): Promise<void>
   - Set qaStatus to REJECTED
   - Store rejection reason
   - Emit qa.rejected event (notify operator)

5. getItemDetail(riuId: string): Promise<QaItemDetail>
   - Return full RIU with extension, operator notes, attachments
   - Include edit history if any prior QA touches

6. abandonClaim(reviewerId: string, riuId: string): Promise<void>
   - Reset qaStatus to PENDING
   - Clear qaReviewerId
   - Emit qa.abandoned event

Create types:
- QaQueueFilters: clientId?, severityMin?, operatorId?, dateFrom?, dateTo?, page, limit
- QaQueueItem: riuId, referenceNumber, category, severityScore, clientName, operatorName, createdAt, flags[]
- QaItemDetail: full RIU + extension + attachments + history
- QaEditsDto: summary?, categoryId?, severityScore?, editNotes?
  </action>
  <verify>npm run build -- --filter=backend</verify>
  <done>QaQueueService compiles with queue and workflow methods</done>
</task>

<task type="auto">
  <name>Task 3: Create Intake and QA controllers</name>
  <files>
    apps/backend/src/modules/portals/operator/intake.controller.ts
    apps/backend/src/modules/portals/operator/qa-queue.controller.ts
    apps/backend/src/modules/portals/operator/operator-portal.module.ts
  </files>
  <action>
Create IntakeController with endpoints:

1. POST /api/v1/operator/intake
   - Requires OPERATOR role
   - Body: CreateIntakeDto
   - Returns IntakeResult

2. PUT /api/v1/operator/intake/:riuId
   - Requires OPERATOR role
   - Body: UpdateIntakeDto

3. POST /api/v1/operator/intake/:riuId/submit-qa
   - Requires OPERATOR role
   - Submits to QA queue

4. GET /api/v1/operator/my-queue
   - Requires OPERATOR role
   - Returns operator's in-progress RIUs

5. GET /api/v1/operator/follow-up/:accessCode
   - OPER-08: Lookup existing case by access code for follow-up calls
   - Requires OPERATOR role
   - Returns FollowUpContext with RIU/case details
   - Rate limit: 10/min

6. POST /api/v1/operator/follow-up/:riuId/note
   - OPER-08: Add follow-up note during callback
   - Requires OPERATOR role
   - Body: FollowUpNoteDto
   - Creates internal note, not reporter message

Create QaQueueController with endpoints:

5. GET /api/v1/operator/qa-queue
   - Requires QA_REVIEWER or SYSTEM_ADMIN role
   - Query: filters (clientId, severityMin, etc.)
   - Returns paginated QaQueueItem[]

6. POST /api/v1/operator/qa-queue/:riuId/claim
   - Requires QA_REVIEWER role
   - Claims item for review

7. GET /api/v1/operator/qa-queue/:riuId
   - Requires QA_REVIEWER role
   - Returns QaItemDetail

8. POST /api/v1/operator/qa-queue/:riuId/release
   - Requires QA_REVIEWER role
   - Body: QaEditsDto (optional)
   - Releases from QA

9. POST /api/v1/operator/qa-queue/:riuId/reject
   - Requires QA_REVIEWER role
   - Body: { reason: string }
   - Rejects back to operator

10. POST /api/v1/operator/qa-queue/:riuId/abandon
    - Requires QA_REVIEWER role
    - Abandons claim

Update OperatorPortalModule:
- Add IntakeService, QaQueueService providers
- Register both controllers
- Export services
  </action>
  <verify>npm run build -- --filter=backend</verify>
  <done>IntakeController and QaQueueController have all endpoints</done>
</task>

</tasks>

<verification>
1. Run `npm run build -- --filter=backend` to verify compilation
2. Verify intake creates RIU with HotlineRiuExtension
3. Verify QA queue sorts by severity DESC
4. Verify claim/release workflow updates qaStatus correctly
</verification>

<success_criteria>
- Operators can create REPORT, REQUEST_FOR_INFO, or WRONG_NUMBER RIUs
- QA check determines if RIU goes to queue
- QA queue shows high-severity items first
- QA reviewers can claim, edit, release, or reject
- Abandoned claims return to queue
</success_criteria>

<output>
After completion, create `.planning/phases/08-portals/08-07-SUMMARY.md`
</output>
