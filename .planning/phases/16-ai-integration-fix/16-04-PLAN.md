---
phase: 16-ai-integration-fix
plan: 04
type: execute
wave: 3
depends_on: [16-02]
files_modified:
  - apps/frontend/src/hooks/useAiSkills.ts
  - apps/frontend/src/components/ai/ai-summary-button.tsx
  - apps/frontend/src/components/ai/ai-category-suggest.tsx
  - apps/frontend/src/components/ai/ai-risk-score.tsx
  - apps/backend/src/modules/ai/skills/skill.registry.ts
autonomous: true

must_haves:
  truths:
    - "useAiSkills hook provides executeSkill function that calls POST /ai/skills/:skillId/execute"
    - "AI summary button triggers the summarize skill and displays result"
    - "AI category suggestion component calls category-suggest skill during RIU intake"
    - "AI risk score component calls risk-score skill and shows confidence-scored result"
    - "All complete but unregistered skills (e.g., triage) are evaluated and registered or documented with TODO"
  artifacts:
    - path: "apps/frontend/src/hooks/useAiSkills.ts"
      provides: "Generic skill execution hook"
      contains: "/ai/skills/"
    - path: "apps/frontend/src/components/ai/ai-summary-button.tsx"
      provides: "Trigger AI summary generation on cases/investigations"
      contains: "summarize"
    - path: "apps/frontend/src/components/ai/ai-category-suggest.tsx"
      provides: "Category suggestion during intake"
      contains: "category-suggest"
    - path: "apps/frontend/src/components/ai/ai-risk-score.tsx"
      provides: "Risk score display with confidence"
      contains: "risk-score"
  key_links:
    - from: "useAiSkills.ts"
      to: "POST /api/v1/ai/skills/:skillId/execute"
      via: "apiClient.post(`/ai/skills/${skillId}/execute`, { input })"
      pattern: "/ai/skills/"
    - from: "ai-summary-button.tsx"
      to: "useAiSkills.ts"
      via: "executeSkill('summarize', { content, entityType, entityId })"
      pattern: "summarize"
---

<objective>
Create frontend components for AI skills (summarize, category-suggest, risk-score) that correctly call the existing backend skill endpoints. Also register the triage skill on the backend if it's complete.

Purpose: The backend has 5 working skills but only note-cleanup has a frontend integration. This plan creates reusable components for the other critical skills.
Output: Working AI skill components for summaries, category suggestions, and risk scoring.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/16-ai-integration-fix/16-RESEARCH.md

Key files to read:
@apps/frontend/src/hooks/useAiNoteCleanup.ts (working pattern to follow)
@apps/backend/src/modules/ai/skills/skill.registry.ts (registered skills)
@apps/backend/src/modules/ai/skills/platform/summarize.skill.ts (skill input schema)
@apps/backend/src/modules/ai/skills/platform/category-suggest.skill.ts
@apps/backend/src/modules/ai/skills/platform/risk-score.skill.ts
@apps/backend/src/modules/ai/skills/triage.skill.ts (check if complete for registration)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useAiSkills generic hook</name>
  <files>apps/frontend/src/hooks/useAiSkills.ts</files>
  <action>
Create a generic hook for executing any AI skill, following the pattern from useAiNoteCleanup.ts:

```typescript
import { useState, useCallback } from 'react';
import { apiClient } from '@/lib/api-client'; // match existing import path

interface UseAiSkillReturn<T = any> {
  execute: (skillId: string, input: Record<string, any>) => Promise<T | null>;
  isLoading: boolean;
  error: string | null;
  result: T | null;
  clearResult: () => void;
}

export function useAiSkills<T = any>(): UseAiSkillReturn<T> {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [result, setResult] = useState<T | null>(null);

  const execute = useCallback(async (skillId: string, input: Record<string, any>): Promise<T | null> => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await apiClient.post(`/ai/skills/${skillId}/execute`, { input });
      const data = response.data;

      if (data.success) {
        setResult(data.data);
        return data.data;
      } else {
        setError(data.error || `Skill ${skillId} failed`);
        return null;
      }
    } catch (err: any) {
      const errorMessage = err?.response?.data?.message || err?.message || 'AI skill execution failed';
      setError(errorMessage);
      return null;
    } finally {
      setIsLoading(false);
    }
  }, []);

  const clearResult = useCallback(() => {
    setResult(null);
    setError(null);
  }, []);

  return { execute, isLoading, error, result, clearResult };
}
```

Match the API client import from useAiNoteCleanup.ts exactly.
  </action>
  <verify>
TypeScript compiles. Hook exports execute, isLoading, error, result.
  </verify>
  <done>
Generic useAiSkills hook created for executing any registered skill.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AI summary button component</name>
  <files>apps/frontend/src/components/ai/ai-summary-button.tsx</files>
  <action>
Create a reusable component for generating AI summaries on cases and investigations:

```typescript
import React, { useState } from 'react';
import { Button } from '@/components/ui/button'; // match shadcn/ui pattern
import { useAiSkills } from '@/hooks/useAiSkills';
import { Sparkles, Loader2 } from 'lucide-react';

interface AiSummaryButtonProps {
  content: string;        // The text content to summarize
  entityType: string;     // 'case' | 'investigation'
  entityId: string;
  length?: 'brief' | 'standard' | 'detailed';
  onSummaryGenerated?: (summary: string) => void;
  className?: string;
}

export function AiSummaryButton({
  content,
  entityType,
  entityId,
  length = 'standard',
  onSummaryGenerated,
  className,
}: AiSummaryButtonProps) {
  const { execute, isLoading, error } = useAiSkills<{ summary: string }>();
  const [summary, setSummary] = useState<string | null>(null);

  const handleGenerate = async () => {
    const result = await execute('summarize', {
      content,
      entityType,
      entityId,
      length,
    });
    if (result?.summary) {
      setSummary(result.summary);
      onSummaryGenerated?.(result.summary);
    }
  };

  return (
    <div className={className}>
      <Button
        variant="outline"
        size="sm"
        onClick={handleGenerate}
        disabled={isLoading || !content}
      >
        {isLoading ? (
          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
        ) : (
          <Sparkles className="mr-2 h-4 w-4" />
        )}
        {isLoading ? 'Generating...' : 'AI Summary'}
      </Button>
      {error && <p className="text-sm text-destructive mt-1">{error}</p>}
      {summary && (
        <div className="mt-2 p-3 bg-muted rounded-md text-sm">
          {summary}
        </div>
      )}
    </div>
  );
}
```

Read the summarize.skill.ts to verify the exact input schema and response shape.
  </action>
  <verify>
Component exists and TypeScript compiles.
  </verify>
  <done>
AiSummaryButton component created for triggering AI summaries on entities.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create AI category suggestion component</name>
  <files>apps/frontend/src/components/ai/ai-category-suggest.tsx</files>
  <action>
Create a component for AI-powered category suggestions during RIU intake:

```typescript
import React, { useEffect, useState } from 'react';
import { useAiSkills } from '@/hooks/useAiSkills';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Sparkles, Loader2, Check } from 'lucide-react';

interface CategorySuggestion {
  categoryId: string;
  categoryName: string;
  confidence: number;
  reason?: string;
}

interface AiCategorySuggestProps {
  content: string;          // RIU description/content
  onCategorySelect?: (categoryId: string) => void;
  autoSuggest?: boolean;    // Auto-trigger when content changes
  className?: string;
}

export function AiCategorySuggest({
  content,
  onCategorySelect,
  autoSuggest = false,
  className,
}: AiCategorySuggestProps) {
  const { execute, isLoading, error } = useAiSkills<{ suggestions: CategorySuggestion[] }>();
  const [suggestions, setSuggestions] = useState<CategorySuggestion[]>([]);

  const handleSuggest = async () => {
    if (!content || content.length < 20) return;
    const result = await execute('category-suggest', { content });
    if (result?.suggestions) {
      setSuggestions(result.suggestions);
    }
  };

  // Auto-suggest with debounce when content changes
  useEffect(() => {
    if (!autoSuggest || !content || content.length < 50) return;
    const timer = setTimeout(handleSuggest, 1000);
    return () => clearTimeout(timer);
  }, [content, autoSuggest]);

  if (!content) return null;

  return (
    <div className={className}>
      {!autoSuggest && (
        <Button
          variant="ghost"
          size="sm"
          onClick={handleSuggest}
          disabled={isLoading || content.length < 20}
        >
          {isLoading ? (
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          ) : (
            <Sparkles className="mr-2 h-4 w-4" />
          )}
          Suggest Category
        </Button>
      )}
      {isLoading && autoSuggest && (
        <div className="flex items-center gap-2 text-sm text-muted-foreground">
          <Loader2 className="h-3 w-3 animate-spin" />
          Analyzing...
        </div>
      )}
      {error && <p className="text-sm text-destructive">{error}</p>}
      {suggestions.length > 0 && (
        <div className="flex flex-wrap gap-2 mt-2">
          {suggestions.map((s) => (
            <Badge
              key={s.categoryId}
              variant={s.confidence > 0.8 ? 'default' : 'secondary'}
              className="cursor-pointer hover:bg-primary/80"
              onClick={() => onCategorySelect?.(s.categoryId)}
            >
              <Check className="mr-1 h-3 w-3" />
              {s.categoryName} ({Math.round(s.confidence * 100)}%)
            </Badge>
          ))}
        </div>
      )}
    </div>
  );
}
```

Read category-suggest.skill.ts to verify exact input/output schema.
  </action>
  <verify>
Component exists and TypeScript compiles.
  </verify>
  <done>
AiCategorySuggest component created for category suggestions during RIU intake.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create AI risk score component</name>
  <files>apps/frontend/src/components/ai/ai-risk-score.tsx</files>
  <action>
Create a component for displaying AI-generated risk scores:

```typescript
import React, { useState } from 'react';
import { useAiSkills } from '@/hooks/useAiSkills';
import { Button } from '@/components/ui/button';
import { Sparkles, Loader2, AlertTriangle, Shield, ShieldAlert } from 'lucide-react';
import { cn } from '@/lib/utils';

interface RiskScoreResult {
  score: number;          // 0-100
  level: 'low' | 'medium' | 'high' | 'critical';
  confidence: number;     // 0-1
  factors: string[];
  recommendation?: string;
}

interface AiRiskScoreProps {
  content: string;
  entityType: string;
  entityId: string;
  onScoreGenerated?: (result: RiskScoreResult) => void;
  className?: string;
}

export function AiRiskScore({
  content,
  entityType,
  entityId,
  onScoreGenerated,
  className,
}: AiRiskScoreProps) {
  const { execute, isLoading, error } = useAiSkills<RiskScoreResult>();
  const [result, setResult] = useState<RiskScoreResult | null>(null);

  const handleScore = async () => {
    const data = await execute('risk-score', {
      content,
      entityType,
      entityId,
    });
    if (data) {
      setResult(data);
      onScoreGenerated?.(data);
    }
  };

  const getLevelColor = (level: string) => {
    switch (level) {
      case 'low': return 'text-green-600 bg-green-50';
      case 'medium': return 'text-yellow-600 bg-yellow-50';
      case 'high': return 'text-orange-600 bg-orange-50';
      case 'critical': return 'text-red-600 bg-red-50';
      default: return 'text-gray-600 bg-gray-50';
    }
  };

  const getLevelIcon = (level: string) => {
    switch (level) {
      case 'low': return <Shield className="h-4 w-4" />;
      case 'medium': return <AlertTriangle className="h-4 w-4" />;
      case 'high':
      case 'critical': return <ShieldAlert className="h-4 w-4" />;
      default: return <Shield className="h-4 w-4" />;
    }
  };

  return (
    <div className={className}>
      {!result && (
        <Button
          variant="outline"
          size="sm"
          onClick={handleScore}
          disabled={isLoading || !content}
        >
          {isLoading ? (
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          ) : (
            <Sparkles className="mr-2 h-4 w-4" />
          )}
          {isLoading ? 'Scoring...' : 'AI Risk Score'}
        </Button>
      )}
      {error && <p className="text-sm text-destructive mt-1">{error}</p>}
      {result && (
        <div className={cn('rounded-lg p-3 mt-2', getLevelColor(result.level))}>
          <div className="flex items-center gap-2 font-medium">
            {getLevelIcon(result.level)}
            Risk: {result.level.toUpperCase()} ({result.score}/100)
            <span className="text-xs opacity-70">
              {Math.round(result.confidence * 100)}% confidence
            </span>
          </div>
          {result.factors.length > 0 && (
            <ul className="mt-2 text-sm space-y-1">
              {result.factors.map((f, i) => (
                <li key={i}>• {f}</li>
              ))}
            </ul>
          )}
          {result.recommendation && (
            <p className="mt-2 text-sm italic">{result.recommendation}</p>
          )}
        </div>
      )}
    </div>
  );
}
```

Read risk-score.skill.ts to verify exact response shape.
  </action>
  <verify>
Component exists and TypeScript compiles.
  </verify>
  <done>
AiRiskScore component displays AI risk assessments with confidence scores and risk factors.
  </done>
</task>

<task type="auto">
  <name>Task 5: Register triage skill if complete</name>
  <files>apps/backend/src/modules/ai/skills/skill.registry.ts</files>
  <action>
Read `apps/backend/src/modules/ai/skills/triage.skill.ts` to check if it's complete.

If the triage skill has a working `execute()` method with proper input/output schema:
1. Import it in `skill.registry.ts`
2. Register it in the `onModuleInit()` method alongside the other 5 skills
3. Follow the exact same pattern as the existing skill registrations

If the triage skill is incomplete/placeholder, add a TODO comment and skip registration.
  </action>
  <verify>
Check `skill.registry.ts` for triage registration. If registered, verify TypeScript compiles.
  </verify>
  <done>
Triage skill evaluated and registered if complete. If incomplete, documented with TODO.
  </done>
</task>

</tasks>

<verification>
1. useAiSkills.ts exists and calls `/ai/skills/${skillId}/execute`
2. ai-summary-button.tsx triggers 'summarize' skill
3. ai-category-suggest.tsx triggers 'category-suggest' skill
4. ai-risk-score.tsx triggers 'risk-score' skill
5. Triage skill checked and handled appropriately
6. TypeScript compiles: `cd apps/frontend && npx tsc --noEmit`
</verification>

<success_criteria>
- AI summaries can be generated on demand for cases/investigations
- Category suggestions appear during RIU intake
- Risk scores display with visual severity indicators and confidence
- All components follow existing shadcn/ui patterns
- Skill endpoints work end-to-end (frontend → REST → skill → Claude API)
</success_criteria>

<output>
After completion, create `.planning/phases/16-ai-integration-fix/16-04-SUMMARY.md`
</output>
