---
phase: 16-ai-integration-fix
plan: 03
type: execute
wave: 2
depends_on: [16-01]
files_modified:
  - apps/frontend/package.json
  - apps/frontend/src/hooks/useAiSocket.ts
  - apps/frontend/src/hooks/useAiStreamingChat.ts
  - apps/frontend/src/providers/ai-socket-provider.tsx
autonomous: true

must_haves:
  truths:
    - "socket.io-client is installed in apps/frontend"
    - "WebSocket connects to /ai namespace with JWT auth token from handshake"
    - "useAiStreamingChat hook sends chat events and receives streaming text_delta events"
    - "Streaming chat collects text_delta events into a growing response displayed in real-time"
  artifacts:
    - path: "apps/frontend/src/hooks/useAiSocket.ts"
      provides: "Socket.io client connection to /ai namespace"
      contains: "io("
    - path: "apps/frontend/src/hooks/useAiStreamingChat.ts"
      provides: "Streaming chat hook using WebSocket"
      contains: "text_delta"
    - path: "apps/frontend/src/providers/ai-socket-provider.tsx"
      provides: "React context provider for shared socket connection"
      contains: "AiSocketProvider"
  key_links:
    - from: "useAiSocket.ts"
      to: "backend AiGateway at /ai namespace"
      via: "socket.io-client connects with auth.token"
      pattern: "io.*\\/ai"
    - from: "useAiStreamingChat.ts"
      to: "useAiSocket.ts"
      via: "emits 'chat' event, listens for 'text_delta' and 'message_complete'"
      pattern: "chat.*text_delta"
---

<objective>
Install socket.io-client and create WebSocket integration for streaming AI chat. The backend already has a full WebSocket gateway at /ai namespace — this plan creates the frontend counterpart for real-time streaming responses.

Purpose: REST chat (Plan 02) works but returns the full response at once. WebSocket streaming shows AI typing in real-time, which is significantly better UX. This is the designed primary chat path.
Output: Working WebSocket connection, streaming chat hook, and provider for shared socket state.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/16-ai-integration-fix/16-RESEARCH.md

Key files to read before implementing:
@apps/backend/src/modules/ai/ai.gateway.ts (WebSocket server — understand events and auth)
@apps/frontend/src/hooks/useAiChat.ts (REST chat hook from Plan 02 — similar pattern)
@apps/frontend/src/lib/auth-storage.ts (or similar — how JWT is stored for handshake auth)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install socket.io-client</name>
  <files>apps/frontend/package.json</files>
  <action>
Run: `cd apps/frontend && npm install socket.io-client`

Verify it appears in package.json dependencies.
  </action>
  <verify>
Check: `grep socket.io-client apps/frontend/package.json` returns a match.
  </verify>
  <done>
socket.io-client installed in frontend.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useAiSocket hook for WebSocket connection</name>
  <files>apps/frontend/src/hooks/useAiSocket.ts</files>
  <action>
Create `useAiSocket.ts` that manages the socket.io connection to the /ai namespace:

```typescript
import { useEffect, useRef, useState, useCallback } from 'react';
import { io, Socket } from 'socket.io-client';

// Read the existing auth storage pattern to get JWT token
// Look at how other hooks/services get the auth token and match that pattern

interface UseAiSocketReturn {
  socket: Socket | null;
  isConnected: boolean;
  connect: () => void;
  disconnect: () => void;
}

export function useAiSocket(): UseAiSocketReturn {
  const socketRef = useRef<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);

  const connect = useCallback(() => {
    if (socketRef.current?.connected) return;

    // Get auth token — read from localStorage or auth store
    // Match the pattern used by api-client.ts for getting the token
    const token = localStorage.getItem('access_token')
      || localStorage.getItem('token')
      || '';

    const socket = io('/ai', {
      auth: { token },
      autoConnect: false,
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
    });

    socket.on('connect', () => {
      setIsConnected(true);
    });

    socket.on('disconnect', () => {
      setIsConnected(false);
    });

    socket.on('connect_error', (err) => {
      console.warn('AI WebSocket connection error:', err.message);
      setIsConnected(false);
    });

    socketRef.current = socket;
    socket.connect();
  }, []);

  const disconnect = useCallback(() => {
    if (socketRef.current) {
      socketRef.current.disconnect();
      socketRef.current = null;
      setIsConnected(false);
    }
  }, []);

  useEffect(() => {
    return () => {
      // Cleanup on unmount
      if (socketRef.current) {
        socketRef.current.disconnect();
      }
    };
  }, []);

  return { socket: socketRef.current, isConnected, connect, disconnect };
}
```

IMPORTANT: Check how the existing frontend stores auth tokens. Look at:
- `apps/frontend/src/lib/auth-storage.ts`
- `apps/frontend/src/lib/api-client.ts`
- `apps/frontend/src/contexts/auth-context.tsx`
Match the token retrieval pattern exactly.
  </action>
  <verify>
TypeScript compiles. The hook imports socket.io-client correctly.
  </verify>
  <done>
useAiSocket hook manages WebSocket connection to /ai namespace with JWT auth.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create AiSocketProvider for shared connection</name>
  <files>apps/frontend/src/providers/ai-socket-provider.tsx</files>
  <action>
Create a React context provider that manages a single shared socket connection:

```typescript
import React, { createContext, useContext, useEffect } from 'react';
import { useAiSocket } from '@/hooks/useAiSocket';
import { Socket } from 'socket.io-client';

interface AiSocketContextType {
  socket: Socket | null;
  isConnected: boolean;
}

const AiSocketContext = createContext<AiSocketContextType>({
  socket: null,
  isConnected: false,
});

export function AiSocketProvider({ children }: { children: React.ReactNode }) {
  const { socket, isConnected, connect, disconnect } = useAiSocket();

  useEffect(() => {
    connect();
    return () => disconnect();
  }, [connect, disconnect]);

  return (
    <AiSocketContext.Provider value={{ socket, isConnected }}>
      {children}
    </AiSocketContext.Provider>
  );
}

export function useAiSocketContext() {
  return useContext(AiSocketContext);
}
```

Then wrap this provider around the app (or just the authenticated layout) by adding it to the appropriate layout component. Read the existing provider hierarchy to find the right place.
  </action>
  <verify>
TypeScript compiles. Provider exports AiSocketProvider and useAiSocketContext.
  </verify>
  <done>
AiSocketProvider manages shared socket connection across the app.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create useAiStreamingChat hook</name>
  <files>apps/frontend/src/hooks/useAiStreamingChat.ts</files>
  <action>
Create `useAiStreamingChat.ts` that uses the WebSocket for streaming AI chat:

```typescript
import { useState, useCallback, useRef, useEffect } from 'react';
import { useAiSocketContext } from '@/providers/ai-socket-provider';

interface StreamingMessage {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: Date;
  isStreaming?: boolean;
  agentType?: string;
}

interface UseAiStreamingChatOptions {
  entityType?: string;
  entityId?: string;
  agentType?: string;
}

export function useAiStreamingChat(options: UseAiStreamingChatOptions = {}) {
  const { socket, isConnected } = useAiSocketContext();
  const [messages, setMessages] = useState<StreamingMessage[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const streamingContentRef = useRef('');
  const messageIdCounter = useRef(0);

  const generateId = () => `msg-${Date.now()}-${++messageIdCounter.current}`;

  // Listen for streaming events
  useEffect(() => {
    if (!socket) return;

    const handleTextDelta = (data: { text: string; messageId?: string }) => {
      streamingContentRef.current += data.text;
      setMessages(prev => {
        const last = prev[prev.length - 1];
        if (last?.isStreaming) {
          return [...prev.slice(0, -1), { ...last, content: streamingContentRef.current }];
        }
        return prev;
      });
    };

    const handleMessageComplete = (data: { content: string; agentType?: string }) => {
      setMessages(prev => {
        const last = prev[prev.length - 1];
        if (last?.isStreaming) {
          return [...prev.slice(0, -1), {
            ...last,
            content: data.content || streamingContentRef.current,
            isStreaming: false,
            agentType: data.agentType,
          }];
        }
        return prev;
      });
      streamingContentRef.current = '';
      setIsLoading(false);
    };

    const handleError = (data: { error: string }) => {
      setError(data.error);
      setIsLoading(false);
      // Remove streaming message on error
      setMessages(prev => prev.filter(m => !m.isStreaming));
      streamingContentRef.current = '';
    };

    socket.on('text_delta', handleTextDelta);
    socket.on('message_complete', handleMessageComplete);
    socket.on('error', handleError);

    return () => {
      socket.off('text_delta', handleTextDelta);
      socket.off('message_complete', handleMessageComplete);
      socket.off('error', handleError);
    };
  }, [socket]);

  const sendMessage = useCallback(async (message: string) => {
    if (!message.trim() || isLoading || !socket) return;

    setError(null);
    streamingContentRef.current = '';

    // Add user message
    const userMsg: StreamingMessage = {
      id: generateId(),
      role: 'user',
      content: message,
      timestamp: new Date(),
    };

    // Add placeholder for assistant streaming response
    const assistantMsg: StreamingMessage = {
      id: generateId(),
      role: 'assistant',
      content: '',
      timestamp: new Date(),
      isStreaming: true,
    };

    setMessages(prev => [...prev, userMsg, assistantMsg]);
    setIsLoading(true);

    // Emit chat event to WebSocket
    socket.emit('chat', {
      message,
      entityType: options.entityType,
      entityId: options.entityId,
      agentType: options.agentType,
    });
  }, [socket, isLoading, options.entityType, options.entityId, options.agentType]);

  const clearMessages = useCallback(() => {
    setMessages([]);
    setError(null);
    streamingContentRef.current = '';
  }, []);

  return {
    messages,
    isLoading,
    error,
    isConnected,
    sendMessage,
    clearMessages,
  };
}
```

IMPORTANT: Read `ai.gateway.ts` to verify the exact event names used:
- Client emits: 'chat' (with { message, entityType, entityId, agentType })
- Server emits: 'text_delta', 'message_complete', 'error'
Match the exact payload shapes.
  </action>
  <verify>
TypeScript compiles. Hook imports socket context and handles text_delta/message_complete events.
  </verify>
  <done>
useAiStreamingChat hook provides real-time streaming AI chat via WebSocket with proper event handling.
  </done>
</task>

</tasks>

<verification>
1. `socket.io-client` is in apps/frontend/package.json dependencies
2. useAiSocket.ts connects to /ai namespace with auth token
3. AiSocketProvider.tsx wraps socket in React context
4. useAiStreamingChat.ts emits 'chat' and handles 'text_delta'/'message_complete' events
5. TypeScript compiles: `cd apps/frontend && npx tsc --noEmit`
</verification>

<success_criteria>
- socket.io-client installed
- WebSocket connects to backend /ai namespace with JWT
- Streaming chat shows AI response as it types (real-time text_delta)
- Connection errors handled gracefully
- Shared socket instance via provider (not per-component)
</success_criteria>

<output>
After completion, create `.planning/phases/16-ai-integration-fix/16-03-SUMMARY.md`
</output>
