---
phase: 16-ai-integration-fix
plan: 06
type: execute
wave: 4
depends_on: [16-02, 16-03, 16-04, 16-05]
# Dependencies justified: 16-02 creates ai-panel.tsx + useAiChat, 16-03 creates socket provider + streaming hook,
# 16-04 creates skill components (AiSummaryButton) used in Task 2, 16-05 creates action components used in Task 3.
files_modified:
  - apps/frontend/src/components/layout/ai-panel.tsx
  - apps/frontend/src/components/cases/case-detail-page.tsx
  - apps/backend/src/modules/ai/ai.controller.ts
  - apps/frontend/src/main.tsx
autonomous: true

must_haves:
  truths:
    - "AI panel opens from case detail page with correct entity context (entityType=case, entityId=caseId)"
    - "AI panel supports both REST chat (immediate) and WebSocket streaming (real-time typing)"
    - "AI features degrade gracefully: show 'AI unavailable' message when API key missing or service down"
    - "AI health check endpoint exists at GET /api/v1/ai/health"
    - "Case detail page AI button passes entity context when opening panel"
  artifacts:
    - path: "apps/backend/src/modules/ai/ai.controller.ts"
      provides: "Health check endpoint for AI service"
      contains: "@Get('health')"
    - path: "apps/frontend/src/components/layout/ai-panel.tsx"
      provides: "Mode toggle between REST and streaming, graceful degradation"
      contains: "isAiAvailable"
  key_links:
    - from: "case-detail-page AI button"
      to: "ai-panel-context openPanel"
      via: "openPanel({ entityType: 'case', entityId: case.id })"
      pattern: "openPanel.*case"
    - from: "ai-panel.tsx"
      to: "useAiChat / useAiStreamingChat"
      via: "Conditional hook based on WebSocket availability"
      pattern: "isConnected.*useAiStreamingChat.*useAiChat"
---

<objective>
Wire the AI panel to case detail pages with entity context, add AI health check for graceful degradation, and integrate streaming mode toggle. Final integration and polish plan.

Purpose: Connect all the pieces from Plans 01-05 into a working end-to-end flow. Ensure AI degrades gracefully when unavailable.
Output: Working AI on case detail pages, health check endpoint, graceful degradation.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/16-ai-integration-fix/16-RESEARCH.md

Key files to read:
@apps/frontend/src/components/cases/case-detail-page.tsx (or wherever case detail is)
@apps/frontend/src/components/layout/ai-panel.tsx (from Plan 02)
@apps/frontend/src/contexts/ai-panel-context.tsx (from Plan 02)
@apps/backend/src/modules/ai/ai.controller.ts (from Plan 01)
@apps/backend/src/modules/ai/services/ai-client.service.ts (check isConfigured method)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AI health check endpoint</name>
  <files>apps/backend/src/modules/ai/ai.controller.ts</files>
  <action>
Add a health check endpoint to the AI controller that reports AI system status:

```typescript
@Get('health')
async getHealth() {
  const isConfigured = this.aiClientService.isConfigured();
  const skills = this.skillRegistry.listSkills();
  const agents = this.agentRegistry.listAgentTypes();
  const actions = this.actionCatalog.listActions();

  return {
    status: isConfigured ? 'available' : 'unavailable',
    configured: isConfigured,
    capabilities: {
      chat: isConfigured,
      skills: skills.map(s => s.id || s.name),
      agents: agents,
      actions: actions.map(a => a.id || a.name),
    },
    model: isConfigured ? process.env.AI_DEFAULT_MODEL || 'claude-sonnet-4-5' : null,
  };
}
```

Read `ai-client.service.ts` to find the `isConfigured()` method name and how services are injected into the controller. Match the existing injection pattern.

Also read `skill.registry.ts`, `agent.registry.ts`, and `action.catalog.ts` to verify list methods exist. If they don't have list methods, use what's available or add simple getters.
  </action>
  <verify>
TypeScript compiles. GET /api/v1/ai/health returns status object.
  </verify>
  <done>
AI health check endpoint reports system status, available capabilities, and model info.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire AI button on case detail page</name>
  <files>apps/frontend/src/components/cases/case-detail-page.tsx</files>
  <action>
**IMPORTANT: Find the actual case detail page first.** This is a Vite+React project (NOT Next.js). Search for it:

```bash
grep -rl "CaseDetail\|case-detail\|caseDetail\|CaseView" apps/frontend/src/ --include="*.tsx"
```

Also try:
```bash
ls apps/frontend/src/pages/cases/ 2>/dev/null
ls apps/frontend/src/components/cases/ 2>/dev/null
```

The file path in `<files>` above is a best guess. Use whatever file the search finds. If multiple results, look for the page-level component (not a small sub-component).

Once found:

1. **Import the AI panel context**:
```typescript
import { useAiPanel } from '@/contexts/ai-panel-context';
```

2. **Get the openPanel function**:
```typescript
const { openPanel } = useAiPanel();
```

3. **Find the existing AI button** (the research says there's an AI button that opens the panel). Update it to pass entity context:
```typescript
<Button
  variant="outline"
  size="sm"
  onClick={() => openPanel({ entityType: 'case', entityId: caseId })}
>
  <Sparkles className="mr-2 h-4 w-4" />
  AI
</Button>
```

4. **If there's no AI button**, add one in the action buttons area (header/toolbar) of the case detail page.

5. **Also wire the AiSummaryButton** into the Summary tab if a summary tab exists:
```typescript
import { AiSummaryButton } from '@/components/ai/ai-summary-button';

// In summary tab content:
<AiSummaryButton
  content={caseDescription}
  entityType="case"
  entityId={caseId}
  onSummaryGenerated={(summary) => { /* update case summary */ }}
/>
```
  </action>
  <verify>
Case detail page imports and uses openPanel with entityType='case'. AI button is present.
  </verify>
  <done>
Case detail page AI button opens panel with correct entity context. Summary button available.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add graceful degradation to AI panel</name>
  <files>apps/frontend/src/components/layout/ai-panel.tsx</files>
  <action>
Enhance the AI panel with graceful degradation when AI is unavailable:

1. **Create a useAiHealth hook** (inline or separate file):
```typescript
const useAiHealth = () => {
  const [isAvailable, setIsAvailable] = useState<boolean | null>(null);
  const [capabilities, setCapabilities] = useState<any>(null);

  useEffect(() => {
    const checkHealth = async () => {
      try {
        const response = await apiClient.get('/ai/health');
        setIsAvailable(response.data.status === 'available');
        setCapabilities(response.data.capabilities);
      } catch {
        setIsAvailable(false);
      }
    };
    checkHealth();
  }, []);

  return { isAvailable, capabilities };
};
```

2. **Show unavailable state** when AI is not configured:
```tsx
{isAvailable === false && (
  <div className="p-6 text-center text-muted-foreground">
    <Sparkles className="mx-auto h-8 w-8 mb-3 opacity-50" />
    <p className="font-medium">AI Assistant Unavailable</p>
    <p className="text-sm mt-1">
      AI features require configuration. Contact your administrator.
    </p>
  </div>
)}
```

3. **Show loading state** while checking:
```tsx
{isAvailable === null && (
  <div className="p-6 text-center">
    <Loader2 className="mx-auto h-6 w-6 animate-spin" />
    <p className="text-sm mt-2 text-muted-foreground">Connecting to AI...</p>
  </div>
)}
```

4. **Add streaming mode toggle** (optional enhancement):
If WebSocket is connected, use streaming. If not, fall back to REST:
```typescript
const { isConnected } = useAiSocketContext();
// Use streaming when available, REST as fallback
const chatHook = isConnected ? useAiStreamingChat(options) : useAiChat(options);
```

IMPORTANT: React hooks can't be called conditionally. Create a `useAiChatAdapter` wrapper hook that internally calls both `useAiChat()` and `useAiStreamingChat()`, then returns the active one's data based on `isConnected`. This keeps the hook call count stable. Verify this fallback works by testing the panel with WebSocket disconnected (no AiSocketProvider or socket connection failure) — REST chat should still work.

5. **Handle API errors gracefully** — show retry button, not crash:
```tsx
{error && (
  <div className="px-4 py-2 bg-destructive/10 border-t">
    <p className="text-sm text-destructive">{error}</p>
    <Button variant="ghost" size="xs" onClick={clearError}>Dismiss</Button>
  </div>
)}
```
  </action>
  <verify>
AI panel shows appropriate state for: available, unavailable, loading, error. TypeScript compiles.
  </verify>
  <done>
AI panel degrades gracefully with health check, unavailable state, and error handling.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add AiSocketProvider to app layout</name>
  <files>apps/frontend/src/main.tsx</files>
  <action>
**This is a Vite+React project (NOT Next.js).** The app entry is likely `apps/frontend/src/main.tsx` or provider hierarchy in a layout component.

Find the provider hierarchy:
```bash
grep -rl "AiPanelProvider\|QueryClientProvider\|AuthProvider\|createRoot\|BrowserRouter" apps/frontend/src/ --include="*.tsx"
```

The providers are typically stacked in `main.tsx` or an `App.tsx` or a dedicated `providers.tsx` file.

Add `AiSocketProvider` to the provider hierarchy, wrapping it around components that need AI:

```typescript
import { AiSocketProvider } from '@/providers/ai-socket-provider';

// Add inside the existing provider stack, after auth (needs token):
<AuthProvider>
  <AiSocketProvider>
    <AiPanelProvider>
      {children}
    </AiPanelProvider>
  </AiSocketProvider>
</AuthProvider>
```

Important: AiSocketProvider should be INSIDE AuthProvider (needs auth token) but OUTSIDE AiPanelProvider (panel uses socket context).

If AiPanelProvider doesn't exist as a separate wrapper, check how the AI panel context is provided and ensure AiSocketProvider wraps it.
  </action>
  <verify>
AiSocketProvider is in the provider hierarchy. App renders without errors.
  </verify>
  <done>
AiSocketProvider added to app layout, enabling WebSocket connection for all AI components.
  </done>
</task>

</tasks>

<verification>
1. GET /api/v1/ai/health returns status and capabilities
2. Case detail page AI button opens panel with entityType='case'
3. AI panel shows "unavailable" when API key not configured
4. AI panel shows "connecting..." while checking health
5. AiSocketProvider is in provider hierarchy
6. Both backend and frontend TypeScript compile
7. REST fallback works when WebSocket is unavailable: AI panel still accepts queries and shows responses via REST chat endpoint
</verification>

<success_criteria>
- AI panel works end-to-end from case detail page
- Health check reports AI system status
- Graceful degradation when AI unavailable (no crashes, clear message)
- WebSocket streaming used when available, REST fallback
- Entity context flows from case page through panel to backend
</success_criteria>

<output>
After completion, create `.planning/phases/16-ai-integration-fix/16-06-SUMMARY.md`
</output>
