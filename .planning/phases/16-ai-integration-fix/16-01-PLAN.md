---
phase: 16-ai-integration-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/src/modules/ai/ai.controller.ts
  - apps/backend/src/modules/ai/services/context-loader.service.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/v1/ai/chat accepts a message and returns an AI-generated response"
    - "AI controller uses JwtAuthGuard for real auth with fallback for unauthenticated demo usage"
    - "ContextLoaderService does not throw when organization/user is not found — returns safe fallback context"
  artifacts:
    - path: "apps/backend/src/modules/ai/ai.controller.ts"
      provides: "REST chat endpoint and auth guard enablement"
      contains: "@Post('chat')"
    - path: "apps/backend/src/modules/ai/services/context-loader.service.ts"
      provides: "Graceful fallback when org/user not found"
      contains: "fallback"
  key_links:
    - from: "ai.controller.ts @Post('chat')"
      to: "AgentRegistry.getAgent()"
      via: "resolves agent type from entityType, delegates to agent.chat()"
      pattern: "agentRegistry\\.getAgent"
    - from: "ai.controller.ts"
      to: "JwtAuthGuard"
      via: "@UseGuards(JwtAuthGuard) decorator on controller"
      pattern: "@UseGuards.*JwtAuthGuard"
---

<objective>
Fix the two critical backend blockers preventing AI from working: (1) enable auth guard on AI controller so real user/org context flows through, with a safe fallback for unauthenticated requests, and (2) add a REST chat endpoint that routes messages through the agent system (not skills). Also harden ContextLoaderService to not throw on missing org/user.

Purpose: Without these backend fixes, every frontend AI call either hits "Skill not found: chat" or "Organization not found: demo". This plan unblocks all downstream frontend work.
Output: Working REST chat endpoint at POST /api/v1/ai/chat, auth guard enabled, context-loader with graceful fallback.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-ai-integration-fix/16-RESEARCH.md

Key files to read before modifying:
@apps/backend/src/modules/ai/ai.controller.ts
@apps/backend/src/modules/ai/services/context-loader.service.ts
@apps/backend/src/modules/ai/agents/agent.registry.ts
@apps/backend/src/modules/ai/agents/base.agent.ts
@apps/backend/src/common/guards/jwt-auth.guard.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable auth guard on AI controller and add REST chat endpoint</name>
  <files>apps/backend/src/modules/ai/ai.controller.ts</files>
  <action>
Modify `ai.controller.ts` to:

1. **Import JwtAuthGuard** from `../../common/guards/jwt-auth.guard`. Also import `UseGuards` from `@nestjs/common`.

2. **Uncomment and apply @UseGuards(JwtAuthGuard)** on the controller class. BUT make it optional/soft — the controller should work with or without auth. To do this, create an `OptionalJwtAuthGuard` that extends `JwtAuthGuard` and overrides `handleRequest` to NOT throw on missing auth but instead return null. Then use `@UseGuards(OptionalJwtAuthGuard)` on the controller. This way:
   - Authenticated users get real `req.user` with `organizationId`, `id`, `role`, `permissions`
   - Unauthenticated users get `req.user = null` and fallbacks still work

   Implementation of OptionalJwtAuthGuard (define at top of controller file or in a separate file if preferred):
   ```typescript
   class OptionalJwtAuthGuard extends JwtAuthGuard {
     handleRequest(err: any, user: any) {
       // Don't throw on missing auth — return null user
       return user || null;
     }
   }
   ```

3. **Add a new POST /ai/chat endpoint** that routes through the agent system. Place it in a new `// ============ Chat ============` section BEFORE the Skills section. Implementation:

```typescript
@Post('chat')
async chat(
  @Body() body: {
    message: string;
    entityType?: string;
    entityId?: string;
    agentType?: string;
    conversationId?: string;
  },
  @Request() req: AuthenticatedRequest,
) {
  const orgId = req.user?.organizationId || 'demo';
  const userId = req.user?.id || 'demo';
  const userRole = req.user?.role || 'EMPLOYEE';
  const permissions = req.user?.permissions || [];

  // Determine agent type from explicit param, entity type, or default
  const resolvedAgentType =
    body.agentType ||
    this.agentRegistry.getAgentTypeForEntity(body.entityType || '') ||
    'compliance-manager';

  const context = {
    organizationId: orgId,
    userId: userId,
    userRole: userRole,
    permissions: permissions,
    entityType: body.entityType,
    entityId: body.entityId,
  };

  // Get or create agent
  const agent = this.agentRegistry.getAgent(resolvedAgentType, context);
  await agent.initialize(context);

  // Collect streamed response into single response (non-streaming REST)
  let fullContent = '';
  let conversationId: string | undefined;

  for await (const event of agent.chat(body.message, context)) {
    if (event.type === 'text_delta' && event.text) {
      fullContent += event.text;
    } else if (event.type === 'error') {
      return {
        success: false,
        error: event.error || 'AI processing failed',
        agentType: resolvedAgentType,
      };
    }
  }

  return {
    success: true,
    response: fullContent,
    agentType: resolvedAgentType,
    entityType: body.entityType,
    entityId: body.entityId,
  };
}
```

4. **Keep all existing fallback patterns** (`req.user?.organizationId || "demo"`) as-is for backward compatibility. The OptionalJwtAuthGuard means authenticated users get real context and unauthenticated users still work with demo fallbacks.
  </action>
  <verify>
Run `cd apps/backend && npx tsc --noEmit` to verify TypeScript compilation succeeds. Then search the file for `@Post('chat')` and `OptionalJwtAuthGuard` to confirm both are present.
  </verify>
  <done>
AI controller has a working POST /ai/chat endpoint that routes through the agent system. Auth guard is enabled but optional (non-breaking). TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add graceful fallback to ContextLoaderService for missing org/user</name>
  <files>apps/backend/src/modules/ai/services/context-loader.service.ts</files>
  <action>
Modify `context-loader.service.ts` to handle missing organizations and users gracefully instead of throwing:

1. **In `loadOrganizationContext`** (around line 480): Replace the `throw new Error('Organization not found: ${orgId}')` with a fallback that returns a minimal OrganizationContext:
```typescript
if (!org) {
  this.logger.warn(`Organization not found: ${orgId} - using fallback context`);
  return {
    id: orgId,
    name: 'Unknown Organization',
    categories: [],
    settings: {
      aiEnabled: true,
      formalityLevel: 'professional',
      noteCleanupStyle: 'light',
      summaryDefaultLength: 'standard',
    },
  };
}
```

2. **In `loadUserContext`** (find the similar throw pattern for missing user): Replace with a fallback:
```typescript
if (!user) {
  this.logger.warn(`User not found: ${userId} - using fallback context`);
  return {
    id: userId,
    name: 'Unknown User',
    role: 'EMPLOYEE',
    preferences: undefined,
    contextFile: undefined,
  };
}
```

3. **In the main `loadContext` method**: Wrap the parallel Promise.all in a try-catch so individual context loading failures don't crash the entire context assembly. If any individual loader fails, log the error and use a null/minimal fallback for that level:
```typescript
async loadContext(params: LoadContextDto): Promise<AIContext> {
  let orgContext: OrganizationContext;
  let userContext: UserContext;
  let teamContext: TeamContext | null = null;
  let entityContext: EntityContext | null = null;

  try {
    [orgContext, userContext, teamContext, entityContext] =
      await Promise.all([
        this.loadOrganizationContext(params.organizationId),
        this.loadUserContext(params.userId, params.organizationId),
        params.teamId
          ? this.loadTeamContext(params.teamId, params.organizationId)
          : null,
        params.entityType && params.entityId
          ? this.loadEntityContext(
              params.entityType,
              params.entityId,
              params.organizationId,
            )
          : null,
      ]);
  } catch (error) {
    this.logger.error(`Context loading error: ${(error as Error).message}`);
    // Provide minimal fallback context
    orgContext = orgContext! || {
      id: params.organizationId,
      name: 'Unknown Organization',
      categories: [],
      settings: {
        aiEnabled: true,
        formalityLevel: 'professional' as const,
        noteCleanupStyle: 'light' as const,
        summaryDefaultLength: 'standard' as const,
      },
    };
    userContext = userContext! || {
      id: params.userId,
      name: 'Unknown User',
      role: 'EMPLOYEE',
    };
  }

  return {
    platform: this.platformContext,
    organization: orgContext,
    team: teamContext || undefined,
    user: userContext,
    entity: entityContext || undefined,
    currentDateTime: new Date().toISOString(),
  };
}
```

This ensures AI features work even when auth provides a "demo" organization that doesn't exist in the database.
  </action>
  <verify>
Run `cd apps/backend && npx tsc --noEmit` to verify TypeScript compilation. Search the file to confirm:
- No `throw new Error('Organization not found` exists anymore
- `using fallback context` log messages exist
- The loadContext method has try-catch wrapping
  </verify>
  <done>
ContextLoaderService never throws on missing org/user. Instead it logs a warning and returns minimal fallback context. AI endpoints return responses even without a matching database organization.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd apps/backend && npx tsc --noEmit` exits 0
2. AI controller has `@Post('chat')` endpoint that imports and uses AgentRegistry
3. AI controller has `@UseGuards(OptionalJwtAuthGuard)` (not commented out)
4. ContextLoaderService has no `throw` statements for missing org/user
5. All existing skill endpoints still work (backward compatible)
6. Full flow verification: Trace the code path from POST /ai/chat through AgentRegistry.getAgent() → agent.initialize() → ContextLoaderService.loadContext() with a "demo" orgId. Verify that ConversationService.getOrCreate() also handles missing user gracefully (doesn't throw). If ConversationService does hard lookups, add similar fallback handling there.
7. Verify downstream services that consume context (ConversationService, PromptService) won't crash when receiving fallback/minimal context objects
</verification>

<success_criteria>
- POST /api/v1/ai/chat endpoint exists and routes through agent system
- Auth guard is enabled but doesn't break unauthenticated requests
- Missing org/user in database does not cause 500 errors at ANY point in the chat flow (not just ContextLoaderService)
- ConversationService handles missing users gracefully
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/16-ai-integration-fix/16-01-SUMMARY.md`
</output>
