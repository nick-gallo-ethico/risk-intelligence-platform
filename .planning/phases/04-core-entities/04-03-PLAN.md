---
phase: 04-core-entities
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - apps/backend/src/modules/hris/hris.module.ts
  - apps/backend/src/modules/hris/hris-sync.service.ts
  - apps/backend/src/modules/hris/merge-client.service.ts
  - apps/backend/src/modules/hris/dto/hris-sync.dto.ts
  - apps/backend/src/modules/hris/types/merge.types.ts
  - apps/backend/package.json
  - apps/backend/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "HRIS sync creates Person records from Employee records via Merge.dev unified API"
    - "Sync is idempotent - running twice produces same result"
    - "Sync respects existing manual edits on Person records"
    - "Sync creates manager hierarchy in correct order (managers before reports)"
  artifacts:
    - path: "apps/backend/src/modules/hris/hris-sync.service.ts"
      provides: "Orchestrates HRIS to Person sync"
      exports: ["HrisSyncService"]
    - path: "apps/backend/src/modules/hris/merge-client.service.ts"
      provides: "Merge.dev API client"
      exports: ["MergeClientService"]
  key_links:
    - from: "apps/backend/src/modules/hris/hris-sync.service.ts"
      to: "PersonsService.createFromEmployee"
      via: "service injection"
      pattern: "this.personsService.createFromEmployee"
---

<objective>
Implement HRIS sync service using Merge.dev unified API to create Person records from Employee data.

Purpose: Per PERS-05, Employee data comes from 50+ HRIS systems via Merge.dev. This service syncs Employee records and ensures corresponding Person records exist for pattern detection. Merge.dev abstracts away individual HRIS differences.

Output: HrisModule with MergeClientService for API calls and HrisSyncService for Person creation orchestration.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-entities/04-CONTEXT.md
@.planning/phases/04-core-entities/04-02-SUMMARY.md
@apps/backend/src/modules/persons/persons.service.ts
@01-SHARED-INFRASTRUCTURE/TECH-SPEC-HRIS-INTEGRATION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Merge.dev client service</name>
  <files>
    apps/backend/package.json
    apps/backend/src/modules/hris/merge-client.service.ts
    apps/backend/src/modules/hris/types/merge.types.ts
  </files>
  <action>
    1. Install axios for HTTP client (if not already present):
       ```bash
       cd apps/backend && npm install axios
       ```

    2. Create `apps/backend/src/modules/hris/types/merge.types.ts`:
       ```typescript
       // Merge.dev HRIS unified model types
       export interface MergeEmployee {
         id: string;
         remote_id: string;
         first_name: string;
         last_name: string;
         display_full_name: string;
         work_email: string;
         personal_email?: string;
         mobile_phone_number?: string;
         work_location?: string;
         manager?: string; // Merge employee ID of manager
         team?: string;
         employment_status?: 'ACTIVE' | 'INACTIVE' | 'PENDING';
         termination_date?: string;
         start_date?: string;
         job_title?: string;
         remote_data?: unknown;
       }

       export interface MergePaginatedResponse<T> {
         next?: string;
         previous?: string;
         results: T[];
       }

       export interface MergeIntegration {
         id: string;
         integration_name: string;
         categories: string[];
         end_user_origin_id: string;
       }
       ```

    3. Create `apps/backend/src/modules/hris/merge-client.service.ts`:
       ```typescript
       import { Injectable, Logger } from '@nestjs/common';
       import { ConfigService } from '@nestjs/config';
       import axios, { AxiosInstance } from 'axios';
       import { MergeEmployee, MergePaginatedResponse } from './types/merge.types';

       @Injectable()
       export class MergeClientService {
         private readonly logger = new Logger(MergeClientService.name);
         private readonly client: AxiosInstance;
         private readonly apiKey: string;

         constructor(private configService: ConfigService) {
           this.apiKey = this.configService.get<string>('MERGE_API_KEY');

           this.client = axios.create({
             baseURL: 'https://api.merge.dev/api/hris/v1',
             headers: {
               'Authorization': `Bearer ${this.apiKey}`,
               'Content-Type': 'application/json',
             },
           });
         }

         /**
          * Get all employees from a linked HRIS account
          * @param accountToken - The linked account token for the organization
          */
         async getEmployees(accountToken: string): Promise<MergeEmployee[]> {
           const allEmployees: MergeEmployee[] = [];
           let nextUrl: string | undefined = '/employees';

           while (nextUrl) {
             const response = await this.client.get<MergePaginatedResponse<MergeEmployee>>(
               nextUrl,
               {
                 headers: { 'X-Account-Token': accountToken },
               }
             );

             allEmployees.push(...response.data.results);
             nextUrl = response.data.next;
           }

           this.logger.log(`Fetched ${allEmployees.length} employees from Merge.dev`);
           return allEmployees;
         }

         /**
          * Get a single employee by Merge ID
          */
         async getEmployee(accountToken: string, employeeId: string): Promise<MergeEmployee> {
           const response = await this.client.get<MergeEmployee>(
             `/employees/${employeeId}`,
             {
               headers: { 'X-Account-Token': accountToken },
             }
           );
           return response.data;
         }

         /**
          * Test connection to linked HRIS
          */
         async testConnection(accountToken: string): Promise<boolean> {
           try {
             await this.client.get('/employees', {
               headers: { 'X-Account-Token': accountToken },
               params: { page_size: 1 },
             });
             return true;
           } catch (error) {
             this.logger.error('Merge.dev connection test failed', error);
             return false;
           }
         }
       }
       ```
  </action>
  <verify>
    ```bash
    cd apps/backend && npm run build
    ```
  </verify>
  <done>MergeClientService exists with getEmployees, getEmployee, testConnection methods.</done>
</task>

<task type="auto">
  <name>Task 2: Create HRIS sync service and module</name>
  <files>
    apps/backend/src/modules/hris/hris-sync.service.ts
    apps/backend/src/modules/hris/dto/hris-sync.dto.ts
    apps/backend/src/modules/hris/hris.module.ts
    apps/backend/src/app.module.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/hris/dto/hris-sync.dto.ts`:
       ```typescript
       import { IsString, IsOptional, IsBoolean } from 'class-validator';

       export class TriggerSyncDto {
         @IsString()
         accountToken: string;

         @IsBoolean()
         @IsOptional()
         fullSync?: boolean; // If true, resync all; if false, only changes
       }

       export class SyncResultDto {
         created: number;
         updated: number;
         skipped: number;
         errors: { employeeId: string; error: string }[];
         durationMs: number;
       }
       ```

    2. Create `apps/backend/src/modules/hris/hris-sync.service.ts`:
       ```typescript
       import { Injectable, Logger } from '@nestjs/common';
       import { EventEmitter2 } from '@nestjs/event-emitter';
       import { PrismaService } from '../prisma/prisma.service';
       import { PersonsService } from '../persons/persons.service';
       import { MergeClientService } from './merge-client.service';
       import { MergeEmployee } from './types/merge.types';
       import { SyncResultDto } from './dto/hris-sync.dto';

       @Injectable()
       export class HrisSyncService {
         private readonly logger = new Logger(HrisSyncService.name);

         constructor(
           private prisma: PrismaService,
           private personsService: PersonsService,
           private mergeClient: MergeClientService,
           private eventEmitter: EventEmitter2,
         ) {}

         /**
          * Sync all employees from Merge.dev to Person records.
          * Creates manager chain in correct order (topological sort).
          */
         async syncEmployees(
           accountToken: string,
           organizationId: string,
           userId: string,
         ): Promise<SyncResultDto> {
           const startTime = Date.now();
           const result: SyncResultDto = {
             created: 0,
             updated: 0,
             skipped: 0,
             errors: [],
             durationMs: 0,
           };

           // 1. Fetch all employees from Merge
           const mergeEmployees = await this.mergeClient.getEmployees(accountToken);

           // 2. Build employee map for manager resolution
           const employeeMap = new Map<string, MergeEmployee>();
           mergeEmployees.forEach(emp => employeeMap.set(emp.id, emp));

           // 3. Topological sort: process employees without managers first
           const sorted = this.topologicalSort(mergeEmployees);

           // 4. Process each employee
           for (const mergeEmployee of sorted) {
             try {
               // Check if Employee exists in our system
               let employee = await this.prisma.employee.findFirst({
                 where: {
                   organizationId,
                   OR: [
                     { hrisEmployeeId: mergeEmployee.remote_id },
                     { email: mergeEmployee.work_email },
                   ],
                 },
               });

               // Create or update Employee record
               if (!employee) {
                 // Find manager Employee if exists
                 let managerEmployeeId: string | undefined;
                 if (mergeEmployee.manager) {
                   const managerMerge = employeeMap.get(mergeEmployee.manager);
                   if (managerMerge) {
                     const managerEmployee = await this.prisma.employee.findFirst({
                       where: { organizationId, hrisEmployeeId: managerMerge.remote_id },
                     });
                     managerEmployeeId = managerEmployee?.id;
                   }
                 }

                 employee = await this.prisma.employee.create({
                   data: {
                     organizationId,
                     hrisEmployeeId: mergeEmployee.remote_id,
                     firstName: mergeEmployee.first_name,
                     lastName: mergeEmployee.last_name,
                     email: mergeEmployee.work_email,
                     phone: mergeEmployee.mobile_phone_number,
                     jobTitle: mergeEmployee.job_title || 'Employee',
                     managerId: managerEmployeeId,
                     managerName: managerEmployeeId ? `${employeeMap.get(mergeEmployee.manager)?.first_name} ${employeeMap.get(mergeEmployee.manager)?.last_name}` : undefined,
                     employmentStatus: this.mapEmploymentStatus(mergeEmployee.employment_status),
                     sourceSystem: 'MERGE_DEV',
                     syncedAt: new Date(),
                     rawHrisData: mergeEmployee as unknown as Prisma.JsonValue,
                   },
                 });
               }

               // Create or get Person record
               const existingPerson = await this.personsService.findByEmployeeId(
                 employee.id,
                 organizationId,
               );

               if (!existingPerson) {
                 await this.personsService.createFromEmployee(
                   employee.id,
                   userId,
                   organizationId,
                 );
                 result.created++;
               } else {
                 // Sync updates (preserving manual edits on Person)
                 await this.personsService.syncFromEmployee(
                   existingPerson.id,
                   employee.id,
                   userId,
                   organizationId,
                 );
                 result.updated++;
               }
             } catch (error) {
               result.errors.push({
                 employeeId: mergeEmployee.id,
                 error: error.message,
               });
               this.logger.error(`Failed to sync employee ${mergeEmployee.id}`, error);
             }
           }

           result.durationMs = Date.now() - startTime;

           // Emit sync complete event
           this.eventEmitter.emit('hris.sync.completed', {
             organizationId,
             result,
           });

           this.logger.log(
             `HRIS sync complete: ${result.created} created, ${result.updated} updated, ${result.errors.length} errors`,
           );

           return result;
         }

         /**
          * Topological sort: managers before their reports
          */
         private topologicalSort(employees: MergeEmployee[]): MergeEmployee[] {
           const visited = new Set<string>();
           const result: MergeEmployee[] = [];
           const employeeMap = new Map<string, MergeEmployee>();
           employees.forEach(e => employeeMap.set(e.id, e));

           const visit = (emp: MergeEmployee) => {
             if (visited.has(emp.id)) return;
             if (emp.manager && employeeMap.has(emp.manager)) {
               visit(employeeMap.get(emp.manager)!);
             }
             visited.add(emp.id);
             result.push(emp);
           };

           employees.forEach(visit);
           return result;
         }

         private mapEmploymentStatus(status?: string): 'ACTIVE' | 'INACTIVE' | 'ON_LEAVE' | 'TERMINATED' {
           switch (status) {
             case 'ACTIVE': return 'ACTIVE';
             case 'INACTIVE': return 'INACTIVE';
             case 'PENDING': return 'ON_LEAVE';
             default: return 'ACTIVE';
           }
         }
       }
       ```

    3. Create `apps/backend/src/modules/hris/hris.module.ts`:
       ```typescript
       import { Module } from '@nestjs/common';
       import { HrisSyncService } from './hris-sync.service';
       import { MergeClientService } from './merge-client.service';
       import { PersonsModule } from '../persons/persons.module';

       @Module({
         imports: [PersonsModule],
         providers: [HrisSyncService, MergeClientService],
         exports: [HrisSyncService, MergeClientService],
       })
       export class HrisModule {}
       ```

    4. Register HrisModule in app.module.ts imports.
  </action>
  <verify>
    ```bash
    cd apps/backend && npm run build
    ```
  </verify>
  <done>HrisModule exists with HrisSyncService and MergeClientService. Sync creates Person records from Employee data with correct manager ordering.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build succeeds:
   ```bash
   cd apps/backend && npm run build
   ```

2. Type check passes:
   ```bash
   cd apps/backend && npm run typecheck
   ```

3. Module dependency graph is valid (PersonsModule imported by HrisModule).
</verification>

<success_criteria>
- MergeClientService can fetch employees from Merge.dev API
- HrisSyncService creates Person records from Employee records
- Topological sort ensures managers created before their reports
- Sync is idempotent (running twice produces same result)
- Errors are logged and collected without stopping sync
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-entities/04-03-SUMMARY.md` using the summary template.
</output>
