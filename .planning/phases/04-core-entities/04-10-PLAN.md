---
phase: 04-core-entities
plan: 10
type: execute
wave: 4
depends_on: ["04-09"]
files_modified:
  - apps/backend/src/modules/associations/pattern-detection/pattern-detection.service.ts
  - apps/backend/src/modules/associations/pattern-detection/pattern-detection.controller.ts
  - apps/backend/src/modules/search/indexing/index-mappings/case.mapping.ts
  - apps/backend/src/modules/search/indexing/indexing.service.ts
  - apps/backend/src/modules/associations/associations.module.ts
autonomous: true

must_haves:
  truths:
    - "Pattern detection queries find all Cases involving a Person across different roles"
    - "Associations are denormalized in Elasticsearch for sub-second queries"
    - "History badge shows 'X previous reports from this person' in triage view"
    - "Multi-person queries work ('Cases where A was subject AND B was witness')"
  artifacts:
    - path: "apps/backend/src/modules/associations/pattern-detection/pattern-detection.service.ts"
      provides: "Pattern detection queries using Elasticsearch"
      exports: ["PatternDetectionService"]
    - path: "apps/backend/src/modules/search/indexing/index-mappings/case.mapping.ts"
      provides: "Case index mapping with nested associations"
      contains: "associations.persons"
  key_links:
    - from: "apps/backend/src/modules/associations/pattern-detection/pattern-detection.service.ts"
      to: "ElasticsearchService"
      via: "nested queries"
      pattern: "nested.*associations.persons"
---

<objective>
Implement pattern detection queries and Elasticsearch association denormalization per ASSOC-04 and CONTEXT.md.

Purpose: Per CONTEXT.md, "Association search is a wow moment in demos." This plan creates the PatternDetectionService that enables queries like "find all Cases involving Person X across different roles" using pre-indexed association data in Elasticsearch. This is the foundation for cross-case pattern detection.

Output: PatternDetectionService with ES-based queries, updated Case index mapping with nested associations, history badge API.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-entities/04-CONTEXT.md
@.planning/phases/04-core-entities/04-RESEARCH.md
@.planning/phases/04-core-entities/04-09-SUMMARY.md
@apps/backend/src/modules/search/indexing/indexing.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Case index mapping with association denormalization</name>
  <files>apps/backend/src/modules/search/indexing/index-mappings/case.mapping.ts</files>
  <action>
    Update or create Case index mapping to include nested associations:

    ```typescript
    // apps/backend/src/modules/search/indexing/index-mappings/case.mapping.ts

    export const CASE_INDEX_MAPPING = {
      settings: {
        number_of_shards: 1,
        number_of_replicas: 0,
        analysis: {
          analyzer: {
            compliance_analyzer: {
              type: 'custom',
              tokenizer: 'standard',
              filter: ['lowercase', 'compliance_synonyms'],
            },
          },
          filter: {
            compliance_synonyms: {
              type: 'synonym',
              synonyms: [
                'harassment, bullying, hostile',
                'fraud, deception, misrepresentation',
                'retaliation, revenge, reprisal',
              ],
            },
          },
        },
      },
      mappings: {
        properties: {
          // Core fields
          id: { type: 'keyword' },
          organizationId: { type: 'keyword' },
          referenceNumber: { type: 'keyword' },
          status: { type: 'keyword' },
          severity: { type: 'keyword' },
          createdAt: { type: 'date' },
          updatedAt: { type: 'date' },

          // Classification
          primaryCategoryId: { type: 'keyword' },
          primaryCategoryName: { type: 'text', fields: { keyword: { type: 'keyword' } } },
          secondaryCategoryId: { type: 'keyword' },

          // Pipeline
          pipelineStage: { type: 'keyword' },
          outcome: { type: 'keyword' },

          // Content (searchable)
          details: { type: 'text', analyzer: 'compliance_analyzer' },
          summary: { type: 'text', analyzer: 'compliance_analyzer' },
          aiSummary: { type: 'text', analyzer: 'compliance_analyzer' },

          // === DENORMALIZED ASSOCIATIONS for pattern detection ===
          associations: {
            properties: {
              persons: {
                type: 'nested',
                properties: {
                  personId: { type: 'keyword' },
                  personName: { type: 'text', fields: { keyword: { type: 'keyword' } } },
                  personEmail: { type: 'keyword' },
                  label: { type: 'keyword' },
                  evidentiaryStatus: { type: 'keyword' },
                  isActive: { type: 'boolean' },
                },
              },
              rius: {
                type: 'nested',
                properties: {
                  riuId: { type: 'keyword' },
                  riuReferenceNumber: { type: 'keyword' },
                  associationType: { type: 'keyword' },
                  riuType: { type: 'keyword' },
                },
              },
              linkedCases: {
                type: 'nested',
                properties: {
                  caseId: { type: 'keyword' },
                  caseReferenceNumber: { type: 'keyword' },
                  label: { type: 'keyword' },
                },
              },
            },
          },

          // Flattened for simple faceting (duplicates nested for performance)
          personIds: { type: 'keyword' },
          subjectPersonIds: { type: 'keyword' },
          witnessPersonIds: { type: 'keyword' },
          reporterPersonIds: { type: 'keyword' },
          investigatorPersonIds: { type: 'keyword' },
        },
      },
    };

    export type CaseDocument = {
      id: string;
      organizationId: string;
      referenceNumber: string;
      status: string;
      severity: string;
      createdAt: string;
      updatedAt: string;
      primaryCategoryId?: string;
      primaryCategoryName?: string;
      pipelineStage?: string;
      outcome?: string;
      details: string;
      summary?: string;
      aiSummary?: string;
      associations: {
        persons: Array<{
          personId: string;
          personName: string;
          personEmail?: string;
          label: string;
          evidentiaryStatus?: string;
          isActive: boolean;
        }>;
        rius: Array<{
          riuId: string;
          riuReferenceNumber: string;
          associationType: string;
          riuType: string;
        }>;
        linkedCases: Array<{
          caseId: string;
          caseReferenceNumber: string;
          label: string;
        }>;
      };
      personIds: string[];
      subjectPersonIds: string[];
      witnessPersonIds: string[];
      reporterPersonIds: string[];
      investigatorPersonIds: string[];
    };
    ```
  </action>
  <verify>
    ```bash
    cd apps/backend && npm run build
    ```
  </verify>
  <done>Case index mapping includes nested associations.persons, associations.rius, associations.linkedCases for pattern detection.</done>
</task>

<task type="auto">
  <name>Task 2: Create PatternDetectionService</name>
  <files>
    apps/backend/src/modules/associations/pattern-detection/pattern-detection.service.ts
    apps/backend/src/modules/associations/pattern-detection/pattern-detection.controller.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/associations/pattern-detection/pattern-detection.service.ts`:
       ```typescript
       import { Injectable, Logger } from '@nestjs/common';
       import { ElasticsearchService } from '@nestjs/elasticsearch';
       import { PrismaService } from '../../prisma/prisma.service';
       import { PersonCaseLabel } from '@prisma/client';

       interface PersonInvolvementSummary {
         personId: string;
         personName: string;
         totalCases: number;
         byRole: {
           label: string;
           count: number;
           byStatus?: { status: string; count: number }[];
         }[];
       }

       interface PatternSearchResult {
         cases: Array<{
           id: string;
           referenceNumber: string;
           status: string;
           createdAt: string;
         }>;
         total: number;
       }

       interface ReporterHistoryBadge {
         previousReportCount: number;
         showBadge: boolean;
         badgeText: string;
       }

       @Injectable()
       export class PatternDetectionService {
         private readonly logger = new Logger(PatternDetectionService.name);

         constructor(
           private readonly esService: ElasticsearchService,
           private readonly prisma: PrismaService,
         ) {}

         private getIndexName(organizationId: string): string {
           return `org_${organizationId}_cases`;
         }

         /**
          * Find all Cases where a Person appears, grouped by role.
          * This is the "wow moment" query for demos.
          */
         async getPersonInvolvementSummary(
           personId: string,
           organizationId: string,
         ): Promise<PersonInvolvementSummary> {
           const indexName = this.getIndexName(organizationId);

           // Get person info
           const person = await this.prisma.person.findUnique({
             where: { id: personId },
           });

           const result = await this.esService.search({
             index: indexName,
             body: {
               size: 0,
               query: {
                 nested: {
                   path: 'associations.persons',
                   query: {
                     term: { 'associations.persons.personId': personId },
                   },
                 },
               },
               aggs: {
                 person_roles: {
                   nested: { path: 'associations.persons' },
                   aggs: {
                     matching_person: {
                       filter: { term: { 'associations.persons.personId': personId } },
                       aggs: {
                         by_label: {
                           terms: { field: 'associations.persons.label', size: 20 },
                           aggs: {
                             by_evidentiary_status: {
                               terms: { field: 'associations.persons.evidentiaryStatus', size: 10 },
                             },
                           },
                         },
                       },
                     },
                   },
                 },
               },
             },
           });

           // Parse aggregations
           const aggs = result.aggregations as any;
           const buckets = aggs?.person_roles?.matching_person?.by_label?.buckets || [];

           return {
             personId,
             personName: person ? `${person.firstName} ${person.lastName}` : 'Unknown',
             totalCases: typeof result.hits.total === 'number' ? result.hits.total : result.hits.total?.value || 0,
             byRole: buckets.map((bucket: any) => ({
               label: bucket.key,
               count: bucket.doc_count,
               byStatus: bucket.by_evidentiary_status?.buckets?.map((sb: any) => ({
                 status: sb.key,
                 count: sb.doc_count,
               })),
             })),
           };
         }

         /**
          * Find Cases where multiple specific Persons are involved.
          * E.g., "Cases where Person A was subject AND Person B was witness"
          */
         async findCasesWithMultiplePersons(
           personCriteria: Array<{ personId: string; labels?: PersonCaseLabel[] }>,
           organizationId: string,
           options: { limit?: number; offset?: number } = {},
         ): Promise<PatternSearchResult> {
           const indexName = this.getIndexName(organizationId);
           const { limit = 20, offset = 0 } = options;

           const nestedQueries = personCriteria.map(criteria => ({
             nested: {
               path: 'associations.persons',
               query: {
                 bool: {
                   must: [
                     { term: { 'associations.persons.personId': criteria.personId } },
                     ...(criteria.labels ? [{ terms: { 'associations.persons.label': criteria.labels } }] : []),
                   ],
                 },
               },
             },
           }));

           const result = await this.esService.search({
             index: indexName,
             body: {
               from: offset,
               size: limit,
               query: {
                 bool: { must: nestedQueries },
               },
               sort: [{ createdAt: 'desc' }],
             },
           });

           return {
             cases: result.hits.hits.map((hit: any) => ({
               id: hit._source.id,
               referenceNumber: hit._source.referenceNumber,
               status: hit._source.status,
               createdAt: hit._source.createdAt,
             })),
             total: typeof result.hits.total === 'number' ? result.hits.total : result.hits.total?.value || 0,
           };
         }

         /**
          * Generate "history alert" badge data for triage view.
          * Per CONTEXT.md: "3 previous reports from this person"
          */
         async getReporterHistory(
           personId: string,
           excludeRiuId: string | null,
           organizationId: string,
         ): Promise<ReporterHistoryBadge> {
           // Count RIUs where this person is the reporter
           const count = await this.prisma.personRiuAssociation.count({
             where: {
               organizationId,
               personId,
               label: 'REPORTER',
               ...(excludeRiuId && { riuId: { not: excludeRiuId } }),
             },
           });

           return {
             previousReportCount: count,
             showBadge: count > 0,
             badgeText: count === 1
               ? '1 previous report'
               : `${count} previous reports`,
           };
         }

         /**
          * Find persons who appear in multiple cases with a specific role.
          * E.g., "People who have been subjects in 3+ cases"
          */
         async findRepeatInvolvements(
           label: PersonCaseLabel,
           minCount: number,
           organizationId: string,
         ): Promise<Array<{ personId: string; personName: string; caseCount: number }>> {
           const indexName = this.getIndexName(organizationId);

           const result = await this.esService.search({
             index: indexName,
             body: {
               size: 0,
               aggs: {
                 persons_by_role: {
                   nested: { path: 'associations.persons' },
                   aggs: {
                     filtered_by_label: {
                       filter: { term: { 'associations.persons.label': label } },
                       aggs: {
                         by_person: {
                           terms: {
                             field: 'associations.persons.personId',
                             size: 1000,
                             min_doc_count: minCount,
                           },
                           aggs: {
                             person_name: {
                               terms: { field: 'associations.persons.personName.keyword', size: 1 },
                             },
                           },
                         },
                       },
                     },
                   },
                 },
               },
             },
           });

           const aggs = result.aggregations as any;
           const buckets = aggs?.persons_by_role?.filtered_by_label?.by_person?.buckets || [];

           return buckets.map((bucket: any) => ({
             personId: bucket.key,
             personName: bucket.person_name?.buckets?.[0]?.key || 'Unknown',
             caseCount: bucket.doc_count,
           }));
         }

         /**
          * Get related cases for a given case (via associations).
          */
         async getRelatedCases(
           caseId: string,
           organizationId: string,
         ): Promise<Array<{ caseId: string; referenceNumber: string; label: string }>> {
           // Get case-case associations
           const associations = await this.prisma.caseCaseAssociation.findMany({
             where: {
               organizationId,
               OR: [
                 { sourceCaseId: caseId },
                 { targetCaseId: caseId },
               ],
             },
             include: {
               sourceCase: { select: { id: true, referenceNumber: true } },
               targetCase: { select: { id: true, referenceNumber: true } },
             },
           });

           return associations.map(assoc => {
             const isSource = assoc.sourceCaseId === caseId;
             const relatedCase = isSource ? assoc.targetCase : assoc.sourceCase;
             return {
               caseId: relatedCase.id,
               referenceNumber: relatedCase.referenceNumber,
               label: assoc.label,
             };
           });
         }
       }
       ```

    2. Create `apps/backend/src/modules/associations/pattern-detection/pattern-detection.controller.ts`:
       ```typescript
       import { Controller, Get, Query, Param, UseGuards } from '@nestjs/common';
       import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
       import { TenantId } from '../../common/decorators/tenant-id.decorator';
       import { PatternDetectionService } from './pattern-detection.service';

       @Controller('api/v1/patterns')
       @UseGuards(JwtAuthGuard)
       export class PatternDetectionController {
         constructor(private readonly patternService: PatternDetectionService) {}

         /**
          * Get involvement summary for a person.
          */
         @Get('person/:personId/involvement')
         async getPersonInvolvement(
           @Param('personId') personId: string,
           @TenantId() organizationId: string,
         ) {
           return this.patternService.getPersonInvolvementSummary(personId, organizationId);
         }

         /**
          * Get reporter history badge.
          */
         @Get('person/:personId/reporter-history')
         async getReporterHistory(
           @Param('personId') personId: string,
           @Query('excludeRiuId') excludeRiuId: string | undefined,
           @TenantId() organizationId: string,
         ) {
           return this.patternService.getReporterHistory(
             personId,
             excludeRiuId || null,
             organizationId,
           );
         }

         /**
          * Find repeat subjects/witnesses.
          */
         @Get('repeat-involvements')
         async findRepeatInvolvements(
           @Query('label') label: string,
           @Query('minCount') minCount: string,
           @TenantId() organizationId: string,
         ) {
           return this.patternService.findRepeatInvolvements(
             label as any,
             parseInt(minCount, 10) || 2,
             organizationId,
           );
         }

         /**
          * Get related cases.
          */
         @Get('case/:caseId/related')
         async getRelatedCases(
           @Param('caseId') caseId: string,
           @TenantId() organizationId: string,
         ) {
           return this.patternService.getRelatedCases(caseId, organizationId);
         }
       }
       ```
  </action>
  <verify>
    ```bash
    cd apps/backend && npm run build
    ```
  </verify>
  <done>PatternDetectionService provides ES-based pattern queries. Controller exposes endpoints for involvement summary, history badge, repeat involvements.</done>
</task>

<task type="auto">
  <name>Task 3: Update IndexingService to include associations when indexing Cases</name>
  <files>apps/backend/src/modules/search/indexing/indexing.service.ts</files>
  <action>
    Update the IndexingService to include denormalized association data when indexing Cases:

    1. Add method to build association document:
       ```typescript
       private async buildCaseAssociations(
         caseId: string,
         organizationId: string,
       ): Promise<CaseDocument['associations']> {
         // Get person-case associations
         const personAssocs = await this.prisma.personCaseAssociation.findMany({
           where: { caseId, organizationId },
           include: { person: true },
         });

         // Get RIU associations
         const riuAssocs = await this.prisma.riuCaseAssociation.findMany({
           where: { caseId },
           include: { riu: true },
         });

         // Get case-case associations
         const caseAssocs = await this.prisma.caseCaseAssociation.findMany({
           where: {
             organizationId,
             OR: [{ sourceCaseId: caseId }, { targetCaseId: caseId }],
           },
           include: { sourceCase: true, targetCase: true },
         });

         return {
           persons: personAssocs.map(a => ({
             personId: a.personId,
             personName: a.person ? `${a.person.firstName} ${a.person.lastName}` : '',
             personEmail: a.person?.email || undefined,
             label: a.label,
             evidentiaryStatus: a.evidentiaryStatus || undefined,
             isActive: !a.endedAt,
           })),
           rius: riuAssocs.map(a => ({
             riuId: a.riuId,
             riuReferenceNumber: a.riu.referenceNumber,
             associationType: a.associationType,
             riuType: a.riu.type,
           })),
           linkedCases: caseAssocs.map(a => {
             const isSource = a.sourceCaseId === caseId;
             const linked = isSource ? a.targetCase : a.sourceCase;
             return {
               caseId: linked.id,
               caseReferenceNumber: linked.referenceNumber,
               label: a.label,
             };
           }),
         };
       }
       ```

    2. Update indexCase method to include associations and flattened arrays:
       ```typescript
       async indexCase(caseId: string, organizationId: string): Promise<void> {
         const caseData = await this.prisma.case.findUnique({
           where: { id: caseId },
           include: { primaryCategory: true },
         });

         if (!caseData) return;

         const associations = await this.buildCaseAssociations(caseId, organizationId);

         const document: CaseDocument = {
           id: caseData.id,
           organizationId: caseData.organizationId,
           referenceNumber: caseData.referenceNumber,
           status: caseData.status,
           severity: caseData.severity,
           createdAt: caseData.createdAt.toISOString(),
           updatedAt: caseData.updatedAt.toISOString(),
           primaryCategoryId: caseData.primaryCategoryId || undefined,
           primaryCategoryName: caseData.primaryCategory?.name,
           pipelineStage: caseData.pipelineStage || undefined,
           outcome: caseData.outcome || undefined,
           details: caseData.details,
           summary: caseData.summary || undefined,
           aiSummary: caseData.aiSummary || undefined,
           associations,
           // Flattened for simple faceting
           personIds: associations.persons.map(p => p.personId),
           subjectPersonIds: associations.persons.filter(p => p.label === 'SUBJECT').map(p => p.personId),
           witnessPersonIds: associations.persons.filter(p => p.label === 'WITNESS').map(p => p.personId),
           reporterPersonIds: associations.persons.filter(p => p.label === 'REPORTER').map(p => p.personId),
           investigatorPersonIds: associations.persons.filter(p => p.label === 'ASSIGNED_INVESTIGATOR').map(p => p.personId),
         };

         await this.esService.index({
           index: this.getIndexName(organizationId, 'cases'),
           id: caseId,
           body: document,
         });
       }
       ```

    3. Add event listener to re-index case when associations change:
       ```typescript
       @OnEvent('association.person-case.created')
       @OnEvent('association.person-case.status-changed')
       async handleAssociationChange(payload: { caseId: string; organizationId: string }) {
         await this.indexCase(payload.caseId, payload.organizationId);
       }
       ```
  </action>
  <verify>
    ```bash
    cd apps/backend && npm run build
    ```
  </verify>
  <done>IndexingService includes denormalized associations when indexing Cases. Association changes trigger re-indexing.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build succeeds:
   ```bash
   cd apps/backend && npm run build
   ```

2. Type check passes:
   ```bash
   cd apps/backend && npm run typecheck
   ```

3. Pattern detection test (manual, requires ES running):
   - Index a Case with Person associations
   - Call GET /api/v1/patterns/person/{personId}/involvement
   - Verify response shows case counts by role
</verification>

<success_criteria>
- Case index mapping includes nested associations.persons with label and status
- PatternDetectionService.getPersonInvolvementSummary returns role breakdown
- findCasesWithMultiplePersons supports multi-person AND queries
- getReporterHistory provides badge data for triage view
- findRepeatInvolvements identifies repeat subjects/witnesses
- Associations are re-indexed when created or updated
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-entities/04-10-SUMMARY.md` using the summary template.
</output>
