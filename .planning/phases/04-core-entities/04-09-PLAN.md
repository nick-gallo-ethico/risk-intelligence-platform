---
phase: 04-core-entities
plan: 09
type: execute
wave: 4
depends_on: ["04-01", "04-04", "04-07"]
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/associations/associations.module.ts
  - apps/backend/src/modules/associations/person-case/person-case-association.service.ts
  - apps/backend/src/modules/associations/person-riu/person-riu-association.service.ts
  - apps/backend/src/modules/associations/case-case/case-case-association.service.ts
  - apps/backend/src/modules/associations/person-person/person-person-association.service.ts
  - apps/backend/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "Associations are first-class entities with labels, status, and audit fields"
    - "Person-Case associations have role labels (reporter, subject, witness, investigator)"
    - "Evidentiary associations use status (active, cleared, substantiated)"
    - "Role associations use validity periods (startedAt, endedAt)"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "PersonCaseAssociation, PersonRiuAssociation, CaseCaseAssociation, PersonPersonAssociation"
      contains: "model PersonCaseAssociation"
    - path: "apps/backend/src/modules/associations/person-case/person-case-association.service.ts"
      provides: "CRUD for Person-Case associations with role-based semantics"
      exports: ["PersonCaseAssociationService"]
  key_links:
    - from: "apps/backend/src/modules/associations/person-case/person-case-association.service.ts"
      to: "prisma.personCaseAssociation"
      via: "service injection"
      pattern: "this.prisma.personCaseAssociation"
---

<objective>
Create first-class Association entities per ASSOC-01 through ASSOC-03 and CONTEXT.md decisions.

Purpose: Per HubSpot V4 Associations pattern, associations are first-class entities with labels, metadata, and distinct semantics. Evidentiary associations (subject, witness, reporter) use status fields. Role associations (investigator, counsel) use validity periods. This enables powerful pattern detection queries.

Output: PersonCaseAssociation, PersonRiuAssociation, CaseCaseAssociation, PersonPersonAssociation models with corresponding services.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-entities/04-CONTEXT.md
@.planning/phases/04-core-entities/04-RESEARCH.md
@.planning/phases/04-core-entities/04-01-SUMMARY.md
@.planning/phases/04-core-entities/04-04-SUMMARY.md
@.planning/phases/04-core-entities/04-07-SUMMARY.md
@apps/backend/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Association models to Prisma schema</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
    Add association models and enums:

    1. Create association label enums:
       ```prisma
       enum PersonCaseLabel {
         REPORTER
         SUBJECT
         WITNESS
         ASSIGNED_INVESTIGATOR
         APPROVER
         STAKEHOLDER
         MANAGER_OF_SUBJECT
         REVIEWER
         LEGAL_COUNSEL

         @@map("person_case_label")
       }

       enum PersonRiuLabel {
         REPORTER
         SUBJECT_MENTIONED
         WITNESS_MENTIONED

         @@map("person_riu_label")
       }

       enum CaseCaseLabel {
         PARENT
         CHILD
         SPLIT_FROM
         SPLIT_TO
         RELATED
         ESCALATED_TO
         SUPERSEDES
         FOLLOW_UP_TO

         @@map("case_case_label")
       }

       enum PersonPersonLabel {
         MANAGER_OF
         REPORTS_TO
         SPOUSE
         DOMESTIC_PARTNER
         FAMILY_MEMBER
         FORMER_COLLEAGUE
         BUSINESS_PARTNER
         CLOSE_PERSONAL_FRIEND

         @@map("person_person_label")
       }

       enum EvidentiaryStatus {
         ACTIVE        // Investigation ongoing
         CLEARED       // Not substantiated
         SUBSTANTIATED // Investigation confirmed
         WITHDRAWN     // Reporter withdrew

         @@map("evidentiary_status")
       }

       enum PersonPersonSource {
         HRIS             // From HRIS manager hierarchy
         DISCLOSURE       // From disclosure form
         INVESTIGATION    // Discovered during investigation
         MANUAL           // Manually entered

         @@map("person_person_source")
       }
       ```

    2. Create PersonCaseAssociation model:
       ```prisma
       /// Person-to-Case association with role labels per ASSOC-02.
       /// Evidentiary associations (subject, witness, reporter) use status field.
       /// Role associations (investigator, counsel) use validity periods.
       model PersonCaseAssociation {
         id              String   @id @default(uuid())
         organizationId  String   @map("organization_id")
         personId        String   @map("person_id")
         caseId          String   @map("case_id")

         // Role label
         label           PersonCaseLabel

         // === EVIDENTIARY STATUS (for subject, witness, reporter) ===
         evidentiaryStatus    EvidentiaryStatus?  @map("evidentiary_status")
         evidentiaryStatusAt  DateTime?           @map("evidentiary_status_at")
         evidentiaryStatusById String?            @map("evidentiary_status_by_id")
         evidentiaryReason    String?             @map("evidentiary_reason")

         // === VALIDITY PERIOD (for role associations like investigator) ===
         startedAt       DateTime   @default(now()) @map("started_at")
         endedAt         DateTime?  @map("ended_at")
         endedReason     String?    @map("ended_reason")

         // Notes
         notes           String?

         // Audit
         createdAt       DateTime @default(now()) @map("created_at")
         createdById     String   @map("created_by_id")

         // Relations
         organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
         person          Person       @relation(fields: [personId], references: [id], onDelete: Cascade)
         case            Case         @relation(fields: [caseId], references: [id], onDelete: Cascade)

         @@unique([organizationId, personId, caseId, label])
         @@index([organizationId])
         @@index([organizationId, personId])
         @@index([organizationId, caseId])
         @@index([organizationId, label])
         @@index([organizationId, evidentiaryStatus])
         @@map("person_case_associations")
       }
       ```

    3. Create PersonRiuAssociation model:
       ```prisma
       /// Person-to-RIU association per ASSOC-01.
       /// Tracks who is mentioned in an RIU (reporter, subject, witness).
       model PersonRiuAssociation {
         id              String   @id @default(uuid())
         organizationId  String   @map("organization_id")
         personId        String   @map("person_id")
         riuId           String   @map("riu_id")

         // Role label
         label           PersonRiuLabel

         // Notes (how they were identified in the RIU)
         notes           String?
         mentionContext  String?  @map("mention_context")  // Quote from RIU

         // Audit
         createdAt       DateTime @default(now()) @map("created_at")
         createdById     String   @map("created_by_id")

         // Relations
         organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
         person          Person       @relation(fields: [personId], references: [id], onDelete: Cascade)
         riu             RiskIntelligenceUnit @relation(fields: [riuId], references: [id], onDelete: Cascade)

         @@unique([organizationId, personId, riuId, label])
         @@index([organizationId])
         @@index([organizationId, personId])
         @@index([organizationId, riuId])
         @@map("person_riu_associations")
       }
       ```

    4. Create CaseCaseAssociation model:
       ```prisma
       /// Case-to-Case association per CONTEXT.md decision.
       /// Supports hierarchy (parent/child), splits, escalations, etc.
       model CaseCaseAssociation {
         id              String   @id @default(uuid())
         organizationId  String   @map("organization_id")
         sourceCaseId    String   @map("source_case_id")  // "From" case
         targetCaseId    String   @map("target_case_id")  // "To" case

         // Directional label (source -> target)
         label           CaseCaseLabel

         // Notes
         notes           String?

         // Audit
         createdAt       DateTime @default(now()) @map("created_at")
         createdById     String   @map("created_by_id")

         // Relations
         organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
         sourceCase      Case         @relation("CaseAssociationSource", fields: [sourceCaseId], references: [id], onDelete: Cascade)
         targetCase      Case         @relation("CaseAssociationTarget", fields: [targetCaseId], references: [id], onDelete: Cascade)

         @@unique([organizationId, sourceCaseId, targetCaseId, label])
         @@index([organizationId])
         @@index([organizationId, sourceCaseId])
         @@index([organizationId, targetCaseId])
         @@map("case_case_associations")
       }
       ```

    5. Create PersonPersonAssociation model:
       ```prisma
       /// Person-to-Person relationship per CONTEXT.md decision.
       /// Sources: HRIS (manager), Disclosure (spouse, business partner), Investigation.
       /// Used for COI detection.
       model PersonPersonAssociation {
         id              String   @id @default(uuid())
         organizationId  String   @map("organization_id")
         personAId       String   @map("person_a_id")  // Canonical: A < B alphabetically
         personBId       String   @map("person_b_id")

         // Relationship label
         label           PersonPersonLabel

         // Source of relationship knowledge
         source          PersonPersonSource

         // Directional flag (if relationship is asymmetric like manager_of)
         isDirectional   Boolean @default(false) @map("is_directional")
         aToB            String? @map("a_to_b")  // A's relationship to B (e.g., "manager_of")
         bToA            String? @map("b_to_a")  // B's relationship to A (e.g., "reports_to")

         // Validity
         effectiveFrom   DateTime @default(now()) @map("effective_from")
         effectiveUntil  DateTime? @map("effective_until")

         // Notes
         notes           String?

         // Audit
         createdAt       DateTime @default(now()) @map("created_at")
         createdById     String   @map("created_by_id")

         // Relations
         organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
         personA         Person       @relation("PersonARelation", fields: [personAId], references: [id], onDelete: Cascade)
         personB         Person       @relation("PersonBRelation", fields: [personBId], references: [id], onDelete: Cascade)

         @@unique([organizationId, personAId, personBId, label])
         @@index([organizationId])
         @@index([organizationId, personAId])
         @@index([organizationId, personBId])
         @@index([organizationId, label])
         @@map("person_person_associations")
       }
       ```

    6. Add relation arrays to Person, Case, RiskIntelligenceUnit, Organization models.

    Run `npx prisma format` to validate.
  </action>
  <verify>
    ```bash
    cd apps/backend && npx prisma validate
    ```
  </verify>
  <done>All four association models exist with proper labels, status fields, validity periods, and relations.</done>
</task>

<task type="auto">
  <name>Task 2: Create Association services</name>
  <files>
    apps/backend/src/modules/associations/associations.module.ts
    apps/backend/src/modules/associations/person-case/person-case-association.service.ts
    apps/backend/src/modules/associations/person-riu/person-riu-association.service.ts
    apps/backend/src/modules/associations/case-case/case-case-association.service.ts
    apps/backend/src/modules/associations/person-person/person-person-association.service.ts
    apps/backend/src/app.module.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/associations/person-case/person-case-association.service.ts`:
       ```typescript
       import { Injectable, Logger, BadRequestException } from '@nestjs/common';
       import { PrismaService } from '../../prisma/prisma.service';
       import { EventEmitter2 } from '@nestjs/event-emitter';
       import { AuditService } from '../../audit/audit.service';
       import { PersonCaseLabel, EvidentiaryStatus } from '@prisma/client';

       // Evidentiary labels use status, not validity periods
       const EVIDENTIARY_LABELS: PersonCaseLabel[] = ['REPORTER', 'SUBJECT', 'WITNESS'];

       // Role labels use validity periods
       const ROLE_LABELS: PersonCaseLabel[] = [
         'ASSIGNED_INVESTIGATOR', 'APPROVER', 'STAKEHOLDER',
         'MANAGER_OF_SUBJECT', 'REVIEWER', 'LEGAL_COUNSEL'
       ];

       @Injectable()
       export class PersonCaseAssociationService {
         private readonly logger = new Logger(PersonCaseAssociationService.name);

         constructor(
           private prisma: PrismaService,
           private eventEmitter: EventEmitter2,
           private auditService: AuditService,
         ) {}

         /**
          * Create association between Person and Case.
          */
         async create(
           personId: string,
           caseId: string,
           label: PersonCaseLabel,
           userId: string,
           organizationId: string,
           options?: { notes?: string; evidentiaryStatus?: EvidentiaryStatus },
         ) {
           // Validate label semantics
           const isEvidentiary = EVIDENTIARY_LABELS.includes(label);

           const association = await this.prisma.personCaseAssociation.create({
             data: {
               organizationId,
               personId,
               caseId,
               label,
               notes: options?.notes,
               ...(isEvidentiary && {
                 evidentiaryStatus: options?.evidentiaryStatus || 'ACTIVE',
                 evidentiaryStatusAt: new Date(),
                 evidentiaryStatusById: userId,
               }),
               createdById: userId,
             },
             include: { person: true, case: true },
           });

           this.eventEmitter.emit('association.person-case.created', {
             organizationId,
             associationId: association.id,
             personId,
             caseId,
             label,
           });

           await this.auditService.log({
             entityType: 'CASE',
             entityId: caseId,
             action: 'association_created',
             actionDescription: `Person associated as ${label}`,
             actionCategory: 'CREATE',
             actorUserId: userId,
             actorType: 'USER',
             organizationId,
             context: { personId, label },
           });

           return association;
         }

         /**
          * Update evidentiary status (for subject, witness, reporter).
          */
         async updateEvidentiaryStatus(
           associationId: string,
           newStatus: EvidentiaryStatus,
           userId: string,
           organizationId: string,
           reason?: string,
         ) {
           const association = await this.prisma.personCaseAssociation.findFirst({
             where: { id: associationId, organizationId },
           });

           if (!association) {
             throw new BadRequestException('Association not found');
           }

           if (!EVIDENTIARY_LABELS.includes(association.label)) {
             throw new BadRequestException(
               `Cannot set evidentiary status on ${association.label} association`
             );
           }

           const oldStatus = association.evidentiaryStatus;

           const updated = await this.prisma.personCaseAssociation.update({
             where: { id: associationId },
             data: {
               evidentiaryStatus: newStatus,
               evidentiaryStatusAt: new Date(),
               evidentiaryStatusById: userId,
               evidentiaryReason: reason,
             },
           });

           this.eventEmitter.emit('association.person-case.status-changed', {
             organizationId,
             associationId,
             oldStatus,
             newStatus,
           });

           return updated;
         }

         /**
          * End a role association (for investigator, counsel, etc.).
          */
         async endRoleAssociation(
           associationId: string,
           userId: string,
           organizationId: string,
           reason?: string,
         ) {
           const association = await this.prisma.personCaseAssociation.findFirst({
             where: { id: associationId, organizationId },
           });

           if (!association) {
             throw new BadRequestException('Association not found');
           }

           if (!ROLE_LABELS.includes(association.label)) {
             throw new BadRequestException(
               `Cannot end ${association.label} association - evidentiary associations are permanent`
             );
           }

           return this.prisma.personCaseAssociation.update({
             where: { id: associationId },
             data: {
               endedAt: new Date(),
               endedReason: reason,
             },
           });
         }

         /**
          * Find all associations for a Case.
          */
         async findByCase(caseId: string, organizationId: string) {
           return this.prisma.personCaseAssociation.findMany({
             where: { organizationId, caseId },
             include: { person: true },
             orderBy: { createdAt: 'asc' },
           });
         }

         /**
          * Find all associations for a Person.
          */
         async findByPerson(personId: string, organizationId: string) {
           return this.prisma.personCaseAssociation.findMany({
             where: { organizationId, personId },
             include: { case: true },
             orderBy: { createdAt: 'desc' },
           });
         }

         /**
          * Find active associations by label.
          */
         async findByLabel(
           caseId: string,
           label: PersonCaseLabel,
           organizationId: string,
         ) {
           return this.prisma.personCaseAssociation.findMany({
             where: {
               organizationId,
               caseId,
               label,
               // For role associations, only return active (not ended)
               ...(ROLE_LABELS.includes(label) && { endedAt: null }),
             },
             include: { person: true },
           });
         }
       }
       ```

    2. Create similar services for PersonRiuAssociation, CaseCaseAssociation, PersonPersonAssociation.

    3. Create `apps/backend/src/modules/associations/associations.module.ts`:
       ```typescript
       import { Module } from '@nestjs/common';
       import { PersonCaseAssociationService } from './person-case/person-case-association.service';
       import { PersonRiuAssociationService } from './person-riu/person-riu-association.service';
       import { CaseCaseAssociationService } from './case-case/case-case-association.service';
       import { PersonPersonAssociationService } from './person-person/person-person-association.service';

       @Module({
         providers: [
           PersonCaseAssociationService,
           PersonRiuAssociationService,
           CaseCaseAssociationService,
           PersonPersonAssociationService,
         ],
         exports: [
           PersonCaseAssociationService,
           PersonRiuAssociationService,
           CaseCaseAssociationService,
           PersonPersonAssociationService,
         ],
       })
       export class AssociationsModule {}
       ```

    4. Register AssociationsModule in app.module.ts.
  </action>
  <verify>
    ```bash
    cd apps/backend && npm run build
    ```
  </verify>
  <done>AssociationsModule exists with services for all four association types, respecting evidentiary vs role semantics.</done>
</task>

<task type="auto">
  <name>Task 3: Run migration for Association tables</name>
  <files>apps/backend/prisma/migrations/</files>
  <action>
    1. Generate and apply migration:
       ```bash
       cd apps/backend && npx prisma migrate dev --name add_association_entities
       ```

    2. Verify migration creates:
       - All association enums
       - person_case_associations table
       - person_riu_associations table
       - case_case_associations table
       - person_person_associations table

    3. Regenerate Prisma client:
       ```bash
       cd apps/backend && npx prisma generate
       ```
  </action>
  <verify>
    ```bash
    cd apps/backend && npm run build
    ```
  </verify>
  <done>Database has all association tables with proper indexes and constraints.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Schema validates:
   ```bash
   cd apps/backend && npx prisma validate
   ```

2. Build succeeds:
   ```bash
   cd apps/backend && npm run build
   ```

3. Association semantics test (manual):
   - Create Person-Case association with label=SUBJECT
   - Verify evidentiaryStatus defaults to ACTIVE
   - Update evidentiaryStatus to CLEARED with reason
   - Verify endedAt remains null (evidentiary associations don't "end")
   - Create Person-Case association with label=ASSIGNED_INVESTIGATOR
   - Call endRoleAssociation - verify endedAt is set
</verification>

<success_criteria>
- PersonCaseAssociation has both evidentiary status AND validity period fields
- Evidentiary labels (SUBJECT, WITNESS, REPORTER) use status, not endedAt
- Role labels (INVESTIGATOR, COUNSEL) use validity periods
- PersonPersonAssociation supports bidirectional relationships
- CaseCaseAssociation supports case hierarchy and splits
- All associations have audit trail via createdBy and AuditLog
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-entities/04-09-SUMMARY.md` using the summary template.
</output>
