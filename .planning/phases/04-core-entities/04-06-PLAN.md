---
phase: 04-core-entities
plan: 06
type: execute
wave: 3
depends_on: ["04-05"]
files_modified:
  - apps/backend/src/modules/rius/riu-access.service.ts
  - apps/backend/src/modules/rius/riu-access.controller.ts
  - apps/backend/src/modules/rius/dto/access-code.dto.ts
  - apps/backend/src/modules/rius/rius.module.ts
autonomous: true

must_haves:
  truths:
    - "Anonymous reporters receive a unique access code upon RIU submission"
    - "Access codes can be used to check RIU status without authentication"
    - "Access codes enable viewing relay messages between reporter and investigator"
    - "Access codes are cryptographically secure (12+ characters)"
  artifacts:
    - path: "apps/backend/src/modules/rius/riu-access.service.ts"
      provides: "Access code generation and lookup"
      exports: ["RiuAccessService"]
    - path: "apps/backend/src/modules/rius/riu-access.controller.ts"
      provides: "Public endpoints for access code operations"
      exports: ["RiuAccessController"]
  key_links:
    - from: "apps/backend/src/modules/rius/riu-access.controller.ts"
      to: "RiuAccessService.checkStatus"
      via: "service injection"
      pattern: "this.accessService.checkStatus"
---

<objective>
Implement anonymous access code generation and status checking for RIUs per RIU-06.

Purpose: Anonymous reporters need a way to check the status of their report and communicate with investigators without revealing their identity. The access code serves as their "ticket" to the anonymous relay system.

Output: RiuAccessService for code generation and lookup, public controller for unauthenticated status checks.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-entities/04-CONTEXT.md
@.planning/phases/04-core-entities/04-05-SUMMARY.md
@apps/backend/prisma/schema.prisma
@apps/backend/src/modules/rius/rius.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RiuAccessService for code generation and lookup</name>
  <files>
    apps/backend/src/modules/rius/riu-access.service.ts
    apps/backend/src/modules/rius/dto/access-code.dto.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/rius/dto/access-code.dto.ts`:
       ```typescript
       import { IsString, Length, Matches } from 'class-validator';

       export class AccessCodeDto {
         @IsString()
         @Length(12, 20)
         @Matches(/^[A-Z0-9]+$/, {
           message: 'Access code must contain only uppercase letters and numbers',
         })
         accessCode: string;
       }

       export class RiuStatusResponseDto {
         accessCode: string;
         status: string;
         statusDescription: string;
         submittedAt: Date;
         lastUpdatedAt: Date;
         hasMessages: boolean;
         unreadMessageCount: number;
         caseLinked: boolean;
         caseReferenceNumber?: string;
       }

       export class RiuMessagesResponseDto {
         messages: {
           id: string;
           direction: 'inbound' | 'outbound';
           content: string;
           createdAt: Date;
           isRead: boolean;
         }[];
         totalCount: number;
       }

       export class SendMessageDto {
         @IsString()
         @Length(1, 10000)
         content: string;
       }
       ```

    2. Create `apps/backend/src/modules/rius/riu-access.service.ts`:
       ```typescript
       import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';
       import { PrismaService } from '../prisma/prisma.service';
       import { EventEmitter2 } from '@nestjs/event-emitter';
       import { customAlphabet } from 'nanoid';
       import { RiuStatusResponseDto, RiuMessagesResponseDto } from './dto/access-code.dto';

       // Generate access codes: uppercase letters and numbers, 12 characters
       // Alphabet excludes confusing characters: 0/O, 1/I/L
       const generateAccessCode = customAlphabet('ABCDEFGHJKMNPQRSTUVWXYZ23456789', 12);

       @Injectable()
       export class RiuAccessService {
         private readonly logger = new Logger(RiuAccessService.name);

         constructor(
           private prisma: PrismaService,
           private eventEmitter: EventEmitter2,
         ) {}

         /**
          * Generate a unique access code for anonymous RIU
          */
         async generateAccessCode(): Promise<string> {
           let code: string;
           let attempts = 0;
           const maxAttempts = 10;

           // Ensure uniqueness
           do {
             code = generateAccessCode();
             const existing = await this.prisma.riskIntelligenceUnit.findFirst({
               where: { anonymousAccessCode: code },
             });
             if (!existing) break;
             attempts++;
           } while (attempts < maxAttempts);

           if (attempts >= maxAttempts) {
             throw new Error('Failed to generate unique access code');
           }

           return code;
         }

         /**
          * Check status of RIU by access code (public, no auth required)
          */
         async checkStatus(accessCode: string): Promise<RiuStatusResponseDto> {
           const riu = await this.prisma.riskIntelligenceUnit.findFirst({
             where: { anonymousAccessCode: accessCode },
             include: {
               caseAssociations: {
                 include: { case: true },
               },
             },
           });

           if (!riu) {
             // Don't reveal whether code exists or not
             throw new NotFoundException('Invalid access code');
           }

           // Get unread message count
           const linkedCaseId = riu.caseAssociations[0]?.caseId;
           let unreadMessageCount = 0;
           if (linkedCaseId) {
             unreadMessageCount = await this.prisma.caseMessage.count({
               where: {
                 caseId: linkedCaseId,
                 direction: 'OUTBOUND', // Messages TO reporter
                 isRead: false,
               },
             });
           }

           return {
             accessCode: riu.anonymousAccessCode!,
             status: riu.status,
             statusDescription: this.getStatusDescription(riu.status),
             submittedAt: riu.createdAt,
             lastUpdatedAt: riu.statusChangedAt || riu.createdAt,
             hasMessages: unreadMessageCount > 0,
             unreadMessageCount,
             caseLinked: riu.caseAssociations.length > 0,
             caseReferenceNumber: riu.caseAssociations[0]?.case?.referenceNumber,
           };
         }

         /**
          * Get messages for RIU by access code
          */
         async getMessages(accessCode: string): Promise<RiuMessagesResponseDto> {
           const riu = await this.prisma.riskIntelligenceUnit.findFirst({
             where: { anonymousAccessCode: accessCode },
             include: {
               caseAssociations: true,
             },
           });

           if (!riu) {
             throw new NotFoundException('Invalid access code');
           }

           const linkedCaseId = riu.caseAssociations[0]?.caseId;
           if (!linkedCaseId) {
             return { messages: [], totalCount: 0 };
           }

           const messages = await this.prisma.caseMessage.findMany({
             where: { caseId: linkedCaseId },
             orderBy: { createdAt: 'asc' },
           });

           // Mark outbound messages as read
           await this.prisma.caseMessage.updateMany({
             where: {
               caseId: linkedCaseId,
               direction: 'OUTBOUND',
               isRead: false,
             },
             data: {
               isRead: true,
               readAt: new Date(),
             },
           });

           return {
             messages: messages.map(m => ({
               id: m.id,
               direction: m.direction.toLowerCase() as 'inbound' | 'outbound',
               content: m.content,
               createdAt: m.createdAt,
               isRead: m.isRead,
             })),
             totalCount: messages.length,
           };
         }

         /**
          * Send message from reporter (via access code)
          */
         async sendMessage(accessCode: string, content: string): Promise<void> {
           const riu = await this.prisma.riskIntelligenceUnit.findFirst({
             where: { anonymousAccessCode: accessCode },
             include: {
               caseAssociations: true,
             },
           });

           if (!riu) {
             throw new NotFoundException('Invalid access code');
           }

           const linkedCaseId = riu.caseAssociations[0]?.caseId;
           if (!linkedCaseId) {
             throw new BadRequestException(
               'Your report has not been assigned to a case yet. Please check back later.'
             );
           }

           // Create inbound message (from reporter)
           const message = await this.prisma.caseMessage.create({
             data: {
               organizationId: riu.organizationId,
               caseId: linkedCaseId,
               direction: 'INBOUND',
               senderType: 'REPORTER',
               content,
               isRead: false,
             },
           });

           // Emit event for notification
           this.eventEmitter.emit('case.message.received', {
             organizationId: riu.organizationId,
             caseId: linkedCaseId,
             messageId: message.id,
             riuId: riu.id,
             isAnonymous: true,
           });
         }

         /**
          * Validate access code format (doesn't check existence)
          */
         isValidFormat(code: string): boolean {
           return /^[A-Z0-9]{12}$/.test(code);
         }

         private getStatusDescription(status: string): string {
           const descriptions: Record<string, string> = {
             PENDING_QA: 'Your report is being reviewed by our team.',
             IN_QA: 'Your report is currently under review.',
             QA_REJECTED: 'We need additional information. Please check messages.',
             RELEASED: 'Your report has been received and is being processed.',
             LINKED: 'Your report has been assigned to an investigator.',
             CLOSED: 'Your report has been closed. Thank you for reporting.',
             RECEIVED: 'Your report has been received.',
             COMPLETED: 'Your submission has been completed.',
           };
           return descriptions[status] || 'Status unknown';
         }
       }
       ```
  </action>
  <verify>
    ```bash
    cd apps/backend && npm run build
    ```
  </verify>
  <done>RiuAccessService exists with generateAccessCode, checkStatus, getMessages, sendMessage methods.</done>
</task>

<task type="auto">
  <name>Task 2: Create public controller for access code operations</name>
  <files>
    apps/backend/src/modules/rius/riu-access.controller.ts
    apps/backend/src/modules/rius/rius.module.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/rius/riu-access.controller.ts`:
       ```typescript
       import {
         Controller,
         Get,
         Post,
         Body,
         Param,
         UseGuards,
         HttpCode,
         HttpStatus,
       } from '@nestjs/common';
       import { Throttle } from '@nestjs/throttler';
       import { RiuAccessService } from './riu-access.service';
       import {
         AccessCodeDto,
         SendMessageDto,
         RiuStatusResponseDto,
         RiuMessagesResponseDto,
       } from './dto/access-code.dto';

       /**
        * Public controller for anonymous RIU access.
        * NO authentication required - uses access code as authorization.
        * Rate limited to prevent brute-force attacks.
        */
       @Controller('api/v1/public/access')
       export class RiuAccessController {
         constructor(private readonly accessService: RiuAccessService) {}

         /**
          * Check RIU status by access code
          * Rate limit: 10 requests per minute per IP
          */
         @Get(':accessCode/status')
         @Throttle({ default: { limit: 10, ttl: 60000 } })
         async checkStatus(
           @Param() params: AccessCodeDto,
         ): Promise<RiuStatusResponseDto> {
           return this.accessService.checkStatus(params.accessCode);
         }

         /**
          * Get messages for RIU by access code
          * Rate limit: 20 requests per minute per IP
          */
         @Get(':accessCode/messages')
         @Throttle({ default: { limit: 20, ttl: 60000 } })
         async getMessages(
           @Param() params: AccessCodeDto,
         ): Promise<RiuMessagesResponseDto> {
           return this.accessService.getMessages(params.accessCode);
         }

         /**
          * Send message as anonymous reporter
          * Rate limit: 5 messages per minute per IP
          */
         @Post(':accessCode/messages')
         @HttpCode(HttpStatus.CREATED)
         @Throttle({ default: { limit: 5, ttl: 60000 } })
         async sendMessage(
           @Param() params: AccessCodeDto,
           @Body() dto: SendMessageDto,
         ): Promise<{ success: boolean }> {
           await this.accessService.sendMessage(params.accessCode, dto.content);
           return { success: true };
         }
       }
       ```

    2. Update `apps/backend/src/modules/rius/rius.module.ts`:
       - Add RiuAccessService to providers
       - Add RiuAccessController to controllers
       - Ensure nanoid is installed (should be - used in forms module)

    3. Verify nanoid is installed:
       ```bash
       cd apps/backend && npm list nanoid || npm install nanoid
       ```
  </action>
  <verify>
    ```bash
    cd apps/backend && npm run build
    ```
  </verify>
  <done>RiuAccessController provides public endpoints for status check, messages, and sending messages via access code.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build succeeds:
   ```bash
   cd apps/backend && npm run build
   ```

2. Type check passes:
   ```bash
   cd apps/backend && npm run typecheck
   ```

3. Manual test (if server running):
   ```bash
   # Check status (no auth required)
   curl http://localhost:3000/api/v1/public/access/ABCD1234EFGH/status

   # Get messages
   curl http://localhost:3000/api/v1/public/access/ABCD1234EFGH/messages

   # Send message
   curl -X POST http://localhost:3000/api/v1/public/access/ABCD1234EFGH/messages \
     -H "Content-Type: application/json" \
     -d '{"content": "I have additional information..."}'
   ```
</verification>

<success_criteria>
- Access codes are 12-character uppercase alphanumeric (excludes confusing chars)
- checkStatus returns RIU status, message counts, case link info
- getMessages marks outbound messages as read when retrieved
- sendMessage creates inbound CaseMessage and emits event
- All endpoints are rate-limited to prevent abuse
- No authentication required (access code IS the authorization)
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-entities/04-06-SUMMARY.md` using the summary template.
</output>
