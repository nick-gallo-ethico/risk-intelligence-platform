---
phase: 04-core-entities
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/rius/rius.service.ts
  - apps/backend/src/modules/rius/dto/create-riu.dto.ts
  - apps/backend/src/modules/rius/types/riu.types.ts
autonomous: true

must_haves:
  truths:
    - "RIU content (details, reporterName, etc.) cannot be modified after creation"
    - "RIU status CAN be modified (New -> Triaged -> Linked -> Closed)"
    - "RIU has no updatedAt field to emphasize immutability"
    - "Only AI enrichment fields and status can change post-creation"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "RIU model with immutability constraints"
      contains: "// IMMUTABLE fields"
    - path: "apps/backend/src/modules/rius/rius.service.ts"
      provides: "RIU service enforcing immutability"
      exports: ["RiusService"]
  key_links:
    - from: "apps/backend/src/modules/rius/rius.service.ts"
      to: "prisma.riskIntelligenceUnit"
      via: "update method blocks immutable fields"
      pattern: "throw.*immutable"
---

<objective>
Enhance the existing RIU entity with proper immutability enforcement and expanded status workflow.

Purpose: Per RIU-01 and RIU-04, RIU content is frozen at intake. This plan adds explicit immutability enforcement in the service layer and expands the status field to support full RIU lifecycle (not just QA workflow).

Output: Enhanced RIU schema with immutability markers, service-layer enforcement, expanded status enum.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-entities/04-CONTEXT.md
@.planning/phases/04-core-entities/04-RESEARCH.md
@apps/backend/prisma/schema.prisma
@apps/backend/src/modules/cases/cases.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand RIU status enum and add language fields</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
    1. Update RiuStatus enum to support full lifecycle per CONTEXT.md:
       ```prisma
       enum RiuStatus {
         // QA workflow
         PENDING_QA     // Awaiting QA review (hotline reports)
         IN_QA          // Currently being reviewed
         QA_REJECTED    // QA found issues, needs rework

         // Post-QA states
         RELEASED       // QA approved, ready for Case creation
         LINKED         // Associated with one or more Cases
         CLOSED         // RIU closed without creating Case (valid per HubSpot pattern)

         // Campaign responses
         RECEIVED       // Web form - no QA needed
         COMPLETED      // Campaign response completed

         @@map("riu_status")
       }
       ```

    2. Add language handling fields per CONTEXT.md decision:
       ```prisma
       // In RiskIntelligenceUnit model
       languageDetected   String?   @map("language_detected")   // Auto-detected
       languageConfirmed  String?   @map("language_confirmed")  // Manual override
       languageEffective  String?   @map("language_effective")  // confirmed ?? detected ?? 'en'
       ```

    3. Add statusChangedAt and statusChangedById for tracking:
       ```prisma
       statusChangedAt    DateTime? @map("status_changed_at")
       statusChangedById  String?   @map("status_changed_by_id")
       ```

    4. Add comments marking immutable vs mutable fields:
       ```prisma
       model RiskIntelligenceUnit {
         // ... existing fields ...

         // === IMMUTABLE FIELDS (set at creation, never modified) ===
         type              RiuType
         sourceChannel     RiuSourceChannel @map("source_channel")
         details           String  // Reporter's narrative
         summary           String?
         reporterType      RiuReporterType @map("reporter_type")
         // ... other immutable fields ...

         // === MUTABLE FIELDS (can change after creation) ===
         status            RiuStatus @default(PENDING_QA)
         statusChangedAt   DateTime? @map("status_changed_at")
         statusChangedById String?   @map("status_changed_by_id")

         // === AI ENRICHMENT (can be regenerated) ===
         aiSummary         String?   @map("ai_summary")
         // ... other AI fields ...
       }
       ```

    Run `npx prisma format` to validate.
  </action>
  <verify>
    ```bash
    cd apps/backend && npx prisma validate
    ```
  </verify>
  <done>RiuStatus enum expanded with full lifecycle states. Language fields and status tracking added.</done>
</task>

<task type="auto">
  <name>Task 2: Create or update RIU service with immutability enforcement</name>
  <files>
    apps/backend/src/modules/rius/rius.service.ts
    apps/backend/src/modules/rius/dto/create-riu.dto.ts
    apps/backend/src/modules/rius/types/riu.types.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/rius/types/riu.types.ts` if not exists:
       ```typescript
       // Fields that cannot be modified after RIU creation
       export const IMMUTABLE_RIU_FIELDS = [
         'type',
         'sourceChannel',
         'details',
         'summary',
         'reporterType',
         'anonymousAccessCode',
         'reporterName',
         'reporterEmail',
         'reporterPhone',
         'categoryId',
         'severity',
         'locationName',
         'locationAddress',
         'locationCity',
         'locationState',
         'locationZip',
         'locationCountry',
         'formResponses',
         'customFields',
         'createdAt',
         'createdById',
       ] as const;

       // Fields that CAN be modified
       export const MUTABLE_RIU_FIELDS = [
         'status',
         'statusChangedAt',
         'statusChangedById',
         'aiSummary',
         'aiRiskScore',
         'aiTranslation',
         'aiLanguageDetected',
         'aiModelVersion',
         'aiGeneratedAt',
         'aiConfidenceScore',
         'languageDetected',
         'languageConfirmed',
         'languageEffective',
       ] as const;

       export type ImmutableRiuField = typeof IMMUTABLE_RIU_FIELDS[number];
       export type MutableRiuField = typeof MUTABLE_RIU_FIELDS[number];
       ```

    2. Update/create `apps/backend/src/modules/rius/rius.service.ts`:
       ```typescript
       import { Injectable, BadRequestException, Logger } from '@nestjs/common';
       import { EventEmitter2 } from '@nestjs/event-emitter';
       import { PrismaService } from '../prisma/prisma.service';
       import { AuditService } from '../audit/audit.service';
       import { IMMUTABLE_RIU_FIELDS, MUTABLE_RIU_FIELDS } from './types/riu.types';
       import { CreateRiuDto, UpdateRiuDto } from './dto';

       @Injectable()
       export class RiusService {
         private readonly logger = new Logger(RiusService.name);

         constructor(
           private prisma: PrismaService,
           private eventEmitter: EventEmitter2,
           private auditService: AuditService,
         ) {}

         async create(dto: CreateRiuDto, userId: string, organizationId: string) {
           // Generate reference number
           const count = await this.prisma.riskIntelligenceUnit.count({
             where: { organizationId },
           });
           const referenceNumber = `RIU-${new Date().getFullYear()}-${String(count + 1).padStart(5, '0')}`;

           // Compute effective language
           const languageEffective = dto.languageConfirmed ?? dto.languageDetected ?? 'en';

           const riu = await this.prisma.riskIntelligenceUnit.create({
             data: {
               ...dto,
               organizationId,
               referenceNumber,
               languageEffective,
               createdById: userId,
             },
           });

           // Emit event
           this.eventEmitter.emit('riu.created', {
             organizationId,
             riuId: riu.id,
             type: riu.type,
           });

           // Log audit
           await this.auditService.log({
             entityType: 'RIU',
             entityId: riu.id,
             action: 'created',
             actionDescription: `RIU ${referenceNumber} created via ${riu.sourceChannel}`,
             actionCategory: 'CREATE',
             actorUserId: userId,
             actorType: 'USER',
             organizationId,
           });

           return riu;
         }

         /**
          * Update RIU - ENFORCES IMMUTABILITY
          * Only status and AI enrichment fields can be modified.
          */
         async update(
           id: string,
           dto: UpdateRiuDto,
           userId: string,
           organizationId: string,
         ) {
           // Check for attempts to modify immutable fields
           const attemptedImmutableChanges = Object.keys(dto).filter(
             key => IMMUTABLE_RIU_FIELDS.includes(key as any)
           );

           if (attemptedImmutableChanges.length > 0) {
             throw new BadRequestException(
               `Cannot modify immutable RIU fields: ${attemptedImmutableChanges.join(', ')}. ` +
               `RIU content is frozen at intake. Corrections should go on the linked Case.`
             );
           }

           const existing = await this.prisma.riskIntelligenceUnit.findUnique({
             where: { id },
           });

           if (!existing || existing.organizationId !== organizationId) {
             throw new BadRequestException('RIU not found');
           }

           // Track status change
           const statusChanged = dto.status && dto.status !== existing.status;

           const updated = await this.prisma.riskIntelligenceUnit.update({
             where: { id },
             data: {
               ...dto,
               ...(statusChanged && {
                 statusChangedAt: new Date(),
                 statusChangedById: userId,
               }),
             },
           });

           // Emit status change event if applicable
           if (statusChanged) {
             this.eventEmitter.emit('riu.status.changed', {
               organizationId,
               riuId: id,
               oldStatus: existing.status,
               newStatus: dto.status,
             });

             await this.auditService.log({
               entityType: 'RIU',
               entityId: id,
               action: 'status_changed',
               actionDescription: `RIU status changed from ${existing.status} to ${dto.status}`,
               actionCategory: 'UPDATE',
               actorUserId: userId,
               actorType: 'USER',
               organizationId,
               changes: { status: { old: existing.status, new: dto.status } },
             });
           }

           return updated;
         }

         /**
          * Update status specifically - convenience method
          */
         async updateStatus(
           id: string,
           newStatus: string,
           userId: string,
           organizationId: string,
         ) {
           return this.update(id, { status: newStatus as any }, userId, organizationId);
         }

         /**
          * Update AI enrichment - allowed even though content is immutable
          */
         async updateAiEnrichment(
           id: string,
           enrichment: {
             aiSummary?: string;
             aiRiskScore?: number;
             aiTranslation?: string;
             aiLanguageDetected?: string;
             aiConfidenceScore?: number;
             aiModelVersion?: string;
           },
           organizationId: string,
         ) {
           return this.prisma.riskIntelligenceUnit.update({
             where: { id },
             data: {
               ...enrichment,
               aiGeneratedAt: new Date(),
             },
           });
         }

         async findOne(id: string, organizationId: string) {
           return this.prisma.riskIntelligenceUnit.findFirst({
             where: { id, organizationId },
             include: {
               caseAssociations: { include: { case: true } },
               category: true,
             },
           });
         }

         async findAll(organizationId: string, filters?: {
           type?: string;
           status?: string;
           sourceChannel?: string;
           limit?: number;
           offset?: number;
         }) {
           return this.prisma.riskIntelligenceUnit.findMany({
             where: {
               organizationId,
               ...(filters?.type && { type: filters.type as any }),
               ...(filters?.status && { status: filters.status as any }),
               ...(filters?.sourceChannel && { sourceChannel: filters.sourceChannel as any }),
             },
             take: filters?.limit ?? 50,
             skip: filters?.offset ?? 0,
             orderBy: { createdAt: 'desc' },
           });
         }
       }
       ```

    3. Create `apps/backend/src/modules/rius/dto/update-riu.dto.ts`:
       ```typescript
       import { IsEnum, IsOptional, IsString, IsNumber, Min, Max } from 'class-validator';
       import { RiuStatus } from '@prisma/client';

       /**
        * UpdateRiuDto - Only mutable fields allowed
        * Attempts to update immutable fields will be rejected by service.
        */
       export class UpdateRiuDto {
         @IsEnum(RiuStatus)
         @IsOptional()
         status?: RiuStatus;

         @IsString()
         @IsOptional()
         aiSummary?: string;

         @IsNumber()
         @Min(0)
         @Max(1)
         @IsOptional()
         aiRiskScore?: number;

         @IsString()
         @IsOptional()
         aiTranslation?: string;

         @IsString()
         @IsOptional()
         languageConfirmed?: string;
       }
       ```
  </action>
  <verify>
    ```bash
    cd apps/backend && npm run build
    ```
  </verify>
  <done>RiusService enforces immutability - throws BadRequestException when attempting to modify immutable fields.</done>
</task>

<task type="auto">
  <name>Task 3: Run migration and test immutability</name>
  <files>apps/backend/prisma/migrations/</files>
  <action>
    1. Generate migration for status enum and language fields:
       ```bash
       cd apps/backend && npx prisma migrate dev --name expand_riu_status_and_language
       ```

    2. Regenerate Prisma client:
       ```bash
       cd apps/backend && npx prisma generate
       ```

    3. Build and verify:
       ```bash
       cd apps/backend && npm run build
       ```
  </action>
  <verify>
    ```bash
    cd apps/backend && npm run build && npm run typecheck
    ```
  </verify>
  <done>Database updated with expanded RiuStatus enum and language fields. Build succeeds.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Schema validates:
   ```bash
   cd apps/backend && npx prisma validate
   ```

2. Build succeeds:
   ```bash
   cd apps/backend && npm run build
   ```

3. Immutability test (manual):
   - Create RIU with details = "Original report"
   - Attempt to update details -> should throw BadRequestException
   - Update status -> should succeed
   - Update aiSummary -> should succeed
</verification>

<success_criteria>
- RiuStatus enum includes full lifecycle (PENDING_QA through CLOSED)
- Language fields (detected, confirmed, effective) exist
- RiusService.update() throws when attempting to modify immutable fields
- Status changes are tracked with statusChangedAt and statusChangedById
- AI enrichment updates work independently of immutability rules
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-entities/04-04-SUMMARY.md` using the summary template.
</output>
