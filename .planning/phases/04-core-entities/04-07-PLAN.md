---
phase: 04-core-entities
plan: 07
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/cases/case-pipeline.service.ts
  - apps/backend/src/modules/cases/case-merge.service.ts
  - apps/backend/src/modules/cases/dto/merge-case.dto.ts
  - apps/backend/src/modules/cases/cases.module.ts
autonomous: true

must_haves:
  truths:
    - "Cases can be assigned to configurable pipeline stages (per tenant)"
    - "Case classification may differ from RIU - corrections go on Case"
    - "Cases can be merged with full audit trail"
    - "Merged cases become tombstones pointing to primary case"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "Case pipeline fields and merge tracking"
      contains: "pipelineStage"
    - path: "apps/backend/src/modules/cases/case-merge.service.ts"
      provides: "Case merge operations"
      exports: ["CaseMergeService"]
  key_links:
    - from: "apps/backend/src/modules/cases/case-merge.service.ts"
      to: "prisma.case"
      via: "transaction for merge"
      pattern: "prisma.\\$transaction"
---

<objective>
Enhance the Case entity with pipeline stages and merge support per CASE-01 through CASE-04.

Purpose: Cases are the mutable work containers (HubSpot Deal equivalent). They need configurable pipeline stages for workflow tracking and merge capability for consolidating related reports. Classification on Case can differ from RIU because corrections and re-categorization happen at the Case level.

Output: Enhanced Case model with pipeline fields, CasePipelineService for stage management, CaseMergeService for consolidation.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-entities/04-CONTEXT.md
@.planning/phases/04-core-entities/04-01-SUMMARY.md
@apps/backend/prisma/schema.prisma
@apps/backend/src/modules/cases/cases.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pipeline and merge fields to Case model</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
    1. Add CaseOutcome enum per CASE-06:
       ```prisma
       enum CaseOutcome {
         SUBSTANTIATED
         UNSUBSTANTIATED
         INCONCLUSIVE
         POLICY_VIOLATION
         NO_VIOLATION

         @@map("case_outcome")
       }
       ```

    2. Add pipeline and merge fields to Case model:
       ```prisma
       // In Case model, add:

       // === PIPELINE (configurable per tenant) ===
       pipelineId        String?   @map("pipeline_id")  // References workflow template
       pipelineStage     String?   @map("pipeline_stage")  // Current stage name
       pipelineStageAt   DateTime? @map("pipeline_stage_at")  // When entered stage
       pipelineStageById String?   @map("pipeline_stage_by_id")  // Who moved to stage

       // === CLASSIFICATION (may differ from RIU - this is corrected) ===
       classificationNotes    String?  @map("classification_notes")  // Why reclassified
       classificationChangedAt DateTime? @map("classification_changed_at")
       classificationChangedById String? @map("classification_changed_by_id")

       // === OUTCOME ===
       outcome           CaseOutcome?
       outcomeNotes      String?       @map("outcome_notes")
       outcomeAt         DateTime?     @map("outcome_at")
       outcomeById       String?       @map("outcome_by_id")

       // === MERGE SUPPORT ===
       mergedIntoCaseId  String?   @map("merged_into_case_id")
       mergedAt          DateTime? @map("merged_at")
       mergedById        String?   @map("merged_by_id")
       mergedReason      String?   @map("merged_reason")
       isMerged          Boolean   @default(false) @map("is_merged")

       // Add self-relation for merge
       mergedIntoCase    Case?   @relation("CaseMerge", fields: [mergedIntoCaseId], references: [id])
       mergedFromCases   Case[]  @relation("CaseMerge")
       ```

    3. Add indexes:
       ```prisma
       @@index([organizationId, pipelineStage])
       @@index([organizationId, outcome])
       @@index([organizationId, isMerged])
       ```

    Run `npx prisma format` to validate.
  </action>
  <verify>
    ```bash
    cd apps/backend && npx prisma validate
    ```
  </verify>
  <done>Case model has pipeline, classification, outcome, and merge fields with proper indexes.</done>
</task>

<task type="auto">
  <name>Task 2: Create CasePipelineService and CaseMergeService</name>
  <files>
    apps/backend/src/modules/cases/case-pipeline.service.ts
    apps/backend/src/modules/cases/case-merge.service.ts
    apps/backend/src/modules/cases/dto/merge-case.dto.ts
    apps/backend/src/modules/cases/cases.module.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/cases/case-pipeline.service.ts`:
       ```typescript
       import { Injectable, Logger, BadRequestException } from '@nestjs/common';
       import { PrismaService } from '../prisma/prisma.service';
       import { EventEmitter2 } from '@nestjs/event-emitter';
       import { AuditService } from '../audit/audit.service';

       @Injectable()
       export class CasePipelineService {
         private readonly logger = new Logger(CasePipelineService.name);

         constructor(
           private prisma: PrismaService,
           private eventEmitter: EventEmitter2,
           private auditService: AuditService,
         ) {}

         /**
          * Move case to a new pipeline stage
          */
         async moveToStage(
           caseId: string,
           newStage: string,
           userId: string,
           organizationId: string,
           notes?: string,
         ) {
           const existingCase = await this.prisma.case.findFirst({
             where: { id: caseId, organizationId },
           });

           if (!existingCase) {
             throw new BadRequestException('Case not found');
           }

           if (existingCase.isMerged) {
             throw new BadRequestException('Cannot modify merged case');
           }

           const oldStage = existingCase.pipelineStage;

           const updated = await this.prisma.case.update({
             where: { id: caseId },
             data: {
               pipelineStage: newStage,
               pipelineStageAt: new Date(),
               pipelineStageById: userId,
               updatedById: userId,
             },
           });

           // Emit stage change event
           this.eventEmitter.emit('case.stage.changed', {
             organizationId,
             caseId,
             oldStage,
             newStage,
             userId,
           });

           // Log audit
           await this.auditService.log({
             entityType: 'CASE',
             entityId: caseId,
             action: 'stage_changed',
             actionDescription: `Case moved from ${oldStage || 'unassigned'} to ${newStage}`,
             actionCategory: 'UPDATE',
             actorUserId: userId,
             actorType: 'USER',
             organizationId,
             changes: {
               pipelineStage: { old: oldStage, new: newStage },
             },
             context: notes ? { notes } : undefined,
           });

           return updated;
         }

         /**
          * Set case outcome
          */
         async setOutcome(
           caseId: string,
           outcome: string,
           userId: string,
           organizationId: string,
           notes?: string,
         ) {
           const existingCase = await this.prisma.case.findFirst({
             where: { id: caseId, organizationId },
           });

           if (!existingCase) {
             throw new BadRequestException('Case not found');
           }

           const updated = await this.prisma.case.update({
             where: { id: caseId },
             data: {
               outcome: outcome as any,
               outcomeNotes: notes,
               outcomeAt: new Date(),
               outcomeById: userId,
               updatedById: userId,
             },
           });

           this.eventEmitter.emit('case.outcome.set', {
             organizationId,
             caseId,
             outcome,
           });

           await this.auditService.log({
             entityType: 'CASE',
             entityId: caseId,
             action: 'outcome_set',
             actionDescription: `Case outcome set to ${outcome}`,
             actionCategory: 'UPDATE',
             actorUserId: userId,
             actorType: 'USER',
             organizationId,
           });

           return updated;
         }

         /**
          * Update classification (correcting RIU classification)
          */
         async updateClassification(
           caseId: string,
           categoryId: string,
           severity: string,
           userId: string,
           organizationId: string,
           notes?: string,
         ) {
           const existingCase = await this.prisma.case.findFirst({
             where: { id: caseId, organizationId },
           });

           if (!existingCase) {
             throw new BadRequestException('Case not found');
           }

           const oldCategory = existingCase.primaryCategoryId;
           const oldSeverity = existingCase.severity;

           const updated = await this.prisma.case.update({
             where: { id: caseId },
             data: {
               primaryCategoryId: categoryId,
               severity: severity as any,
               classificationNotes: notes,
               classificationChangedAt: new Date(),
               classificationChangedById: userId,
               updatedById: userId,
             },
           });

           this.eventEmitter.emit('case.classification.changed', {
             organizationId,
             caseId,
             oldCategory,
             newCategory: categoryId,
             oldSeverity,
             newSeverity: severity,
           });

           await this.auditService.log({
             entityType: 'CASE',
             entityId: caseId,
             action: 'classification_changed',
             actionDescription: `Case classification updated${notes ? ': ' + notes : ''}`,
             actionCategory: 'UPDATE',
             actorUserId: userId,
             actorType: 'USER',
             organizationId,
             changes: {
               primaryCategoryId: { old: oldCategory, new: categoryId },
               severity: { old: oldSeverity, new: severity },
             },
           });

           return updated;
         }
       }
       ```

    2. Create `apps/backend/src/modules/cases/dto/merge-case.dto.ts`:
       ```typescript
       import { IsString, IsUUID, IsOptional, IsArray } from 'class-validator';

       export class MergeCaseDto {
         @IsUUID()
         primaryCaseId: string;  // Case that survives

         @IsUUID()
         secondaryCaseId: string;  // Case that becomes tombstone

         @IsString()
         @IsOptional()
         reason?: string;
       }

       export class MergeResultDto {
         primaryCase: {
           id: string;
           referenceNumber: string;
           linkedRiuCount: number;
         };
         secondaryCase: {
           id: string;
           referenceNumber: string;
           isMerged: boolean;
         };
         movedAssociations: number;
       }
       ```

    3. Create `apps/backend/src/modules/cases/case-merge.service.ts`:
       ```typescript
       import { Injectable, Logger, BadRequestException } from '@nestjs/common';
       import { PrismaService } from '../prisma/prisma.service';
       import { EventEmitter2 } from '@nestjs/event-emitter';
       import { AuditService } from '../audit/audit.service';
       import { MergeCaseDto, MergeResultDto } from './dto/merge-case.dto';

       @Injectable()
       export class CaseMergeService {
         private readonly logger = new Logger(CaseMergeService.name);

         constructor(
           private prisma: PrismaService,
           private eventEmitter: EventEmitter2,
           private auditService: AuditService,
         ) {}

         /**
          * Merge two cases - secondary becomes tombstone, primary absorbs RIUs.
          * Per CASE-04: Full audit trail required.
          */
         async merge(
           dto: MergeCaseDto,
           userId: string,
           organizationId: string,
         ): Promise<MergeResultDto> {
           const { primaryCaseId, secondaryCaseId, reason } = dto;

           if (primaryCaseId === secondaryCaseId) {
             throw new BadRequestException('Cannot merge case into itself');
           }

           return this.prisma.$transaction(async (tx) => {
             // 1. Load both cases
             const [primary, secondary] = await Promise.all([
               tx.case.findFirst({
                 where: { id: primaryCaseId, organizationId },
                 include: { riuAssociations: true },
               }),
               tx.case.findFirst({
                 where: { id: secondaryCaseId, organizationId },
                 include: { riuAssociations: true },
               }),
             ]);

             if (!primary || !secondary) {
               throw new BadRequestException('One or both cases not found');
             }

             if (primary.isMerged) {
               throw new BadRequestException('Primary case is already merged');
             }

             if (secondary.isMerged) {
               throw new BadRequestException('Secondary case is already merged');
             }

             // 2. Move RIU associations from secondary to primary
             // Update association type to MERGED_FROM
             const movedCount = await tx.riuCaseAssociation.updateMany({
               where: { caseId: secondaryCaseId },
               data: {
                 caseId: primaryCaseId,
                 associationType: 'MERGED_FROM',
                 notes: `Merged from Case ${secondary.referenceNumber}`,
               },
             });

             // 3. Move subjects from secondary to primary
             await tx.subject.updateMany({
               where: { caseId: secondaryCaseId },
               data: { caseId: primaryCaseId },
             });

             // 4. Move messages from secondary to primary
             await tx.caseMessage.updateMany({
               where: { caseId: secondaryCaseId },
               data: { caseId: primaryCaseId },
             });

             // 5. Move interactions from secondary to primary
             await tx.interaction.updateMany({
               where: { caseId: secondaryCaseId },
               data: { caseId: primaryCaseId },
             });

             // 6. Mark secondary as merged (tombstone)
             await tx.case.update({
               where: { id: secondaryCaseId },
               data: {
                 isMerged: true,
                 mergedIntoCaseId: primaryCaseId,
                 mergedAt: new Date(),
                 mergedById: userId,
                 mergedReason: reason,
                 status: 'CLOSED',
                 statusRationale: `Merged into ${primary.referenceNumber}`,
                 updatedById: userId,
               },
             });

             // 7. Update primary case metadata
             const updatedPrimary = await tx.case.update({
               where: { id: primaryCaseId },
               data: { updatedById: userId },
               include: { riuAssociations: true },
             });

             // 8. Log audit for both cases
             await this.auditService.log({
               entityType: 'CASE',
               entityId: primaryCaseId,
               action: 'merged_into',
               actionDescription: `Case ${secondary.referenceNumber} merged into this case`,
               actionCategory: 'UPDATE',
               actorUserId: userId,
               actorType: 'USER',
               organizationId,
               context: {
                 secondaryCaseId,
                 secondaryReferenceNumber: secondary.referenceNumber,
                 movedRiuCount: movedCount.count,
                 reason,
               },
             });

             await this.auditService.log({
               entityType: 'CASE',
               entityId: secondaryCaseId,
               action: 'merged_from',
               actionDescription: `Case merged into ${primary.referenceNumber}`,
               actionCategory: 'UPDATE',
               actorUserId: userId,
               actorType: 'USER',
               organizationId,
               context: {
                 primaryCaseId,
                 primaryReferenceNumber: primary.referenceNumber,
                 reason,
               },
             });

             // 9. Emit merge event
             this.eventEmitter.emit('case.merged', {
               organizationId,
               primaryCaseId,
               secondaryCaseId,
               movedRiuCount: movedCount.count,
             });

             return {
               primaryCase: {
                 id: updatedPrimary.id,
                 referenceNumber: updatedPrimary.referenceNumber,
                 linkedRiuCount: updatedPrimary.riuAssociations.length,
               },
               secondaryCase: {
                 id: secondaryCaseId,
                 referenceNumber: secondary.referenceNumber,
                 isMerged: true,
               },
               movedAssociations: movedCount.count,
             };
           });
         }

         /**
          * Get merge history for a case
          */
         async getMergeHistory(caseId: string, organizationId: string) {
           return this.prisma.case.findMany({
             where: {
               organizationId,
               mergedIntoCaseId: caseId,
             },
             select: {
               id: true,
               referenceNumber: true,
               mergedAt: true,
               mergedReason: true,
             },
           });
         }
       }
       ```

    4. Update cases.module.ts to include new services.
  </action>
  <verify>
    ```bash
    cd apps/backend && npm run build
    ```
  </verify>
  <done>CasePipelineService and CaseMergeService exist with stage management, outcome setting, and merge operations.</done>
</task>

<task type="auto">
  <name>Task 3: Run migration for Case enhancements</name>
  <files>apps/backend/prisma/migrations/</files>
  <action>
    1. Generate and apply migration:
       ```bash
       cd apps/backend && npx prisma migrate dev --name add_case_pipeline_and_merge
       ```

    2. Verify migration includes:
       - case_outcome enum
       - Pipeline fields (pipelineStage, pipelineStageAt, etc.)
       - Classification tracking fields
       - Merge fields (mergedIntoCaseId, isMerged, etc.)

    3. Regenerate Prisma client:
       ```bash
       cd apps/backend && npx prisma generate
       ```
  </action>
  <verify>
    ```bash
    cd apps/backend && npm run build
    ```
  </verify>
  <done>Database schema updated with pipeline and merge fields.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Schema validates:
   ```bash
   cd apps/backend && npx prisma validate
   ```

2. Build succeeds:
   ```bash
   cd apps/backend && npm run build
   ```

3. Merge logic test (manual):
   - Create Case A with RIU-1
   - Create Case B with RIU-2
   - Merge B into A
   - Verify: Case A has both RIUs, Case B is tombstone with isMerged=true
</verification>

<success_criteria>
- Case has pipelineStage field for configurable workflow stages
- Case classification can differ from RIU (corrections tracked)
- CaseOutcome enum supports standard investigation outcomes
- Merge operation atomically moves all associations
- Merged cases become tombstones (isMerged=true, closed status)
- Full audit trail for all pipeline and merge operations
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-entities/04-07-SUMMARY.md` using the summary template.
</output>
