---
phase: 04-core-entities
plan: 05
type: execute
wave: 2
depends_on: ["04-04"]
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/rius/extensions/hotline-riu.service.ts
  - apps/backend/src/modules/rius/extensions/disclosure-riu.service.ts
  - apps/backend/src/modules/rius/extensions/web-form-riu.service.ts
  - apps/backend/src/modules/rius/rius.service.ts
autonomous: true

must_haves:
  truths:
    - "Each RIU type has a dedicated extension table for type-specific fields"
    - "Hotline RIUs track call duration, interpreter usage, caller demeanor, QA workflow"
    - "Disclosure RIUs track disclosure type, value, threshold trigger, conflict detection"
    - "Web form RIUs track form version, submission source, validation state"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "RIU extension tables (RiuHotlineExtension, RiuDisclosureExtension, RiuWebFormExtension)"
      contains: "model RiuHotlineExtension"
    - path: "apps/backend/src/modules/rius/extensions/hotline-riu.service.ts"
      provides: "Hotline-specific RIU operations"
      exports: ["HotlineRiuService"]
  key_links:
    - from: "apps/backend/prisma/schema.prisma"
      to: "RiuHotlineExtension.riuId"
      via: "@relation to RiskIntelligenceUnit"
      pattern: "riu RiskIntelligenceUnit"
---

<objective>
Create type-specific extension tables for RIU types per CONTEXT.md decision on extension tables.

Purpose: Different RIU types have distinct field requirements. Hotline reports need call duration and QA workflow. Disclosures need value tracking and conflict detection. Extension tables provide database-level constraints and efficient queries while keeping the base RIU table clean.

Output: RiuHotlineExtension, RiuDisclosureExtension, RiuWebFormExtension models with corresponding services.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-entities/04-CONTEXT.md
@.planning/phases/04-core-entities/04-RESEARCH.md
@.planning/phases/04-core-entities/04-04-SUMMARY.md
@apps/backend/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RIU extension tables to Prisma schema</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
    Add extension tables after the RiskIntelligenceUnit model:

    1. Create RiuQaStatus enum:
       ```prisma
       enum RiuQaStatus {
         PENDING
         IN_REVIEW
         APPROVED
         REJECTED
         NEEDS_REVISION

         @@map("riu_qa_status")
       }
       ```

    2. Create DisclosureType enum:
       ```prisma
       enum DisclosureType {
         COI                 // Conflict of Interest
         GIFT                // Gifts & Entertainment
         OUTSIDE_EMPLOYMENT  // Outside business activities
         POLITICAL           // Political contributions
         CHARITABLE          // Charitable donations
         TRAVEL              // Travel & hospitality

         @@map("disclosure_type")
       }
       ```

    3. Create RiuHotlineExtension model:
       ```prisma
       /// Hotline-specific fields for RIU type = HOTLINE_REPORT
       model RiuHotlineExtension {
         id              String @id @default(uuid())
         riuId           String @unique @map("riu_id")
         organizationId  String @map("organization_id")

         // Call metadata
         callDuration        Int?      @map("call_duration")  // seconds
         interpreterUsed     Boolean   @default(false) @map("interpreter_used")
         interpreterLanguage String?   @map("interpreter_language")
         callerDemeanor      String?   @map("caller_demeanor")  // calm, distressed, angry, fearful
         transferredFrom     String?   @map("transferred_from")  // phone number if transferred
         recordingUrl        String?   @map("recording_url")
         callbackRequested   Boolean   @default(false) @map("callback_requested")
         callbackNumber      String?   @map("callback_number")

         // Operator notes
         operatorNotes       String?   @map("operator_notes")

         // QA workflow
         qaStatus            RiuQaStatus @default(PENDING) @map("qa_status")
         qaReviewerId        String?     @map("qa_reviewer_id")
         qaReviewedAt        DateTime?   @map("qa_reviewed_at")
         qaNotes             String?     @map("qa_notes")
         qaRejectionReason   String?     @map("qa_rejection_reason")

         // Timestamps
         createdAt DateTime @default(now()) @map("created_at")

         // Relations
         riu            RiskIntelligenceUnit @relation(fields: [riuId], references: [id], onDelete: Cascade)

         @@index([organizationId])
         @@index([qaStatus])
         @@map("riu_hotline_extensions")
       }
       ```

    4. Create RiuDisclosureExtension model:
       ```prisma
       /// Disclosure-specific fields for RIU type = DISCLOSURE_RESPONSE
       model RiuDisclosureExtension {
         id              String @id @default(uuid())
         riuId           String @unique @map("riu_id")
         organizationId  String @map("organization_id")

         // Disclosure classification
         disclosureType      DisclosureType  @map("disclosure_type")
         disclosureSubtype   String?         @map("disclosure_subtype")  // e.g., "vendor relationship"

         // Value tracking
         disclosureValue     Decimal?        @map("disclosure_value") @db.Decimal(12, 2)
         disclosureCurrency  String?         @map("disclosure_currency")  // ISO 4217
         estimatedAnnualValue Decimal?       @map("estimated_annual_value") @db.Decimal(12, 2)

         // Threshold and conflict detection
         thresholdTriggered  Boolean         @default(false) @map("threshold_triggered")
         thresholdAmount     Decimal?        @map("threshold_amount") @db.Decimal(12, 2)
         conflictDetected    Boolean         @default(false) @map("conflict_detected")
         conflictReason      String?         @map("conflict_reason")

         // Related party (who the disclosure involves)
         relatedPersonId     String?         @map("related_person_id")
         relatedPersonName   String?         @map("related_person_name")
         relatedCompany      String?         @map("related_company")
         relationshipType    String?         @map("relationship_type")  // spouse, family, business_partner

         // Dates
         effectiveDate       DateTime?       @map("effective_date")
         expirationDate      DateTime?       @map("expiration_date")

         // Timestamps
         createdAt DateTime @default(now()) @map("created_at")

         // Relations
         riu             RiskIntelligenceUnit @relation(fields: [riuId], references: [id], onDelete: Cascade)

         @@index([organizationId])
         @@index([disclosureType])
         @@index([thresholdTriggered])
         @@index([conflictDetected])
         @@map("riu_disclosure_extensions")
       }
       ```

    5. Create RiuWebFormExtension model:
       ```prisma
       /// Web form-specific fields for RIU type = WEB_FORM_SUBMISSION
       model RiuWebFormExtension {
         id              String @id @default(uuid())
         riuId           String @unique @map("riu_id")
         organizationId  String @map("organization_id")

         // Form metadata
         formDefinitionId      String   @map("form_definition_id")
         formDefinitionVersion Int      @map("form_definition_version")
         formName              String?  @map("form_name")

         // Submission metadata
         submissionSource      String?  @map("submission_source")  // portal, embed, api
         submitterIpAddress    String?  @map("submitter_ip_address")
         submitterUserAgent    String?  @map("submitter_user_agent")
         submissionDuration    Int?     @map("submission_duration")  // seconds from start to submit

         // Validation
         validationPassed      Boolean  @default(true) @map("validation_passed")
         validationErrors      Json?    @map("validation_errors")

         // Attachments summary
         attachmentCount       Int      @default(0) @map("attachment_count")
         totalAttachmentSize   Int      @default(0) @map("total_attachment_size")  // bytes

         // Timestamps
         createdAt DateTime @default(now()) @map("created_at")

         // Relations
         riu RiskIntelligenceUnit @relation(fields: [riuId], references: [id], onDelete: Cascade)

         @@index([organizationId])
         @@index([formDefinitionId])
         @@map("riu_web_form_extensions")
       }
       ```

    6. Add extension relations to RiskIntelligenceUnit model:
       ```prisma
       // In RiskIntelligenceUnit model, add:
       hotlineExtension    RiuHotlineExtension?
       disclosureExtension RiuDisclosureExtension?
       webFormExtension    RiuWebFormExtension?
       ```

    Run `npx prisma format` to validate.
  </action>
  <verify>
    ```bash
    cd apps/backend && npx prisma validate
    ```
  </verify>
  <done>RiuHotlineExtension, RiuDisclosureExtension, RiuWebFormExtension models exist with all type-specific fields.</done>
</task>

<task type="auto">
  <name>Task 2: Create extension services</name>
  <files>
    apps/backend/src/modules/rius/extensions/hotline-riu.service.ts
    apps/backend/src/modules/rius/extensions/disclosure-riu.service.ts
    apps/backend/src/modules/rius/extensions/web-form-riu.service.ts
    apps/backend/src/modules/rius/rius.service.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/rius/extensions/hotline-riu.service.ts`:
       ```typescript
       import { Injectable, Logger, NotFoundException } from '@nestjs/common';
       import { PrismaService } from '../../prisma/prisma.service';
       import { EventEmitter2 } from '@nestjs/event-emitter';
       import { RiuQaStatus } from '@prisma/client';

       export interface CreateHotlineExtensionDto {
         callDuration?: number;
         interpreterUsed?: boolean;
         interpreterLanguage?: string;
         callerDemeanor?: string;
         transferredFrom?: string;
         recordingUrl?: string;
         callbackRequested?: boolean;
         callbackNumber?: string;
         operatorNotes?: string;
       }

       @Injectable()
       export class HotlineRiuService {
         private readonly logger = new Logger(HotlineRiuService.name);

         constructor(
           private prisma: PrismaService,
           private eventEmitter: EventEmitter2,
         ) {}

         async createExtension(
           riuId: string,
           dto: CreateHotlineExtensionDto,
           organizationId: string,
         ) {
           return this.prisma.riuHotlineExtension.create({
             data: {
               riuId,
               organizationId,
               ...dto,
             },
           });
         }

         async getExtension(riuId: string) {
           return this.prisma.riuHotlineExtension.findUnique({
             where: { riuId },
           });
         }

         /**
          * Update QA status for hotline RIU
          */
         async updateQaStatus(
           riuId: string,
           newStatus: RiuQaStatus,
           reviewerId: string,
           notes?: string,
           rejectionReason?: string,
         ) {
           const extension = await this.prisma.riuHotlineExtension.findUnique({
             where: { riuId },
           });

           if (!extension) {
             throw new NotFoundException('Hotline extension not found');
           }

           const oldStatus = extension.qaStatus;

           const updated = await this.prisma.riuHotlineExtension.update({
             where: { riuId },
             data: {
               qaStatus: newStatus,
               qaReviewerId: reviewerId,
               qaReviewedAt: new Date(),
               qaNotes: notes,
               ...(newStatus === 'REJECTED' && { qaRejectionReason: rejectionReason }),
             },
           });

           // Emit QA status change event
           this.eventEmitter.emit('riu.hotline.qa.changed', {
             riuId,
             organizationId: extension.organizationId,
             oldStatus,
             newStatus,
             reviewerId,
           });

           return updated;
         }

         /**
          * Get pending QA queue
          */
         async getPendingQaQueue(organizationId: string, limit = 50) {
           return this.prisma.riuHotlineExtension.findMany({
             where: {
               organizationId,
               qaStatus: { in: ['PENDING', 'IN_REVIEW', 'NEEDS_REVISION'] },
             },
             include: {
               riu: true,
             },
             orderBy: { createdAt: 'asc' },
             take: limit,
           });
         }
       }
       ```

    2. Create `apps/backend/src/modules/rius/extensions/disclosure-riu.service.ts`:
       ```typescript
       import { Injectable, Logger } from '@nestjs/common';
       import { PrismaService } from '../../prisma/prisma.service';
       import { DisclosureType } from '@prisma/client';
       import { Decimal } from '@prisma/client/runtime/library';

       export interface CreateDisclosureExtensionDto {
         disclosureType: DisclosureType;
         disclosureSubtype?: string;
         disclosureValue?: number;
         disclosureCurrency?: string;
         estimatedAnnualValue?: number;
         relatedPersonId?: string;
         relatedPersonName?: string;
         relatedCompany?: string;
         relationshipType?: string;
         effectiveDate?: Date;
         expirationDate?: Date;
       }

       @Injectable()
       export class DisclosureRiuService {
         private readonly logger = new Logger(DisclosureRiuService.name);

         constructor(private prisma: PrismaService) {}

         async createExtension(
           riuId: string,
           dto: CreateDisclosureExtensionDto,
           organizationId: string,
           thresholdConfig?: { amount: number; currency: string },
         ) {
           // Check threshold if value provided
           const thresholdTriggered = dto.disclosureValue && thresholdConfig
             ? dto.disclosureValue >= thresholdConfig.amount
             : false;

           return this.prisma.riuDisclosureExtension.create({
             data: {
               riuId,
               organizationId,
               ...dto,
               disclosureValue: dto.disclosureValue ? new Decimal(dto.disclosureValue) : undefined,
               estimatedAnnualValue: dto.estimatedAnnualValue ? new Decimal(dto.estimatedAnnualValue) : undefined,
               thresholdTriggered,
               thresholdAmount: thresholdConfig ? new Decimal(thresholdConfig.amount) : undefined,
             },
           });
         }

         async getExtension(riuId: string) {
           return this.prisma.riuDisclosureExtension.findUnique({
             where: { riuId },
           });
         }

         /**
          * Flag conflict detection on a disclosure
          */
         async flagConflict(riuId: string, reason: string) {
           return this.prisma.riuDisclosureExtension.update({
             where: { riuId },
             data: {
               conflictDetected: true,
               conflictReason: reason,
             },
           });
         }

         /**
          * Get disclosures by person for conflict detection
          */
         async getDisclosuresByPerson(
           personId: string,
           organizationId: string,
         ) {
           return this.prisma.riuDisclosureExtension.findMany({
             where: {
               organizationId,
               relatedPersonId: personId,
             },
             include: { riu: true },
             orderBy: { createdAt: 'desc' },
           });
         }

         /**
          * Get disclosures exceeding threshold
          */
         async getThresholdTriggeredDisclosures(organizationId: string) {
           return this.prisma.riuDisclosureExtension.findMany({
             where: {
               organizationId,
               thresholdTriggered: true,
             },
             include: { riu: true },
           });
         }
       }
       ```

    3. Create `apps/backend/src/modules/rius/extensions/web-form-riu.service.ts`:
       ```typescript
       import { Injectable, Logger } from '@nestjs/common';
       import { PrismaService } from '../../prisma/prisma.service';

       export interface CreateWebFormExtensionDto {
         formDefinitionId: string;
         formDefinitionVersion: number;
         formName?: string;
         submissionSource?: string;
         submitterIpAddress?: string;
         submitterUserAgent?: string;
         submissionDuration?: number;
         validationPassed?: boolean;
         validationErrors?: unknown;
         attachmentCount?: number;
         totalAttachmentSize?: number;
       }

       @Injectable()
       export class WebFormRiuService {
         private readonly logger = new Logger(WebFormRiuService.name);

         constructor(private prisma: PrismaService) {}

         async createExtension(
           riuId: string,
           dto: CreateWebFormExtensionDto,
           organizationId: string,
         ) {
           return this.prisma.riuWebFormExtension.create({
             data: {
               riuId,
               organizationId,
               ...dto,
               validationErrors: dto.validationErrors as any,
             },
           });
         }

         async getExtension(riuId: string) {
           return this.prisma.riuWebFormExtension.findUnique({
             where: { riuId },
           });
         }

         /**
          * Get submissions by form
          */
         async getSubmissionsByForm(
           formDefinitionId: string,
           organizationId: string,
         ) {
           return this.prisma.riuWebFormExtension.findMany({
             where: {
               organizationId,
               formDefinitionId,
             },
             include: { riu: true },
             orderBy: { createdAt: 'desc' },
           });
         }
       }
       ```

    4. Update RiusService to include extensions when creating RIUs:
       Add factory method that creates appropriate extension based on type.
  </action>
  <verify>
    ```bash
    cd apps/backend && npm run build
    ```
  </verify>
  <done>HotlineRiuService, DisclosureRiuService, WebFormRiuService exist with type-specific operations.</done>
</task>

<task type="auto">
  <name>Task 3: Run migration for extension tables</name>
  <files>apps/backend/prisma/migrations/</files>
  <action>
    1. Generate and apply migration:
       ```bash
       cd apps/backend && npx prisma migrate dev --name add_riu_extension_tables
       ```

    2. Verify migration creates:
       - riu_hotline_extensions table
       - riu_disclosure_extensions table
       - riu_web_form_extensions table
       - New enums (riu_qa_status, disclosure_type)

    3. Regenerate Prisma client:
       ```bash
       cd apps/backend && npx prisma generate
       ```
  </action>
  <verify>
    ```bash
    cd apps/backend && npm run build
    ```
  </verify>
  <done>Database has RIU extension tables. Build succeeds.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Schema validates:
   ```bash
   cd apps/backend && npx prisma validate
   ```

2. Build succeeds:
   ```bash
   cd apps/backend && npm run build
   ```

3. Extension tables exist with proper relations to RiskIntelligenceUnit.
</verification>

<success_criteria>
- RiuHotlineExtension has call metadata and QA workflow fields
- RiuDisclosureExtension has value tracking and conflict detection
- RiuWebFormExtension has form metadata and validation tracking
- Each extension has 1:1 relation to RiskIntelligenceUnit via riuId
- Extension services provide type-specific operations
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-entities/04-05-SUMMARY.md` using the summary template.
</output>
