---
phase: 04-core-entities
plan: 08
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/campaigns/campaigns.module.ts
  - apps/backend/src/modules/campaigns/campaigns.service.ts
  - apps/backend/src/modules/campaigns/campaigns.controller.ts
  - apps/backend/src/modules/campaigns/targeting/segment.service.ts
  - apps/backend/src/modules/campaigns/targeting/segment-query.builder.ts
  - apps/backend/src/modules/campaigns/assignments/campaign-assignment.service.ts
  - apps/backend/src/modules/campaigns/dto/create-campaign.dto.ts
  - apps/backend/src/modules/campaigns/dto/segment-criteria.dto.ts
  - apps/backend/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "Campaigns can target audiences by business unit, location, role"
    - "Segments use query builder with nested AND/OR conditions"
    - "Campaign launch generates CampaignAssignment for each target employee"
    - "Segments are reusable across campaigns"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "Campaign, Segment, CampaignAssignment models"
      contains: "model Campaign"
    - path: "apps/backend/src/modules/campaigns/targeting/segment-query.builder.ts"
      provides: "Prisma where clause builder from segment criteria"
      exports: ["SegmentQueryBuilder"]
  key_links:
    - from: "apps/backend/src/modules/campaigns/campaigns.service.ts"
      to: "SegmentQueryBuilder.buildWhereClause"
      via: "service injection"
      pattern: "this.queryBuilder.buildWhereClause"
---

<objective>
Create Campaign and CampaignAssignment entities with segment-based targeting per CAMP-01 through CAMP-05.

Purpose: Campaigns (HubSpot Sequence equivalent) enable outbound compliance requests - disclosures, attestations, surveys. Segments define reusable audience criteria using a query builder. Campaign launch creates assignments for each target employee.

Output: Campaign, Segment, CampaignAssignment models; CampaignsModule with targeting and assignment services.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-entities/04-CONTEXT.md
@.planning/phases/04-core-entities/04-RESEARCH.md
@.planning/phases/04-core-entities/04-02-SUMMARY.md
@apps/backend/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Campaign, Segment, CampaignAssignment models to Prisma</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
    Add the following models after the existing workflow entities:

    1. Create campaign-related enums:
       ```prisma
       enum CampaignType {
         DISCLOSURE     // COI, gifts, outside employment
         ATTESTATION    // Policy acknowledgment
         SURVEY         // Compliance surveys

         @@map("campaign_type")
       }

       enum CampaignStatus {
         DRAFT
         SCHEDULED
         ACTIVE
         PAUSED
         COMPLETED
         CANCELLED

         @@map("campaign_status")
       }

       enum AudienceMode {
         CLOSED         // Snapshot at launch
         OPEN           // Auto-add new matches
         OPEN_WITH_REVIEW  // Queue new matches for approval

         @@map("audience_mode")
       }

       enum AssignmentStatus {
         PENDING
         IN_PROGRESS
         COMPLETED
         OVERDUE
         SKIPPED

         @@map("assignment_status")
       }
       ```

    2. Create Segment model:
       ```prisma
       model Segment {
         id              String @id @default(uuid())
         organizationId  String @map("organization_id")

         name            String
         description     String?
         criteria        Json    // SegmentCriteria structure

         // Whether segment auto-updates
         isDynamic       Boolean @default(true) @map("is_dynamic")

         // Cached count (updated periodically)
         cachedCount     Int?    @map("cached_count")
         cachedAt        DateTime? @map("cached_at")

         // Audit
         createdAt       DateTime @default(now()) @map("created_at")
         updatedAt       DateTime @updatedAt @map("updated_at")
         createdById     String   @map("created_by_id")

         // Relations
         organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
         campaigns       Campaign[]

         @@unique([organizationId, name])
         @@index([organizationId])
         @@map("segments")
       }
       ```

    3. Create Campaign model:
       ```prisma
       model Campaign {
         id              String @id @default(uuid())
         organizationId  String @map("organization_id")

         // Identity
         name            String
         description     String?
         campaignType    CampaignType @map("campaign_type")

         // Status
         status          CampaignStatus @default(DRAFT)

         // Scheduling
         launchAt        DateTime?  @map("launch_at")
         dueDate         DateTime   @map("due_date")
         reminderSchedule Json?     @map("reminder_schedule")  // Array of reminder configs

         // Targeting
         segmentId       String?    @map("segment_id")
         audienceMode    AudienceMode @default(CLOSED) @map("audience_mode")

         // Manual overrides
         manualIncludes  String[]   @default([]) @map("manual_includes")  // Employee IDs
         manualExcludes  String[]   @default([]) @map("manual_excludes")  // Employee IDs

         // Linked form
         formDefinitionId String?   @map("form_definition_id")

         // Auto-case rules
         autoCaseThreshold  Json?   @map("auto_case_threshold")

         // Statistics (denormalized)
         totalAssignments    Int @default(0) @map("total_assignments")
         completedCount      Int @default(0) @map("completed_count")
         overdueCount        Int @default(0) @map("overdue_count")

         // Audit
         createdAt       DateTime @default(now()) @map("created_at")
         updatedAt       DateTime @updatedAt @map("updated_at")
         createdById     String   @map("created_by_id")
         launchedAt      DateTime? @map("launched_at")
         launchedById    String?   @map("launched_by_id")

         // Relations
         organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
         segment         Segment?     @relation(fields: [segmentId], references: [id])
         assignments     CampaignAssignment[]

         @@index([organizationId])
         @@index([organizationId, status])
         @@index([organizationId, campaignType])
         @@map("campaigns")
       }
       ```

    4. Create CampaignAssignment model:
       ```prisma
       model CampaignAssignment {
         id              String @id @default(uuid())
         organizationId  String @map("organization_id")
         campaignId      String @map("campaign_id")
         employeeId      String @map("employee_id")

         // Status
         status          AssignmentStatus @default(PENDING)

         // Timing
         assignedAt      DateTime @default(now()) @map("assigned_at")
         dueDate         DateTime @map("due_date")
         completedAt     DateTime? @map("completed_at")

         // Response
         riuId           String?  @map("riu_id")  // Created RIU when completed

         // Snapshot fields (for audit)
         employeeNameSnapshot    String  @map("employee_name_snapshot")
         employeeDepartmentSnapshot String? @map("employee_department_snapshot")
         employeeEmailSnapshot   String? @map("employee_email_snapshot")

         // Reminders
         remindersSent   Int @default(0) @map("reminders_sent")
         lastReminderAt  DateTime? @map("last_reminder_at")

         // Audit
         createdAt       DateTime @default(now()) @map("created_at")
         updatedAt       DateTime @updatedAt @map("updated_at")

         // Relations
         organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
         campaign        Campaign     @relation(fields: [campaignId], references: [id], onDelete: Cascade)
         employee        Employee     @relation(fields: [employeeId], references: [id])
         riu             RiskIntelligenceUnit? @relation(fields: [riuId], references: [id])

         @@unique([campaignId, employeeId])
         @@index([organizationId])
         @@index([organizationId, campaignId])
         @@index([organizationId, employeeId])
         @@index([organizationId, status])
         @@index([organizationId, dueDate])
         @@map("campaign_assignments")
       }
       ```

    5. Add relations to Organization and Employee models:
       ```prisma
       // In Organization model, add:
       segments            Segment[]
       campaigns           Campaign[]
       campaignAssignments CampaignAssignment[]

       // In Employee model, add:
       campaignAssignments CampaignAssignment[]

       // In RiskIntelligenceUnit model, add:
       campaignAssignments CampaignAssignment[]
       ```

    Run `npx prisma format` to validate.
  </action>
  <verify>
    ```bash
    cd apps/backend && npx prisma validate
    ```
  </verify>
  <done>Campaign, Segment, CampaignAssignment models exist with all fields and relations.</done>
</task>

<task type="auto">
  <name>Task 2: Create segment query builder and services</name>
  <files>
    apps/backend/src/modules/campaigns/dto/segment-criteria.dto.ts
    apps/backend/src/modules/campaigns/targeting/segment-query.builder.ts
    apps/backend/src/modules/campaigns/targeting/segment.service.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/campaigns/dto/segment-criteria.dto.ts`:
       ```typescript
       import { IsString, IsEnum, IsOptional, IsArray, ValidateNested, IsNotEmpty } from 'class-validator';
       import { Type } from 'class-transformer';

       export type ConditionOperator =
         | 'equals' | 'notEquals'
         | 'contains' | 'notContains'
         | 'startsWith' | 'endsWith'
         | 'greaterThan' | 'lessThan'
         | 'in' | 'notIn'
         | 'isNull' | 'isNotNull';

       export class SegmentCondition {
         @IsString()
         field: string; // 'businessUnitId', 'locationId', 'jobTitle', etc.

         @IsString()
         operator: ConditionOperator;

         @IsNotEmpty()
         value: unknown;
       }

       export class SegmentCriteria {
         @IsEnum(['AND', 'OR'])
         operator: 'AND' | 'OR';

         @IsArray()
         @ValidateNested({ each: true })
         @Type(() => Object) // Can be SegmentCondition or nested SegmentCriteria
         conditions: (SegmentCondition | SegmentCriteria)[];
       }

       export class CreateSegmentDto {
         @IsString()
         name: string;

         @IsString()
         @IsOptional()
         description?: string;

         @ValidateNested()
         @Type(() => SegmentCriteria)
         criteria: SegmentCriteria;
       }
       ```

    2. Create `apps/backend/src/modules/campaigns/targeting/segment-query.builder.ts`:
       ```typescript
       import { Injectable } from '@nestjs/common';
       import { Prisma } from '@prisma/client';
       import { SegmentCriteria, SegmentCondition } from '../dto/segment-criteria.dto';

       @Injectable()
       export class SegmentQueryBuilder {
         /**
          * Build Prisma where clause from segment criteria.
          */
         buildWhereClause(
           criteria: SegmentCriteria,
           organizationId: string,
         ): Prisma.EmployeeWhereInput {
           const where: Prisma.EmployeeWhereInput = {
             organizationId,
             employmentStatus: 'ACTIVE', // Only active employees
           };

           const criteriaWhere = this.buildCriteriaClause(criteria);
           return { AND: [where, criteriaWhere] };
         }

         private buildCriteriaClause(criteria: SegmentCriteria): Prisma.EmployeeWhereInput {
           const clauses = criteria.conditions.map(condition => {
             if (this.isNestedCriteria(condition)) {
               return this.buildCriteriaClause(condition as SegmentCriteria);
             }
             return this.buildConditionClause(condition as SegmentCondition);
           });

           if (criteria.operator === 'AND') {
             return { AND: clauses };
           } else {
             return { OR: clauses };
           }
         }

         private isNestedCriteria(obj: unknown): boolean {
           return typeof obj === 'object' && obj !== null && 'operator' in obj && 'conditions' in obj;
         }

         private buildConditionClause(condition: SegmentCondition): Prisma.EmployeeWhereInput {
           const { field, operator, value } = condition;

           switch (operator) {
             case 'equals':
               return { [field]: value };
             case 'notEquals':
               return { [field]: { not: value } };
             case 'contains':
               return { [field]: { contains: value as string, mode: 'insensitive' } };
             case 'notContains':
               return { NOT: { [field]: { contains: value as string, mode: 'insensitive' } } };
             case 'startsWith':
               return { [field]: { startsWith: value as string, mode: 'insensitive' } };
             case 'endsWith':
               return { [field]: { endsWith: value as string, mode: 'insensitive' } };
             case 'greaterThan':
               return { [field]: { gt: value } };
             case 'lessThan':
               return { [field]: { lt: value } };
             case 'in':
               return { [field]: { in: value as string[] } };
             case 'notIn':
               return { [field]: { notIn: value as string[] } };
             case 'isNull':
               return { [field]: null };
             case 'isNotNull':
               return { [field]: { not: null } };
             default:
               throw new Error(`Unknown operator: ${operator}`);
           }
         }
       }
       ```

    3. Create `apps/backend/src/modules/campaigns/targeting/segment.service.ts`:
       ```typescript
       import { Injectable, Logger, ConflictException, NotFoundException } from '@nestjs/common';
       import { PrismaService } from '../../prisma/prisma.service';
       import { SegmentQueryBuilder } from './segment-query.builder';
       import { CreateSegmentDto, SegmentCriteria } from '../dto/segment-criteria.dto';

       @Injectable()
       export class SegmentService {
         private readonly logger = new Logger(SegmentService.name);

         constructor(
           private prisma: PrismaService,
           private queryBuilder: SegmentQueryBuilder,
         ) {}

         async create(dto: CreateSegmentDto, userId: string, organizationId: string) {
           // Check uniqueness
           const existing = await this.prisma.segment.findUnique({
             where: {
               organizationId_name: { organizationId, name: dto.name },
             },
           });

           if (existing) {
             throw new ConflictException(`Segment "${dto.name}" already exists`);
           }

           return this.prisma.segment.create({
             data: {
               organizationId,
               name: dto.name,
               description: dto.description,
               criteria: dto.criteria as any,
               createdById: userId,
             },
           });
         }

         async findAll(organizationId: string) {
           return this.prisma.segment.findMany({
             where: { organizationId },
             orderBy: { name: 'asc' },
           });
         }

         async findOne(id: string, organizationId: string) {
           const segment = await this.prisma.segment.findFirst({
             where: { id, organizationId },
           });

           if (!segment) {
             throw new NotFoundException('Segment not found');
           }

           return segment;
         }

         /**
          * Preview segment audience with pagination.
          */
         async previewAudience(
           segmentId: string,
           organizationId: string,
           options: { limit: number; offset: number },
         ) {
           const segment = await this.findOne(segmentId, organizationId);
           const criteria = segment.criteria as unknown as SegmentCriteria;
           const where = this.queryBuilder.buildWhereClause(criteria, organizationId);

           const [employees, total] = await Promise.all([
             this.prisma.employee.findMany({
               where,
               take: options.limit,
               skip: options.offset,
               orderBy: { lastName: 'asc' },
               select: {
                 id: true,
                 firstName: true,
                 lastName: true,
                 email: true,
                 jobTitle: true,
                 department: true,
                 location: true,
               },
             }),
             this.prisma.employee.count({ where }),
           ]);

           return { employees, total };
         }

         /**
          * Evaluate segment and return all matching employee IDs.
          */
         async evaluateSegment(segmentId: string, organizationId: string): Promise<string[]> {
           const segment = await this.findOne(segmentId, organizationId);
           const criteria = segment.criteria as unknown as SegmentCriteria;
           const where = this.queryBuilder.buildWhereClause(criteria, organizationId);

           const employees = await this.prisma.employee.findMany({
             where,
             select: { id: true },
           });

           return employees.map(e => e.id);
         }

         /**
          * Update cached count for segment.
          */
         async updateCachedCount(segmentId: string, organizationId: string) {
           const segment = await this.findOne(segmentId, organizationId);
           const criteria = segment.criteria as unknown as SegmentCriteria;
           const where = this.queryBuilder.buildWhereClause(criteria, organizationId);

           const count = await this.prisma.employee.count({ where });

           return this.prisma.segment.update({
             where: { id: segmentId },
             data: {
               cachedCount: count,
               cachedAt: new Date(),
             },
           });
         }
       }
       ```
  </action>
  <verify>
    ```bash
    cd apps/backend && npm run build
    ```
  </verify>
  <done>SegmentQueryBuilder converts JSON criteria to Prisma where clauses. SegmentService manages segments with preview and evaluation.</done>
</task>

<task type="auto">
  <name>Task 3: Create CampaignAssignmentService and CampaignsModule</name>
  <files>
    apps/backend/src/modules/campaigns/assignments/campaign-assignment.service.ts
    apps/backend/src/modules/campaigns/campaigns.service.ts
    apps/backend/src/modules/campaigns/campaigns.controller.ts
    apps/backend/src/modules/campaigns/dto/create-campaign.dto.ts
    apps/backend/src/modules/campaigns/campaigns.module.ts
    apps/backend/src/app.module.ts
  </files>
  <action>
    1. Create `apps/backend/src/modules/campaigns/dto/create-campaign.dto.ts`:
       ```typescript
       import { IsString, IsEnum, IsOptional, IsArray, IsDateString, IsUUID } from 'class-validator';
       import { CampaignType, AudienceMode } from '@prisma/client';

       export class CreateCampaignDto {
         @IsString()
         name: string;

         @IsString()
         @IsOptional()
         description?: string;

         @IsEnum(CampaignType)
         campaignType: CampaignType;

         @IsDateString()
         dueDate: string;

         @IsDateString()
         @IsOptional()
         launchAt?: string;

         @IsUUID()
         @IsOptional()
         segmentId?: string;

         @IsEnum(AudienceMode)
         @IsOptional()
         audienceMode?: AudienceMode;

         @IsArray()
         @IsString({ each: true })
         @IsOptional()
         manualIncludes?: string[];

         @IsArray()
         @IsString({ each: true })
         @IsOptional()
         manualExcludes?: string[];

         @IsUUID()
         @IsOptional()
         formDefinitionId?: string;
       }
       ```

    2. Create `apps/backend/src/modules/campaigns/assignments/campaign-assignment.service.ts`:
       ```typescript
       import { Injectable, Logger } from '@nestjs/common';
       import { PrismaService } from '../../prisma/prisma.service';
       import { EventEmitter2 } from '@nestjs/event-emitter';
       import { SegmentService } from '../targeting/segment.service';
       import { AssignmentStatus } from '@prisma/client';

       @Injectable()
       export class CampaignAssignmentService {
         private readonly logger = new Logger(CampaignAssignmentService.name);

         constructor(
           private prisma: PrismaService,
           private segmentService: SegmentService,
           private eventEmitter: EventEmitter2,
         ) {}

         /**
          * Generate assignments for all target employees.
          * Called when campaign is launched.
          */
         async generateAssignments(
           campaignId: string,
           organizationId: string,
         ): Promise<{ created: number; skipped: number }> {
           const campaign = await this.prisma.campaign.findUnique({
             where: { id: campaignId },
           });

           if (!campaign) {
             throw new Error('Campaign not found');
           }

           // 1. Get target employee IDs
           let employeeIds: string[] = [];

           if (campaign.segmentId) {
             employeeIds = await this.segmentService.evaluateSegment(
               campaign.segmentId,
               organizationId,
             );
           }

           // 2. Apply manual includes
           if (campaign.manualIncludes.length > 0) {
             const includeSet = new Set(employeeIds);
             campaign.manualIncludes.forEach(id => includeSet.add(id));
             employeeIds = Array.from(includeSet);
           }

           // 3. Apply manual excludes
           if (campaign.manualExcludes.length > 0) {
             const excludeSet = new Set(campaign.manualExcludes);
             employeeIds = employeeIds.filter(id => !excludeSet.has(id));
           }

           // 4. Get employees for snapshot data
           const employees = await this.prisma.employee.findMany({
             where: { id: { in: employeeIds } },
           });

           const employeeMap = new Map(employees.map(e => [e.id, e]));

           // 5. Create assignments
           let created = 0;
           let skipped = 0;

           for (const employeeId of employeeIds) {
             const employee = employeeMap.get(employeeId);
             if (!employee) {
               skipped++;
               continue;
             }

             try {
               await this.prisma.campaignAssignment.create({
                 data: {
                   organizationId,
                   campaignId,
                   employeeId,
                   dueDate: campaign.dueDate,
                   status: 'PENDING',
                   employeeNameSnapshot: `${employee.firstName} ${employee.lastName}`,
                   employeeDepartmentSnapshot: employee.department,
                   employeeEmailSnapshot: employee.email,
                 },
               });
               created++;
             } catch (error) {
               // Likely duplicate - skip
               skipped++;
             }
           }

           // 6. Update campaign statistics
           await this.prisma.campaign.update({
             where: { id: campaignId },
             data: { totalAssignments: created },
           });

           // 7. Emit event
           this.eventEmitter.emit('campaign.assignments.generated', {
             organizationId,
             campaignId,
             created,
             skipped,
           });

           return { created, skipped };
         }

         /**
          * Mark assignment as completed (creates RIU).
          */
         async completeAssignment(
           assignmentId: string,
           riuId: string,
           organizationId: string,
         ) {
           const assignment = await this.prisma.campaignAssignment.update({
             where: { id: assignmentId },
             data: {
               status: 'COMPLETED',
               completedAt: new Date(),
               riuId,
             },
           });

           // Update campaign stats
           await this.prisma.campaign.update({
             where: { id: assignment.campaignId },
             data: { completedCount: { increment: 1 } },
           });

           this.eventEmitter.emit('campaign.assignment.completed', {
             organizationId,
             campaignId: assignment.campaignId,
             assignmentId,
             riuId,
           });

           return assignment;
         }

         /**
          * Get assignments for a campaign.
          */
         async findByCampaign(
           campaignId: string,
           organizationId: string,
           options?: { status?: AssignmentStatus; limit?: number; offset?: number },
         ) {
           return this.prisma.campaignAssignment.findMany({
             where: {
               organizationId,
               campaignId,
               ...(options?.status && { status: options.status }),
             },
             include: { employee: true },
             take: options?.limit ?? 100,
             skip: options?.offset ?? 0,
             orderBy: { employeeNameSnapshot: 'asc' },
           });
         }

         /**
          * Get assignments for an employee.
          */
         async findByEmployee(employeeId: string, organizationId: string) {
           return this.prisma.campaignAssignment.findMany({
             where: { organizationId, employeeId },
             include: { campaign: true },
             orderBy: { dueDate: 'asc' },
           });
         }
       }
       ```

    3. Create CampaignsService with basic CRUD and launch functionality.

    4. Create CampaignsController with endpoints.

    5. Create CampaignsModule importing SegmentService and CampaignAssignmentService.

    6. Register CampaignsModule in app.module.ts.
  </action>
  <verify>
    ```bash
    cd apps/backend && npm run build
    ```
  </verify>
  <done>CampaignsModule exists with Campaign CRUD, segment targeting, and assignment generation.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Schema validates:
   ```bash
   cd apps/backend && npx prisma validate
   ```

2. Build succeeds:
   ```bash
   cd apps/backend && npm run build
   ```

3. Migration runs:
   ```bash
   cd apps/backend && npx prisma migrate dev --name add_campaigns_and_segments
   ```
</verification>

<success_criteria>
- Campaign model supports disclosure, attestation, survey types
- Segment model stores JSON criteria for query builder
- SegmentQueryBuilder converts criteria to Prisma where clauses
- Campaign launch generates CampaignAssignment for each target employee
- Assignment snapshots employee data at creation time for audit
- Campaign statistics (total, completed, overdue) are maintained
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-entities/04-08-SUMMARY.md` using the summary template.
</output>
