---
phase: 06-case-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/investigations/templates/template.service.ts
  - apps/backend/src/modules/investigations/templates/template.controller.ts
  - apps/backend/src/modules/investigations/templates/dto/template.dto.ts
  - apps/backend/src/modules/investigations/investigations.module.ts
autonomous: true

must_haves:
  truths:
    - "InvestigationTemplate model exists with JSON schema for sections/items"
    - "Templates support three tiers: OFFICIAL, TEAM, PERSONAL"
    - "Templates are versioned with version-on-publish pattern"
    - "Templates can be archived but remain visible for historical reference"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "InvestigationTemplate and TemplateTier enum"
      contains: "model InvestigationTemplate"
    - path: "apps/backend/src/modules/investigations/templates/template.service.ts"
      provides: "Template CRUD with versioning"
      exports: ["InvestigationTemplateService"]
    - path: "apps/backend/src/modules/investigations/templates/template.controller.ts"
      provides: "REST endpoints for template management"
      exports: ["InvestigationTemplateController"]
  key_links:
    - from: "template.controller.ts"
      to: "template.service.ts"
      via: "DI injection"
      pattern: "constructor.*InvestigationTemplateService"
    - from: "template.service.ts"
      to: "prisma"
      via: "PrismaService"
      pattern: "prisma\\.investigationTemplate"
---

<objective>
Create the InvestigationTemplate model and service for defining reusable investigation checklists with sections, items, and conditional rules.

Purpose: Templates standardize investigation processes across the organization while allowing investigator customization. This is the foundation for category-specific workflows and compliance audit trails.

Output: Prisma model, DTOs, service with CRUD + versioning, REST controller
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-case-management/06-RESEARCH.md
@.planning/phases/06-case-management/06-CONTEXT.md
@apps/backend/prisma/schema.prisma
@apps/backend/src/modules/investigations/investigations.module.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add InvestigationTemplate model to Prisma schema</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
Add the following to schema.prisma:

1. TemplateTier enum:
```prisma
enum TemplateTier {
  OFFICIAL   // Admin-created, org-wide
  TEAM       // Shared with specific team
  PERSONAL   // Creator-only, save-as from cases

  @@map("template_tier")
}
```

2. InvestigationTemplate model:
```prisma
model InvestigationTemplate {
  id              String   @id @default(uuid())
  organizationId  String   @map("organization_id")

  // Identity
  name            String
  description     String?
  categoryId      String?  @map("category_id")  // Optional category binding

  // Template tier
  tier            TemplateTier @default(PERSONAL)
  createdById     String   @map("created_by_id")
  sharedWithTeamId String? @map("shared_with_team_id")

  // Versioning (same pattern as WorkflowTemplate)
  version         Int      @default(1)
  isActive        Boolean  @default(true)  @map("is_active")
  isArchived      Boolean  @default(false) @map("is_archived")
  isDefault       Boolean  @default(false) @map("is_default")

  // Schema (JSON)
  sections        Json     // Array of ChecklistSection
  suggestedDurations Json? @map("suggested_durations")
  conditionalRules Json?   @map("conditional_rules")

  // Import/Export
  isSystemTemplate Boolean @default(false) @map("is_system_template")
  sourceTemplateId String? @map("source_template_id")

  // Analytics tracking
  usageCount      Int      @default(0) @map("usage_count")

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([organizationId, name, version])
  @@index([organizationId, tier])
  @@index([organizationId, categoryId])
  @@index([organizationId, isActive, isArchived])
  @@map("investigation_templates")
}
```

3. Add relation to Organization model:
```prisma
investigationTemplates InvestigationTemplate[]
```

Run: `cd apps/backend && npx prisma db push` to sync schema.
  </action>
  <verify>npx prisma validate passes. Database has investigation_templates table.</verify>
  <done>InvestigationTemplate model exists with tier enum, versioning fields, and JSON schema for sections.</done>
</task>

<task type="auto">
  <name>Task 2: Create Template DTOs and Service</name>
  <files>
    apps/backend/src/modules/investigations/templates/dto/template.dto.ts
    apps/backend/src/modules/investigations/templates/template.service.ts
  </files>
  <action>
Create directory: `apps/backend/src/modules/investigations/templates/`

**template.dto.ts:**
```typescript
import { IsString, IsOptional, IsEnum, IsBoolean, IsArray, ValidateNested, IsUUID, IsInt, Min } from 'class-validator';
import { Type } from 'class-transformer';
import { TemplateTier } from '@prisma/client';

// JSON Schema types for template structure
export interface ChecklistItem {
  id: string;
  text: string;
  order: number;
  required: boolean;
  evidenceRequired: boolean;
  guidance?: string;
  dependencies?: string[];
}

export interface ChecklistSection {
  id: string;
  name: string;
  order: number;
  suggestedDays?: number;
  sectionDependencies?: string[];
  items: ChecklistItem[];
}

export interface ConditionalRule {
  targetId: string;  // Section or item ID
  targetType: 'section' | 'item';
  condition: {
    field: string;  // e.g., 'category', 'severity', 'customField.hipaa'
    operator: 'equals' | 'not_equals' | 'contains' | 'in';
    value: string | string[];
  };
  action: 'show' | 'hide' | 'require';
}

export class CreateTemplateDto {
  @IsString()
  name: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsUUID()
  @IsOptional()
  categoryId?: string;

  @IsEnum(TemplateTier)
  @IsOptional()
  tier?: TemplateTier;

  @IsUUID()
  @IsOptional()
  sharedWithTeamId?: string;

  @IsArray()
  sections: ChecklistSection[];

  @IsOptional()
  suggestedDurations?: Record<string, number>;

  @IsArray()
  @IsOptional()
  conditionalRules?: ConditionalRule[];

  @IsBoolean()
  @IsOptional()
  isDefault?: boolean;
}

export class UpdateTemplateDto {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsUUID()
  @IsOptional()
  categoryId?: string;

  @IsEnum(TemplateTier)
  @IsOptional()
  tier?: TemplateTier;

  @IsUUID()
  @IsOptional()
  sharedWithTeamId?: string;

  @IsArray()
  @IsOptional()
  sections?: ChecklistSection[];

  @IsOptional()
  suggestedDurations?: Record<string, number>;

  @IsArray()
  @IsOptional()
  conditionalRules?: ConditionalRule[];

  @IsBoolean()
  @IsOptional()
  isDefault?: boolean;
}

export class TemplateQueryDto {
  @IsEnum(TemplateTier)
  @IsOptional()
  tier?: TemplateTier;

  @IsUUID()
  @IsOptional()
  categoryId?: string;

  @IsBoolean()
  @IsOptional()
  includeArchived?: boolean;

  @IsInt()
  @Min(1)
  @IsOptional()
  @Type(() => Number)
  page?: number = 1;

  @IsInt()
  @Min(1)
  @IsOptional()
  @Type(() => Number)
  limit?: number = 20;
}

export class PublishTemplateDto {
  @IsBoolean()
  @IsOptional()
  createNewVersion?: boolean;
}

export class ImportTemplateDto {
  @IsString()
  templateJson: string;  // Stringified template export

  @IsBoolean()
  @IsOptional()
  importAsOfficial?: boolean;
}
```

**template.service.ts:**
```typescript
import { Injectable, NotFoundException, BadRequestException, ForbiddenException } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { TemplateTier, Prisma } from '@prisma/client';
import { CreateTemplateDto, UpdateTemplateDto, TemplateQueryDto, ChecklistSection } from './dto/template.dto';
import { nanoid } from 'nanoid';

@Injectable()
export class InvestigationTemplateService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  async create(
    organizationId: string,
    userId: string,
    dto: CreateTemplateDto,
  ) {
    // Validate sections have unique IDs
    this.validateSections(dto.sections);

    const template = await this.prisma.investigationTemplate.create({
      data: {
        organizationId,
        createdById: userId,
        name: dto.name,
        description: dto.description,
        categoryId: dto.categoryId,
        tier: dto.tier || TemplateTier.PERSONAL,
        sharedWithTeamId: dto.sharedWithTeamId,
        sections: dto.sections as unknown as Prisma.JsonValue,
        suggestedDurations: dto.suggestedDurations as unknown as Prisma.JsonValue,
        conditionalRules: dto.conditionalRules as unknown as Prisma.JsonValue,
        isDefault: dto.isDefault || false,
      },
    });

    this.eventEmitter.emit('investigation.template.created', {
      organizationId,
      templateId: template.id,
      userId,
    });

    return template;
  }

  async findById(organizationId: string, id: string) {
    const template = await this.prisma.investigationTemplate.findFirst({
      where: { id, organizationId },
    });

    if (!template) {
      throw new NotFoundException('Investigation template not found');
    }

    return template;
  }

  async findAll(organizationId: string, userId: string, query: TemplateQueryDto) {
    const where: Prisma.InvestigationTemplateWhereInput = {
      organizationId,
      isArchived: query.includeArchived ? undefined : false,
      ...(query.tier && { tier: query.tier }),
      ...(query.categoryId && { categoryId: query.categoryId }),
      // Access control: show OFFICIAL to all, TEAM to team members, PERSONAL to creator
      OR: [
        { tier: TemplateTier.OFFICIAL },
        { tier: TemplateTier.TEAM },  // TODO: Filter by actual team membership
        { tier: TemplateTier.PERSONAL, createdById: userId },
      ],
    };

    const [templates, total] = await Promise.all([
      this.prisma.investigationTemplate.findMany({
        where,
        orderBy: [
          { tier: 'asc' },
          { name: 'asc' },
        ],
        skip: ((query.page || 1) - 1) * (query.limit || 20),
        take: query.limit || 20,
      }),
      this.prisma.investigationTemplate.count({ where }),
    ]);

    return {
      data: templates,
      meta: {
        total,
        page: query.page || 1,
        limit: query.limit || 20,
        totalPages: Math.ceil(total / (query.limit || 20)),
      },
    };
  }

  async update(
    organizationId: string,
    id: string,
    userId: string,
    dto: UpdateTemplateDto,
  ) {
    const existing = await this.findById(organizationId, id);

    // Check permission: only creator can edit PERSONAL, admins can edit OFFICIAL
    if (existing.tier === TemplateTier.PERSONAL && existing.createdById !== userId) {
      throw new ForbiddenException('Cannot edit another user\'s personal template');
    }

    if (dto.sections) {
      this.validateSections(dto.sections);
    }

    const template = await this.prisma.investigationTemplate.update({
      where: { id },
      data: {
        ...(dto.name && { name: dto.name }),
        ...(dto.description !== undefined && { description: dto.description }),
        ...(dto.categoryId !== undefined && { categoryId: dto.categoryId }),
        ...(dto.tier && { tier: dto.tier }),
        ...(dto.sharedWithTeamId !== undefined && { sharedWithTeamId: dto.sharedWithTeamId }),
        ...(dto.sections && { sections: dto.sections as unknown as Prisma.JsonValue }),
        ...(dto.suggestedDurations !== undefined && { suggestedDurations: dto.suggestedDurations as unknown as Prisma.JsonValue }),
        ...(dto.conditionalRules !== undefined && { conditionalRules: dto.conditionalRules as unknown as Prisma.JsonValue }),
        ...(dto.isDefault !== undefined && { isDefault: dto.isDefault }),
      },
    });

    this.eventEmitter.emit('investigation.template.updated', {
      organizationId,
      templateId: id,
      userId,
    });

    return template;
  }

  async publish(
    organizationId: string,
    id: string,
    userId: string,
    createNewVersion: boolean = false,
  ) {
    const existing = await this.findById(organizationId, id);

    if (createNewVersion) {
      // Check if template has active instances (checklists in progress)
      // If so, create new version; otherwise, update in place
      const hasActiveInstances = await this.hasActiveInstances(organizationId, id);

      if (hasActiveInstances) {
        // Create new version, deactivate old
        await this.prisma.investigationTemplate.update({
          where: { id },
          data: { isActive: false },
        });

        const newTemplate = await this.prisma.investigationTemplate.create({
          data: {
            organizationId,
            createdById: existing.createdById,
            name: existing.name,
            description: existing.description,
            categoryId: existing.categoryId,
            tier: existing.tier,
            sharedWithTeamId: existing.sharedWithTeamId,
            sections: existing.sections,
            suggestedDurations: existing.suggestedDurations,
            conditionalRules: existing.conditionalRules,
            isDefault: existing.isDefault,
            version: existing.version + 1,
            sourceTemplateId: id,
          },
        });

        this.eventEmitter.emit('investigation.template.published', {
          organizationId,
          templateId: newTemplate.id,
          previousVersion: id,
          userId,
        });

        return newTemplate;
      }
    }

    // Just mark as active (no version change needed)
    return this.prisma.investigationTemplate.update({
      where: { id },
      data: { isActive: true },
    });
  }

  async archive(organizationId: string, id: string, userId: string) {
    await this.findById(organizationId, id);

    const template = await this.prisma.investigationTemplate.update({
      where: { id },
      data: { isArchived: true, isActive: false },
    });

    this.eventEmitter.emit('investigation.template.archived', {
      organizationId,
      templateId: id,
      userId,
    });

    return template;
  }

  async unarchive(organizationId: string, id: string) {
    await this.findById(organizationId, id);

    return this.prisma.investigationTemplate.update({
      where: { id },
      data: { isArchived: false },
    });
  }

  async duplicate(
    organizationId: string,
    id: string,
    userId: string,
    newName?: string,
  ) {
    const existing = await this.findById(organizationId, id);

    const template = await this.prisma.investigationTemplate.create({
      data: {
        organizationId,
        createdById: userId,
        name: newName || `${existing.name} (Copy)`,
        description: existing.description,
        categoryId: existing.categoryId,
        tier: TemplateTier.PERSONAL,  // Duplicates start as personal
        sections: existing.sections,
        suggestedDurations: existing.suggestedDurations,
        conditionalRules: existing.conditionalRules,
        sourceTemplateId: id,
      },
    });

    return template;
  }

  async exportTemplate(organizationId: string, id: string) {
    const template = await this.findById(organizationId, id);

    // Remove org-specific fields for export
    const exportData = {
      name: template.name,
      description: template.description,
      sections: template.sections,
      suggestedDurations: template.suggestedDurations,
      conditionalRules: template.conditionalRules,
      exportedAt: new Date().toISOString(),
      version: template.version,
    };

    return JSON.stringify(exportData, null, 2);
  }

  async importTemplate(
    organizationId: string,
    userId: string,
    templateJson: string,
    importAsOfficial: boolean = false,
  ) {
    const importData = JSON.parse(templateJson);

    // Regenerate all IDs to avoid conflicts
    const sections = this.regenerateSectionIds(importData.sections);

    return this.create(organizationId, userId, {
      name: importData.name,
      description: importData.description,
      sections,
      suggestedDurations: importData.suggestedDurations,
      conditionalRules: importData.conditionalRules,
      tier: importAsOfficial ? TemplateTier.OFFICIAL : TemplateTier.PERSONAL,
    });
  }

  async incrementUsageCount(id: string) {
    await this.prisma.investigationTemplate.update({
      where: { id },
      data: { usageCount: { increment: 1 } },
    });
  }

  // Private helpers

  private validateSections(sections: ChecklistSection[]) {
    const sectionIds = new Set<string>();
    const itemIds = new Set<string>();

    for (const section of sections) {
      if (sectionIds.has(section.id)) {
        throw new BadRequestException(`Duplicate section ID: ${section.id}`);
      }
      sectionIds.add(section.id);

      for (const item of section.items) {
        if (itemIds.has(item.id)) {
          throw new BadRequestException(`Duplicate item ID: ${item.id}`);
        }
        itemIds.add(item.id);
      }
    }
  }

  private regenerateSectionIds(sections: ChecklistSection[]): ChecklistSection[] {
    const idMap = new Map<string, string>();

    // Generate new IDs
    for (const section of sections) {
      const newSectionId = nanoid(12);
      idMap.set(section.id, newSectionId);

      for (const item of section.items) {
        idMap.set(item.id, nanoid(12));
      }
    }

    // Apply new IDs
    return sections.map(section => ({
      ...section,
      id: idMap.get(section.id)!,
      sectionDependencies: section.sectionDependencies?.map(id => idMap.get(id) || id),
      items: section.items.map(item => ({
        ...item,
        id: idMap.get(item.id)!,
        dependencies: item.dependencies?.map(id => idMap.get(id) || id),
      })),
    }));
  }

  private async hasActiveInstances(organizationId: string, templateId: string): Promise<boolean> {
    // Will be implemented in Plan 06-07 with InvestigationChecklistProgress
    // For now, return false to allow in-place updates
    return false;
  }
}
```

Create index file: `apps/backend/src/modules/investigations/templates/index.ts`
```typescript
export * from './template.service';
export * from './dto/template.dto';
```
  </action>
  <verify>TypeScript compiles without errors. Service methods exist for CRUD, versioning, duplicate, export/import.</verify>
  <done>InvestigationTemplateService handles full template lifecycle with versioning support.</done>
</task>

<task type="auto">
  <name>Task 3: Create Template Controller and Wire Module</name>
  <files>
    apps/backend/src/modules/investigations/templates/template.controller.ts
    apps/backend/src/modules/investigations/investigations.module.ts
  </files>
  <action>
**template.controller.ts:**
```typescript
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
  ParseUUIDPipe,
} from '@nestjs/common';
import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../../auth/guards/roles.guard';
import { Roles } from '../../auth/decorators/roles.decorator';
import { CurrentUser } from '../../auth/decorators/current-user.decorator';
import { UserRole } from '@prisma/client';
import { InvestigationTemplateService } from './template.service';
import {
  CreateTemplateDto,
  UpdateTemplateDto,
  TemplateQueryDto,
  ImportTemplateDto,
} from './dto/template.dto';

interface AuthUser {
  id: string;
  organizationId: string;
  role: UserRole;
}

@Controller('api/v1/investigation-templates')
@UseGuards(JwtAuthGuard, RolesGuard)
export class InvestigationTemplateController {
  constructor(private readonly templateService: InvestigationTemplateService) {}

  @Post()
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async create(
    @CurrentUser() user: AuthUser,
    @Body() dto: CreateTemplateDto,
  ) {
    return this.templateService.create(user.organizationId, user.id, dto);
  }

  @Get()
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async findAll(
    @CurrentUser() user: AuthUser,
    @Query() query: TemplateQueryDto,
  ) {
    return this.templateService.findAll(user.organizationId, user.id, query);
  }

  @Get(':id')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async findOne(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    return this.templateService.findById(user.organizationId, id);
  }

  @Put(':id')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async update(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
    @Body() dto: UpdateTemplateDto,
  ) {
    return this.templateService.update(user.organizationId, id, user.id, dto);
  }

  @Post(':id/publish')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async publish(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
    @Query('createNewVersion') createNewVersion?: string,
  ) {
    return this.templateService.publish(
      user.organizationId,
      id,
      user.id,
      createNewVersion === 'true',
    );
  }

  @Post(':id/archive')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async archive(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    return this.templateService.archive(user.organizationId, id, user.id);
  }

  @Post(':id/unarchive')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async unarchive(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    return this.templateService.unarchive(user.organizationId, id);
  }

  @Post(':id/duplicate')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async duplicate(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
    @Body('name') name?: string,
  ) {
    return this.templateService.duplicate(user.organizationId, id, user.id, name);
  }

  @Get(':id/export')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async exportTemplate(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    const json = await this.templateService.exportTemplate(user.organizationId, id);
    return { template: json };
  }

  @Post('import')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async importTemplate(
    @CurrentUser() user: AuthUser,
    @Body() dto: ImportTemplateDto,
  ) {
    return this.templateService.importTemplate(
      user.organizationId,
      user.id,
      dto.templateJson,
      dto.importAsOfficial,
    );
  }
}
```

**Update investigations.module.ts** to register the template service and controller:
- Import InvestigationTemplateService from './templates/template.service'
- Import InvestigationTemplateController from './templates/template.controller'
- Add InvestigationTemplateService to providers array
- Add InvestigationTemplateController to controllers array
- Export InvestigationTemplateService
  </action>
  <verify>
Run `cd apps/backend && npm run build` - compiles successfully.
Test endpoint: `curl -X GET http://localhost:3000/api/v1/investigation-templates -H "Authorization: Bearer $TOKEN"` returns empty array.
  </verify>
  <done>Investigation template endpoints are accessible with role-based access control.</done>
</task>

</tasks>

<verification>
- [ ] `npx prisma validate` passes
- [ ] `npm run build` in apps/backend succeeds
- [ ] InvestigationTemplate model has sections JSON field
- [ ] TemplateTier enum has OFFICIAL, TEAM, PERSONAL values
- [ ] Template service supports CRUD, versioning, duplicate, export/import
- [ ] Controller endpoints require appropriate roles
</verification>

<success_criteria>
1. InvestigationTemplate Prisma model exists with versioning fields
2. Templates store sections/items as JSON with proper TypeScript interfaces
3. Service handles full lifecycle: create, update, publish, archive, duplicate
4. Export/import enables cross-organization template sharing
5. Events emitted for audit integration
</success_criteria>

<output>
After completion, create `.planning/phases/06-case-management/06-01-SUMMARY.md`
</output>
