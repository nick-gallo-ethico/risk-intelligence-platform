---
phase: 06-case-management
plan: 07
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/investigations/checklists/checklist.service.ts
  - apps/backend/src/modules/investigations/checklists/checklist.controller.ts
  - apps/backend/src/modules/investigations/checklists/dto/checklist.dto.ts
  - apps/backend/src/modules/investigations/investigations.module.ts
autonomous: true

must_haves:
  truths:
    - "InvestigationChecklistProgress tracks per-investigation completion"
    - "Item states include completion notes and evidence attachments"
    - "Checklist captures template version at creation time"
    - "Investigators can add custom items and skip irrelevant ones"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "InvestigationChecklistProgress model"
      contains: "model InvestigationChecklistProgress"
    - path: "apps/backend/src/modules/investigations/checklists/checklist.service.ts"
      provides: "Checklist progress tracking"
      exports: ["InvestigationChecklistService"]
  key_links:
    - from: "checklist.service.ts"
      to: "template.service.ts"
      via: "DI injection"
      pattern: "InvestigationTemplateService"
---

<objective>
Create the InvestigationChecklistProgress model and service for tracking per-investigation checklist completion with item states and evidence.

Purpose: Checklist progress enables investigators to track investigation steps with completion evidence, supporting audit trails and handoff between team members.

Output: Prisma model, DTOs, service for progress tracking, REST controller
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/06-case-management/06-CONTEXT.md
@.planning/phases/06-case-management/06-01-SUMMARY.md
@apps/backend/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add InvestigationChecklistProgress model to Prisma schema</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
Add the following to schema.prisma:

1. InvestigationChecklistProgress model:
```prisma
model InvestigationChecklistProgress {
  id              String   @id @default(uuid())
  investigationId String   @unique @map("investigation_id")
  organizationId  String   @map("organization_id")
  templateId      String   @map("template_id")
  templateVersion Int      @map("template_version")

  // Current state (JSON)
  itemStates      Json     @map("item_states")     // { [itemId]: ChecklistItemState }
  sectionStates   Json     @map("section_states")  // { [sectionId]: SectionState }

  // Customizations (investigator changes)
  customItems     Json?    @map("custom_items")    // Items added by investigator
  skippedItems    Json?    @map("skipped_items")   // Items marked N/A with reason
  itemOrder       Json?    @map("item_order")      // Custom ordering

  // Summary metrics (denormalized for queries)
  totalItems      Int      @map("total_items")
  completedItems  Int      @default(0) @map("completed_items")
  skippedCount    Int      @default(0) @map("skipped_count")
  customCount     Int      @default(0) @map("custom_count")

  // Progress percentage (0-100)
  progressPercent Int      @default(0) @map("progress_percent")

  // Timestamps
  startedAt       DateTime? @map("started_at")
  completedAt     DateTime? @map("completed_at")
  lastActivityAt  DateTime? @map("last_activity_at")

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  investigation   Investigation @relation(fields: [investigationId], references: [id], onDelete: Cascade)
  template        InvestigationTemplate @relation(fields: [templateId], references: [id])

  @@index([organizationId])
  @@index([organizationId, templateId])
  @@map("investigation_checklist_progress")
}
```

2. Add relations:
- Organization: `checklistProgress InvestigationChecklistProgress[]`
- Investigation: `checklistProgress InvestigationChecklistProgress?`
- InvestigationTemplate: `checklistInstances InvestigationChecklistProgress[]`

Run: `cd apps/backend && npx prisma db push`
  </action>
  <verify>npx prisma validate passes. Database has investigation_checklist_progress table.</verify>
  <done>InvestigationChecklistProgress model exists with item states and metrics.</done>
</task>

<task type="auto">
  <name>Task 2: Create Checklist DTOs and Service</name>
  <files>
    apps/backend/src/modules/investigations/checklists/dto/checklist.dto.ts
    apps/backend/src/modules/investigations/checklists/checklist.service.ts
  </files>
  <action>
Create directory: `apps/backend/src/modules/investigations/checklists/`

**dto/checklist.dto.ts:**
```typescript
import { IsString, IsOptional, IsBoolean, IsUUID, IsArray } from 'class-validator';

export type ItemStatus = 'pending' | 'completed' | 'skipped';
export type SectionStatus = 'pending' | 'in_progress' | 'completed';

export interface ChecklistItemState {
  status: ItemStatus;
  completedAt?: string;
  completedById?: string;
  completedByName?: string;
  completionNotes?: string;
  attachmentIds?: string[];
  linkedInterviewIds?: string[];
}

export interface SectionState {
  status: SectionStatus;
  completedItems: number;
  totalItems: number;
}

export interface CustomItem {
  id: string;
  sectionId: string;
  text: string;
  order: number;
  required: boolean;
  evidenceRequired: boolean;
  addedById: string;
  addedAt: string;
}

export interface SkippedItem {
  itemId: string;
  reason: string;
  skippedById: string;
  skippedAt: string;
}

export class ApplyTemplateDto {
  @IsUUID()
  investigationId: string;

  @IsUUID()
  templateId: string;
}

export class CompleteItemDto {
  @IsString()
  @IsOptional()
  completionNotes?: string;

  @IsArray()
  @IsUUID('4', { each: true })
  @IsOptional()
  attachmentIds?: string[];

  @IsArray()
  @IsUUID('4', { each: true })
  @IsOptional()
  linkedInterviewIds?: string[];
}

export class SkipItemDto {
  @IsString()
  reason: string;
}

export class AddCustomItemDto {
  @IsUUID()
  sectionId: string;

  @IsString()
  text: string;

  @IsBoolean()
  @IsOptional()
  required?: boolean;

  @IsBoolean()
  @IsOptional()
  evidenceRequired?: boolean;
}

export class ChecklistProgressResponse {
  id: string;
  investigationId: string;
  templateId: string;
  templateVersion: number;
  template: {
    name: string;
    sections: any[];
  };
  itemStates: Record<string, ChecklistItemState>;
  sectionStates: Record<string, SectionState>;
  customItems: CustomItem[];
  skippedItems: SkippedItem[];
  totalItems: number;
  completedItems: number;
  skippedCount: number;
  progressPercent: number;
  startedAt?: string;
  completedAt?: string;
}
```

**checklist.service.ts:**
```typescript
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { Prisma } from '@prisma/client';
import { InvestigationTemplateService, ChecklistSection, ChecklistItem } from '../templates';
import {
  ApplyTemplateDto,
  CompleteItemDto,
  SkipItemDto,
  AddCustomItemDto,
  ChecklistItemState,
  SectionState,
  CustomItem,
  SkippedItem,
} from './dto/checklist.dto';
import { nanoid } from 'nanoid';

@Injectable()
export class InvestigationChecklistService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly eventEmitter: EventEmitter2,
    private readonly templateService: InvestigationTemplateService,
  ) {}

  async applyTemplate(
    organizationId: string,
    userId: string,
    dto: ApplyTemplateDto,
  ) {
    // Check if investigation already has a checklist
    const existing = await this.prisma.investigationChecklistProgress.findUnique({
      where: { investigationId: dto.investigationId },
    });

    if (existing) {
      throw new BadRequestException('Investigation already has a checklist. Use swap template instead.');
    }

    // Load template
    const template = await this.templateService.findById(organizationId, dto.templateId);
    const sections = template.sections as ChecklistSection[];

    // Initialize item and section states
    const itemStates: Record<string, ChecklistItemState> = {};
    const sectionStates: Record<string, SectionState> = {};
    let totalItems = 0;

    for (const section of sections) {
      sectionStates[section.id] = {
        status: 'pending',
        completedItems: 0,
        totalItems: section.items.length,
      };

      for (const item of section.items) {
        itemStates[item.id] = { status: 'pending' };
        totalItems++;
      }
    }

    // Create progress record
    const progress = await this.prisma.investigationChecklistProgress.create({
      data: {
        organizationId,
        investigationId: dto.investigationId,
        templateId: template.id,
        templateVersion: template.version,
        itemStates: itemStates as unknown as Prisma.JsonValue,
        sectionStates: sectionStates as unknown as Prisma.JsonValue,
        totalItems,
        startedAt: new Date(),
      },
    });

    // Increment template usage count
    await this.templateService.incrementUsageCount(template.id);

    this.eventEmitter.emit('investigation.checklist.applied', {
      organizationId,
      investigationId: dto.investigationId,
      templateId: template.id,
      userId,
    });

    return this.getProgress(organizationId, dto.investigationId);
  }

  async getProgress(organizationId: string, investigationId: string) {
    const progress = await this.prisma.investigationChecklistProgress.findFirst({
      where: { investigationId, organizationId },
      include: {
        template: {
          select: { name: true, sections: true },
        },
      },
    });

    if (!progress) {
      throw new NotFoundException('No checklist found for this investigation');
    }

    return {
      ...progress,
      itemStates: progress.itemStates as Record<string, ChecklistItemState>,
      sectionStates: progress.sectionStates as Record<string, SectionState>,
      customItems: (progress.customItems || []) as CustomItem[],
      skippedItems: (progress.skippedItems || []) as SkippedItem[],
    };
  }

  async completeItem(
    organizationId: string,
    investigationId: string,
    itemId: string,
    userId: string,
    userName: string,
    dto: CompleteItemDto,
  ) {
    const progress = await this.getProgress(organizationId, investigationId);
    const itemStates = progress.itemStates;
    const sectionStates = progress.sectionStates;

    // Find which section contains this item
    const template = progress.template;
    const sections = template.sections as ChecklistSection[];
    let targetSection: ChecklistSection | undefined;
    let targetItem: ChecklistItem | undefined;
    let isCustomItem = false;

    for (const section of sections) {
      const item = section.items.find(i => i.id === itemId);
      if (item) {
        targetSection = section;
        targetItem = item;
        break;
      }
    }

    // Check custom items
    if (!targetItem) {
      const customItem = progress.customItems.find(ci => ci.id === itemId);
      if (customItem) {
        isCustomItem = true;
        targetSection = sections.find(s => s.id === customItem.sectionId);
      }
    }

    if (!targetSection) {
      throw new NotFoundException('Item not found in checklist');
    }

    // Check dependencies
    if (targetItem?.dependencies?.length) {
      const unmetDeps = targetItem.dependencies.filter(
        depId => itemStates[depId]?.status !== 'completed'
      );
      if (unmetDeps.length > 0) {
        throw new BadRequestException('Complete prerequisite items first');
      }
    }

    // Check section dependencies
    if (targetSection.sectionDependencies?.length) {
      const unmetSectionDeps = targetSection.sectionDependencies.filter(
        secId => sectionStates[secId]?.status !== 'completed'
      );
      if (unmetSectionDeps.length > 0) {
        throw new BadRequestException('Complete prerequisite sections first');
      }
    }

    // Update item state
    itemStates[itemId] = {
      status: 'completed',
      completedAt: new Date().toISOString(),
      completedById: userId,
      completedByName: userName,
      completionNotes: dto.completionNotes,
      attachmentIds: dto.attachmentIds,
      linkedInterviewIds: dto.linkedInterviewIds,
    };

    // Update section state
    const sectionItems = isCustomItem
      ? [itemId, ...sections.find(s => s.id === targetSection!.id)!.items.map(i => i.id)]
      : sections.find(s => s.id === targetSection!.id)!.items.map(i => i.id);

    const completedInSection = sectionItems.filter(
      id => itemStates[id]?.status === 'completed'
    ).length;

    sectionStates[targetSection.id] = {
      ...sectionStates[targetSection.id],
      completedItems: completedInSection,
      status: completedInSection === sectionStates[targetSection.id].totalItems
        ? 'completed'
        : 'in_progress',
    };

    // Calculate overall progress
    const totalCompleted = Object.values(itemStates).filter(
      s => s.status === 'completed'
    ).length;
    const totalSkipped = Object.values(itemStates).filter(
      s => s.status === 'skipped'
    ).length;
    const progressPercent = Math.round(
      ((totalCompleted + totalSkipped) / progress.totalItems) * 100
    );

    // Update progress record
    await this.prisma.investigationChecklistProgress.update({
      where: { id: progress.id },
      data: {
        itemStates: itemStates as unknown as Prisma.JsonValue,
        sectionStates: sectionStates as unknown as Prisma.JsonValue,
        completedItems: totalCompleted,
        skippedCount: totalSkipped,
        progressPercent,
        lastActivityAt: new Date(),
        ...(progressPercent === 100 && { completedAt: new Date() }),
      },
    });

    this.eventEmitter.emit('investigation.checklist.item.completed', {
      organizationId,
      investigationId,
      itemId,
      userId,
    });

    return this.getProgress(organizationId, investigationId);
  }

  async skipItem(
    organizationId: string,
    investigationId: string,
    itemId: string,
    userId: string,
    dto: SkipItemDto,
  ) {
    const progress = await this.getProgress(organizationId, investigationId);
    const itemStates = progress.itemStates;
    const skippedItems = progress.skippedItems;

    // Mark as skipped
    itemStates[itemId] = { status: 'skipped' };

    // Record skip reason
    skippedItems.push({
      itemId,
      reason: dto.reason,
      skippedById: userId,
      skippedAt: new Date().toISOString(),
    });

    // Recalculate progress
    const totalCompleted = Object.values(itemStates).filter(s => s.status === 'completed').length;
    const totalSkipped = Object.values(itemStates).filter(s => s.status === 'skipped').length;
    const progressPercent = Math.round(((totalCompleted + totalSkipped) / progress.totalItems) * 100);

    await this.prisma.investigationChecklistProgress.update({
      where: { id: progress.id },
      data: {
        itemStates: itemStates as unknown as Prisma.JsonValue,
        skippedItems: skippedItems as unknown as Prisma.JsonValue,
        skippedCount: totalSkipped,
        progressPercent,
        lastActivityAt: new Date(),
      },
    });

    return this.getProgress(organizationId, investigationId);
  }

  async addCustomItem(
    organizationId: string,
    investigationId: string,
    userId: string,
    dto: AddCustomItemDto,
  ) {
    const progress = await this.getProgress(organizationId, investigationId);

    const customItem: CustomItem = {
      id: nanoid(12),
      sectionId: dto.sectionId,
      text: dto.text,
      order: progress.customItems.length,
      required: dto.required || false,
      evidenceRequired: dto.evidenceRequired || false,
      addedById: userId,
      addedAt: new Date().toISOString(),
    };

    const customItems = [...progress.customItems, customItem];
    const itemStates = {
      ...progress.itemStates,
      [customItem.id]: { status: 'pending' as const },
    };

    // Update section total
    const sectionStates = { ...progress.sectionStates };
    if (sectionStates[dto.sectionId]) {
      sectionStates[dto.sectionId] = {
        ...sectionStates[dto.sectionId],
        totalItems: sectionStates[dto.sectionId].totalItems + 1,
      };
    }

    await this.prisma.investigationChecklistProgress.update({
      where: { id: progress.id },
      data: {
        customItems: customItems as unknown as Prisma.JsonValue,
        itemStates: itemStates as unknown as Prisma.JsonValue,
        sectionStates: sectionStates as unknown as Prisma.JsonValue,
        customCount: customItems.length,
        totalItems: progress.totalItems + 1,
        lastActivityAt: new Date(),
      },
    });

    return this.getProgress(organizationId, investigationId);
  }

  async uncompleteItem(
    organizationId: string,
    investigationId: string,
    itemId: string,
    userId: string,
  ) {
    const progress = await this.getProgress(organizationId, investigationId);
    const itemStates = progress.itemStates;

    if (itemStates[itemId]?.status !== 'completed') {
      throw new BadRequestException('Item is not completed');
    }

    // Reset item state
    itemStates[itemId] = { status: 'pending' };

    // Recalculate progress
    const totalCompleted = Object.values(itemStates).filter(s => s.status === 'completed').length;
    const totalSkipped = Object.values(itemStates).filter(s => s.status === 'skipped').length;
    const progressPercent = Math.round(((totalCompleted + totalSkipped) / progress.totalItems) * 100);

    await this.prisma.investigationChecklistProgress.update({
      where: { id: progress.id },
      data: {
        itemStates: itemStates as unknown as Prisma.JsonValue,
        completedItems: totalCompleted,
        progressPercent,
        lastActivityAt: new Date(),
        completedAt: null,  // Reopen if was completed
      },
    });

    return this.getProgress(organizationId, investigationId);
  }

  async deleteChecklist(organizationId: string, investigationId: string) {
    const progress = await this.prisma.investigationChecklistProgress.findFirst({
      where: { investigationId, organizationId },
    });

    if (!progress) {
      throw new NotFoundException('No checklist found for this investigation');
    }

    await this.prisma.investigationChecklistProgress.delete({
      where: { id: progress.id },
    });
  }
}
```

Create index: `apps/backend/src/modules/investigations/checklists/index.ts`
```typescript
export * from './checklist.service';
export * from './dto/checklist.dto';
```
  </action>
  <verify>TypeScript compiles. ChecklistService handles progress tracking with item states.</verify>
  <done>InvestigationChecklistService provides complete checklist progress management.</done>
</task>

<task type="auto">
  <name>Task 3: Create Checklist Controller and Wire Module</name>
  <files>
    apps/backend/src/modules/investigations/checklists/checklist.controller.ts
    apps/backend/src/modules/investigations/investigations.module.ts
  </files>
  <action>
**checklist.controller.ts:**
```typescript
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  UseGuards,
  ParseUUIDPipe,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../../auth/guards/roles.guard';
import { Roles } from '../../auth/decorators/roles.decorator';
import { CurrentUser } from '../../auth/decorators/current-user.decorator';
import { UserRole } from '@prisma/client';
import { InvestigationChecklistService } from './checklist.service';
import {
  ApplyTemplateDto,
  CompleteItemDto,
  SkipItemDto,
  AddCustomItemDto,
} from './dto/checklist.dto';

interface AuthUser {
  id: string;
  organizationId: string;
  firstName: string;
  lastName: string;
  role: UserRole;
}

@Controller('api/v1/investigation-checklists')
@UseGuards(JwtAuthGuard, RolesGuard)
export class InvestigationChecklistController {
  constructor(private readonly checklistService: InvestigationChecklistService) {}

  @Post('apply')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async applyTemplate(
    @CurrentUser() user: AuthUser,
    @Body() dto: ApplyTemplateDto,
  ) {
    return this.checklistService.applyTemplate(user.organizationId, user.id, dto);
  }

  @Get('by-investigation/:investigationId')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async getProgress(
    @CurrentUser() user: AuthUser,
    @Param('investigationId', ParseUUIDPipe) investigationId: string,
  ) {
    return this.checklistService.getProgress(user.organizationId, investigationId);
  }

  @Post(':investigationId/items/:itemId/complete')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async completeItem(
    @CurrentUser() user: AuthUser,
    @Param('investigationId', ParseUUIDPipe) investigationId: string,
    @Param('itemId') itemId: string,
    @Body() dto: CompleteItemDto,
  ) {
    const userName = `${user.firstName} ${user.lastName}`;
    return this.checklistService.completeItem(
      user.organizationId,
      investigationId,
      itemId,
      user.id,
      userName,
      dto,
    );
  }

  @Post(':investigationId/items/:itemId/skip')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async skipItem(
    @CurrentUser() user: AuthUser,
    @Param('investigationId', ParseUUIDPipe) investigationId: string,
    @Param('itemId') itemId: string,
    @Body() dto: SkipItemDto,
  ) {
    return this.checklistService.skipItem(
      user.organizationId,
      investigationId,
      itemId,
      user.id,
      dto,
    );
  }

  @Post(':investigationId/items/:itemId/uncomplete')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async uncompleteItem(
    @CurrentUser() user: AuthUser,
    @Param('investigationId', ParseUUIDPipe) investigationId: string,
    @Param('itemId') itemId: string,
  ) {
    return this.checklistService.uncompleteItem(
      user.organizationId,
      investigationId,
      itemId,
      user.id,
    );
  }

  @Post(':investigationId/custom-items')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async addCustomItem(
    @CurrentUser() user: AuthUser,
    @Param('investigationId', ParseUUIDPipe) investigationId: string,
    @Body() dto: AddCustomItemDto,
  ) {
    return this.checklistService.addCustomItem(
      user.organizationId,
      investigationId,
      user.id,
      dto,
    );
  }

  @Delete(':investigationId')
  @HttpCode(HttpStatus.NO_CONTENT)
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async deleteChecklist(
    @CurrentUser() user: AuthUser,
    @Param('investigationId', ParseUUIDPipe) investigationId: string,
  ) {
    await this.checklistService.deleteChecklist(user.organizationId, investigationId);
  }
}
```

**Update investigations.module.ts:**
- Import InvestigationChecklistService from './checklists/checklist.service'
- Import InvestigationChecklistController from './checklists/checklist.controller'
- Add InvestigationChecklistService to providers array
- Add InvestigationChecklistController to controllers array
- Export InvestigationChecklistService
  </action>
  <verify>
Run `cd apps/backend && npm run build` - compiles successfully.
POST /api/v1/investigation-checklists/apply creates checklist from template.
POST /api/v1/investigation-checklists/:id/items/:itemId/complete marks item done.
  </verify>
  <done>Checklist endpoints enable template application and progress tracking.</done>
</task>

</tasks>

<verification>
- [ ] `npx prisma validate` passes
- [ ] `npm run build` in apps/backend succeeds
- [ ] InvestigationChecklistProgress captures templateVersion
- [ ] Item completion includes notes and attachment links
- [ ] Custom items can be added to sections
- [ ] Progress percentage calculated correctly
</verification>

<success_criteria>
1. InvestigationChecklistProgress Prisma model exists with item states
2. Template version captured at apply time (immutable)
3. Item completion supports notes, attachments, interview links
4. Custom items and skip with reason supported
5. Progress metrics (completed, skipped, percent) denormalized
</success_criteria>

<output>
After completion, create `.planning/phases/06-case-management/06-07-SUMMARY.md`
</output>
