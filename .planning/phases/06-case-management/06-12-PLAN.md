---
phase: 06-case-management
plan: 12
type: execute
wave: 4
depends_on: ["06-04"]
files_modified:
  - apps/frontend/src/pages/cases/CaseListPage.tsx
  - apps/frontend/src/components/cases/CaseFilters.tsx
  - apps/frontend/src/components/common/SavedViewSelector.tsx
  - apps/frontend/src/hooks/useSavedViews.ts
  - apps/frontend/src/services/savedViews.service.ts
autonomous: true

must_haves:
  truths:
    - "Case list supports advanced filtering by status, category, severity, date, assignee"
    - "Saved views dropdown shows user's saved and shared views"
    - "Applying a view loads filter configuration"
    - "Current filters can be saved as new view"
  artifacts:
    - path: "apps/frontend/src/pages/cases/CaseListPage.tsx"
      provides: "Case list with saved views integration"
    - path: "apps/frontend/src/components/common/SavedViewSelector.tsx"
      provides: "Reusable saved view selector component"
  key_links:
    - from: "CaseListPage.tsx"
      to: "savedViews.service.ts"
      via: "API client"
      pattern: "savedViewsService"
---

<objective>
Implement the Case list page with advanced filtering and saved views integration on the frontend.

Purpose: Investigators need to quickly filter large case lists and save frequently-used filter combinations.

Output: CaseListPage with filters, SavedViewSelector component, saved views service
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/06-case-management/06-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Saved Views Service and Hook</name>
  <files>
    apps/frontend/src/services/savedViews.service.ts
    apps/frontend/src/hooks/useSavedViews.ts
  </files>
  <action>
**savedViews.service.ts:**
```typescript
import { apiClient } from './api-client';

export interface SavedView {
  id: string;
  name: string;
  description?: string;
  entityType: string;
  filters: Record<string, unknown>;
  sortBy?: string;
  sortOrder?: string;
  columns?: { key: string; visible: boolean; order: number }[];
  isDefault: boolean;
  isPinned: boolean;
  isShared: boolean;
  createdById: string;
}

export const savedViewsService = {
  list: (entityType?: string) =>
    apiClient.get<{ data: SavedView[]; grouped: Record<string, SavedView[]> }>(
      '/saved-views',
      { params: { entityType, includeShared: true } }
    ),

  get: (id: string) =>
    apiClient.get<SavedView>(`/saved-views/${id}`),

  create: (data: Partial<SavedView>) =>
    apiClient.post<SavedView>('/saved-views', data),

  update: (id: string, data: Partial<SavedView>) =>
    apiClient.put<SavedView>(`/saved-views/${id}`, data),

  delete: (id: string) =>
    apiClient.delete(`/saved-views/${id}`),

  apply: (id: string) =>
    apiClient.post<{
      filters: Record<string, unknown>;
      sortBy?: string;
      sortOrder?: string;
      invalidFilters: string[];
    }>(`/saved-views/${id}/apply`),

  duplicate: (id: string, name?: string) =>
    apiClient.post<SavedView>(`/saved-views/${id}/duplicate`, { name }),

  getDefault: (entityType: string) =>
    apiClient.get<SavedView | null>(`/saved-views/default/${entityType}`),
};
```

**useSavedViews.ts:**
```typescript
import { useState, useEffect, useCallback } from 'react';
import { savedViewsService, SavedView } from '../services/savedViews.service';

export function useSavedViews(entityType: string) {
  const [views, setViews] = useState<SavedView[]>([]);
  const [loading, setLoading] = useState(true);
  const [activeView, setActiveView] = useState<SavedView | null>(null);

  const loadViews = useCallback(async () => {
    setLoading(true);
    try {
      const response = await savedViewsService.list(entityType);
      setViews(response.data.data);

      // Load default view if exists
      const defaultView = response.data.data.find(v => v.isDefault);
      if (defaultView) {
        setActiveView(defaultView);
      }
    } catch (error) {
      console.error('Failed to load saved views', error);
    } finally {
      setLoading(false);
    }
  }, [entityType]);

  useEffect(() => {
    loadViews();
  }, [loadViews]);

  const applyView = async (viewId: string) => {
    const result = await savedViewsService.apply(viewId);
    const view = views.find(v => v.id === viewId);
    if (view) {
      setActiveView(view);
    }
    return result.data;
  };

  const saveCurrentView = async (name: string, filters: Record<string, unknown>, options?: Partial<SavedView>) => {
    const newView = await savedViewsService.create({
      name,
      entityType,
      filters,
      ...options,
    });
    setViews(prev => [...prev, newView.data]);
    return newView.data;
  };

  const deleteView = async (viewId: string) => {
    await savedViewsService.delete(viewId);
    setViews(prev => prev.filter(v => v.id !== viewId));
    if (activeView?.id === viewId) {
      setActiveView(null);
    }
  };

  return {
    views,
    loading,
    activeView,
    applyView,
    saveCurrentView,
    deleteView,
    refreshViews: loadViews,
  };
}
```
  </action>
  <verify>TypeScript compiles. Hook manages saved views state and API calls.</verify>
  <done>Saved views service and hook provide view management functionality.</done>
</task>

<task type="auto">
  <name>Task 2: Create SavedViewSelector Component</name>
  <files>apps/frontend/src/components/common/SavedViewSelector.tsx</files>
  <action>
**SavedViewSelector.tsx:**
```typescript
import React, { useState } from 'react';
import {
  Button,
  Menu,
  MenuItem,
  ListItemIcon,
  ListItemText,
  Divider,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Checkbox,
  FormControlLabel,
  IconButton,
  Tooltip,
  Chip,
} from '@mui/material';
import {
  BookmarkBorder,
  Bookmark,
  Add,
  Delete,
  Share,
  Star,
  StarBorder,
} from '@mui/icons-material';
import { SavedView } from '../../services/savedViews.service';

interface SavedViewSelectorProps {
  views: SavedView[];
  activeView: SavedView | null;
  onApplyView: (viewId: string) => void;
  onSaveView: (name: string, isShared: boolean, isPinned: boolean) => Promise<void>;
  onDeleteView: (viewId: string) => void;
  hasActiveFilters: boolean;
}

export function SavedViewSelector({
  views,
  activeView,
  onApplyView,
  onSaveView,
  onDeleteView,
  hasActiveFilters,
}: SavedViewSelectorProps) {
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const [saveDialogOpen, setSaveDialogOpen] = useState(false);
  const [newViewName, setNewViewName] = useState('');
  const [isShared, setIsShared] = useState(false);
  const [isPinned, setIsPinned] = useState(false);

  const pinnedViews = views.filter(v => v.isPinned);
  const otherViews = views.filter(v => !v.isPinned);

  const handleSave = async () => {
    await onSaveView(newViewName, isShared, isPinned);
    setSaveDialogOpen(false);
    setNewViewName('');
    setIsShared(false);
    setIsPinned(false);
  };

  return (
    <>
      <Button
        variant="outlined"
        startIcon={activeView ? <Bookmark /> : <BookmarkBorder />}
        onClick={(e) => setAnchorEl(e.currentTarget)}
        size="small"
      >
        {activeView ? activeView.name : 'Saved Views'}
      </Button>

      <Menu
        anchorEl={anchorEl}
        open={Boolean(anchorEl)}
        onClose={() => setAnchorEl(null)}
        PaperProps={{ sx: { minWidth: 250 } }}
      >
        {hasActiveFilters && (
          <>
            <MenuItem onClick={() => { setSaveDialogOpen(true); setAnchorEl(null); }}>
              <ListItemIcon><Add fontSize="small" /></ListItemIcon>
              <ListItemText>Save current filters...</ListItemText>
            </MenuItem>
            <Divider />
          </>
        )}

        {pinnedViews.length > 0 && (
          <>
            {pinnedViews.map(view => (
              <MenuItem
                key={view.id}
                onClick={() => { onApplyView(view.id); setAnchorEl(null); }}
                selected={activeView?.id === view.id}
              >
                <ListItemIcon><Star fontSize="small" color="primary" /></ListItemIcon>
                <ListItemText>{view.name}</ListItemText>
                {view.isShared && <Chip label="Shared" size="small" sx={{ ml: 1 }} />}
              </MenuItem>
            ))}
            <Divider />
          </>
        )}

        {otherViews.map(view => (
          <MenuItem
            key={view.id}
            onClick={() => { onApplyView(view.id); setAnchorEl(null); }}
            selected={activeView?.id === view.id}
          >
            <ListItemText>{view.name}</ListItemText>
            {view.isShared && <Chip label="Shared" size="small" sx={{ ml: 1 }} />}
            <IconButton
              size="small"
              onClick={(e) => { e.stopPropagation(); onDeleteView(view.id); }}
              sx={{ ml: 1 }}
            >
              <Delete fontSize="small" />
            </IconButton>
          </MenuItem>
        ))}

        {views.length === 0 && (
          <MenuItem disabled>
            <ListItemText secondary="No saved views yet" />
          </MenuItem>
        )}
      </Menu>

      <Dialog open={saveDialogOpen} onClose={() => setSaveDialogOpen(false)}>
        <DialogTitle>Save View</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="View Name"
            fullWidth
            value={newViewName}
            onChange={(e) => setNewViewName(e.target.value)}
          />
          <FormControlLabel
            control={<Checkbox checked={isShared} onChange={(e) => setIsShared(e.target.checked)} />}
            label="Share with team"
          />
          <FormControlLabel
            control={<Checkbox checked={isPinned} onChange={(e) => setIsPinned(e.target.checked)} />}
            label="Pin to top"
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setSaveDialogOpen(false)}>Cancel</Button>
          <Button onClick={handleSave} variant="contained" disabled={!newViewName.trim()}>
            Save
          </Button>
        </DialogActions>
      </Dialog>
    </>
  );
}
```
  </action>
  <verify>Component renders with view selection, save dialog, and delete functionality.</verify>
  <done>SavedViewSelector component provides reusable view management UI.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate Saved Views into CaseListPage</name>
  <files>
    apps/frontend/src/pages/cases/CaseListPage.tsx
    apps/frontend/src/components/cases/CaseFilters.tsx
  </files>
  <action>
Update CaseListPage to:
1. Use useSavedViews hook with entityType='CASES'
2. Render SavedViewSelector in toolbar
3. Apply filters when view selected
4. Track hasActiveFilters state
5. Pass save/delete handlers to SavedViewSelector

Create CaseFilters component with:
1. Status multi-select (NEW, OPEN, CLOSED)
2. Category dropdown (from categories API)
3. Severity select (HIGH, MEDIUM, LOW)
4. Date range picker (created, updated)
5. Assigned to (user search)
6. Pipeline stage
7. Clear all filters button
8. Real-time filter application

Connect filters to URL params for shareable filtered views.
  </action>
  <verify>
Case list page loads default view on mount.
Selecting a saved view applies its filters.
"Save current filters" creates new view.
  </verify>
  <done>CaseListPage integrates saved views with advanced filtering.</done>
</task>

</tasks>

<verification>
- [ ] `npm run build` in apps/frontend succeeds
- [ ] SavedViewSelector shows pinned views at top
- [ ] Applying view updates filter state
- [ ] Current filters can be saved as new view
- [ ] Delete removes view and clears if active
</verification>

<success_criteria>
1. Case list shows advanced filter panel
2. Saved views dropdown with pin/share indicators
3. Applying view loads filter configuration
4. Save dialog creates new view from current filters
5. URL params reflect active filters for sharing
</success_criteria>

<output>
After completion, create `.planning/phases/06-case-management/06-12-SUMMARY.md`
</output>
