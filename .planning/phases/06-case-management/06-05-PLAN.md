---
phase: 06-case-management
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/custom-properties/custom-properties.module.ts
  - apps/backend/src/modules/custom-properties/custom-properties.service.ts
  - apps/backend/src/modules/custom-properties/custom-properties.controller.ts
  - apps/backend/src/modules/custom-properties/dto/custom-property.dto.ts
  - apps/backend/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "CustomPropertyDefinition model exists for tenant-configurable fields"
    - "Definitions support multiple data types (text, number, date, select, multi-select, boolean)"
    - "Values are stored in entity customFields JSON column"
    - "Properties can be required or optional with validation rules"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "CustomPropertyDefinition model"
      contains: "model CustomPropertyDefinition"
    - path: "apps/backend/src/modules/custom-properties/custom-properties.service.ts"
      provides: "Property definition CRUD and value validation"
      exports: ["CustomPropertiesService"]
  key_links:
    - from: "custom-properties.service.ts"
      to: "prisma"
      via: "PrismaService"
      pattern: "prisma\\.customPropertyDefinition"
---

<objective>
Create the CustomPropertyDefinition model and service for tenant-configurable fields on Cases, Investigations, and Persons.

Purpose: Custom properties allow organizations to capture industry-specific or compliance-specific data without requiring schema changes.

Output: Prisma model, DTOs, service with CRUD and value validation, REST controller
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-case-management/06-CONTEXT.md
@.planning/phases/06-case-management/06-RESEARCH.md
@apps/backend/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CustomPropertyDefinition model to Prisma schema</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
Add the following to schema.prisma:

1. CustomPropertyEntityType enum:
```prisma
enum CustomPropertyEntityType {
  CASE
  INVESTIGATION
  PERSON
  RIU

  @@map("custom_property_entity_type")
}
```

2. PropertyDataType enum:
```prisma
enum PropertyDataType {
  TEXT
  NUMBER
  DATE
  DATETIME
  SELECT
  MULTI_SELECT
  BOOLEAN
  URL
  EMAIL
  PHONE

  @@map("property_data_type")
}
```

3. CustomPropertyDefinition model:
```prisma
model CustomPropertyDefinition {
  id              String   @id @default(uuid())
  organizationId  String   @map("organization_id")

  // Target entity
  entityType      CustomPropertyEntityType @map("entity_type")

  // Property definition
  name            String
  key             String   // Unique key within entity type, used in customFields JSON
  description     String?

  // Type and validation
  dataType        PropertyDataType @map("data_type")
  isRequired      Boolean  @default(false) @map("is_required")
  defaultValue    Json?    @map("default_value")

  // Options for SELECT/MULTI_SELECT
  options         Json?    // Array of { value: string, label: string, color?: string }

  // Validation rules
  validationRules Json?    @map("validation_rules")
  // For TEXT: { minLength?, maxLength?, pattern? }
  // For NUMBER: { min?, max?, decimals? }
  // For DATE: { minDate?, maxDate? }

  // Display configuration
  displayOrder    Int      @default(0) @map("display_order")
  groupName       String?  @map("group_name")  // For grouping related properties
  isVisible       Boolean  @default(true) @map("is_visible")
  helpText        String?  @map("help_text")

  // UI hints
  placeholder     String?
  width           String?  // 'full', 'half', 'third'

  // Status
  isActive        Boolean  @default(true) @map("is_active")

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  createdById     String   @map("created_by_id")

  // Relations
  organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([organizationId, entityType, key])
  @@index([organizationId, entityType])
  @@index([organizationId, entityType, isActive])
  @@map("custom_property_definitions")
}
```

4. Add relation to Organization model:
```prisma
customPropertyDefinitions CustomPropertyDefinition[]
```

Run: `cd apps/backend && npx prisma db push`
  </action>
  <verify>npx prisma validate passes. Database has custom_property_definitions table.</verify>
  <done>CustomPropertyDefinition model exists with data type and validation rules support.</done>
</task>

<task type="auto">
  <name>Task 2: Create CustomProperties DTOs and Service</name>
  <files>
    apps/backend/src/modules/custom-properties/dto/custom-property.dto.ts
    apps/backend/src/modules/custom-properties/custom-properties.service.ts
  </files>
  <action>
Create directory: `apps/backend/src/modules/custom-properties/`

**dto/custom-property.dto.ts:**
```typescript
import { IsString, IsOptional, IsEnum, IsBoolean, IsInt, IsArray, Min, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';
import { CustomPropertyEntityType, PropertyDataType } from '@prisma/client';

export interface SelectOption {
  value: string;
  label: string;
  color?: string;
}

export interface TextValidation {
  minLength?: number;
  maxLength?: number;
  pattern?: string;  // Regex pattern
}

export interface NumberValidation {
  min?: number;
  max?: number;
  decimals?: number;
}

export interface DateValidation {
  minDate?: string;  // ISO date string
  maxDate?: string;
  allowFuture?: boolean;
  allowPast?: boolean;
}

export type ValidationRules = TextValidation | NumberValidation | DateValidation;

export class CreateCustomPropertyDto {
  @IsEnum(CustomPropertyEntityType)
  entityType: CustomPropertyEntityType;

  @IsString()
  name: string;

  @IsString()
  key: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsEnum(PropertyDataType)
  dataType: PropertyDataType;

  @IsBoolean()
  @IsOptional()
  isRequired?: boolean;

  @IsOptional()
  defaultValue?: unknown;

  @IsArray()
  @IsOptional()
  options?: SelectOption[];

  @IsOptional()
  validationRules?: ValidationRules;

  @IsInt()
  @Min(0)
  @IsOptional()
  displayOrder?: number;

  @IsString()
  @IsOptional()
  groupName?: string;

  @IsString()
  @IsOptional()
  helpText?: string;

  @IsString()
  @IsOptional()
  placeholder?: string;

  @IsString()
  @IsOptional()
  width?: string;
}

export class UpdateCustomPropertyDto {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsBoolean()
  @IsOptional()
  isRequired?: boolean;

  @IsOptional()
  defaultValue?: unknown;

  @IsArray()
  @IsOptional()
  options?: SelectOption[];

  @IsOptional()
  validationRules?: ValidationRules;

  @IsInt()
  @Min(0)
  @IsOptional()
  displayOrder?: number;

  @IsString()
  @IsOptional()
  groupName?: string;

  @IsBoolean()
  @IsOptional()
  isVisible?: boolean;

  @IsString()
  @IsOptional()
  helpText?: string;

  @IsString()
  @IsOptional()
  placeholder?: string;

  @IsString()
  @IsOptional()
  width?: string;

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
}

export class ValidateValuesDto {
  @IsEnum(CustomPropertyEntityType)
  entityType: CustomPropertyEntityType;

  values: Record<string, unknown>;
}

export class ValidationResult {
  valid: boolean;
  errors: {
    key: string;
    message: string;
  }[];
  sanitized: Record<string, unknown>;
}
```

**custom-properties.service.ts:**
```typescript
import { Injectable, NotFoundException, BadRequestException, ConflictException } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { CustomPropertyEntityType, PropertyDataType, Prisma } from '@prisma/client';
import {
  CreateCustomPropertyDto,
  UpdateCustomPropertyDto,
  ValidationRules,
  SelectOption,
  ValidationResult,
} from './dto/custom-property.dto';

@Injectable()
export class CustomPropertiesService {
  constructor(private readonly prisma: PrismaService) {}

  async create(
    organizationId: string,
    userId: string,
    dto: CreateCustomPropertyDto,
  ) {
    // Validate key format (alphanumeric, underscore, starts with letter)
    if (!/^[a-zA-Z][a-zA-Z0-9_]*$/.test(dto.key)) {
      throw new BadRequestException(
        'Key must start with a letter and contain only letters, numbers, and underscores'
      );
    }

    // Check for duplicate key
    const existing = await this.prisma.customPropertyDefinition.findFirst({
      where: {
        organizationId,
        entityType: dto.entityType,
        key: dto.key,
      },
    });

    if (existing) {
      throw new ConflictException(`Property with key "${dto.key}" already exists for ${dto.entityType}`);
    }

    // Validate options for SELECT/MULTI_SELECT
    if (
      (dto.dataType === PropertyDataType.SELECT || dto.dataType === PropertyDataType.MULTI_SELECT) &&
      (!dto.options || dto.options.length === 0)
    ) {
      throw new BadRequestException('SELECT and MULTI_SELECT types require options');
    }

    return this.prisma.customPropertyDefinition.create({
      data: {
        organizationId,
        entityType: dto.entityType,
        name: dto.name,
        key: dto.key,
        description: dto.description,
        dataType: dto.dataType,
        isRequired: dto.isRequired || false,
        defaultValue: dto.defaultValue as Prisma.JsonValue,
        options: dto.options as unknown as Prisma.JsonValue,
        validationRules: dto.validationRules as unknown as Prisma.JsonValue,
        displayOrder: dto.displayOrder || 0,
        groupName: dto.groupName,
        helpText: dto.helpText,
        placeholder: dto.placeholder,
        width: dto.width,
        createdById: userId,
      },
    });
  }

  async findById(organizationId: string, id: string) {
    const definition = await this.prisma.customPropertyDefinition.findFirst({
      where: { id, organizationId },
    });

    if (!definition) {
      throw new NotFoundException('Custom property definition not found');
    }

    return definition;
  }

  async findByEntityType(organizationId: string, entityType: CustomPropertyEntityType) {
    return this.prisma.customPropertyDefinition.findMany({
      where: {
        organizationId,
        entityType,
        isActive: true,
      },
      orderBy: [
        { groupName: 'asc' },
        { displayOrder: 'asc' },
        { name: 'asc' },
      ],
    });
  }

  async findAll(organizationId: string, includeInactive: boolean = false) {
    const where: Prisma.CustomPropertyDefinitionWhereInput = {
      organizationId,
      ...(includeInactive ? {} : { isActive: true }),
    };

    const definitions = await this.prisma.customPropertyDefinition.findMany({
      where,
      orderBy: [
        { entityType: 'asc' },
        { groupName: 'asc' },
        { displayOrder: 'asc' },
      ],
    });

    // Group by entity type
    const grouped = definitions.reduce((acc, def) => {
      const key = def.entityType;
      if (!acc[key]) acc[key] = [];
      acc[key].push(def);
      return acc;
    }, {} as Record<string, typeof definitions>);

    return {
      data: definitions,
      grouped,
    };
  }

  async update(
    organizationId: string,
    id: string,
    dto: UpdateCustomPropertyDto,
  ) {
    const existing = await this.findById(organizationId, id);

    // Cannot change dataType if property has been used
    // (Future: check for existing values)

    return this.prisma.customPropertyDefinition.update({
      where: { id },
      data: {
        ...(dto.name && { name: dto.name }),
        ...(dto.description !== undefined && { description: dto.description }),
        ...(dto.isRequired !== undefined && { isRequired: dto.isRequired }),
        ...(dto.defaultValue !== undefined && { defaultValue: dto.defaultValue as Prisma.JsonValue }),
        ...(dto.options && { options: dto.options as unknown as Prisma.JsonValue }),
        ...(dto.validationRules !== undefined && { validationRules: dto.validationRules as unknown as Prisma.JsonValue }),
        ...(dto.displayOrder !== undefined && { displayOrder: dto.displayOrder }),
        ...(dto.groupName !== undefined && { groupName: dto.groupName }),
        ...(dto.isVisible !== undefined && { isVisible: dto.isVisible }),
        ...(dto.helpText !== undefined && { helpText: dto.helpText }),
        ...(dto.placeholder !== undefined && { placeholder: dto.placeholder }),
        ...(dto.width !== undefined && { width: dto.width }),
        ...(dto.isActive !== undefined && { isActive: dto.isActive }),
      },
    });
  }

  async delete(organizationId: string, id: string) {
    await this.findById(organizationId, id);

    // Soft delete by deactivating
    return this.prisma.customPropertyDefinition.update({
      where: { id },
      data: { isActive: false },
    });
  }

  async reorder(
    organizationId: string,
    entityType: CustomPropertyEntityType,
    propertyOrders: { id: string; displayOrder: number }[],
  ) {
    await this.prisma.$transaction(
      propertyOrders.map(({ id, displayOrder }) =>
        this.prisma.customPropertyDefinition.updateMany({
          where: { id, organizationId, entityType },
          data: { displayOrder },
        })
      )
    );
  }

  // Value validation
  async validateValues(
    organizationId: string,
    entityType: CustomPropertyEntityType,
    values: Record<string, unknown>,
  ): Promise<ValidationResult> {
    const definitions = await this.findByEntityType(organizationId, entityType);
    const errors: { key: string; message: string }[] = [];
    const sanitized: Record<string, unknown> = {};

    for (const def of definitions) {
      const value = values[def.key];

      // Check required
      if (def.isRequired && (value === undefined || value === null || value === '')) {
        errors.push({ key: def.key, message: `${def.name} is required` });
        continue;
      }

      // Skip if no value and not required
      if (value === undefined || value === null || value === '') {
        if (def.defaultValue !== null) {
          sanitized[def.key] = def.defaultValue;
        }
        continue;
      }

      // Type-specific validation
      const validation = this.validateValue(def.dataType, value, def.validationRules, def.options);
      if (validation.error) {
        errors.push({ key: def.key, message: validation.error });
      } else {
        sanitized[def.key] = validation.value;
      }
    }

    // Warn about unknown keys (but don't fail)
    const knownKeys = new Set(definitions.map(d => d.key));
    for (const key of Object.keys(values)) {
      if (!knownKeys.has(key) && values[key] !== undefined) {
        // Keep unknown values but don't validate them
        sanitized[key] = values[key];
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      sanitized,
    };
  }

  // Get default values for a new entity
  async getDefaultValues(
    organizationId: string,
    entityType: CustomPropertyEntityType,
  ): Promise<Record<string, unknown>> {
    const definitions = await this.findByEntityType(organizationId, entityType);
    const defaults: Record<string, unknown> = {};

    for (const def of definitions) {
      if (def.defaultValue !== null) {
        defaults[def.key] = def.defaultValue;
      }
    }

    return defaults;
  }

  private validateValue(
    dataType: PropertyDataType,
    value: unknown,
    rules: unknown,
    options: unknown,
  ): { value?: unknown; error?: string } {
    const validationRules = rules as ValidationRules | null;
    const selectOptions = options as SelectOption[] | null;

    switch (dataType) {
      case PropertyDataType.TEXT:
        return this.validateText(value, validationRules);

      case PropertyDataType.NUMBER:
        return this.validateNumber(value, validationRules);

      case PropertyDataType.DATE:
      case PropertyDataType.DATETIME:
        return this.validateDate(value, validationRules);

      case PropertyDataType.SELECT:
        return this.validateSelect(value, selectOptions);

      case PropertyDataType.MULTI_SELECT:
        return this.validateMultiSelect(value, selectOptions);

      case PropertyDataType.BOOLEAN:
        return this.validateBoolean(value);

      case PropertyDataType.URL:
        return this.validateUrl(value);

      case PropertyDataType.EMAIL:
        return this.validateEmail(value);

      case PropertyDataType.PHONE:
        return this.validatePhone(value);

      default:
        return { value };
    }
  }

  private validateText(value: unknown, rules: ValidationRules | null): { value?: string; error?: string } {
    if (typeof value !== 'string') {
      return { error: 'Must be a text value' };
    }

    const textRules = rules as { minLength?: number; maxLength?: number; pattern?: string } | null;

    if (textRules?.minLength && value.length < textRules.minLength) {
      return { error: `Must be at least ${textRules.minLength} characters` };
    }

    if (textRules?.maxLength && value.length > textRules.maxLength) {
      return { error: `Must be at most ${textRules.maxLength} characters` };
    }

    if (textRules?.pattern) {
      try {
        const regex = new RegExp(textRules.pattern);
        if (!regex.test(value)) {
          return { error: 'Does not match required format' };
        }
      } catch {
        // Invalid regex, skip pattern validation
      }
    }

    return { value };
  }

  private validateNumber(value: unknown, rules: ValidationRules | null): { value?: number; error?: string } {
    const num = typeof value === 'string' ? parseFloat(value) : value;

    if (typeof num !== 'number' || isNaN(num)) {
      return { error: 'Must be a number' };
    }

    const numRules = rules as { min?: number; max?: number; decimals?: number } | null;

    if (numRules?.min !== undefined && num < numRules.min) {
      return { error: `Must be at least ${numRules.min}` };
    }

    if (numRules?.max !== undefined && num > numRules.max) {
      return { error: `Must be at most ${numRules.max}` };
    }

    if (numRules?.decimals !== undefined) {
      const rounded = parseFloat(num.toFixed(numRules.decimals));
      return { value: rounded };
    }

    return { value: num };
  }

  private validateDate(value: unknown, rules: ValidationRules | null): { value?: string; error?: string } {
    if (typeof value !== 'string') {
      return { error: 'Must be a date string' };
    }

    const date = new Date(value);
    if (isNaN(date.getTime())) {
      return { error: 'Invalid date format' };
    }

    const dateRules = rules as { minDate?: string; maxDate?: string; allowFuture?: boolean; allowPast?: boolean } | null;

    if (dateRules?.minDate) {
      const min = new Date(dateRules.minDate);
      if (date < min) {
        return { error: `Date must be on or after ${dateRules.minDate}` };
      }
    }

    if (dateRules?.maxDate) {
      const max = new Date(dateRules.maxDate);
      if (date > max) {
        return { error: `Date must be on or before ${dateRules.maxDate}` };
      }
    }

    if (dateRules?.allowFuture === false && date > new Date()) {
      return { error: 'Future dates are not allowed' };
    }

    if (dateRules?.allowPast === false && date < new Date()) {
      return { error: 'Past dates are not allowed' };
    }

    return { value: date.toISOString() };
  }

  private validateSelect(value: unknown, options: SelectOption[] | null): { value?: string; error?: string } {
    if (typeof value !== 'string') {
      return { error: 'Must be a string value' };
    }

    if (options && !options.some(o => o.value === value)) {
      return { error: 'Invalid option selected' };
    }

    return { value };
  }

  private validateMultiSelect(value: unknown, options: SelectOption[] | null): { value?: string[]; error?: string } {
    if (!Array.isArray(value)) {
      return { error: 'Must be an array of values' };
    }

    const stringValues = value.filter((v): v is string => typeof v === 'string');

    if (options) {
      const validValues = new Set(options.map(o => o.value));
      const invalid = stringValues.filter(v => !validValues.has(v));
      if (invalid.length > 0) {
        return { error: `Invalid options: ${invalid.join(', ')}` };
      }
    }

    return { value: stringValues };
  }

  private validateBoolean(value: unknown): { value?: boolean; error?: string } {
    if (typeof value === 'boolean') {
      return { value };
    }
    if (value === 'true' || value === '1') {
      return { value: true };
    }
    if (value === 'false' || value === '0') {
      return { value: false };
    }
    return { error: 'Must be a boolean value' };
  }

  private validateUrl(value: unknown): { value?: string; error?: string } {
    if (typeof value !== 'string') {
      return { error: 'Must be a URL string' };
    }

    try {
      new URL(value);
      return { value };
    } catch {
      return { error: 'Invalid URL format' };
    }
  }

  private validateEmail(value: unknown): { value?: string; error?: string } {
    if (typeof value !== 'string') {
      return { error: 'Must be an email string' };
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(value)) {
      return { error: 'Invalid email format' };
    }

    return { value: value.toLowerCase() };
  }

  private validatePhone(value: unknown): { value?: string; error?: string } {
    if (typeof value !== 'string') {
      return { error: 'Must be a phone number string' };
    }

    // Basic validation - allow digits, spaces, dashes, parens, plus
    const cleanPhone = value.replace(/[\s\-\(\)\.]/g, '');
    if (!/^\+?\d{7,15}$/.test(cleanPhone)) {
      return { error: 'Invalid phone number format' };
    }

    return { value };
  }
}
```

Create index file: `apps/backend/src/modules/custom-properties/index.ts`
```typescript
export * from './custom-properties.service';
export * from './dto/custom-property.dto';
```
  </action>
  <verify>TypeScript compiles without errors. Service handles definition CRUD and value validation.</verify>
  <done>CustomPropertiesService provides property definition management with comprehensive value validation.</done>
</task>

<task type="auto">
  <name>Task 3: Create CustomProperties Controller and Module</name>
  <files>
    apps/backend/src/modules/custom-properties/custom-properties.controller.ts
    apps/backend/src/modules/custom-properties/custom-properties.module.ts
    apps/backend/src/app.module.ts
  </files>
  <action>
**custom-properties.controller.ts:**
```typescript
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
  ParseUUIDPipe,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { CurrentUser } from '../auth/decorators/current-user.decorator';
import { UserRole, CustomPropertyEntityType } from '@prisma/client';
import { CustomPropertiesService } from './custom-properties.service';
import {
  CreateCustomPropertyDto,
  UpdateCustomPropertyDto,
} from './dto/custom-property.dto';

interface AuthUser {
  id: string;
  organizationId: string;
  role: UserRole;
}

@Controller('api/v1/custom-properties')
@UseGuards(JwtAuthGuard, RolesGuard)
export class CustomPropertiesController {
  constructor(private readonly customPropertiesService: CustomPropertiesService) {}

  @Post()
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async create(
    @CurrentUser() user: AuthUser,
    @Body() dto: CreateCustomPropertyDto,
  ) {
    return this.customPropertiesService.create(user.organizationId, user.id, dto);
  }

  @Get()
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async findAll(
    @CurrentUser() user: AuthUser,
    @Query('includeInactive') includeInactive?: string,
  ) {
    return this.customPropertiesService.findAll(
      user.organizationId,
      includeInactive === 'true',
    );
  }

  @Get('by-entity/:entityType')
  async findByEntityType(
    @CurrentUser() user: AuthUser,
    @Param('entityType') entityType: CustomPropertyEntityType,
  ) {
    return this.customPropertiesService.findByEntityType(user.organizationId, entityType);
  }

  @Get('defaults/:entityType')
  async getDefaults(
    @CurrentUser() user: AuthUser,
    @Param('entityType') entityType: CustomPropertyEntityType,
  ) {
    return this.customPropertiesService.getDefaultValues(user.organizationId, entityType);
  }

  @Get(':id')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async findOne(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    return this.customPropertiesService.findById(user.organizationId, id);
  }

  @Put(':id')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async update(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
    @Body() dto: UpdateCustomPropertyDto,
  ) {
    return this.customPropertiesService.update(user.organizationId, id, dto);
  }

  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async delete(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    await this.customPropertiesService.delete(user.organizationId, id);
  }

  @Put('reorder/:entityType')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async reorder(
    @CurrentUser() user: AuthUser,
    @Param('entityType') entityType: CustomPropertyEntityType,
    @Body() propertyOrders: { id: string; displayOrder: number }[],
  ) {
    await this.customPropertiesService.reorder(user.organizationId, entityType, propertyOrders);
    return { success: true };
  }

  @Post('validate/:entityType')
  async validate(
    @CurrentUser() user: AuthUser,
    @Param('entityType') entityType: CustomPropertyEntityType,
    @Body() values: Record<string, unknown>,
  ) {
    return this.customPropertiesService.validateValues(user.organizationId, entityType, values);
  }
}
```

**custom-properties.module.ts:**
```typescript
import { Module } from '@nestjs/common';
import { PrismaModule } from '../../prisma/prisma.module';
import { CustomPropertiesService } from './custom-properties.service';
import { CustomPropertiesController } from './custom-properties.controller';

@Module({
  imports: [PrismaModule],
  controllers: [CustomPropertiesController],
  providers: [CustomPropertiesService],
  exports: [CustomPropertiesService],
})
export class CustomPropertiesModule {}
```

**Update app.module.ts** to import CustomPropertiesModule.
  </action>
  <verify>
Run `cd apps/backend && npm run build` - compiles successfully.
Endpoints /api/v1/custom-properties accessible.
POST /api/v1/custom-properties/validate/:entityType validates values against definitions.
  </verify>
  <done>CustomProperties endpoints support definition management and value validation.</done>
</task>

</tasks>

<verification>
- [ ] `npx prisma validate` passes
- [ ] `npm run build` in apps/backend succeeds
- [ ] CustomPropertyDefinition model has entityType and dataType
- [ ] Validation supports TEXT, NUMBER, DATE, SELECT, MULTI_SELECT, BOOLEAN, URL, EMAIL, PHONE
- [ ] Options stored for SELECT/MULTI_SELECT types
- [ ] Validation endpoint returns sanitized values and errors
</verification>

<success_criteria>
1. CustomPropertyDefinition Prisma model exists with data type support
2. Property definitions grouped by entity type (CASE, INVESTIGATION, PERSON, RIU)
3. Comprehensive value validation for all data types
4. Default values and required field support
5. Reordering support for display order customization
</success_criteria>

<output>
After completion, create `.planning/phases/06-case-management/06-05-SUMMARY.md`
</output>
