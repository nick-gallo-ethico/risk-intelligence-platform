---
phase: 06-case-management
plan: 08
type: execute
wave: 2
depends_on: ["06-03"]
files_modified:
  - apps/backend/src/modules/remediation/remediation-notification.service.ts
  - apps/backend/src/modules/remediation/handlers/remediation-event.handler.ts
  - apps/backend/src/modules/remediation/remediation.module.ts
  - apps/backend/src/modules/jobs/processors/remediation.processor.ts
autonomous: true

must_haves:
  truths:
    - "External contacts receive email notifications for assigned steps"
    - "Pre-due reminders sent at configurable intervals"
    - "Overdue escalation notifies compliance officers"
    - "Notification events integrate with job queue"
  artifacts:
    - path: "apps/backend/src/modules/remediation/remediation-notification.service.ts"
      provides: "Notification scheduling and sending"
      exports: ["RemediationNotificationService"]
    - path: "apps/backend/src/modules/remediation/handlers/remediation-event.handler.ts"
      provides: "Event-driven notification triggers"
      exports: ["RemediationEventHandler"]
  key_links:
    - from: "remediation-event.handler.ts"
      to: "remediation-notification.service.ts"
      via: "DI injection"
      pattern: "RemediationNotificationService"
---

<objective>
Create notification service and event handlers for remediation step assignments and reminders.

Purpose: External assignees need email notifications since they don't have system access. Internal users need reminders for due dates and escalations for overdue items.

Output: Notification service, event handlers, job processor for scheduled reminders
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/06-case-management/06-CONTEXT.md
@.planning/phases/06-case-management/06-03-SUMMARY.md
@apps/backend/src/modules/remediation/remediation.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RemediationNotificationService</name>
  <files>apps/backend/src/modules/remediation/remediation-notification.service.ts</files>
  <action>
**remediation-notification.service.ts:**
```typescript
import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { InjectQueue } from '@nestjs/bullmq';
import { Queue } from 'bullmq';
import { StepStatus } from '@prisma/client';

export interface StepNotificationData {
  organizationId: string;
  stepId: string;
  planId: string;
  caseId: string;
  caseReferenceNumber?: string;
  stepTitle: string;
  planTitle: string;
  dueDate?: Date;
  assigneeEmail?: string;
  assigneeName?: string;
  assigneeUserId?: string;
}

export interface ReminderConfig {
  preDueReminders: number[];  // Days before due date [3, 1]
  overdueReminders: number[]; // Days after due date [3, 7]
  escalationDays: number;     // Days until CO escalation (default 7)
}

const DEFAULT_REMINDER_CONFIG: ReminderConfig = {
  preDueReminders: [3, 1],
  overdueReminders: [3, 7],
  escalationDays: 7,
};

@Injectable()
export class RemediationNotificationService {
  private readonly logger = new Logger(RemediationNotificationService.name);

  constructor(
    private readonly prisma: PrismaService,
    @InjectQueue('email') private readonly emailQueue: Queue,
  ) {}

  // ===== Assignment Notifications =====

  async notifyStepAssigned(data: StepNotificationData) {
    if (data.assigneeEmail) {
      // External contact - send email with step details
      await this.queueExternalAssignmentEmail(data);
    }

    if (data.assigneeUserId) {
      // Internal user - create in-app notification (Phase 7)
      // For now, emit event that will be handled when notifications module exists
      this.logger.log(`Step assigned to user ${data.assigneeUserId}: ${data.stepTitle}`);
    }
  }

  private async queueExternalAssignmentEmail(data: StepNotificationData) {
    await this.emailQueue.add(
      'remediation-assignment',
      {
        to: data.assigneeEmail,
        subject: `Action Required: ${data.stepTitle}`,
        template: 'remediation-step-assigned',
        context: {
          assigneeName: data.assigneeName || 'Team Member',
          stepTitle: data.stepTitle,
          planTitle: data.planTitle,
          caseReference: data.caseReferenceNumber || 'N/A',
          dueDate: data.dueDate?.toLocaleDateString() || 'No due date',
          // Note: No direct link since external contacts don't have accounts
          // They'll need to contact CO to report completion
        },
      },
      {
        attempts: 3,
        backoff: { type: 'exponential', delay: 5000 },
      },
    );

    this.logger.log(`Queued assignment email to ${data.assigneeEmail} for step ${data.stepId}`);
  }

  // ===== Reminder Scheduling =====

  async scheduleReminders(
    stepId: string,
    dueDate: Date,
    config: ReminderConfig = DEFAULT_REMINDER_CONFIG,
  ) {
    const now = new Date();

    // Schedule pre-due reminders
    for (const daysBefore of config.preDueReminders) {
      const reminderDate = new Date(dueDate);
      reminderDate.setDate(reminderDate.getDate() - daysBefore);

      if (reminderDate > now) {
        await this.emailQueue.add(
          'remediation-reminder',
          { stepId, type: 'pre-due', daysBefore },
          {
            delay: reminderDate.getTime() - now.getTime(),
            jobId: `reminder-${stepId}-pre-${daysBefore}`,
            removeOnComplete: true,
          },
        );
      }
    }

    // Schedule overdue reminders
    for (const daysAfter of config.overdueReminders) {
      const reminderDate = new Date(dueDate);
      reminderDate.setDate(reminderDate.getDate() + daysAfter);

      await this.emailQueue.add(
        'remediation-reminder',
        { stepId, type: 'overdue', daysAfter },
        {
          delay: Math.max(0, reminderDate.getTime() - now.getTime()),
          jobId: `reminder-${stepId}-overdue-${daysAfter}`,
          removeOnComplete: true,
        },
      );
    }

    // Schedule escalation
    const escalationDate = new Date(dueDate);
    escalationDate.setDate(escalationDate.getDate() + config.escalationDays);

    await this.emailQueue.add(
      'remediation-escalation',
      { stepId },
      {
        delay: Math.max(0, escalationDate.getTime() - now.getTime()),
        jobId: `escalation-${stepId}`,
        removeOnComplete: true,
      },
    );
  }

  async cancelReminders(stepId: string) {
    // Remove scheduled jobs for this step
    const jobIds = [
      `reminder-${stepId}-pre-3`,
      `reminder-${stepId}-pre-1`,
      `reminder-${stepId}-overdue-3`,
      `reminder-${stepId}-overdue-7`,
      `escalation-${stepId}`,
    ];

    for (const jobId of jobIds) {
      try {
        const job = await this.emailQueue.getJob(jobId);
        if (job) {
          await job.remove();
        }
      } catch (error) {
        // Job may not exist - ignore
      }
    }
  }

  // ===== Reminder Processing =====

  async processReminder(stepId: string, type: 'pre-due' | 'overdue', days: number) {
    const step = await this.prisma.remediationStep.findUnique({
      where: { id: stepId },
      include: {
        plan: {
          include: {
            case: { select: { referenceNumber: true } },
          },
        },
      },
    });

    if (!step) {
      this.logger.warn(`Step ${stepId} not found for reminder`);
      return;
    }

    // Skip if already completed
    if (step.status === StepStatus.COMPLETED || step.status === StepStatus.SKIPPED) {
      this.logger.log(`Skipping reminder for completed step ${stepId}`);
      return;
    }

    // Update reminder timestamp
    await this.prisma.remediationStep.update({
      where: { id: stepId },
      data: { reminderSentAt: new Date() },
    });

    // Send reminder
    if (step.assigneeEmail) {
      await this.emailQueue.add(
        'send-email',
        {
          to: step.assigneeEmail,
          subject: type === 'pre-due'
            ? `Reminder: ${step.title} due in ${days} day(s)`
            : `Overdue: ${step.title} was due ${days} day(s) ago`,
          template: 'remediation-reminder',
          context: {
            assigneeName: step.assigneeName || 'Team Member',
            stepTitle: step.title,
            planTitle: step.plan.title,
            caseReference: step.plan.case.referenceNumber,
            dueDate: step.dueDate?.toLocaleDateString(),
            isOverdue: type === 'overdue',
            days,
          },
        },
      );
    }

    if (step.assigneeUserId) {
      // Queue in-app notification (Phase 7)
      this.logger.log(`Would send in-app reminder to user ${step.assigneeUserId}`);
    }
  }

  async processEscalation(stepId: string) {
    const step = await this.prisma.remediationStep.findUnique({
      where: { id: stepId },
      include: {
        plan: {
          include: {
            case: { select: { referenceNumber: true, organizationId: true } },
          },
        },
      },
    });

    if (!step || step.status === StepStatus.COMPLETED || step.status === StepStatus.SKIPPED) {
      return;
    }

    // Update escalation timestamp
    await this.prisma.remediationStep.update({
      where: { id: stepId },
      data: { escalatedAt: new Date() },
    });

    // Find compliance officers to notify
    const complianceOfficers = await this.prisma.user.findMany({
      where: {
        organizationId: step.organizationId,
        role: 'COMPLIANCE_OFFICER',
        isActive: true,
      },
      select: { email: true, firstName: true },
    });

    for (const co of complianceOfficers) {
      await this.emailQueue.add(
        'send-email',
        {
          to: co.email,
          subject: `Escalation: Overdue remediation step - ${step.title}`,
          template: 'remediation-escalation',
          context: {
            coName: co.firstName,
            stepTitle: step.title,
            planTitle: step.plan.title,
            caseReference: step.plan.case.referenceNumber,
            assigneeName: step.assigneeName || step.assigneeEmail || 'Unassigned',
            dueDate: step.dueDate?.toLocaleDateString(),
            daysOverdue: step.dueDate
              ? Math.floor((Date.now() - step.dueDate.getTime()) / (1000 * 60 * 60 * 24))
              : 'Unknown',
          },
        },
      );
    }

    this.logger.log(`Escalated step ${stepId} to ${complianceOfficers.length} compliance officers`);
  }

  // ===== Bulk Operations =====

  async checkOverdueSteps(organizationId?: string) {
    const where = {
      status: StepStatus.PENDING,
      dueDate: { lt: new Date() },
      escalatedAt: null,  // Not yet escalated
      ...(organizationId && { organizationId }),
    };

    const overdueSteps = await this.prisma.remediationStep.findMany({
      where,
      select: { id: true },
    });

    for (const step of overdueSteps) {
      await this.processEscalation(step.id);
    }

    return overdueSteps.length;
  }
}
```
  </action>
  <verify>TypeScript compiles. Service handles notification scheduling and processing.</verify>
  <done>RemediationNotificationService provides assignment and reminder notifications.</done>
</task>

<task type="auto">
  <name>Task 2: Create Event Handler for Remediation Events</name>
  <files>
    apps/backend/src/modules/remediation/handlers/remediation-event.handler.ts
    apps/backend/src/modules/remediation/remediation.module.ts
  </files>
  <action>
Create directory: `apps/backend/src/modules/remediation/handlers/`

**handlers/remediation-event.handler.ts:**
```typescript
import { Injectable, Logger } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';
import { PrismaService } from '../../../prisma/prisma.service';
import { RemediationNotificationService, StepNotificationData } from '../remediation-notification.service';

interface RemediationStepEvent {
  organizationId: string;
  stepId: string;
  planId: string;
  userId: string;
  requiresApproval?: boolean;
}

interface RemediationPlanEvent {
  organizationId: string;
  planId: string;
  caseId: string;
  userId: string;
}

@Injectable()
export class RemediationEventHandler {
  private readonly logger = new Logger(RemediationEventHandler.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly notificationService: RemediationNotificationService,
  ) {}

  @OnEvent('remediation.step.created')
  async handleStepCreated(event: RemediationStepEvent) {
    this.logger.log(`Handling step created: ${event.stepId}`);

    const step = await this.prisma.remediationStep.findUnique({
      where: { id: event.stepId },
      include: {
        plan: {
          include: {
            case: { select: { id: true, referenceNumber: true } },
          },
        },
      },
    });

    if (!step) return;

    // Notify assignee
    if (step.assigneeEmail || step.assigneeUserId) {
      const notificationData: StepNotificationData = {
        organizationId: event.organizationId,
        stepId: step.id,
        planId: step.planId,
        caseId: step.plan.caseId,
        caseReferenceNumber: step.plan.case.referenceNumber,
        stepTitle: step.title,
        planTitle: step.plan.title,
        dueDate: step.dueDate || undefined,
        assigneeEmail: step.assigneeEmail || undefined,
        assigneeName: step.assigneeName || undefined,
        assigneeUserId: step.assigneeUserId || undefined,
      };

      await this.notificationService.notifyStepAssigned(notificationData);
    }

    // Schedule reminders if due date set
    if (step.dueDate) {
      await this.notificationService.scheduleReminders(step.id, step.dueDate);
    }
  }

  @OnEvent('remediation.step.completed')
  async handleStepCompleted(event: RemediationStepEvent) {
    this.logger.log(`Handling step completed: ${event.stepId}`);

    // Cancel pending reminders
    await this.notificationService.cancelReminders(event.stepId);

    // If requires approval, notify compliance officers
    if (event.requiresApproval) {
      const step = await this.prisma.remediationStep.findUnique({
        where: { id: event.stepId },
        include: {
          plan: {
            include: {
              case: { select: { referenceNumber: true } },
            },
          },
        },
      });

      if (step) {
        // Queue notification to CO for approval (Phase 7)
        this.logger.log(`Step ${event.stepId} completed and awaiting CO approval`);
      }
    }
  }

  @OnEvent('remediation.step.approved')
  async handleStepApproved(event: RemediationStepEvent) {
    this.logger.log(`Handling step approved: ${event.stepId}`);

    // Notify assignee of approval
    const step = await this.prisma.remediationStep.findUnique({
      where: { id: event.stepId },
    });

    if (step?.assigneeEmail) {
      // Queue approval confirmation email (Phase 7)
      this.logger.log(`Would notify ${step.assigneeEmail} of approval`);
    }
  }

  @OnEvent('remediation.plan.created')
  async handlePlanCreated(event: RemediationPlanEvent) {
    this.logger.log(`Handling plan created: ${event.planId}`);
    // Could notify case owner, log to audit, etc.
  }

  @OnEvent('remediation.plan.completed')
  async handlePlanCompleted(event: RemediationPlanEvent) {
    this.logger.log(`Handling plan completed: ${event.planId}`);

    // Notify case owner that remediation is complete
    const plan = await this.prisma.remediationPlan.findUnique({
      where: { id: event.planId },
      include: {
        case: { select: { referenceNumber: true } },
      },
    });

    if (plan) {
      this.logger.log(`Remediation plan for case ${plan.case.referenceNumber} completed`);
      // Queue completion notification to case owner (Phase 7)
    }
  }
}
```

**Update remediation.module.ts:**
```typescript
import { Module, forwardRef } from '@nestjs/common';
import { BullModule } from '@nestjs/bullmq';
import { PrismaModule } from '../../prisma/prisma.module';
import { RemediationService } from './remediation.service';
import { RemediationStepService } from './remediation-step.service';
import { RemediationNotificationService } from './remediation-notification.service';
import { RemediationEventHandler } from './handlers/remediation-event.handler';
import { RemediationController } from './remediation.controller';

@Module({
  imports: [
    PrismaModule,
    BullModule.registerQueue({ name: 'email' }),
  ],
  controllers: [RemediationController],
  providers: [
    RemediationService,
    RemediationStepService,
    RemediationNotificationService,
    RemediationEventHandler,
  ],
  exports: [RemediationService, RemediationStepService, RemediationNotificationService],
})
export class RemediationModule {}
```
  </action>
  <verify>TypeScript compiles. Event handler triggers notifications on remediation events.</verify>
  <done>RemediationEventHandler wires events to notification service.</done>
</task>

<task type="auto">
  <name>Task 3: Create Remediation Job Processor</name>
  <files>apps/backend/src/modules/jobs/processors/remediation.processor.ts</files>
  <action>
**remediation.processor.ts:**
```typescript
import { Processor, WorkerHost } from '@nestjs/bullmq';
import { Logger } from '@nestjs/common';
import { Job } from 'bullmq';
import { RemediationNotificationService } from '../../remediation/remediation-notification.service';

interface ReminderJobData {
  stepId: string;
  type: 'pre-due' | 'overdue';
  daysBefore?: number;
  daysAfter?: number;
}

interface EscalationJobData {
  stepId: string;
}

@Processor('email')
export class RemediationProcessor extends WorkerHost {
  private readonly logger = new Logger(RemediationProcessor.name);

  constructor(
    private readonly notificationService: RemediationNotificationService,
  ) {
    super();
  }

  async process(job: Job<ReminderJobData | EscalationJobData>): Promise<void> {
    switch (job.name) {
      case 'remediation-reminder':
        await this.processReminder(job.data as ReminderJobData);
        break;

      case 'remediation-escalation':
        await this.processEscalation(job.data as EscalationJobData);
        break;

      case 'remediation-assignment':
        // Handled by email processor - this is just the job data
        this.logger.log(`Assignment notification job: ${JSON.stringify(job.data)}`);
        break;

      default:
        // Pass to next processor
        break;
    }
  }

  private async processReminder(data: ReminderJobData) {
    this.logger.log(`Processing ${data.type} reminder for step ${data.stepId}`);

    const days = data.type === 'pre-due' ? data.daysBefore! : data.daysAfter!;
    await this.notificationService.processReminder(data.stepId, data.type, days);
  }

  private async processEscalation(data: EscalationJobData) {
    this.logger.log(`Processing escalation for step ${data.stepId}`);
    await this.notificationService.processEscalation(data.stepId);
  }
}
```

**Update jobs module to register processor** (if not using auto-discovery):
- Import RemediationProcessor
- Ensure it's registered with the email queue
  </action>
  <verify>
Run `cd apps/backend && npm run build` - compiles successfully.
Job processor handles remediation-reminder and remediation-escalation jobs.
  </verify>
  <done>RemediationProcessor handles scheduled reminder and escalation jobs.</done>
</task>

</tasks>

<verification>
- [ ] `npm run build` in apps/backend succeeds
- [ ] Notification service queues emails for external contacts
- [ ] Reminders scheduled based on due date
- [ ] Escalation notifies compliance officers after configured days
- [ ] Completed steps cancel pending reminders
</verification>

<success_criteria>
1. External contacts receive assignment emails via queue
2. Pre-due reminders scheduled at 3 days and 1 day before
3. Overdue reminders at 3 and 7 days after due date
4. Escalation to compliance officers at configurable threshold
5. Events trigger notification scheduling/cancellation
</success_criteria>

<output>
After completion, create `.planning/phases/06-case-management/06-08-SUMMARY.md`
</output>
