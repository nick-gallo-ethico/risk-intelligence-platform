---
phase: 06-case-management
plan: 06
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/investigations/templates/template-assignment.service.ts
  - apps/backend/src/modules/investigations/templates/template.controller.ts
  - apps/backend/src/modules/investigations/investigations.module.ts
autonomous: true

must_haves:
  truths:
    - "CategoryTemplateMapping links categories to required/recommended templates"
    - "Templates auto-apply when investigation created for mapped category"
    - "Investigators can override or swap templates"
    - "Mapping is configurable by compliance officers"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "CategoryTemplateMapping model"
      contains: "model CategoryTemplateMapping"
    - path: "apps/backend/src/modules/investigations/templates/template-assignment.service.ts"
      provides: "Template assignment logic"
      exports: ["TemplateAssignmentService"]
  key_links:
    - from: "template-assignment.service.ts"
      to: "template.service.ts"
      via: "DI injection"
      pattern: "InvestigationTemplateService"
---

<objective>
Create the CategoryTemplateMapping model and service for auto-assigning investigation templates based on case category.

Purpose: Different incident types require different investigation approaches. Category-to-template mapping ensures consistent process without manual template selection.

Output: Prisma model, assignment service, updated controller endpoints
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/06-case-management/06-CONTEXT.md
@.planning/phases/06-case-management/06-01-SUMMARY.md
@apps/backend/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CategoryTemplateMapping model to Prisma schema</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
Add the following to schema.prisma:

1. TemplateRequirement enum:
```prisma
enum TemplateRequirement {
  REQUIRED     // Investigation cannot proceed without template
  RECOMMENDED  // Auto-applies but can be removed
  OPTIONAL     // Investigator chooses

  @@map("template_requirement")
}
```

2. CategoryTemplateMapping model:
```prisma
model CategoryTemplateMapping {
  id              String   @id @default(uuid())
  organizationId  String   @map("organization_id")

  // Category link
  categoryId      String   @map("category_id")

  // Template link
  templateId      String   @map("template_id")

  // Requirement level
  requirement     TemplateRequirement @default(RECOMMENDED)

  // Priority (for multiple mappings per category)
  priority        Int      @default(0)

  isActive        Boolean  @default(true) @map("is_active")

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  createdById     String   @map("created_by_id")

  // Relations
  organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  category        Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  template        InvestigationTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  @@unique([organizationId, categoryId, templateId])
  @@index([organizationId, categoryId])
  @@map("category_template_mappings")
}
```

3. Add relations:
- Organization: `categoryTemplateMappings CategoryTemplateMapping[]`
- Category: `templateMappings CategoryTemplateMapping[]`
- InvestigationTemplate: `categoryMappings CategoryTemplateMapping[]`

Run: `cd apps/backend && npx prisma db push`
  </action>
  <verify>npx prisma validate passes. Database has category_template_mappings table.</verify>
  <done>CategoryTemplateMapping model exists with requirement level and priority.</done>
</task>

<task type="auto">
  <name>Task 2: Create TemplateAssignmentService</name>
  <files>
    apps/backend/src/modules/investigations/templates/template-assignment.service.ts
    apps/backend/src/modules/investigations/templates/dto/template.dto.ts
  </files>
  <action>
**Add to dto/template.dto.ts:**
```typescript
import { TemplateRequirement } from '@prisma/client';

export class CreateCategoryMappingDto {
  @IsUUID()
  categoryId: string;

  @IsUUID()
  templateId: string;

  @IsEnum(TemplateRequirement)
  @IsOptional()
  requirement?: TemplateRequirement;

  @IsInt()
  @Min(0)
  @IsOptional()
  priority?: number;
}

export class UpdateCategoryMappingDto {
  @IsEnum(TemplateRequirement)
  @IsOptional()
  requirement?: TemplateRequirement;

  @IsInt()
  @Min(0)
  @IsOptional()
  priority?: number;

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
}

export interface TemplateRecommendation {
  template: InvestigationTemplate;
  requirement: TemplateRequirement;
  reason: string;
}
```

**template-assignment.service.ts:**
```typescript
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { TemplateRequirement } from '@prisma/client';
import { InvestigationTemplateService } from './template.service';
import { CreateCategoryMappingDto, UpdateCategoryMappingDto, TemplateRecommendation } from './dto/template.dto';

@Injectable()
export class TemplateAssignmentService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly templateService: InvestigationTemplateService,
  ) {}

  // ===== Category Mapping CRUD =====

  async createMapping(
    organizationId: string,
    userId: string,
    dto: CreateCategoryMappingDto,
  ) {
    // Verify category exists
    const category = await this.prisma.category.findFirst({
      where: { id: dto.categoryId, organizationId },
    });
    if (!category) {
      throw new NotFoundException('Category not found');
    }

    // Verify template exists
    await this.templateService.findById(organizationId, dto.templateId);

    return this.prisma.categoryTemplateMapping.create({
      data: {
        organizationId,
        categoryId: dto.categoryId,
        templateId: dto.templateId,
        requirement: dto.requirement || TemplateRequirement.RECOMMENDED,
        priority: dto.priority || 0,
        createdById: userId,
      },
      include: {
        category: { select: { id: true, name: true } },
        template: { select: { id: true, name: true, tier: true } },
      },
    });
  }

  async findMappingsByCategory(organizationId: string, categoryId: string) {
    return this.prisma.categoryTemplateMapping.findMany({
      where: {
        organizationId,
        categoryId,
        isActive: true,
      },
      include: {
        template: true,
      },
      orderBy: { priority: 'asc' },
    });
  }

  async findMappingsByTemplate(organizationId: string, templateId: string) {
    return this.prisma.categoryTemplateMapping.findMany({
      where: {
        organizationId,
        templateId,
        isActive: true,
      },
      include: {
        category: { select: { id: true, name: true, path: true } },
      },
    });
  }

  async findAllMappings(organizationId: string) {
    return this.prisma.categoryTemplateMapping.findMany({
      where: { organizationId, isActive: true },
      include: {
        category: { select: { id: true, name: true, path: true } },
        template: { select: { id: true, name: true, tier: true } },
      },
      orderBy: [
        { category: { name: 'asc' } },
        { priority: 'asc' },
      ],
    });
  }

  async updateMapping(
    organizationId: string,
    id: string,
    dto: UpdateCategoryMappingDto,
  ) {
    const existing = await this.prisma.categoryTemplateMapping.findFirst({
      where: { id, organizationId },
    });

    if (!existing) {
      throw new NotFoundException('Mapping not found');
    }

    return this.prisma.categoryTemplateMapping.update({
      where: { id },
      data: {
        ...(dto.requirement && { requirement: dto.requirement }),
        ...(dto.priority !== undefined && { priority: dto.priority }),
        ...(dto.isActive !== undefined && { isActive: dto.isActive }),
      },
    });
  }

  async deleteMapping(organizationId: string, id: string) {
    const existing = await this.prisma.categoryTemplateMapping.findFirst({
      where: { id, organizationId },
    });

    if (!existing) {
      throw new NotFoundException('Mapping not found');
    }

    await this.prisma.categoryTemplateMapping.delete({ where: { id } });
  }

  // ===== Template Recommendation =====

  async getTemplateForCase(
    organizationId: string,
    categoryId: string | null,
  ): Promise<{
    templates: TemplateRecommendation[];
    defaultTemplate: TemplateRecommendation | null;
  }> {
    const recommendations: TemplateRecommendation[] = [];

    // Check category-to-template mappings
    if (categoryId) {
      const mappings = await this.prisma.categoryTemplateMapping.findMany({
        where: {
          organizationId,
          categoryId,
          isActive: true,
        },
        include: { template: true },
        orderBy: { priority: 'asc' },
      });

      for (const mapping of mappings) {
        if (mapping.template.isActive && !mapping.template.isArchived) {
          recommendations.push({
            template: mapping.template,
            requirement: mapping.requirement,
            reason: `Mapped to category`,
          });
        }
      }

      // Check parent category if no direct mapping
      if (recommendations.length === 0) {
        const category = await this.prisma.category.findFirst({
          where: { id: categoryId, organizationId },
          select: { parentCategoryId: true },
        });

        if (category?.parentCategoryId) {
          const parentResult = await this.getTemplateForCase(organizationId, category.parentCategoryId);
          for (const rec of parentResult.templates) {
            recommendations.push({
              ...rec,
              reason: 'Inherited from parent category',
            });
          }
        }
      }
    }

    // Get org default template if no category-specific
    let defaultTemplate: TemplateRecommendation | null = null;
    if (recommendations.length === 0) {
      const orgDefault = await this.prisma.investigationTemplate.findFirst({
        where: {
          organizationId,
          isActive: true,
          isArchived: false,
          isDefault: true,
        },
      });

      if (orgDefault) {
        defaultTemplate = {
          template: orgDefault,
          requirement: TemplateRequirement.OPTIONAL,
          reason: 'Organization default template',
        };
      }
    }

    return {
      templates: recommendations,
      defaultTemplate,
    };
  }

  async getRecommendedTemplate(
    organizationId: string,
    categoryId: string | null,
  ) {
    const { templates, defaultTemplate } = await this.getTemplateForCase(organizationId, categoryId);

    // Return highest priority (first) template if any mappings exist
    if (templates.length > 0) {
      return templates[0];
    }

    // Fall back to default
    return defaultTemplate;
  }

  async isTemplateRequired(
    organizationId: string,
    categoryId: string | null,
  ): Promise<boolean> {
    if (!categoryId) return false;

    const mapping = await this.prisma.categoryTemplateMapping.findFirst({
      where: {
        organizationId,
        categoryId,
        isActive: true,
        requirement: TemplateRequirement.REQUIRED,
      },
    });

    return !!mapping;
  }
}
```

Update index: `apps/backend/src/modules/investigations/templates/index.ts`
```typescript
export * from './template.service';
export * from './template-assignment.service';
export * from './dto/template.dto';
```
  </action>
  <verify>TypeScript compiles. TemplateAssignmentService provides mapping CRUD and recommendation logic.</verify>
  <done>TemplateAssignmentService handles category-template mappings and recommendations.</done>
</task>

<task type="auto">
  <name>Task 3: Add Mapping Endpoints to Controller</name>
  <files>
    apps/backend/src/modules/investigations/templates/template.controller.ts
    apps/backend/src/modules/investigations/investigations.module.ts
  </files>
  <action>
**Add to template.controller.ts:**
```typescript
import { TemplateAssignmentService } from './template-assignment.service';
import { CreateCategoryMappingDto, UpdateCategoryMappingDto } from './dto/template.dto';

// In constructor:
constructor(
  private readonly templateService: InvestigationTemplateService,
  private readonly assignmentService: TemplateAssignmentService,
) {}

// Add new endpoints:

// ===== Category Mappings =====

@Post('mappings')
@Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
async createMapping(
  @CurrentUser() user: AuthUser,
  @Body() dto: CreateCategoryMappingDto,
) {
  return this.assignmentService.createMapping(user.organizationId, user.id, dto);
}

@Get('mappings')
@Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
async findAllMappings(@CurrentUser() user: AuthUser) {
  return this.assignmentService.findAllMappings(user.organizationId);
}

@Get('mappings/by-category/:categoryId')
@Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
async findMappingsByCategory(
  @CurrentUser() user: AuthUser,
  @Param('categoryId', ParseUUIDPipe) categoryId: string,
) {
  return this.assignmentService.findMappingsByCategory(user.organizationId, categoryId);
}

@Get('mappings/by-template/:templateId')
@Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
async findMappingsByTemplate(
  @CurrentUser() user: AuthUser,
  @Param('templateId', ParseUUIDPipe) templateId: string,
) {
  return this.assignmentService.findMappingsByTemplate(user.organizationId, templateId);
}

@Put('mappings/:id')
@Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
async updateMapping(
  @CurrentUser() user: AuthUser,
  @Param('id', ParseUUIDPipe) id: string,
  @Body() dto: UpdateCategoryMappingDto,
) {
  return this.assignmentService.updateMapping(user.organizationId, id, dto);
}

@Delete('mappings/:id')
@HttpCode(HttpStatus.NO_CONTENT)
@Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
async deleteMapping(
  @CurrentUser() user: AuthUser,
  @Param('id', ParseUUIDPipe) id: string,
) {
  await this.assignmentService.deleteMapping(user.organizationId, id);
}

// ===== Recommendations =====

@Get('recommend')
@Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
async getRecommendation(
  @CurrentUser() user: AuthUser,
  @Query('categoryId') categoryId?: string,
) {
  return this.assignmentService.getTemplateForCase(user.organizationId, categoryId || null);
}

@Get('is-required')
@Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
async isRequired(
  @CurrentUser() user: AuthUser,
  @Query('categoryId') categoryId?: string,
) {
  const required = await this.assignmentService.isTemplateRequired(user.organizationId, categoryId || null);
  return { required };
}
```

**Update investigations.module.ts:**
- Import TemplateAssignmentService from './templates/template-assignment.service'
- Add TemplateAssignmentService to providers array
- Export TemplateAssignmentService
  </action>
  <verify>
Run `cd apps/backend && npm run build` - compiles successfully.
GET /api/v1/investigation-templates/mappings returns all mappings.
GET /api/v1/investigation-templates/recommend?categoryId=xxx returns template recommendations.
  </verify>
  <done>Template mapping endpoints enable category-specific template configuration.</done>
</task>

</tasks>

<verification>
- [ ] `npx prisma validate` passes
- [ ] `npm run build` in apps/backend succeeds
- [ ] CategoryTemplateMapping model has requirement level enum
- [ ] Mappings support inheritance from parent categories
- [ ] Recommendation endpoint returns templates with requirement level
- [ ] isRequired endpoint checks for REQUIRED mappings
</verification>

<success_criteria>
1. CategoryTemplateMapping Prisma model exists with requirement levels
2. Mappings auto-inherit from parent categories when no direct mapping
3. Recommendation endpoint returns prioritized templates
4. isRequired check enables frontend validation
5. CRUD endpoints for mapping management
</success_criteria>

<output>
After completion, create `.planning/phases/06-case-management/06-06-SUMMARY.md`
</output>
