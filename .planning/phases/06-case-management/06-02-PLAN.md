---
phase: 06-case-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/investigations/interviews/interview.service.ts
  - apps/backend/src/modules/investigations/interviews/interview.controller.ts
  - apps/backend/src/modules/investigations/interviews/dto/interview.dto.ts
  - apps/backend/src/modules/investigations/investigations.module.ts
autonomous: true

must_haves:
  truths:
    - "InvestigationInterview model exists linking to Investigation"
    - "Interviews can link to Person records or store freeform interviewee names"
    - "Interview templates store required and optional question sets"
    - "Interviews track recording metadata (notes, duration, attachment links)"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "InvestigationInterview and InterviewQuestion models"
      contains: "model InvestigationInterview"
    - path: "apps/backend/src/modules/investigations/interviews/interview.service.ts"
      provides: "Interview CRUD with Person linking"
      exports: ["InvestigationInterviewService"]
  key_links:
    - from: "interview.service.ts"
      to: "prisma"
      via: "PrismaService"
      pattern: "prisma\\.investigationInterview"
---

<objective>
Create the InvestigationInterview model and service for recording structured interviews during investigations with template questions and Person linking.

Purpose: Structured interviews ensure consistent documentation across investigations and support linking interviews to checklist items for evidence tracking.

Output: Prisma models, DTOs, service with CRUD, controller
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-case-management/06-CONTEXT.md
@apps/backend/prisma/schema.prisma
@apps/backend/src/modules/investigations/investigations.module.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add InvestigationInterview model to Prisma schema</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
Add the following to schema.prisma:

1. InterviewStatus enum:
```prisma
enum InterviewStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED

  @@map("interview_status")
}
```

2. IntervieweeType enum:
```prisma
enum IntervieweeType {
  PERSON        // Linked to Person record
  EXTERNAL      // Freeform name (not in system)
  ANONYMOUS     // Anonymous participant

  @@map("interviewee_type")
}
```

3. InvestigationInterview model:
```prisma
model InvestigationInterview {
  id              String   @id @default(uuid())
  organizationId  String   @map("organization_id")
  investigationId String   @map("investigation_id")

  // Interviewee (either link to Person OR freeform)
  intervieweeType   IntervieweeType @map("interviewee_type")
  intervieweePersonId String?       @map("interviewee_person_id")
  intervieweeName   String?         @map("interviewee_name")  // For EXTERNAL type
  intervieweeTitle  String?         @map("interviewee_title")
  intervieweeEmail  String?         @map("interviewee_email")
  intervieweePhone  String?         @map("interviewee_phone")

  // Interview metadata
  status          InterviewStatus @default(SCHEDULED)
  scheduledAt     DateTime?       @map("scheduled_at")
  startedAt       DateTime?       @map("started_at")
  completedAt     DateTime?       @map("completed_at")
  duration        Int?            // Duration in minutes
  location        String?         // Physical location or "Video Call"

  // Interviewer(s)
  conductedById   String   @map("conducted_by_id")
  secondaryInterviewerIds String[] @default([]) @map("secondary_interviewer_ids")

  // Content
  purpose         String?         // Purpose/scope of interview
  notes           String?         @db.Text  // Rich text notes
  summary         String?         // Brief summary
  keyFindings     String?         @map("key_findings")  // Important findings

  // Template Questions (JSON)
  templateId      String?         @map("template_id")  // Reference to interview template
  questions       Json?           // Array of { questionId, question, response, isRequired }

  // Checklist linking (can link to specific checklist item as evidence)
  checklistItemId String?         @map("checklist_item_id")

  // Recording
  hasRecording    Boolean @default(false) @map("has_recording")
  recordingUrl    String?         @map("recording_url")
  transcriptUrl   String?         @map("transcript_url")

  // Consent
  consentObtained Boolean @default(false) @map("consent_obtained")
  consentNotes    String?         @map("consent_notes")

  // Timestamps
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  createdById     String   @map("created_by_id")

  // Relations
  organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  investigation   Investigation @relation(fields: [investigationId], references: [id], onDelete: Cascade)

  @@index([organizationId])
  @@index([organizationId, investigationId])
  @@index([organizationId, intervieweePersonId])
  @@index([organizationId, status])
  @@map("investigation_interviews")
}
```

4. InterviewTemplate model (for reusable question sets):
```prisma
model InterviewTemplate {
  id              String   @id @default(uuid())
  organizationId  String   @map("organization_id")

  name            String
  description     String?
  categoryId      String?  @map("category_id")  // For category-specific templates

  // Questions (JSON array)
  questions       Json     // Array of { id, question, isRequired, guidance, order }

  isActive        Boolean  @default(true) @map("is_active")
  isSystem        Boolean  @default(false) @map("is_system")

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  createdById     String   @map("created_by_id")

  // Relations
  organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([organizationId, name])
  @@index([organizationId])
  @@index([organizationId, categoryId])
  @@map("interview_templates")
}
```

5. Add relations to Organization and Investigation models:
- Organization: `investigationInterviews InvestigationInterview[]` and `interviewTemplates InterviewTemplate[]`
- Investigation: `interviews InvestigationInterview[]`

Run: `cd apps/backend && npx prisma db push`
  </action>
  <verify>npx prisma validate passes. Database has investigation_interviews and interview_templates tables.</verify>
  <done>InvestigationInterview and InterviewTemplate models exist with proper relations.</done>
</task>

<task type="auto">
  <name>Task 2: Create Interview DTOs and Service</name>
  <files>
    apps/backend/src/modules/investigations/interviews/dto/interview.dto.ts
    apps/backend/src/modules/investigations/interviews/interview.service.ts
  </files>
  <action>
Create directory: `apps/backend/src/modules/investigations/interviews/`

**interview.dto.ts:**
```typescript
import { IsString, IsOptional, IsEnum, IsBoolean, IsUUID, IsInt, IsArray, IsDateString, Min } from 'class-validator';
import { Type } from 'class-transformer';
import { InterviewStatus, IntervieweeType } from '@prisma/client';

export interface InterviewQuestion {
  id: string;
  question: string;
  response?: string;
  isRequired: boolean;
  guidance?: string;
  order: number;
}

export class CreateInterviewDto {
  @IsUUID()
  investigationId: string;

  @IsEnum(IntervieweeType)
  intervieweeType: IntervieweeType;

  @IsUUID()
  @IsOptional()
  intervieweePersonId?: string;

  @IsString()
  @IsOptional()
  intervieweeName?: string;

  @IsString()
  @IsOptional()
  intervieweeTitle?: string;

  @IsString()
  @IsOptional()
  intervieweeEmail?: string;

  @IsString()
  @IsOptional()
  intervieweePhone?: string;

  @IsDateString()
  @IsOptional()
  scheduledAt?: string;

  @IsString()
  @IsOptional()
  location?: string;

  @IsString()
  @IsOptional()
  purpose?: string;

  @IsUUID()
  @IsOptional()
  templateId?: string;

  @IsArray()
  @IsOptional()
  questions?: InterviewQuestion[];

  @IsUUID()
  @IsOptional()
  checklistItemId?: string;
}

export class UpdateInterviewDto {
  @IsEnum(InterviewStatus)
  @IsOptional()
  status?: InterviewStatus;

  @IsDateString()
  @IsOptional()
  scheduledAt?: string;

  @IsDateString()
  @IsOptional()
  startedAt?: string;

  @IsDateString()
  @IsOptional()
  completedAt?: string;

  @IsInt()
  @Min(0)
  @IsOptional()
  duration?: number;

  @IsString()
  @IsOptional()
  location?: string;

  @IsString()
  @IsOptional()
  purpose?: string;

  @IsString()
  @IsOptional()
  notes?: string;

  @IsString()
  @IsOptional()
  summary?: string;

  @IsString()
  @IsOptional()
  keyFindings?: string;

  @IsArray()
  @IsOptional()
  questions?: InterviewQuestion[];

  @IsBoolean()
  @IsOptional()
  hasRecording?: boolean;

  @IsString()
  @IsOptional()
  recordingUrl?: string;

  @IsString()
  @IsOptional()
  transcriptUrl?: string;

  @IsBoolean()
  @IsOptional()
  consentObtained?: boolean;

  @IsString()
  @IsOptional()
  consentNotes?: string;

  @IsArray()
  @IsUUID('4', { each: true })
  @IsOptional()
  secondaryInterviewerIds?: string[];
}

export class InterviewQueryDto {
  @IsUUID()
  @IsOptional()
  investigationId?: string;

  @IsEnum(InterviewStatus)
  @IsOptional()
  status?: InterviewStatus;

  @IsUUID()
  @IsOptional()
  intervieweePersonId?: string;

  @IsInt()
  @Min(1)
  @IsOptional()
  @Type(() => Number)
  page?: number = 1;

  @IsInt()
  @Min(1)
  @IsOptional()
  @Type(() => Number)
  limit?: number = 20;
}

// Interview Template DTOs
export class CreateInterviewTemplateDto {
  @IsString()
  name: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsUUID()
  @IsOptional()
  categoryId?: string;

  @IsArray()
  questions: Omit<InterviewQuestion, 'response'>[];
}

export class UpdateInterviewTemplateDto {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsUUID()
  @IsOptional()
  categoryId?: string;

  @IsArray()
  @IsOptional()
  questions?: Omit<InterviewQuestion, 'response'>[];

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
}
```

**interview.service.ts:**
```typescript
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { InterviewStatus, IntervieweeType, Prisma } from '@prisma/client';
import {
  CreateInterviewDto,
  UpdateInterviewDto,
  InterviewQueryDto,
  CreateInterviewTemplateDto,
  UpdateInterviewTemplateDto,
  InterviewQuestion,
} from './dto/interview.dto';

@Injectable()
export class InvestigationInterviewService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  // ===== Interview CRUD =====

  async create(
    organizationId: string,
    userId: string,
    dto: CreateInterviewDto,
  ) {
    // Validate interviewee data
    if (dto.intervieweeType === IntervieweeType.PERSON && !dto.intervieweePersonId) {
      throw new BadRequestException('intervieweePersonId required for PERSON type');
    }
    if (dto.intervieweeType === IntervieweeType.EXTERNAL && !dto.intervieweeName) {
      throw new BadRequestException('intervieweeName required for EXTERNAL type');
    }

    // If template provided, load questions from template
    let questions = dto.questions;
    if (dto.templateId && !questions) {
      const template = await this.prisma.interviewTemplate.findFirst({
        where: { id: dto.templateId, organizationId },
      });
      if (template) {
        questions = template.questions as InterviewQuestion[];
      }
    }

    const interview = await this.prisma.investigationInterview.create({
      data: {
        organizationId,
        investigationId: dto.investigationId,
        intervieweeType: dto.intervieweeType,
        intervieweePersonId: dto.intervieweePersonId,
        intervieweeName: dto.intervieweeName,
        intervieweeTitle: dto.intervieweeTitle,
        intervieweeEmail: dto.intervieweeEmail,
        intervieweePhone: dto.intervieweePhone,
        scheduledAt: dto.scheduledAt ? new Date(dto.scheduledAt) : null,
        location: dto.location,
        purpose: dto.purpose,
        templateId: dto.templateId,
        questions: questions as unknown as Prisma.JsonValue,
        checklistItemId: dto.checklistItemId,
        conductedById: userId,
        createdById: userId,
      },
    });

    this.eventEmitter.emit('investigation.interview.created', {
      organizationId,
      interviewId: interview.id,
      investigationId: dto.investigationId,
      userId,
    });

    return interview;
  }

  async findById(organizationId: string, id: string) {
    const interview = await this.prisma.investigationInterview.findFirst({
      where: { id, organizationId },
      include: {
        investigation: {
          select: { id: true, caseId: true, investigationNumber: true },
        },
      },
    });

    if (!interview) {
      throw new NotFoundException('Interview not found');
    }

    return interview;
  }

  async findByInvestigation(organizationId: string, investigationId: string) {
    return this.prisma.investigationInterview.findMany({
      where: { organizationId, investigationId },
      orderBy: { createdAt: 'desc' },
    });
  }

  async findAll(organizationId: string, query: InterviewQueryDto) {
    const where: Prisma.InvestigationInterviewWhereInput = {
      organizationId,
      ...(query.investigationId && { investigationId: query.investigationId }),
      ...(query.status && { status: query.status }),
      ...(query.intervieweePersonId && { intervieweePersonId: query.intervieweePersonId }),
    };

    const [interviews, total] = await Promise.all([
      this.prisma.investigationInterview.findMany({
        where,
        orderBy: { createdAt: 'desc' },
        skip: ((query.page || 1) - 1) * (query.limit || 20),
        take: query.limit || 20,
        include: {
          investigation: {
            select: { id: true, caseId: true, investigationNumber: true },
          },
        },
      }),
      this.prisma.investigationInterview.count({ where }),
    ]);

    return {
      data: interviews,
      meta: {
        total,
        page: query.page || 1,
        limit: query.limit || 20,
        totalPages: Math.ceil(total / (query.limit || 20)),
      },
    };
  }

  async update(
    organizationId: string,
    id: string,
    userId: string,
    dto: UpdateInterviewDto,
  ) {
    await this.findById(organizationId, id);

    const interview = await this.prisma.investigationInterview.update({
      where: { id },
      data: {
        ...(dto.status && { status: dto.status }),
        ...(dto.scheduledAt && { scheduledAt: new Date(dto.scheduledAt) }),
        ...(dto.startedAt && { startedAt: new Date(dto.startedAt) }),
        ...(dto.completedAt && { completedAt: new Date(dto.completedAt) }),
        ...(dto.duration !== undefined && { duration: dto.duration }),
        ...(dto.location !== undefined && { location: dto.location }),
        ...(dto.purpose !== undefined && { purpose: dto.purpose }),
        ...(dto.notes !== undefined && { notes: dto.notes }),
        ...(dto.summary !== undefined && { summary: dto.summary }),
        ...(dto.keyFindings !== undefined && { keyFindings: dto.keyFindings }),
        ...(dto.questions && { questions: dto.questions as unknown as Prisma.JsonValue }),
        ...(dto.hasRecording !== undefined && { hasRecording: dto.hasRecording }),
        ...(dto.recordingUrl !== undefined && { recordingUrl: dto.recordingUrl }),
        ...(dto.transcriptUrl !== undefined && { transcriptUrl: dto.transcriptUrl }),
        ...(dto.consentObtained !== undefined && { consentObtained: dto.consentObtained }),
        ...(dto.consentNotes !== undefined && { consentNotes: dto.consentNotes }),
        ...(dto.secondaryInterviewerIds && { secondaryInterviewerIds: dto.secondaryInterviewerIds }),
      },
    });

    this.eventEmitter.emit('investigation.interview.updated', {
      organizationId,
      interviewId: id,
      userId,
    });

    return interview;
  }

  async start(organizationId: string, id: string, userId: string) {
    const interview = await this.findById(organizationId, id);

    if (interview.status !== InterviewStatus.SCHEDULED) {
      throw new BadRequestException('Interview must be in SCHEDULED status to start');
    }

    return this.update(organizationId, id, userId, {
      status: InterviewStatus.IN_PROGRESS,
      startedAt: new Date().toISOString(),
    });
  }

  async complete(organizationId: string, id: string, userId: string, summary?: string) {
    const interview = await this.findById(organizationId, id);

    if (interview.status !== InterviewStatus.IN_PROGRESS) {
      throw new BadRequestException('Interview must be in IN_PROGRESS status to complete');
    }

    const startedAt = interview.startedAt ? new Date(interview.startedAt) : new Date();
    const completedAt = new Date();
    const duration = Math.round((completedAt.getTime() - startedAt.getTime()) / 60000);

    return this.update(organizationId, id, userId, {
      status: InterviewStatus.COMPLETED,
      completedAt: completedAt.toISOString(),
      duration,
      summary,
    });
  }

  async cancel(organizationId: string, id: string, userId: string) {
    await this.findById(organizationId, id);

    return this.update(organizationId, id, userId, {
      status: InterviewStatus.CANCELLED,
    });
  }

  async delete(organizationId: string, id: string, userId: string) {
    await this.findById(organizationId, id);

    await this.prisma.investigationInterview.delete({
      where: { id },
    });

    this.eventEmitter.emit('investigation.interview.deleted', {
      organizationId,
      interviewId: id,
      userId,
    });
  }

  // ===== Interview Templates =====

  async createTemplate(
    organizationId: string,
    userId: string,
    dto: CreateInterviewTemplateDto,
  ) {
    return this.prisma.interviewTemplate.create({
      data: {
        organizationId,
        name: dto.name,
        description: dto.description,
        categoryId: dto.categoryId,
        questions: dto.questions as unknown as Prisma.JsonValue,
        createdById: userId,
      },
    });
  }

  async findTemplateById(organizationId: string, id: string) {
    const template = await this.prisma.interviewTemplate.findFirst({
      where: { id, organizationId },
    });

    if (!template) {
      throw new NotFoundException('Interview template not found');
    }

    return template;
  }

  async findAllTemplates(organizationId: string, categoryId?: string) {
    return this.prisma.interviewTemplate.findMany({
      where: {
        organizationId,
        isActive: true,
        ...(categoryId && { categoryId }),
      },
      orderBy: { name: 'asc' },
    });
  }

  async updateTemplate(
    organizationId: string,
    id: string,
    dto: UpdateInterviewTemplateDto,
  ) {
    await this.findTemplateById(organizationId, id);

    return this.prisma.interviewTemplate.update({
      where: { id },
      data: {
        ...(dto.name && { name: dto.name }),
        ...(dto.description !== undefined && { description: dto.description }),
        ...(dto.categoryId !== undefined && { categoryId: dto.categoryId }),
        ...(dto.questions && { questions: dto.questions as unknown as Prisma.JsonValue }),
        ...(dto.isActive !== undefined && { isActive: dto.isActive }),
      },
    });
  }

  async deleteTemplate(organizationId: string, id: string) {
    await this.findTemplateById(organizationId, id);

    // Soft delete by deactivating
    return this.prisma.interviewTemplate.update({
      where: { id },
      data: { isActive: false },
    });
  }

  // ===== Queries for Pattern Detection =====

  async findInterviewsByPerson(organizationId: string, personId: string) {
    return this.prisma.investigationInterview.findMany({
      where: {
        organizationId,
        intervieweePersonId: personId,
      },
      include: {
        investigation: {
          select: { id: true, caseId: true, investigationNumber: true },
        },
      },
      orderBy: { createdAt: 'desc' },
    });
  }
}
```

Create index file: `apps/backend/src/modules/investigations/interviews/index.ts`
```typescript
export * from './interview.service';
export * from './dto/interview.dto';
```
  </action>
  <verify>TypeScript compiles without errors. Service handles interview lifecycle and template management.</verify>
  <done>InvestigationInterviewService provides CRUD for interviews with Person linking and template support.</done>
</task>

<task type="auto">
  <name>Task 3: Create Interview Controller and Wire Module</name>
  <files>
    apps/backend/src/modules/investigations/interviews/interview.controller.ts
    apps/backend/src/modules/investigations/investigations.module.ts
  </files>
  <action>
**interview.controller.ts:**
```typescript
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
  ParseUUIDPipe,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../../auth/guards/roles.guard';
import { Roles } from '../../auth/decorators/roles.decorator';
import { CurrentUser } from '../../auth/decorators/current-user.decorator';
import { UserRole } from '@prisma/client';
import { InvestigationInterviewService } from './interview.service';
import {
  CreateInterviewDto,
  UpdateInterviewDto,
  InterviewQueryDto,
  CreateInterviewTemplateDto,
  UpdateInterviewTemplateDto,
} from './dto/interview.dto';

interface AuthUser {
  id: string;
  organizationId: string;
  role: UserRole;
}

@Controller('api/v1/investigation-interviews')
@UseGuards(JwtAuthGuard, RolesGuard)
export class InvestigationInterviewController {
  constructor(private readonly interviewService: InvestigationInterviewService) {}

  // ===== Interviews =====

  @Post()
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async create(
    @CurrentUser() user: AuthUser,
    @Body() dto: CreateInterviewDto,
  ) {
    return this.interviewService.create(user.organizationId, user.id, dto);
  }

  @Get()
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async findAll(
    @CurrentUser() user: AuthUser,
    @Query() query: InterviewQueryDto,
  ) {
    return this.interviewService.findAll(user.organizationId, query);
  }

  @Get(':id')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async findOne(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    return this.interviewService.findById(user.organizationId, id);
  }

  @Put(':id')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async update(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
    @Body() dto: UpdateInterviewDto,
  ) {
    return this.interviewService.update(user.organizationId, id, user.id, dto);
  }

  @Post(':id/start')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async start(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    return this.interviewService.start(user.organizationId, id, user.id);
  }

  @Post(':id/complete')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async complete(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
    @Body('summary') summary?: string,
  ) {
    return this.interviewService.complete(user.organizationId, id, user.id, summary);
  }

  @Post(':id/cancel')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async cancel(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    return this.interviewService.cancel(user.organizationId, id, user.id);
  }

  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async delete(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    await this.interviewService.delete(user.organizationId, id, user.id);
  }

  // ===== Interview Templates =====

  @Post('templates')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async createTemplate(
    @CurrentUser() user: AuthUser,
    @Body() dto: CreateInterviewTemplateDto,
  ) {
    return this.interviewService.createTemplate(user.organizationId, user.id, dto);
  }

  @Get('templates')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async findAllTemplates(
    @CurrentUser() user: AuthUser,
    @Query('categoryId') categoryId?: string,
  ) {
    return this.interviewService.findAllTemplates(user.organizationId, categoryId);
  }

  @Get('templates/:id')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async findTemplateById(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    return this.interviewService.findTemplateById(user.organizationId, id);
  }

  @Put('templates/:id')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async updateTemplate(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
    @Body() dto: UpdateInterviewTemplateDto,
  ) {
    return this.interviewService.updateTemplate(user.organizationId, id, dto);
  }

  @Delete('templates/:id')
  @HttpCode(HttpStatus.NO_CONTENT)
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async deleteTemplate(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    await this.interviewService.deleteTemplate(user.organizationId, id);
  }

  // ===== Person History =====

  @Get('by-person/:personId')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async findByPerson(
    @CurrentUser() user: AuthUser,
    @Param('personId', ParseUUIDPipe) personId: string,
  ) {
    return this.interviewService.findInterviewsByPerson(user.organizationId, personId);
  }
}
```

**Update investigations.module.ts** to register the interview service and controller:
- Import InvestigationInterviewService from './interviews/interview.service'
- Import InvestigationInterviewController from './interviews/interview.controller'
- Add InvestigationInterviewService to providers array
- Add InvestigationInterviewController to controllers array
- Export InvestigationInterviewService
  </action>
  <verify>
Run `cd apps/backend && npm run build` - compiles successfully.
Endpoints /api/v1/investigation-interviews and /api/v1/investigation-interviews/templates accessible.
  </verify>
  <done>Interview endpoints support full lifecycle management with template-based questions.</done>
</task>

</tasks>

<verification>
- [ ] `npx prisma validate` passes
- [ ] `npm run build` in apps/backend succeeds
- [ ] InvestigationInterview model has intervieweeType discriminator
- [ ] InterviewTemplate model has questions JSON field
- [ ] Interview service supports start/complete/cancel workflow
- [ ] Interviews can link to Person records or freeform names
</verification>

<success_criteria>
1. InvestigationInterview Prisma model exists with status workflow
2. Interviews support both Person-linked and external interviewees
3. InterviewTemplate provides reusable question sets
4. Service handles interview lifecycle (scheduled -> in_progress -> completed)
5. Interviews can link to checklist items for evidence tracking
</success_criteria>

<output>
After completion, create `.planning/phases/06-case-management/06-02-SUMMARY.md`
</output>
