---
phase: 06-case-management
plan: 11
type: execute
wave: 3
depends_on: []
files_modified:
  - apps/backend/src/modules/activity/activity-timeline.service.ts
  - apps/backend/src/modules/activity/activity-timeline.controller.ts
  - apps/backend/src/modules/activity/activity.module.ts
  - apps/backend/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "Activity timeline aggregates events from AuditLog for any entity"
    - "Timeline includes related entity activities (Case includes Investigation activities)"
    - "Events formatted with natural language descriptions"
    - "Pagination and date range filtering supported"
  artifacts:
    - path: "apps/backend/src/modules/activity/activity-timeline.service.ts"
      provides: "Timeline aggregation from audit logs"
      exports: ["ActivityTimelineService"]
  key_links:
    - from: "activity-timeline.controller.ts"
      to: "activity-timeline.service.ts"
      via: "DI injection"
      pattern: "ActivityTimelineService"
---

<objective>
Create activity timeline service that aggregates audit events into a unified timeline for any entity with related entity inclusion.

Purpose: Users need to see complete activity history including related entities (Case timeline includes Investigation activities) for context.

Output: Activity timeline service, REST controller
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@apps/backend/src/modules/audit/audit.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ActivityTimelineService</name>
  <files>apps/backend/src/modules/activity/activity-timeline.service.ts</files>
  <action>
Create `apps/backend/src/modules/activity/` directory.

**activity-timeline.service.ts:**
```typescript
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { AuditEntityType } from '@prisma/client';

export interface TimelineEntry {
  id: string;
  timestamp: Date;
  entityType: AuditEntityType;
  entityId: string;
  action: string;
  description: string;
  actorName: string | null;
  actorType: string;
  changes?: Record<string, { old: unknown; new: unknown }>;
  isRelated: boolean;  // True if from related entity
  relatedEntityType?: string;
}

export interface TimelineOptions {
  page?: number;
  limit?: number;
  startDate?: Date;
  endDate?: Date;
  includeRelated?: boolean;
  actorUserId?: string;
  actionCategories?: string[];
}

@Injectable()
export class ActivityTimelineService {
  constructor(private readonly prisma: PrismaService) {}

  async getTimeline(
    organizationId: string,
    entityType: AuditEntityType,
    entityId: string,
    options: TimelineOptions = {},
  ): Promise<{ entries: TimelineEntry[]; total: number; hasMore: boolean }> {
    const limit = options.limit || 50;
    const page = options.page || 1;
    const offset = (page - 1) * limit;

    // Build where clause
    const baseWhere = {
      organizationId,
      createdAt: {
        ...(options.startDate && { gte: options.startDate }),
        ...(options.endDate && { lte: options.endDate }),
      },
      ...(options.actorUserId && { actorUserId: options.actorUserId }),
      ...(options.actionCategories?.length && {
        actionCategory: { in: options.actionCategories },
      }),
    };

    // Get related entity IDs based on entity type
    const relatedEntityIds = options.includeRelated !== false
      ? await this.getRelatedEntityIds(organizationId, entityType, entityId)
      : [];

    // Query audit logs
    const where = {
      ...baseWhere,
      OR: [
        { entityType, entityId },
        ...(relatedEntityIds.length > 0
          ? relatedEntityIds.map(r => ({
              entityType: r.entityType,
              entityId: r.entityId,
            }))
          : []),
      ],
    };

    const [logs, total] = await Promise.all([
      this.prisma.auditLog.findMany({
        where,
        orderBy: { createdAt: 'desc' },
        skip: offset,
        take: limit + 1,  // +1 to check hasMore
      }),
      this.prisma.auditLog.count({ where }),
    ]);

    const hasMore = logs.length > limit;
    const entries = logs.slice(0, limit).map(log => ({
      id: log.id,
      timestamp: log.createdAt,
      entityType: log.entityType,
      entityId: log.entityId,
      action: log.action,
      description: log.actionDescription,
      actorName: log.actorName,
      actorType: log.actorType,
      changes: log.changes as any,
      isRelated: log.entityId !== entityId,
      relatedEntityType: log.entityId !== entityId ? log.entityType : undefined,
    }));

    return { entries, total, hasMore };
  }

  private async getRelatedEntityIds(
    organizationId: string,
    entityType: AuditEntityType,
    entityId: string,
  ): Promise<{ entityType: AuditEntityType; entityId: string }[]> {
    const related: { entityType: AuditEntityType; entityId: string }[] = [];

    switch (entityType) {
      case AuditEntityType.CASE:
        // Include investigations for this case
        const investigations = await this.prisma.investigation.findMany({
          where: { caseId: entityId, organizationId },
          select: { id: true },
        });
        related.push(
          ...investigations.map(i => ({
            entityType: AuditEntityType.INVESTIGATION,
            entityId: i.id,
          }))
        );
        break;

      case AuditEntityType.INVESTIGATION:
        // Include parent case
        const investigation = await this.prisma.investigation.findUnique({
          where: { id: entityId },
          select: { caseId: true },
        });
        if (investigation) {
          related.push({
            entityType: AuditEntityType.CASE,
            entityId: investigation.caseId,
          });
        }
        break;

      // Add other entity types as needed
    }

    return related;
  }

  async getRecentActivity(
    organizationId: string,
    userId: string,
    limit: number = 20,
  ): Promise<TimelineEntry[]> {
    const logs = await this.prisma.auditLog.findMany({
      where: {
        organizationId,
        actorUserId: userId,
      },
      orderBy: { createdAt: 'desc' },
      take: limit,
    });

    return logs.map(log => ({
      id: log.id,
      timestamp: log.createdAt,
      entityType: log.entityType,
      entityId: log.entityId,
      action: log.action,
      description: log.actionDescription,
      actorName: log.actorName,
      actorType: log.actorType,
      isRelated: false,
    }));
  }
}
```
  </action>
  <verify>TypeScript compiles. Service aggregates audit logs into timeline entries.</verify>
  <done>ActivityTimelineService provides entity timeline with related entity inclusion.</done>
</task>

<task type="auto">
  <name>Task 2: Create Activity Controller and Module</name>
  <files>
    apps/backend/src/modules/activity/activity-timeline.controller.ts
    apps/backend/src/modules/activity/activity.module.ts
    apps/backend/src/app.module.ts
  </files>
  <action>
**activity-timeline.controller.ts:**
```typescript
import { Controller, Get, Param, Query, UseGuards, ParseUUIDPipe } from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { CurrentUser } from '../auth/decorators/current-user.decorator';
import { AuditEntityType } from '@prisma/client';
import { ActivityTimelineService, TimelineOptions } from './activity-timeline.service';

@Controller('api/v1/activity')
@UseGuards(JwtAuthGuard)
export class ActivityTimelineController {
  constructor(private readonly timelineService: ActivityTimelineService) {}

  @Get(':entityType/:entityId')
  async getTimeline(
    @CurrentUser() user: { organizationId: string },
    @Param('entityType') entityType: AuditEntityType,
    @Param('entityId', ParseUUIDPipe) entityId: string,
    @Query('page') page?: number,
    @Query('limit') limit?: number,
    @Query('includeRelated') includeRelated?: string,
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
  ) {
    const options: TimelineOptions = {
      page: page || 1,
      limit: limit || 50,
      includeRelated: includeRelated !== 'false',
      startDate: startDate ? new Date(startDate) : undefined,
      endDate: endDate ? new Date(endDate) : undefined,
    };

    return this.timelineService.getTimeline(
      user.organizationId,
      entityType,
      entityId,
      options,
    );
  }

  @Get('my-recent')
  async getMyRecent(
    @CurrentUser() user: { id: string; organizationId: string },
    @Query('limit') limit?: number,
  ) {
    return this.timelineService.getRecentActivity(
      user.organizationId,
      user.id,
      limit || 20,
    );
  }
}
```

**activity.module.ts:**
```typescript
import { Module } from '@nestjs/common';
import { PrismaModule } from '../../prisma/prisma.module';
import { ActivityTimelineService } from './activity-timeline.service';
import { ActivityTimelineController } from './activity-timeline.controller';

@Module({
  imports: [PrismaModule],
  controllers: [ActivityTimelineController],
  providers: [ActivityTimelineService],
  exports: [ActivityTimelineService],
})
export class ActivityModule {}
```

Update app.module.ts to import ActivityModule.
  </action>
  <verify>GET /api/v1/activity/CASE/:caseId returns timeline with related investigation activities.</verify>
  <done>Activity timeline endpoints available with filtering and pagination.</done>
</task>

</tasks>

<verification>
- [ ] `npm run build` in apps/backend succeeds
- [ ] Timeline aggregates audit logs for entity
- [ ] Related entity activities included (Case -> Investigation)
- [ ] Pagination and date filtering work
- [ ] Recent activity endpoint for user's actions
</verification>

<success_criteria>
1. Activity timeline aggregates audit events for any entity
2. Case timeline includes Investigation activities
3. Natural language descriptions from audit log
4. Pagination and date range filtering supported
</success_criteria>

<output>
After completion, create `.planning/phases/06-case-management/06-11-SUMMARY.md`
</output>
