---
phase: 06-case-management
plan: 09
type: execute
wave: 2
depends_on: []
files_modified:
  - apps/backend/src/modules/messaging/relay.service.ts
  - apps/backend/src/modules/messaging/pii-detection.service.ts
  - apps/backend/src/modules/messaging/messaging.controller.ts
  - apps/backend/src/modules/messaging/messaging.module.ts
  - apps/backend/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "RelayService sends messages without exposing reporter identity"
    - "PII detection warns investigators before sending"
    - "Reporters can attach files to messages"
    - "Message retrieval marks outbound messages as read"
  artifacts:
    - path: "apps/backend/src/modules/messaging/relay.service.ts"
      provides: "Identity-protecting message relay"
      exports: ["MessageRelayService"]
    - path: "apps/backend/src/modules/messaging/pii-detection.service.ts"
      provides: "PII pattern detection"
      exports: ["PiiDetectionService"]
  key_links:
    - from: "messaging.controller.ts"
      to: "relay.service.ts"
      via: "DI injection"
      pattern: "MessageRelayService"
---

<objective>
Enhance the messaging system with a relay service that protects reporter identity and detects PII before sending messages.

Purpose: Anonymous reporters must be able to communicate without revealing their identity. PII detection prevents accidental identity disclosure.

Output: Relay service, PII detection service, enhanced controller endpoints
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/06-case-management/06-CONTEXT.md
@.planning/phases/06-case-management/06-RESEARCH.md
@.planning/phases/04-core-entities/04-06-SUMMARY.md
@apps/backend/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PII Detection Service</name>
  <files>apps/backend/src/modules/messaging/pii-detection.service.ts</files>
  <action>
Create directory: `apps/backend/src/modules/messaging/`

**pii-detection.service.ts:**
```typescript
import { Injectable } from '@nestjs/common';

export interface PiiDetectionResult {
  hasPii: boolean;
  types: string[];
  matches: {
    type: string;
    value: string;
    position: number;
  }[];
  warning: string | null;
  sanitized?: string;
}

export interface PiiPattern {
  name: string;
  pattern: RegExp;
  description: string;
}

const PII_PATTERNS: PiiPattern[] = [
  {
    name: 'email',
    pattern: /\b[\w.-]+@[\w.-]+\.\w{2,}\b/gi,
    description: 'Email address',
  },
  {
    name: 'phone_us',
    pattern: /\b(?:\+?1[-.\s]?)?\(?[2-9]\d{2}\)?[-.\s]?\d{3}[-.\s]?\d{4}\b/g,
    description: 'US phone number',
  },
  {
    name: 'phone_intl',
    pattern: /\b\+\d{1,3}[-.\s]?\d{1,4}[-.\s]?\d{1,4}[-.\s]?\d{1,9}\b/g,
    description: 'International phone number',
  },
  {
    name: 'ssn',
    pattern: /\b\d{3}[-.\s]?\d{2}[-.\s]?\d{4}\b/g,
    description: 'Social Security Number',
  },
  {
    name: 'credit_card',
    pattern: /\b(?:\d{4}[-.\s]?){3}\d{4}\b/g,
    description: 'Credit card number',
  },
  {
    name: 'date_of_birth',
    pattern: /\b(?:DOB|date of birth|birthday|born on)[:\s]+(?:\d{1,2}[-/]\d{1,2}[-/]\d{2,4}|\w+\s+\d{1,2},?\s*\d{4})\b/gi,
    description: 'Date of birth',
  },
  {
    name: 'address',
    pattern: /\b\d+\s+[\w\s]+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr|Court|Ct|Circle|Cir)\.?\s*(?:#?\d+|Apt\.?\s*\d+|Suite\s*\d+)?\s*,?\s*[\w\s]+,?\s*[A-Z]{2}\s*\d{5}(?:-\d{4})?\b/gi,
    description: 'Street address with ZIP',
  },
  {
    name: 'employee_id',
    pattern: /\b(?:employee\s*(?:id|number|#)|emp\s*(?:id|#))[:\s]*[\w-]+\b/gi,
    description: 'Employee ID',
  },
  {
    name: 'ip_address',
    pattern: /\b(?:\d{1,3}\.){3}\d{1,3}\b/g,
    description: 'IP address',
  },
];

@Injectable()
export class PiiDetectionService {
  /**
   * Detect potential PII in text content
   */
  detect(content: string): PiiDetectionResult {
    const matches: PiiDetectionResult['matches'] = [];
    const detectedTypes = new Set<string>();

    for (const { name, pattern, description } of PII_PATTERNS) {
      // Reset regex state for global patterns
      pattern.lastIndex = 0;

      let match;
      while ((match = pattern.exec(content)) !== null) {
        detectedTypes.add(name);
        matches.push({
          type: name,
          value: this.redactPartial(match[0], name),
          position: match.index,
        });
      }
    }

    const types = Array.from(detectedTypes);
    const hasPii = types.length > 0;

    let warning: string | null = null;
    if (hasPii) {
      const typeDescriptions = types.map(t =>
        PII_PATTERNS.find(p => p.name === t)?.description || t
      );
      warning = `Message may contain personal information: ${typeDescriptions.join(', ')}. ` +
        `Please review before sending to protect anonymity.`;
    }

    return {
      hasPii,
      types,
      matches,
      warning,
    };
  }

  /**
   * Sanitize content by redacting detected PII
   */
  sanitize(content: string): PiiDetectionResult {
    let sanitized = content;

    for (const { name, pattern } of PII_PATTERNS) {
      pattern.lastIndex = 0;
      sanitized = sanitized.replace(pattern, (match) => this.redact(match, name));
    }

    const result = this.detect(content);
    result.sanitized = sanitized;

    return result;
  }

  /**
   * Partially redact a value for display in warnings
   */
  private redactPartial(value: string, type: string): string {
    switch (type) {
      case 'email':
        const [local, domain] = value.split('@');
        return `${local[0]}***@${domain}`;

      case 'phone_us':
      case 'phone_intl':
        return `***-***-${value.slice(-4)}`;

      case 'ssn':
        return `***-**-${value.slice(-4)}`;

      case 'credit_card':
        return `****-****-****-${value.slice(-4)}`;

      default:
        if (value.length > 8) {
          return `${value.slice(0, 3)}...${value.slice(-3)}`;
        }
        return `${value[0]}***`;
    }
  }

  /**
   * Fully redact a value for sanitized output
   */
  private redact(value: string, type: string): string {
    switch (type) {
      case 'email':
        return '[EMAIL REDACTED]';
      case 'phone_us':
      case 'phone_intl':
        return '[PHONE REDACTED]';
      case 'ssn':
        return '[SSN REDACTED]';
      case 'credit_card':
        return '[CARD REDACTED]';
      case 'date_of_birth':
        return '[DOB REDACTED]';
      case 'address':
        return '[ADDRESS REDACTED]';
      case 'employee_id':
        return '[EMPLOYEE ID REDACTED]';
      case 'ip_address':
        return '[IP REDACTED]';
      default:
        return '[REDACTED]';
    }
  }

  /**
   * Check if specific content contains a specific PII type
   */
  containsType(content: string, type: string): boolean {
    const pattern = PII_PATTERNS.find(p => p.name === type);
    if (!pattern) return false;

    pattern.pattern.lastIndex = 0;
    return pattern.pattern.test(content);
  }
}
```
  </action>
  <verify>TypeScript compiles. PII detection identifies common PII patterns.</verify>
  <done>PiiDetectionService detects emails, phones, SSNs, and other PII patterns.</done>
</task>

<task type="auto">
  <name>Task 2: Create Message Relay Service</name>
  <files>apps/backend/src/modules/messaging/relay.service.ts</files>
  <action>
**relay.service.ts:**
```typescript
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { InjectQueue } from '@nestjs/bullmq';
import { Queue } from 'bullmq';
import { MessageDirection, MessageSenderType, MessageDeliveryStatus } from '@prisma/client';
import { PiiDetectionService, PiiDetectionResult } from './pii-detection.service';

export interface SendMessageDto {
  content: string;
  subject?: string;
  attachmentIds?: string[];
  skipPiiWarning?: boolean;  // Acknowledge PII warning
}

export interface MessageResponse {
  id: string;
  direction: MessageDirection;
  senderType: MessageSenderType;
  content: string;
  subject?: string;
  createdAt: Date;
  isRead: boolean;
  attachments?: {
    id: string;
    fileName: string;
    mimeType: string;
  }[];
}

@Injectable()
export class MessageRelayService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly eventEmitter: EventEmitter2,
    private readonly piiService: PiiDetectionService,
    @InjectQueue('email') private readonly emailQueue: Queue,
  ) {}

  /**
   * Send message from investigator to reporter (outbound)
   * Reporter identity is NEVER exposed to the investigator
   */
  async sendToReporter(
    organizationId: string,
    caseId: string,
    userId: string,
    dto: SendMessageDto,
  ): Promise<{ message: MessageResponse; piiWarning?: PiiDetectionResult }> {
    // Check for PII in message
    const piiResult = this.piiService.detect(dto.content);

    if (piiResult.hasPii && !dto.skipPiiWarning) {
      return {
        message: null as any,
        piiWarning: piiResult,
      };
    }

    // Create outbound message
    const message = await this.prisma.caseMessage.create({
      data: {
        organizationId,
        caseId,
        direction: MessageDirection.OUTBOUND,
        senderType: MessageSenderType.INVESTIGATOR,
        content: dto.content,
        subject: dto.subject,
        createdById: userId,
        deliveryStatus: MessageDeliveryStatus.PENDING,
      },
    });

    // Get primary RIU to find reporter contact (but never expose to investigator)
    const caseRecord = await this.prisma.case.findUnique({
      where: { id: caseId },
      select: {
        riuAssociations: {
          where: { associationType: 'PRIMARY' },
          include: {
            riu: {
              select: {
                id: true,
                reporterEmail: true,
                anonymousAccessCode: true,
                reporterType: true,
              },
            },
          },
        },
      },
    });

    const primaryRiu = caseRecord?.riuAssociations[0]?.riu;

    // If reporter provided email and opted for notifications, queue notification
    if (primaryRiu?.reporterEmail) {
      await this.queueReporterNotification(
        primaryRiu.reporterEmail,
        primaryRiu.anonymousAccessCode!,
        caseId,
        message.id,
      );

      // Update delivery status
      await this.prisma.caseMessage.update({
        where: { id: message.id },
        data: { deliveryStatus: MessageDeliveryStatus.SENT },
      });
    }

    this.eventEmitter.emit('case.message.sent', {
      organizationId,
      caseId,
      messageId: message.id,
      direction: 'outbound',
    });

    return {
      message: this.formatMessage(message),
    };
  }

  /**
   * Receive message from reporter (inbound via access code)
   * This is called from the public access code endpoint
   */
  async receiveFromReporter(
    caseId: string,
    content: string,
    subject?: string,
    attachmentIds?: string[],
  ): Promise<MessageResponse> {
    const caseRecord = await this.prisma.case.findUnique({
      where: { id: caseId },
      select: { organizationId: true },
    });

    if (!caseRecord) {
      throw new NotFoundException('Case not found');
    }

    const message = await this.prisma.caseMessage.create({
      data: {
        organizationId: caseRecord.organizationId,
        caseId,
        direction: MessageDirection.INBOUND,
        senderType: MessageSenderType.REPORTER,
        content,
        subject,
        // No createdById - reporter is anonymous
      },
    });

    this.eventEmitter.emit('case.message.received', {
      organizationId: caseRecord.organizationId,
      caseId,
      messageId: message.id,
    });

    return this.formatMessage(message);
  }

  /**
   * Get messages for investigators (internal view)
   */
  async getMessagesForInvestigator(
    organizationId: string,
    caseId: string,
    userId: string,
  ): Promise<MessageResponse[]> {
    const messages = await this.prisma.caseMessage.findMany({
      where: { organizationId, caseId },
      orderBy: { createdAt: 'asc' },
    });

    // Mark unread outbound messages as read (they're now seen by investigator)
    // This is different from reporter marking inbound as read
    const unreadOutbound = messages.filter(
      m => m.direction === MessageDirection.OUTBOUND && !m.isRead
    );

    if (unreadOutbound.length > 0) {
      await this.prisma.caseMessage.updateMany({
        where: {
          id: { in: unreadOutbound.map(m => m.id) },
        },
        data: {
          isRead: true,
          readAt: new Date(),
          readById: userId,
        },
      });
    }

    return messages.map(m => this.formatMessage(m));
  }

  /**
   * Get messages for reporter (via access code - public endpoint)
   */
  async getMessagesForReporter(
    caseId: string,
    accessCode: string,
  ): Promise<MessageResponse[]> {
    // Verify access code matches case's RIU
    const caseRecord = await this.prisma.case.findUnique({
      where: { id: caseId },
      select: {
        riuAssociations: {
          where: { associationType: 'PRIMARY' },
          include: {
            riu: {
              select: { anonymousAccessCode: true },
            },
          },
        },
      },
    });

    const primaryRiu = caseRecord?.riuAssociations[0]?.riu;
    if (!primaryRiu || primaryRiu.anonymousAccessCode !== accessCode) {
      throw new BadRequestException('Invalid access code');
    }

    const messages = await this.prisma.caseMessage.findMany({
      where: { caseId },
      orderBy: { createdAt: 'asc' },
    });

    // Mark unread inbound messages as read (outbound to reporter)
    const unreadInbound = messages.filter(
      m => m.direction === MessageDirection.OUTBOUND && !m.isRead
    );

    if (unreadInbound.length > 0) {
      await this.prisma.caseMessage.updateMany({
        where: {
          id: { in: unreadInbound.map(m => m.id) },
        },
        data: {
          isRead: true,
          readAt: new Date(),
          // No readById for anonymous reporter
        },
      });
    }

    return messages.map(m => this.formatMessage(m));
  }

  /**
   * Get unread message count
   */
  async getUnreadCount(organizationId: string, caseId: string): Promise<{
    fromReporter: number;
    toReporter: number;
  }> {
    const [fromReporter, toReporter] = await Promise.all([
      this.prisma.caseMessage.count({
        where: {
          organizationId,
          caseId,
          direction: MessageDirection.INBOUND,
          isRead: false,
        },
      }),
      this.prisma.caseMessage.count({
        where: {
          organizationId,
          caseId,
          direction: MessageDirection.OUTBOUND,
          isRead: false,
        },
      }),
    ]);

    return { fromReporter, toReporter };
  }

  /**
   * Check message content for PII before sending
   */
  checkForPii(content: string): PiiDetectionResult {
    return this.piiService.detect(content);
  }

  // ===== Private Helpers =====

  private async queueReporterNotification(
    email: string,
    accessCode: string,
    caseId: string,
    messageId: string,
  ) {
    // Queue email notification (content stripped - just tells them to check)
    await this.emailQueue.add(
      'send-email',
      {
        to: email,
        subject: 'New message regarding your report',
        template: 'case-message-notification',
        context: {
          // DO NOT include message content - just tell them to check
          accessCode: accessCode.slice(0, 4) + '****',  // Partial for reference
          checkUrl: '/check-status',  // Generic - no case ID in URL
        },
      },
      {
        attempts: 3,
        backoff: { type: 'exponential', delay: 5000 },
      },
    );
  }

  private formatMessage(message: any): MessageResponse {
    return {
      id: message.id,
      direction: message.direction,
      senderType: message.senderType,
      content: message.content,
      subject: message.subject,
      createdAt: message.createdAt,
      isRead: message.isRead,
    };
  }
}
```
  </action>
  <verify>TypeScript compiles. RelayService sends messages without exposing reporter identity.</verify>
  <done>MessageRelayService provides identity-protecting message relay with PII warnings.</done>
</task>

<task type="auto">
  <name>Task 3: Create Messaging Controller and Module</name>
  <files>
    apps/backend/src/modules/messaging/messaging.controller.ts
    apps/backend/src/modules/messaging/messaging.module.ts
    apps/backend/src/app.module.ts
  </files>
  <action>
**messaging.controller.ts:**
```typescript
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Query,
  UseGuards,
  ParseUUIDPipe,
} from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { CurrentUser } from '../auth/decorators/current-user.decorator';
import { UserRole } from '@prisma/client';
import { MessageRelayService, SendMessageDto } from './relay.service';
import { PiiDetectionService } from './pii-detection.service';

interface AuthUser {
  id: string;
  organizationId: string;
  role: UserRole;
}

@Controller('api/v1/case-messages')
@UseGuards(JwtAuthGuard, RolesGuard)
export class MessagingController {
  constructor(
    private readonly relayService: MessageRelayService,
    private readonly piiService: PiiDetectionService,
  ) {}

  @Post(':caseId/send')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async sendMessage(
    @CurrentUser() user: AuthUser,
    @Param('caseId', ParseUUIDPipe) caseId: string,
    @Body() dto: SendMessageDto,
  ) {
    return this.relayService.sendToReporter(
      user.organizationId,
      caseId,
      user.id,
      dto,
    );
  }

  @Get(':caseId')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async getMessages(
    @CurrentUser() user: AuthUser,
    @Param('caseId', ParseUUIDPipe) caseId: string,
  ) {
    return this.relayService.getMessagesForInvestigator(
      user.organizationId,
      caseId,
      user.id,
    );
  }

  @Get(':caseId/unread-count')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async getUnreadCount(
    @CurrentUser() user: AuthUser,
    @Param('caseId', ParseUUIDPipe) caseId: string,
  ) {
    return this.relayService.getUnreadCount(user.organizationId, caseId);
  }

  @Post('check-pii')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async checkPii(@Body('content') content: string) {
    return this.piiService.detect(content);
  }
}

// Public controller for reporter access (no auth)
@Controller('api/v1/public/messages')
export class PublicMessagingController {
  constructor(private readonly relayService: MessageRelayService) {}

  @Get(':caseId')
  async getMessages(
    @Param('caseId', ParseUUIDPipe) caseId: string,
    @Query('accessCode') accessCode: string,
  ) {
    if (!accessCode) {
      throw new Error('Access code required');
    }
    return this.relayService.getMessagesForReporter(caseId, accessCode);
  }

  @Post(':caseId')
  async sendMessage(
    @Param('caseId', ParseUUIDPipe) caseId: string,
    @Query('accessCode') accessCode: string,
    @Body() dto: { content: string; subject?: string },
  ) {
    if (!accessCode) {
      throw new Error('Access code required');
    }

    // Verify access code
    return this.relayService.receiveFromReporter(
      caseId,
      dto.content,
      dto.subject,
    );
  }
}
```

**messaging.module.ts:**
```typescript
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bullmq';
import { PrismaModule } from '../../prisma/prisma.module';
import { MessageRelayService } from './relay.service';
import { PiiDetectionService } from './pii-detection.service';
import { MessagingController, PublicMessagingController } from './messaging.controller';

@Module({
  imports: [
    PrismaModule,
    BullModule.registerQueue({ name: 'email' }),
  ],
  controllers: [MessagingController, PublicMessagingController],
  providers: [MessageRelayService, PiiDetectionService],
  exports: [MessageRelayService, PiiDetectionService],
})
export class MessagingModule {}
```

**Update app.module.ts** to import MessagingModule.
  </action>
  <verify>
Run `cd apps/backend && npm run build` - compiles successfully.
POST /api/v1/case-messages/:caseId/send sends message with PII check.
GET /api/v1/public/messages/:caseId?accessCode=xxx retrieves messages for reporter.
  </verify>
  <done>Messaging endpoints support two-way anonymous communication with PII protection.</done>
</task>

</tasks>

<verification>
- [ ] `npm run build` in apps/backend succeeds
- [ ] PII detection identifies email, phone, SSN patterns
- [ ] Relay service never exposes reporter contact to investigator
- [ ] Public endpoints validate access code before allowing message access
- [ ] Outbound messages marked as read when reporter retrieves them
</verification>

<success_criteria>
1. PiiDetectionService detects common PII patterns with warnings
2. MessageRelayService sends without exposing reporter identity
3. Reporter notification emails don't contain message content
4. Public messaging endpoints require access code validation
5. Read status tracked separately for investigator vs reporter views
</success_criteria>

<output>
After completion, create `.planning/phases/06-case-management/06-09-SUMMARY.md`
</output>
