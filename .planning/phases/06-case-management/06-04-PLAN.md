---
phase: 06-case-management
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/saved-views/saved-views.module.ts
  - apps/backend/src/modules/saved-views/saved-views.service.ts
  - apps/backend/src/modules/saved-views/saved-views.controller.ts
  - apps/backend/src/modules/saved-views/dto/saved-view.dto.ts
  - apps/backend/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "SavedView model exists supporting filter persistence"
    - "Views can be personal or shared with team"
    - "Filter values are validated on load to handle enum changes"
    - "Users can set default views per entity type"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "SavedView model with entityType discriminator"
      contains: "model SavedView"
    - path: "apps/backend/src/modules/saved-views/saved-views.service.ts"
      provides: "View CRUD with filter validation"
      exports: ["SavedViewsService"]
  key_links:
    - from: "saved-views.controller.ts"
      to: "saved-views.service.ts"
      via: "DI injection"
      pattern: "constructor.*SavedViewsService"
---

<objective>
Create the SavedView model and service for persisting user-created filtered views across Cases, RIUs, and Investigations.

Purpose: Saved views allow users to quickly access frequently-used filter combinations without recreating them each time.

Output: Prisma model, DTOs, service with CRUD and filter validation, REST controller
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-case-management/06-CONTEXT.md
@.planning/phases/06-case-management/06-RESEARCH.md
@apps/backend/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SavedView model to Prisma schema</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
Add the following to schema.prisma:

1. ViewEntityType enum:
```prisma
enum ViewEntityType {
  CASES
  RIUS
  INVESTIGATIONS
  PERSONS
  CAMPAIGNS
  REMEDIATION_PLANS

  @@map("view_entity_type")
}
```

2. SavedView model:
```prisma
model SavedView {
  id              String   @id @default(uuid())
  organizationId  String   @map("organization_id")

  // Ownership
  createdById     String   @map("created_by_id")
  isShared        Boolean  @default(false) @map("is_shared")
  sharedWithTeamId String? @map("shared_with_team_id")

  // View definition
  name            String
  description     String?
  entityType      ViewEntityType @map("entity_type")

  // Filter configuration (JSON)
  filters         Json     // Filter criteria
  sortBy          String?  @map("sort_by")
  sortOrder       String?  @map("sort_order")  // 'asc' or 'desc'
  columns         Json?    // Column visibility and order

  // User preferences
  isDefault       Boolean  @default(false) @map("is_default")
  isPinned        Boolean  @default(false) @map("is_pinned")
  displayOrder    Int      @default(0) @map("display_order")
  color           String?  // Optional color for visual distinction

  // Usage tracking
  lastUsedAt      DateTime? @map("last_used_at")
  useCount        Int      @default(0) @map("use_count")

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([organizationId, createdById, entityType, name])
  @@index([organizationId, createdById])
  @@index([organizationId, entityType])
  @@index([organizationId, isShared])
  @@map("saved_views")
}
```

3. Add relation to Organization model:
```prisma
savedViews SavedView[]
```

Run: `cd apps/backend && npx prisma db push`
  </action>
  <verify>npx prisma validate passes. Database has saved_views table.</verify>
  <done>SavedView model exists with entityType discriminator and filter JSON field.</done>
</task>

<task type="auto">
  <name>Task 2: Create SavedViews DTOs and Service</name>
  <files>
    apps/backend/src/modules/saved-views/dto/saved-view.dto.ts
    apps/backend/src/modules/saved-views/saved-views.service.ts
  </files>
  <action>
Create directory: `apps/backend/src/modules/saved-views/`

**dto/saved-view.dto.ts:**
```typescript
import { IsString, IsOptional, IsEnum, IsBoolean, IsUUID, IsInt, IsObject, Min } from 'class-validator';
import { Type } from 'class-transformer';
import { ViewEntityType } from '@prisma/client';

// Filter structure varies by entity type, but has common patterns
export interface FilterCriteria {
  // Common filters
  status?: string | string[];
  dateRange?: {
    field: string;
    from?: string;
    to?: string;
  };
  search?: string;

  // Case-specific
  categoryId?: string;
  severity?: string | string[];
  assignedTo?: string;
  pipelineStage?: string;

  // RIU-specific
  sourceChannel?: string | string[];
  reporterType?: string;

  // Investigation-specific
  investigationType?: string;
  slaStatus?: string;

  // Custom fields
  customFields?: Record<string, unknown>;

  // Advanced
  and?: FilterCriteria[];
  or?: FilterCriteria[];
}

export interface ColumnConfig {
  key: string;
  visible: boolean;
  order: number;
  width?: number;
}

export class CreateSavedViewDto {
  @IsString()
  name: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsEnum(ViewEntityType)
  entityType: ViewEntityType;

  @IsObject()
  filters: FilterCriteria;

  @IsString()
  @IsOptional()
  sortBy?: string;

  @IsString()
  @IsOptional()
  sortOrder?: string;

  @IsOptional()
  columns?: ColumnConfig[];

  @IsBoolean()
  @IsOptional()
  isShared?: boolean;

  @IsUUID()
  @IsOptional()
  sharedWithTeamId?: string;

  @IsBoolean()
  @IsOptional()
  isDefault?: boolean;

  @IsBoolean()
  @IsOptional()
  isPinned?: boolean;

  @IsString()
  @IsOptional()
  color?: string;
}

export class UpdateSavedViewDto {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsObject()
  @IsOptional()
  filters?: FilterCriteria;

  @IsString()
  @IsOptional()
  sortBy?: string;

  @IsString()
  @IsOptional()
  sortOrder?: string;

  @IsOptional()
  columns?: ColumnConfig[];

  @IsBoolean()
  @IsOptional()
  isShared?: boolean;

  @IsUUID()
  @IsOptional()
  sharedWithTeamId?: string;

  @IsBoolean()
  @IsOptional()
  isDefault?: boolean;

  @IsBoolean()
  @IsOptional()
  isPinned?: boolean;

  @IsInt()
  @IsOptional()
  displayOrder?: number;

  @IsString()
  @IsOptional()
  color?: string;
}

export class SavedViewQueryDto {
  @IsEnum(ViewEntityType)
  @IsOptional()
  entityType?: ViewEntityType;

  @IsBoolean()
  @IsOptional()
  @Type(() => Boolean)
  includeShared?: boolean;

  @IsBoolean()
  @IsOptional()
  @Type(() => Boolean)
  pinnedOnly?: boolean;
}

export class ApplyViewResponseDto {
  filters: FilterCriteria;
  sortBy?: string;
  sortOrder?: string;
  columns?: ColumnConfig[];
  invalidFilters: string[];  // Filters that couldn't be validated
}
```

**saved-views.service.ts:**
```typescript
import { Injectable, NotFoundException, BadRequestException, ForbiddenException } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { ViewEntityType, Prisma, CaseStatus, Severity, RiuStatus, InvestigationStatus, SlaStatus } from '@prisma/client';
import {
  CreateSavedViewDto,
  UpdateSavedViewDto,
  SavedViewQueryDto,
  FilterCriteria,
  ApplyViewResponseDto,
} from './dto/saved-view.dto';

// Valid enum values for filter validation
const VALID_ENUMS: Record<string, Record<string, string[]>> = {
  CASES: {
    status: Object.values(CaseStatus),
    severity: Object.values(Severity),
  },
  RIUS: {
    status: Object.values(RiuStatus),
    severity: Object.values(Severity),
  },
  INVESTIGATIONS: {
    status: Object.values(InvestigationStatus),
    slaStatus: Object.values(SlaStatus),
  },
};

@Injectable()
export class SavedViewsService {
  constructor(private readonly prisma: PrismaService) {}

  async create(
    organizationId: string,
    userId: string,
    dto: CreateSavedViewDto,
  ) {
    // Validate filters against known enum values
    const { valid, invalid } = this.validateFilters(dto.entityType, dto.filters);

    if (invalid.length > 0) {
      throw new BadRequestException(`Invalid filter values: ${invalid.join(', ')}`);
    }

    // If setting as default, unset other defaults for this entity type
    if (dto.isDefault) {
      await this.prisma.savedView.updateMany({
        where: {
          organizationId,
          createdById: userId,
          entityType: dto.entityType,
          isDefault: true,
        },
        data: { isDefault: false },
      });
    }

    return this.prisma.savedView.create({
      data: {
        organizationId,
        createdById: userId,
        name: dto.name,
        description: dto.description,
        entityType: dto.entityType,
        filters: dto.filters as unknown as Prisma.JsonValue,
        sortBy: dto.sortBy,
        sortOrder: dto.sortOrder,
        columns: dto.columns as unknown as Prisma.JsonValue,
        isShared: dto.isShared || false,
        sharedWithTeamId: dto.sharedWithTeamId,
        isDefault: dto.isDefault || false,
        isPinned: dto.isPinned || false,
        color: dto.color,
      },
    });
  }

  async findById(organizationId: string, userId: string, id: string) {
    const view = await this.prisma.savedView.findFirst({
      where: {
        id,
        organizationId,
        OR: [
          { createdById: userId },
          { isShared: true },
        ],
      },
    });

    if (!view) {
      throw new NotFoundException('Saved view not found');
    }

    return view;
  }

  async findAll(organizationId: string, userId: string, query: SavedViewQueryDto) {
    const where: Prisma.SavedViewWhereInput = {
      organizationId,
      ...(query.entityType && { entityType: query.entityType }),
      ...(query.pinnedOnly && { isPinned: true }),
      OR: [
        { createdById: userId },
        ...(query.includeShared !== false ? [{ isShared: true }] : []),
      ],
    };

    const views = await this.prisma.savedView.findMany({
      where,
      orderBy: [
        { isPinned: 'desc' },
        { displayOrder: 'asc' },
        { name: 'asc' },
      ],
    });

    // Group by entity type for easier frontend consumption
    const grouped = views.reduce((acc, view) => {
      const key = view.entityType;
      if (!acc[key]) acc[key] = [];
      acc[key].push(view);
      return acc;
    }, {} as Record<string, typeof views>);

    return {
      data: views,
      grouped,
      total: views.length,
    };
  }

  async update(
    organizationId: string,
    userId: string,
    id: string,
    dto: UpdateSavedViewDto,
  ) {
    const existing = await this.findById(organizationId, userId, id);

    // Only owner can edit
    if (existing.createdById !== userId) {
      throw new ForbiddenException('Cannot edit another user\'s view');
    }

    // Validate filters if provided
    if (dto.filters) {
      const { invalid } = this.validateFilters(existing.entityType, dto.filters);
      if (invalid.length > 0) {
        throw new BadRequestException(`Invalid filter values: ${invalid.join(', ')}`);
      }
    }

    // Handle default toggle
    if (dto.isDefault === true) {
      await this.prisma.savedView.updateMany({
        where: {
          organizationId,
          createdById: userId,
          entityType: existing.entityType,
          isDefault: true,
          id: { not: id },
        },
        data: { isDefault: false },
      });
    }

    return this.prisma.savedView.update({
      where: { id },
      data: {
        ...(dto.name && { name: dto.name }),
        ...(dto.description !== undefined && { description: dto.description }),
        ...(dto.filters && { filters: dto.filters as unknown as Prisma.JsonValue }),
        ...(dto.sortBy !== undefined && { sortBy: dto.sortBy }),
        ...(dto.sortOrder !== undefined && { sortOrder: dto.sortOrder }),
        ...(dto.columns !== undefined && { columns: dto.columns as unknown as Prisma.JsonValue }),
        ...(dto.isShared !== undefined && { isShared: dto.isShared }),
        ...(dto.sharedWithTeamId !== undefined && { sharedWithTeamId: dto.sharedWithTeamId }),
        ...(dto.isDefault !== undefined && { isDefault: dto.isDefault }),
        ...(dto.isPinned !== undefined && { isPinned: dto.isPinned }),
        ...(dto.displayOrder !== undefined && { displayOrder: dto.displayOrder }),
        ...(dto.color !== undefined && { color: dto.color }),
      },
    });
  }

  async delete(organizationId: string, userId: string, id: string) {
    const existing = await this.findById(organizationId, userId, id);

    if (existing.createdById !== userId) {
      throw new ForbiddenException('Cannot delete another user\'s view');
    }

    await this.prisma.savedView.delete({ where: { id } });
  }

  async applyView(
    organizationId: string,
    userId: string,
    id: string,
  ): Promise<ApplyViewResponseDto> {
    const view = await this.findById(organizationId, userId, id);

    // Track usage
    await this.prisma.savedView.update({
      where: { id },
      data: {
        lastUsedAt: new Date(),
        useCount: { increment: 1 },
      },
    });

    // Validate filters are still valid (enums may have changed)
    const filters = view.filters as FilterCriteria;
    const { valid, invalid } = this.validateFilters(view.entityType, filters);

    return {
      filters: valid,
      sortBy: view.sortBy || undefined,
      sortOrder: view.sortOrder || undefined,
      columns: view.columns as any || undefined,
      invalidFilters: invalid,
    };
  }

  async duplicate(
    organizationId: string,
    userId: string,
    id: string,
    newName?: string,
  ) {
    const existing = await this.findById(organizationId, userId, id);

    return this.prisma.savedView.create({
      data: {
        organizationId,
        createdById: userId,
        name: newName || `${existing.name} (Copy)`,
        description: existing.description,
        entityType: existing.entityType,
        filters: existing.filters,
        sortBy: existing.sortBy,
        sortOrder: existing.sortOrder,
        columns: existing.columns,
        isShared: false,  // Duplicates start as personal
        isPinned: false,
        isDefault: false,
      },
    });
  }

  async getDefaultView(organizationId: string, userId: string, entityType: ViewEntityType) {
    return this.prisma.savedView.findFirst({
      where: {
        organizationId,
        createdById: userId,
        entityType,
        isDefault: true,
      },
    });
  }

  async reorder(
    organizationId: string,
    userId: string,
    viewOrders: { id: string; displayOrder: number }[],
  ) {
    await this.prisma.$transaction(
      viewOrders.map(({ id, displayOrder }) =>
        this.prisma.savedView.updateMany({
          where: { id, organizationId, createdById: userId },
          data: { displayOrder },
        })
      )
    );
  }

  // Filter validation
  private validateFilters(
    entityType: ViewEntityType,
    filters: FilterCriteria,
  ): { valid: FilterCriteria; invalid: string[] } {
    const invalid: string[] = [];
    const valid: FilterCriteria = { ...filters };
    const validEnums = VALID_ENUMS[entityType] || {};

    // Validate status values
    if (filters.status) {
      const statuses = Array.isArray(filters.status) ? filters.status : [filters.status];
      const validStatuses = statuses.filter(s => validEnums.status?.includes(s));
      const invalidStatuses = statuses.filter(s => !validEnums.status?.includes(s));

      if (invalidStatuses.length > 0) {
        invalid.push(`status: ${invalidStatuses.join(', ')}`);
      }
      valid.status = validStatuses.length > 0 ? validStatuses : undefined;
    }

    // Validate severity values
    if (filters.severity) {
      const severities = Array.isArray(filters.severity) ? filters.severity : [filters.severity];
      const validSeverities = severities.filter(s => validEnums.severity?.includes(s));
      const invalidSeverities = severities.filter(s => !validEnums.severity?.includes(s));

      if (invalidSeverities.length > 0) {
        invalid.push(`severity: ${invalidSeverities.join(', ')}`);
      }
      valid.severity = validSeverities.length > 0 ? validSeverities : undefined;
    }

    // Validate SLA status for investigations
    if (filters.slaStatus && entityType === ViewEntityType.INVESTIGATIONS) {
      if (!validEnums.slaStatus?.includes(filters.slaStatus)) {
        invalid.push(`slaStatus: ${filters.slaStatus}`);
        valid.slaStatus = undefined;
      }
    }

    return { valid, invalid };
  }
}
```

Create index file: `apps/backend/src/modules/saved-views/index.ts`
```typescript
export * from './saved-views.service';
export * from './dto/saved-view.dto';
```
  </action>
  <verify>TypeScript compiles without errors. Service handles view lifecycle with filter validation.</verify>
  <done>SavedViewsService provides CRUD with filter validation against current enum values.</done>
</task>

<task type="auto">
  <name>Task 3: Create SavedViews Controller and Module</name>
  <files>
    apps/backend/src/modules/saved-views/saved-views.controller.ts
    apps/backend/src/modules/saved-views/saved-views.module.ts
    apps/backend/src/app.module.ts
  </files>
  <action>
**saved-views.controller.ts:**
```typescript
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
  ParseUUIDPipe,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { CurrentUser } from '../auth/decorators/current-user.decorator';
import { UserRole, ViewEntityType } from '@prisma/client';
import { SavedViewsService } from './saved-views.service';
import {
  CreateSavedViewDto,
  UpdateSavedViewDto,
  SavedViewQueryDto,
} from './dto/saved-view.dto';

interface AuthUser {
  id: string;
  organizationId: string;
  role: UserRole;
}

@Controller('api/v1/saved-views')
@UseGuards(JwtAuthGuard)
export class SavedViewsController {
  constructor(private readonly savedViewsService: SavedViewsService) {}

  @Post()
  async create(
    @CurrentUser() user: AuthUser,
    @Body() dto: CreateSavedViewDto,
  ) {
    return this.savedViewsService.create(user.organizationId, user.id, dto);
  }

  @Get()
  async findAll(
    @CurrentUser() user: AuthUser,
    @Query() query: SavedViewQueryDto,
  ) {
    return this.savedViewsService.findAll(user.organizationId, user.id, query);
  }

  @Get('default/:entityType')
  async getDefault(
    @CurrentUser() user: AuthUser,
    @Param('entityType') entityType: ViewEntityType,
  ) {
    return this.savedViewsService.getDefaultView(user.organizationId, user.id, entityType);
  }

  @Get(':id')
  async findOne(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    return this.savedViewsService.findById(user.organizationId, user.id, id);
  }

  @Put(':id')
  async update(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
    @Body() dto: UpdateSavedViewDto,
  ) {
    return this.savedViewsService.update(user.organizationId, user.id, id, dto);
  }

  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  async delete(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    await this.savedViewsService.delete(user.organizationId, user.id, id);
  }

  @Post(':id/apply')
  async apply(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    return this.savedViewsService.applyView(user.organizationId, user.id, id);
  }

  @Post(':id/duplicate')
  async duplicate(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
    @Body('name') name?: string,
  ) {
    return this.savedViewsService.duplicate(user.organizationId, user.id, id, name);
  }

  @Put('reorder')
  async reorder(
    @CurrentUser() user: AuthUser,
    @Body() viewOrders: { id: string; displayOrder: number }[],
  ) {
    await this.savedViewsService.reorder(user.organizationId, user.id, viewOrders);
    return { success: true };
  }
}
```

**saved-views.module.ts:**
```typescript
import { Module } from '@nestjs/common';
import { PrismaModule } from '../../prisma/prisma.module';
import { SavedViewsService } from './saved-views.service';
import { SavedViewsController } from './saved-views.controller';

@Module({
  imports: [PrismaModule],
  controllers: [SavedViewsController],
  providers: [SavedViewsService],
  exports: [SavedViewsService],
})
export class SavedViewsModule {}
```

**Update app.module.ts** to import SavedViewsModule.
  </action>
  <verify>
Run `cd apps/backend && npm run build` - compiles successfully.
Endpoints /api/v1/saved-views accessible.
  </verify>
  <done>SavedViews endpoints support view management with apply and duplicate operations.</done>
</task>

</tasks>

<verification>
- [ ] `npx prisma validate` passes
- [ ] `npm run build` in apps/backend succeeds
- [ ] SavedView model has entityType discriminator
- [ ] Filters stored as JSON with TypeScript interfaces
- [ ] Filter validation catches invalid enum values
- [ ] Default view toggle unsets other defaults
</verification>

<success_criteria>
1. SavedView Prisma model exists with entityType and filters
2. Views support personal and shared visibility
3. Filter validation on create/update and apply
4. Default view management per entity type
5. Usage tracking (lastUsedAt, useCount) for analytics
</success_criteria>

<output>
After completion, create `.planning/phases/06-case-management/06-04-SUMMARY.md`
</output>
