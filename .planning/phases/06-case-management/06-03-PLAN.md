---
phase: 06-case-management
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/remediation/remediation.module.ts
  - apps/backend/src/modules/remediation/remediation.service.ts
  - apps/backend/src/modules/remediation/remediation-step.service.ts
  - apps/backend/src/modules/remediation/remediation.controller.ts
  - apps/backend/src/modules/remediation/dto/remediation.dto.ts
  - apps/backend/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "RemediationPlan model exists linking to Cases"
    - "RemediationStep model tracks individual steps with assignees"
    - "Steps can be assigned to users or external contacts (email)"
    - "Remediation plans track completion status independently of case closure"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "RemediationPlan and RemediationStep models"
      contains: "model RemediationPlan"
    - path: "apps/backend/src/modules/remediation/remediation.service.ts"
      provides: "Remediation plan CRUD"
      exports: ["RemediationService"]
    - path: "apps/backend/src/modules/remediation/remediation-step.service.ts"
      provides: "Step management with assignment"
      exports: ["RemediationStepService"]
  key_links:
    - from: "remediation.controller.ts"
      to: "remediation.service.ts"
      via: "DI injection"
      pattern: "constructor.*RemediationService"
---

<objective>
Create the RemediationPlan and RemediationStep models and services for tracking post-investigation remediation with assignees, due dates, and completion evidence.

Purpose: Remediation plans ensure findings are addressed with clear accountability. Plans continue independently after case closure for complete audit trail.

Output: Prisma models, DTOs, services for plan and step management, REST controller
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-case-management/06-CONTEXT.md
@.planning/phases/06-case-management/06-RESEARCH.md
@apps/backend/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RemediationPlan and RemediationStep models to Prisma schema</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
Add the following to schema.prisma:

1. RemediationStatus enum:
```prisma
enum RemediationStatus {
  DRAFT
  ACTIVE
  PAUSED
  COMPLETED
  CANCELLED

  @@map("remediation_status")
}
```

2. StepStatus enum:
```prisma
enum StepStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  SKIPPED
  BLOCKED

  @@map("step_status")
}
```

3. RemediationPlan model:
```prisma
model RemediationPlan {
  id              String   @id @default(uuid())
  organizationId  String   @map("organization_id")
  caseId          String   @map("case_id")

  // Link to specific finding (not just case)
  findingId       String?  @map("finding_id")
  findingDescription String? @map("finding_description")

  // Plan details
  title           String
  description     String?

  // Template (optional)
  templateId      String?  @map("template_id")
  templateVersion Int?     @map("template_version")

  // Status
  status          RemediationStatus @default(DRAFT)
  dueDate         DateTime? @map("due_date")
  completedAt     DateTime? @map("completed_at")
  completedById   String?   @map("completed_by_id")

  // Summary (denormalized for queries)
  totalSteps      Int      @default(0) @map("total_steps")
  completedSteps  Int      @default(0) @map("completed_steps")
  overdueSteps    Int      @default(0) @map("overdue_steps")

  // Owner
  ownerId         String   @map("owner_id")

  // Timestamps
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  createdById     String   @map("created_by_id")

  // Relations
  organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  case            Case @relation(fields: [caseId], references: [id], onDelete: Cascade)
  steps           RemediationStep[]

  @@index([organizationId])
  @@index([organizationId, caseId])
  @@index([organizationId, status])
  @@index([organizationId, ownerId])
  @@index([organizationId, dueDate])
  @@map("remediation_plans")
}
```

4. RemediationStep model:
```prisma
model RemediationStep {
  id              String   @id @default(uuid())
  planId          String   @map("plan_id")
  organizationId  String   @map("organization_id")

  // Step details
  order           Int
  title           String
  description     String?
  dueDate         DateTime? @map("due_date")

  // Assignment (user OR external contact)
  assigneeUserId  String?  @map("assignee_user_id")
  assigneeEmail   String?  @map("assignee_email")  // For non-users
  assigneeName    String?  @map("assignee_name")

  // Completion
  status          StepStatus @default(PENDING)
  requiresCoApproval Boolean @default(false) @map("requires_co_approval")
  completedAt     DateTime? @map("completed_at")
  completedById   String?  @map("completed_by_id")
  completionNotes String?  @map("completion_notes") @db.Text
  completionEvidence Json? @map("completion_evidence")  // Attachment IDs, links

  // Approval (if requiresCoApproval)
  approvedById    String?  @map("approved_by_id")
  approvedAt      DateTime? @map("approved_at")
  approvalNotes   String?  @map("approval_notes")

  // Dependencies (other step IDs that must complete first)
  dependsOnStepIds String[] @default([]) @map("depends_on_step_ids")

  // Notifications
  reminderSentAt  DateTime? @map("reminder_sent_at")
  escalatedAt     DateTime? @map("escalated_at")

  // Timestamps
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  plan            RemediationPlan @relation(fields: [planId], references: [id], onDelete: Cascade)

  @@index([planId])
  @@index([organizationId])
  @@index([organizationId, assigneeUserId])
  @@index([organizationId, status, dueDate])
  @@map("remediation_steps")
}
```

5. RemediationTemplate model:
```prisma
model RemediationTemplate {
  id              String   @id @default(uuid())
  organizationId  String   @map("organization_id")

  name            String
  description     String?
  categoryId      String?  @map("category_id")

  // Steps template (JSON)
  steps           Json     // Array of { order, title, description, roleSlug, requiresCoApproval, dueDaysOffset }

  isActive        Boolean  @default(true) @map("is_active")
  isSystem        Boolean  @default(false) @map("is_system")

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  createdById     String   @map("created_by_id")

  // Relations
  organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([organizationId, name])
  @@index([organizationId])
  @@index([organizationId, categoryId])
  @@map("remediation_templates")
}
```

6. Add relations to Organization and Case models:
- Organization: `remediationPlans RemediationPlan[]` and `remediationTemplates RemediationTemplate[]`
- Case: `remediationPlans RemediationPlan[]`

Run: `cd apps/backend && npx prisma db push`
  </action>
  <verify>npx prisma validate passes. Database has remediation_plans and remediation_steps tables.</verify>
  <done>RemediationPlan and RemediationStep models exist with proper relations and enums.</done>
</task>

<task type="auto">
  <name>Task 2: Create Remediation DTOs and Services</name>
  <files>
    apps/backend/src/modules/remediation/dto/remediation.dto.ts
    apps/backend/src/modules/remediation/remediation.service.ts
    apps/backend/src/modules/remediation/remediation-step.service.ts
  </files>
  <action>
Create directory: `apps/backend/src/modules/remediation/`

**dto/remediation.dto.ts:**
```typescript
import { IsString, IsOptional, IsEnum, IsBoolean, IsUUID, IsInt, IsArray, IsDateString, IsEmail, Min, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';
import { RemediationStatus, StepStatus } from '@prisma/client';

// Step template for creating from template
export interface StepTemplate {
  order: number;
  title: string;
  description?: string;
  roleSlug?: string;  // e.g., 'hr_director', 'it_manager' - resolved at apply time
  requiresCoApproval: boolean;
  dueDaysOffset?: number;  // Days from plan start
}

export class CreateRemediationPlanDto {
  @IsUUID()
  caseId: string;

  @IsString()
  title: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsUUID()
  @IsOptional()
  findingId?: string;

  @IsString()
  @IsOptional()
  findingDescription?: string;

  @IsDateString()
  @IsOptional()
  dueDate?: string;

  @IsUUID()
  @IsOptional()
  ownerId?: string;

  @IsUUID()
  @IsOptional()
  templateId?: string;
}

export class UpdateRemediationPlanDto {
  @IsString()
  @IsOptional()
  title?: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsString()
  @IsOptional()
  findingDescription?: string;

  @IsEnum(RemediationStatus)
  @IsOptional()
  status?: RemediationStatus;

  @IsDateString()
  @IsOptional()
  dueDate?: string;

  @IsUUID()
  @IsOptional()
  ownerId?: string;
}

export class CreateRemediationStepDto {
  @IsUUID()
  planId: string;

  @IsInt()
  @Min(0)
  order: number;

  @IsString()
  title: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsDateString()
  @IsOptional()
  dueDate?: string;

  @IsUUID()
  @IsOptional()
  assigneeUserId?: string;

  @IsEmail()
  @IsOptional()
  assigneeEmail?: string;

  @IsString()
  @IsOptional()
  assigneeName?: string;

  @IsBoolean()
  @IsOptional()
  requiresCoApproval?: boolean;

  @IsArray()
  @IsUUID('4', { each: true })
  @IsOptional()
  dependsOnStepIds?: string[];
}

export class UpdateRemediationStepDto {
  @IsInt()
  @Min(0)
  @IsOptional()
  order?: number;

  @IsString()
  @IsOptional()
  title?: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsDateString()
  @IsOptional()
  dueDate?: string;

  @IsUUID()
  @IsOptional()
  assigneeUserId?: string;

  @IsEmail()
  @IsOptional()
  assigneeEmail?: string;

  @IsString()
  @IsOptional()
  assigneeName?: string;

  @IsBoolean()
  @IsOptional()
  requiresCoApproval?: boolean;

  @IsArray()
  @IsUUID('4', { each: true })
  @IsOptional()
  dependsOnStepIds?: string[];
}

export class CompleteStepDto {
  @IsString()
  @IsOptional()
  completionNotes?: string;

  @IsOptional()
  completionEvidence?: { attachmentIds?: string[]; links?: string[] };
}

export class ApproveStepDto {
  @IsString()
  @IsOptional()
  approvalNotes?: string;
}

export class RemediationQueryDto {
  @IsUUID()
  @IsOptional()
  caseId?: string;

  @IsEnum(RemediationStatus)
  @IsOptional()
  status?: RemediationStatus;

  @IsUUID()
  @IsOptional()
  ownerId?: string;

  @IsBoolean()
  @IsOptional()
  @Type(() => Boolean)
  overdue?: boolean;

  @IsInt()
  @Min(1)
  @IsOptional()
  @Type(() => Number)
  page?: number = 1;

  @IsInt()
  @Min(1)
  @IsOptional()
  @Type(() => Number)
  limit?: number = 20;
}

// Template DTOs
export class CreateRemediationTemplateDto {
  @IsString()
  name: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsUUID()
  @IsOptional()
  categoryId?: string;

  @IsArray()
  steps: StepTemplate[];
}
```

**remediation.service.ts:**
```typescript
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { RemediationStatus, Prisma } from '@prisma/client';
import {
  CreateRemediationPlanDto,
  UpdateRemediationPlanDto,
  RemediationQueryDto,
  CreateRemediationTemplateDto,
  StepTemplate,
} from './dto/remediation.dto';

@Injectable()
export class RemediationService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  async create(
    organizationId: string,
    userId: string,
    dto: CreateRemediationPlanDto,
  ) {
    // If template provided, we'll create steps from it
    let templateSteps: StepTemplate[] | null = null;
    if (dto.templateId) {
      const template = await this.prisma.remediationTemplate.findFirst({
        where: { id: dto.templateId, organizationId },
      });
      if (template) {
        templateSteps = template.steps as StepTemplate[];
      }
    }

    const plan = await this.prisma.remediationPlan.create({
      data: {
        organizationId,
        caseId: dto.caseId,
        title: dto.title,
        description: dto.description,
        findingId: dto.findingId,
        findingDescription: dto.findingDescription,
        dueDate: dto.dueDate ? new Date(dto.dueDate) : null,
        ownerId: dto.ownerId || userId,
        templateId: dto.templateId,
        createdById: userId,
        totalSteps: templateSteps?.length || 0,
      },
    });

    // Create steps from template if provided
    if (templateSteps && templateSteps.length > 0) {
      const planStartDate = new Date();
      await this.prisma.remediationStep.createMany({
        data: templateSteps.map(step => ({
          planId: plan.id,
          organizationId,
          order: step.order,
          title: step.title,
          description: step.description,
          requiresCoApproval: step.requiresCoApproval,
          dueDate: step.dueDaysOffset
            ? new Date(planStartDate.getTime() + step.dueDaysOffset * 24 * 60 * 60 * 1000)
            : null,
        })),
      });
    }

    this.eventEmitter.emit('remediation.plan.created', {
      organizationId,
      planId: plan.id,
      caseId: dto.caseId,
      userId,
    });

    return this.findById(organizationId, plan.id);
  }

  async findById(organizationId: string, id: string) {
    const plan = await this.prisma.remediationPlan.findFirst({
      where: { id, organizationId },
      include: {
        steps: {
          orderBy: { order: 'asc' },
        },
        case: {
          select: { id: true, referenceNumber: true, status: true },
        },
      },
    });

    if (!plan) {
      throw new NotFoundException('Remediation plan not found');
    }

    return plan;
  }

  async findByCase(organizationId: string, caseId: string) {
    return this.prisma.remediationPlan.findMany({
      where: { organizationId, caseId },
      include: {
        steps: {
          orderBy: { order: 'asc' },
        },
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  async findAll(organizationId: string, query: RemediationQueryDto) {
    const where: Prisma.RemediationPlanWhereInput = {
      organizationId,
      ...(query.caseId && { caseId: query.caseId }),
      ...(query.status && { status: query.status }),
      ...(query.ownerId && { ownerId: query.ownerId }),
      ...(query.overdue && {
        dueDate: { lt: new Date() },
        status: { in: [RemediationStatus.DRAFT, RemediationStatus.ACTIVE] },
      }),
    };

    const [plans, total] = await Promise.all([
      this.prisma.remediationPlan.findMany({
        where,
        include: {
          case: {
            select: { id: true, referenceNumber: true },
          },
          _count: {
            select: { steps: true },
          },
        },
        orderBy: { createdAt: 'desc' },
        skip: ((query.page || 1) - 1) * (query.limit || 20),
        take: query.limit || 20,
      }),
      this.prisma.remediationPlan.count({ where }),
    ]);

    return {
      data: plans,
      meta: {
        total,
        page: query.page || 1,
        limit: query.limit || 20,
        totalPages: Math.ceil(total / (query.limit || 20)),
      },
    };
  }

  async update(
    organizationId: string,
    id: string,
    userId: string,
    dto: UpdateRemediationPlanDto,
  ) {
    await this.findById(organizationId, id);

    const plan = await this.prisma.remediationPlan.update({
      where: { id },
      data: {
        ...(dto.title && { title: dto.title }),
        ...(dto.description !== undefined && { description: dto.description }),
        ...(dto.findingDescription !== undefined && { findingDescription: dto.findingDescription }),
        ...(dto.status && { status: dto.status }),
        ...(dto.dueDate && { dueDate: new Date(dto.dueDate) }),
        ...(dto.ownerId && { ownerId: dto.ownerId }),
      },
    });

    this.eventEmitter.emit('remediation.plan.updated', {
      organizationId,
      planId: id,
      userId,
    });

    return plan;
  }

  async activate(organizationId: string, id: string, userId: string) {
    const plan = await this.findById(organizationId, id);

    if (plan.status !== RemediationStatus.DRAFT) {
      throw new BadRequestException('Only draft plans can be activated');
    }

    return this.update(organizationId, id, userId, {
      status: RemediationStatus.ACTIVE,
    });
  }

  async complete(organizationId: string, id: string, userId: string) {
    const plan = await this.findById(organizationId, id);

    // Check all required steps are completed
    const incompleteSteps = plan.steps.filter(
      s => s.status !== 'COMPLETED' && s.status !== 'SKIPPED'
    );

    if (incompleteSteps.length > 0) {
      throw new BadRequestException(
        `Cannot complete plan: ${incompleteSteps.length} steps still pending`
      );
    }

    return this.prisma.remediationPlan.update({
      where: { id },
      data: {
        status: RemediationStatus.COMPLETED,
        completedAt: new Date(),
        completedById: userId,
      },
    });
  }

  async cancel(organizationId: string, id: string, userId: string) {
    await this.findById(organizationId, id);

    return this.prisma.remediationPlan.update({
      where: { id },
      data: {
        status: RemediationStatus.CANCELLED,
      },
    });
  }

  async updateStepCounts(planId: string) {
    const steps = await this.prisma.remediationStep.findMany({
      where: { planId },
    });

    const totalSteps = steps.length;
    const completedSteps = steps.filter(s => s.status === 'COMPLETED').length;
    const overdueSteps = steps.filter(
      s => s.dueDate && new Date(s.dueDate) < new Date() && s.status === 'PENDING'
    ).length;

    await this.prisma.remediationPlan.update({
      where: { id: planId },
      data: { totalSteps, completedSteps, overdueSteps },
    });
  }

  // ===== Templates =====

  async createTemplate(
    organizationId: string,
    userId: string,
    dto: CreateRemediationTemplateDto,
  ) {
    return this.prisma.remediationTemplate.create({
      data: {
        organizationId,
        name: dto.name,
        description: dto.description,
        categoryId: dto.categoryId,
        steps: dto.steps as unknown as Prisma.JsonValue,
        createdById: userId,
      },
    });
  }

  async findAllTemplates(organizationId: string, categoryId?: string) {
    return this.prisma.remediationTemplate.findMany({
      where: {
        organizationId,
        isActive: true,
        ...(categoryId && { categoryId }),
      },
      orderBy: { name: 'asc' },
    });
  }
}
```

**remediation-step.service.ts:**
```typescript
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { StepStatus } from '@prisma/client';
import {
  CreateRemediationStepDto,
  UpdateRemediationStepDto,
  CompleteStepDto,
  ApproveStepDto,
} from './dto/remediation.dto';
import { RemediationService } from './remediation.service';

@Injectable()
export class RemediationStepService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly eventEmitter: EventEmitter2,
    private readonly remediationService: RemediationService,
  ) {}

  async create(
    organizationId: string,
    userId: string,
    dto: CreateRemediationStepDto,
  ) {
    // Validate dependencies form a DAG (no circular dependencies)
    if (dto.dependsOnStepIds?.length) {
      await this.validateDependencies(dto.planId, dto.dependsOnStepIds);
    }

    const step = await this.prisma.remediationStep.create({
      data: {
        planId: dto.planId,
        organizationId,
        order: dto.order,
        title: dto.title,
        description: dto.description,
        dueDate: dto.dueDate ? new Date(dto.dueDate) : null,
        assigneeUserId: dto.assigneeUserId,
        assigneeEmail: dto.assigneeEmail,
        assigneeName: dto.assigneeName,
        requiresCoApproval: dto.requiresCoApproval || false,
        dependsOnStepIds: dto.dependsOnStepIds || [],
      },
    });

    // Update plan step counts
    await this.remediationService.updateStepCounts(dto.planId);

    this.eventEmitter.emit('remediation.step.created', {
      organizationId,
      stepId: step.id,
      planId: dto.planId,
      userId,
    });

    return step;
  }

  async findById(organizationId: string, id: string) {
    const step = await this.prisma.remediationStep.findFirst({
      where: { id, organizationId },
      include: {
        plan: {
          select: { id: true, title: true, caseId: true, status: true },
        },
      },
    });

    if (!step) {
      throw new NotFoundException('Remediation step not found');
    }

    return step;
  }

  async update(
    organizationId: string,
    id: string,
    dto: UpdateRemediationStepDto,
  ) {
    const existing = await this.findById(organizationId, id);

    if (dto.dependsOnStepIds?.length) {
      await this.validateDependencies(existing.planId, dto.dependsOnStepIds, id);
    }

    const step = await this.prisma.remediationStep.update({
      where: { id },
      data: {
        ...(dto.order !== undefined && { order: dto.order }),
        ...(dto.title && { title: dto.title }),
        ...(dto.description !== undefined && { description: dto.description }),
        ...(dto.dueDate && { dueDate: new Date(dto.dueDate) }),
        ...(dto.assigneeUserId !== undefined && { assigneeUserId: dto.assigneeUserId }),
        ...(dto.assigneeEmail !== undefined && { assigneeEmail: dto.assigneeEmail }),
        ...(dto.assigneeName !== undefined && { assigneeName: dto.assigneeName }),
        ...(dto.requiresCoApproval !== undefined && { requiresCoApproval: dto.requiresCoApproval }),
        ...(dto.dependsOnStepIds && { dependsOnStepIds: dto.dependsOnStepIds }),
      },
    });

    return step;
  }

  async complete(
    organizationId: string,
    id: string,
    userId: string,
    dto: CompleteStepDto,
  ) {
    const step = await this.findById(organizationId, id);

    // Check dependencies are satisfied
    if (step.dependsOnStepIds.length > 0) {
      const dependencySteps = await this.prisma.remediationStep.findMany({
        where: { id: { in: step.dependsOnStepIds } },
      });

      const unmetDependencies = dependencySteps.filter(
        s => s.status !== StepStatus.COMPLETED && s.status !== StepStatus.SKIPPED
      );

      if (unmetDependencies.length > 0) {
        throw new BadRequestException(
          `Cannot complete: ${unmetDependencies.length} prerequisite steps incomplete`
        );
      }
    }

    const updatedStep = await this.prisma.remediationStep.update({
      where: { id },
      data: {
        status: step.requiresCoApproval ? StepStatus.COMPLETED : StepStatus.COMPLETED,
        completedAt: new Date(),
        completedById: userId,
        completionNotes: dto.completionNotes,
        completionEvidence: dto.completionEvidence as any,
      },
    });

    // Update plan step counts
    await this.remediationService.updateStepCounts(step.planId);

    this.eventEmitter.emit('remediation.step.completed', {
      organizationId,
      stepId: id,
      planId: step.planId,
      userId,
      requiresApproval: step.requiresCoApproval,
    });

    return updatedStep;
  }

  async approve(
    organizationId: string,
    id: string,
    userId: string,
    dto: ApproveStepDto,
  ) {
    const step = await this.findById(organizationId, id);

    if (!step.requiresCoApproval) {
      throw new BadRequestException('This step does not require approval');
    }

    if (step.status !== StepStatus.COMPLETED) {
      throw new BadRequestException('Step must be completed before approval');
    }

    const updatedStep = await this.prisma.remediationStep.update({
      where: { id },
      data: {
        approvedById: userId,
        approvedAt: new Date(),
        approvalNotes: dto.approvalNotes,
      },
    });

    this.eventEmitter.emit('remediation.step.approved', {
      organizationId,
      stepId: id,
      planId: step.planId,
      userId,
    });

    return updatedStep;
  }

  async skip(organizationId: string, id: string, userId: string, reason: string) {
    const step = await this.findById(organizationId, id);

    const updatedStep = await this.prisma.remediationStep.update({
      where: { id },
      data: {
        status: StepStatus.SKIPPED,
        completionNotes: `Skipped: ${reason}`,
        completedAt: new Date(),
        completedById: userId,
      },
    });

    await this.remediationService.updateStepCounts(step.planId);

    return updatedStep;
  }

  async delete(organizationId: string, id: string) {
    const step = await this.findById(organizationId, id);

    await this.prisma.remediationStep.delete({ where: { id } });

    await this.remediationService.updateStepCounts(step.planId);
  }

  async reorder(organizationId: string, planId: string, stepOrders: { id: string; order: number }[]) {
    await this.prisma.$transaction(
      stepOrders.map(({ id, order }) =>
        this.prisma.remediationStep.updateMany({
          where: { id, organizationId, planId },
          data: { order },
        })
      )
    );
  }

  // Validate no circular dependencies
  private async validateDependencies(
    planId: string,
    dependsOnStepIds: string[],
    excludeStepId?: string,
  ) {
    const allSteps = await this.prisma.remediationStep.findMany({
      where: { planId },
      select: { id: true, dependsOnStepIds: true },
    });

    const visited = new Set<string>();
    const recursionStack = new Set<string>();

    const hasCycle = (stepId: string): boolean => {
      if (recursionStack.has(stepId)) return true;
      if (visited.has(stepId)) return false;

      visited.add(stepId);
      recursionStack.add(stepId);

      const step = allSteps.find(s => s.id === stepId);
      const deps = step?.dependsOnStepIds || [];

      for (const depId of deps) {
        if (hasCycle(depId)) return true;
      }

      recursionStack.delete(stepId);
      return false;
    };

    // Temporarily add the new dependencies to check
    if (excludeStepId) {
      const idx = allSteps.findIndex(s => s.id === excludeStepId);
      if (idx !== -1) {
        allSteps[idx] = { ...allSteps[idx], dependsOnStepIds: dependsOnStepIds };
      }
    }

    for (const stepId of dependsOnStepIds) {
      if (hasCycle(stepId)) {
        throw new BadRequestException('Circular dependency detected');
      }
    }
  }

  // Get steps assigned to a user
  async findByAssignee(organizationId: string, userId: string, email?: string) {
    return this.prisma.remediationStep.findMany({
      where: {
        organizationId,
        OR: [
          { assigneeUserId: userId },
          ...(email ? [{ assigneeEmail: email }] : []),
        ],
        status: { in: [StepStatus.PENDING, StepStatus.IN_PROGRESS] },
      },
      include: {
        plan: {
          select: { id: true, title: true, caseId: true },
        },
      },
      orderBy: [
        { dueDate: 'asc' },
        { createdAt: 'asc' },
      ],
    });
  }
}
```

Create index file: `apps/backend/src/modules/remediation/index.ts`
```typescript
export * from './remediation.service';
export * from './remediation-step.service';
export * from './dto/remediation.dto';
```
  </action>
  <verify>TypeScript compiles without errors. Services handle plan/step lifecycle and dependency validation.</verify>
  <done>RemediationService and RemediationStepService provide full remediation management with DAG validation.</done>
</task>

<task type="auto">
  <name>Task 3: Create Remediation Controller and Module</name>
  <files>
    apps/backend/src/modules/remediation/remediation.controller.ts
    apps/backend/src/modules/remediation/remediation.module.ts
    apps/backend/src/app.module.ts
  </files>
  <action>
**remediation.controller.ts:**
```typescript
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
  ParseUUIDPipe,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { CurrentUser } from '../auth/decorators/current-user.decorator';
import { UserRole } from '@prisma/client';
import { RemediationService } from './remediation.service';
import { RemediationStepService } from './remediation-step.service';
import {
  CreateRemediationPlanDto,
  UpdateRemediationPlanDto,
  RemediationQueryDto,
  CreateRemediationStepDto,
  UpdateRemediationStepDto,
  CompleteStepDto,
  ApproveStepDto,
  CreateRemediationTemplateDto,
} from './dto/remediation.dto';

interface AuthUser {
  id: string;
  organizationId: string;
  email: string;
  role: UserRole;
}

@Controller('api/v1/remediation')
@UseGuards(JwtAuthGuard, RolesGuard)
export class RemediationController {
  constructor(
    private readonly remediationService: RemediationService,
    private readonly stepService: RemediationStepService,
  ) {}

  // ===== Plans =====

  @Post('plans')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async createPlan(
    @CurrentUser() user: AuthUser,
    @Body() dto: CreateRemediationPlanDto,
  ) {
    return this.remediationService.create(user.organizationId, user.id, dto);
  }

  @Get('plans')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async findAllPlans(
    @CurrentUser() user: AuthUser,
    @Query() query: RemediationQueryDto,
  ) {
    return this.remediationService.findAll(user.organizationId, query);
  }

  @Get('plans/:id')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async findPlan(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    return this.remediationService.findById(user.organizationId, id);
  }

  @Get('plans/by-case/:caseId')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async findPlansByCase(
    @CurrentUser() user: AuthUser,
    @Param('caseId', ParseUUIDPipe) caseId: string,
  ) {
    return this.remediationService.findByCase(user.organizationId, caseId);
  }

  @Put('plans/:id')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async updatePlan(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
    @Body() dto: UpdateRemediationPlanDto,
  ) {
    return this.remediationService.update(user.organizationId, id, user.id, dto);
  }

  @Post('plans/:id/activate')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async activatePlan(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    return this.remediationService.activate(user.organizationId, id, user.id);
  }

  @Post('plans/:id/complete')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async completePlan(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    return this.remediationService.complete(user.organizationId, id, user.id);
  }

  @Post('plans/:id/cancel')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async cancelPlan(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    return this.remediationService.cancel(user.organizationId, id, user.id);
  }

  // ===== Steps =====

  @Post('steps')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async createStep(
    @CurrentUser() user: AuthUser,
    @Body() dto: CreateRemediationStepDto,
  ) {
    return this.stepService.create(user.organizationId, user.id, dto);
  }

  @Get('steps/:id')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async findStep(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    return this.stepService.findById(user.organizationId, id);
  }

  @Put('steps/:id')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async updateStep(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
    @Body() dto: UpdateRemediationStepDto,
  ) {
    return this.stepService.update(user.organizationId, id, dto);
  }

  @Post('steps/:id/complete')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR, UserRole.MANAGER)
  async completeStep(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
    @Body() dto: CompleteStepDto,
  ) {
    return this.stepService.complete(user.organizationId, id, user.id, dto);
  }

  @Post('steps/:id/approve')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async approveStep(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
    @Body() dto: ApproveStepDto,
  ) {
    return this.stepService.approve(user.organizationId, id, user.id, dto);
  }

  @Post('steps/:id/skip')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async skipStep(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
    @Body('reason') reason: string,
  ) {
    return this.stepService.skip(user.organizationId, id, user.id, reason);
  }

  @Delete('steps/:id')
  @HttpCode(HttpStatus.NO_CONTENT)
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async deleteStep(
    @CurrentUser() user: AuthUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    await this.stepService.delete(user.organizationId, id);
  }

  @Put('plans/:planId/steps/reorder')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async reorderSteps(
    @CurrentUser() user: AuthUser,
    @Param('planId', ParseUUIDPipe) planId: string,
    @Body() stepOrders: { id: string; order: number }[],
  ) {
    await this.stepService.reorder(user.organizationId, planId, stepOrders);
    return { success: true };
  }

  // ===== My Assignments =====

  @Get('my-steps')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR, UserRole.MANAGER, UserRole.EMPLOYEE)
  async findMySteps(@CurrentUser() user: AuthUser) {
    return this.stepService.findByAssignee(user.organizationId, user.id, user.email);
  }

  // ===== Templates =====

  @Post('templates')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async createTemplate(
    @CurrentUser() user: AuthUser,
    @Body() dto: CreateRemediationTemplateDto,
  ) {
    return this.remediationService.createTemplate(user.organizationId, user.id, dto);
  }

  @Get('templates')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async findAllTemplates(
    @CurrentUser() user: AuthUser,
    @Query('categoryId') categoryId?: string,
  ) {
    return this.remediationService.findAllTemplates(user.organizationId, categoryId);
  }
}
```

**remediation.module.ts:**
```typescript
import { Module, forwardRef } from '@nestjs/common';
import { PrismaModule } from '../../prisma/prisma.module';
import { RemediationService } from './remediation.service';
import { RemediationStepService } from './remediation-step.service';
import { RemediationController } from './remediation.controller';

@Module({
  imports: [PrismaModule],
  controllers: [RemediationController],
  providers: [RemediationService, RemediationStepService],
  exports: [RemediationService, RemediationStepService],
})
export class RemediationModule {}
```

**Update app.module.ts** to import RemediationModule.
  </action>
  <verify>
Run `cd apps/backend && npm run build` - compiles successfully.
Endpoints /api/v1/remediation/plans and /api/v1/remediation/steps accessible.
  </verify>
  <done>Remediation endpoints support full plan and step management with dependency validation.</done>
</task>

</tasks>

<verification>
- [ ] `npx prisma validate` passes
- [ ] `npm run build` in apps/backend succeeds
- [ ] RemediationPlan model has status enum and step counts
- [ ] RemediationStep model supports user and email assignees
- [ ] Step dependencies validated as DAG (no cycles)
- [ ] Plans track completion independently of case status
</verification>

<success_criteria>
1. RemediationPlan and RemediationStep Prisma models exist
2. Steps support both user assignment and external email contacts
3. Dependency validation prevents circular references
4. Plan completion requires all steps completed or skipped
5. Step approval workflow for requiresCoApproval steps
</success_criteria>

<output>
After completion, create `.planning/phases/06-case-management/06-03-SUMMARY.md`
</output>
