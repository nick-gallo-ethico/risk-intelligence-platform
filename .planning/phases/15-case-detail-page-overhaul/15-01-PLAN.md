---
phase: 15-case-detail-page-overhaul
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/src/modules/cases/cases.controller.ts
  - apps/backend/src/modules/cases/cases.module.ts
  - apps/backend/src/modules/cases/dto/merge-case.dto.ts
  - apps/backend/src/modules/cases/dto/index.ts
  - apps/backend/src/modules/associations/person-case/person-case-association.controller.ts
  - apps/backend/src/modules/associations/person-case/person-case-association.module.ts
autonomous: true

must_haves:
  truths:
    - "POST /cases/:id/merge returns merged case result with audit trail"
    - "GET /cases/:id/merge-history returns array of merge records"
    - "GET /cases/:id/can-merge/:targetId returns boolean feasibility check"
    - "GET /cases/:id/persons returns connected people with evidentiary/role labels"
    - "POST /cases/:id/persons creates person-case association with label"
  artifacts:
    - path: "apps/backend/src/modules/cases/cases.controller.ts"
      provides: "Merge endpoints (POST merge, GET merge-history, GET can-merge)"
      contains: "mergeCases"
    - path: "apps/backend/src/modules/cases/dto/merge-case.dto.ts"
      provides: "MergeCaseDto validation"
      contains: "class MergeCaseDto"
    - path: "apps/backend/src/modules/associations/person-case/person-case-association.controller.ts"
      provides: "Person-case REST endpoints"
      contains: "PersonCaseAssociationController"
  key_links:
    - from: "cases.controller.ts"
      to: "case-merge.service.ts"
      via: "CaseMergeService injection"
      pattern: "caseMergeService\\.merge"
    - from: "person-case-association.controller.ts"
      to: "person-case-association.service.ts"
      via: "PersonCaseAssociationService injection"
      pattern: "personCaseAssociationService\\."
---

<objective>
Expose missing backend REST endpoints that the frontend case detail page needs: case merge operations, person-case association CRUD, and verify the activity timeline API path.

Purpose: The backend services for merge and person-case associations are fully implemented but have no REST controllers/endpoints. The frontend will 404 when trying to call these features without this plan.

Output: New controller endpoints wired to existing services — no new business logic, just REST exposure.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/backend/src/modules/cases/cases.controller.ts
@apps/backend/src/modules/cases/case-merge.service.ts
@apps/backend/src/modules/associations/person-case/person-case-association.service.ts
@apps/backend/src/modules/cases/cases.module.ts
@apps/backend/src/modules/associations/person-case/person-case-association.module.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add merge endpoints to CasesController</name>
  <files>
    apps/backend/src/modules/cases/cases.controller.ts
    apps/backend/src/modules/cases/dto/merge-case.dto.ts
    apps/backend/src/modules/cases/dto/index.ts
    apps/backend/src/modules/cases/cases.module.ts
  </files>
  <action>
    1. Create `merge-case.dto.ts` with:
       - `MergeCaseDto`: `sourceCaseId` (UUID, required), `reason` (string, required, min 10 chars)
       - Use class-validator decorators: @IsUUID(), @IsString(), @MinLength(10)

    2. Export MergeCaseDto from `dto/index.ts`

    3. In `cases.module.ts`, verify CaseMergeService is already imported/provided. If not, add it to providers.

    4. In `cases.controller.ts`:
       - Import CaseMergeService and inject it in the constructor
       - Add three endpoints:

       ```typescript
       @Post(':id/merge')
       @Roles(UserRole.COMPLIANCE_OFFICER, UserRole.SYSTEM_ADMIN)
       @UseGuards(RolesGuard)
       @ApiOperation({ summary: 'Merge cases', description: 'Merge source case into target case' })
       @ApiParam({ name: 'id', description: 'Target case UUID' })
       async mergeCases(
         @Param('id', ParseUUIDPipe) id: string,
         @Body() dto: MergeCaseDto,
         @CurrentUser() user: RequestUser,
         @TenantId() organizationId: string,
       ) {
         return this.caseMergeService.merge(
           { sourceCaseId: dto.sourceCaseId, targetCaseId: id, reason: dto.reason },
           user.id,
           organizationId,
         );
       }

       @Get(':id/merge-history')
       @ApiOperation({ summary: 'Get merge history' })
       @ApiParam({ name: 'id', description: 'Case UUID' })
       async getMergeHistory(
         @Param('id', ParseUUIDPipe) id: string,
         @TenantId() organizationId: string,
       ) {
         return this.caseMergeService.getMergeHistory(id, organizationId);
       }

       @Get(':id/can-merge/:targetId')
       @ApiOperation({ summary: 'Check merge feasibility' })
       async canMerge(
         @Param('id', ParseUUIDPipe) id: string,
         @Param('targetId', ParseUUIDPipe) targetId: string,
         @TenantId() organizationId: string,
       ) {
         return this.caseMergeService.canMerge(id, targetId, organizationId);
       }
       ```

    IMPORTANT: Place the merge-history and can-merge routes BEFORE the generic `:id` GET route to avoid route conflicts. The `@Get(':id/merge-history')` must be above `@Get(':id')`. If the existing controller has `:id` GET early, add the new routes above it OR use NestJS route ordering (most specific first).

    Check the CaseMergeService method signatures. The merge method likely takes an object with {sourceCaseId, targetCaseId, reason}, userId, and organizationId. Match whatever signature exists in the service.

  </action>
  <verify>
    Run `cd apps/backend && npx tsc --noEmit` to verify TypeScript compiles without errors. Check that CaseMergeService is properly injectable by verifying it's in the module providers.
  </verify>
  <done>
    Three new REST endpoints on CasesController: POST :id/merge, GET :id/merge-history, GET :id/can-merge/:targetId. All delegate to existing CaseMergeService methods. MergeCaseDto validates input.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PersonCaseAssociation controller</name>
  <files>
    apps/backend/src/modules/associations/person-case/person-case-association.controller.ts
    apps/backend/src/modules/associations/person-case/person-case-association.module.ts
  </files>
  <action>
    1. Create `person-case-association.controller.ts` with:

    ```typescript
    @ApiTags('Case Associations')
    @ApiBearerAuth('JWT')
    @Controller('cases')
    @UseGuards(JwtAuthGuard, TenantGuard)
    export class PersonCaseAssociationController {
      constructor(
        private readonly personCaseAssociationService: PersonCaseAssociationService,
      ) {}

      @Get(':caseId/persons')
      @ApiOperation({ summary: 'Get connected people for a case' })
      async findByCase(
        @Param('caseId', ParseUUIDPipe) caseId: string,
        @TenantId() organizationId: string,
      ) {
        return this.personCaseAssociationService.findByCase(caseId, organizationId);
      }

      @Post(':caseId/persons')
      @Roles(UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR, UserRole.SYSTEM_ADMIN)
      @UseGuards(RolesGuard)
      @ApiOperation({ summary: 'Add person to case' })
      async create(
        @Param('caseId', ParseUUIDPipe) caseId: string,
        @Body() dto: CreatePersonCaseAssociationDto,
        @CurrentUser() user: RequestUser,
        @TenantId() organizationId: string,
      ) {
        return this.personCaseAssociationService.create({
          ...dto,
          caseId,
          organizationId,
          createdById: user.id,
        });
      }

      @Delete(':caseId/persons/:associationId')
      @Roles(UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR, UserRole.SYSTEM_ADMIN)
      @UseGuards(RolesGuard)
      @ApiOperation({ summary: 'Remove person from case' })
      async remove(
        @Param('caseId', ParseUUIDPipe) caseId: string,
        @Param('associationId', ParseUUIDPipe) associationId: string,
        @TenantId() organizationId: string,
      ) {
        return this.personCaseAssociationService.remove(associationId, organizationId);
      }
    }
    ```

    2. Create a DTO for the create operation. Check the PersonCaseAssociationService.create() method signature to match the expected input. It likely needs: personId, evidentiaryLabel (REPORTER, SUBJECT, WITNESS), roleLabel (optional), notes (optional). Create `CreatePersonCaseAssociationDto` in the same directory or a `dto/` subfolder.

    3. In `person-case-association.module.ts`, add the controller to the `controllers` array. Make sure PersonCaseAssociationService is in providers. Import necessary modules (JwtAuthGuard needs AuthModule or be available globally).

    4. IMPORTANT: Check if the module is imported in the main app module. If PersonCaseAssociationModule is already imported in AppModule or CasesModule, the controller will be auto-registered. If not, add the module import in the appropriate parent module.

  </action>
  <verify>
    Run `cd apps/backend && npx tsc --noEmit` to verify compilation. Verify that the module exports and imports are correct by checking that PersonCaseAssociationModule is in the imports array of its parent module.
  </verify>
  <done>
    PersonCaseAssociationController exists with GET :caseId/persons and POST :caseId/persons endpoints. Both delegate to existing PersonCaseAssociationService. The controller is registered in the module and accessible via the API.
  </done>
</task>

</tasks>

<verification>
1. `cd apps/backend && npx tsc --noEmit` compiles without errors
2. Verify merge endpoints exist by checking controller has `@Post(':id/merge')`, `@Get(':id/merge-history')`, `@Get(':id/can-merge/:targetId')` decorators
3. Verify person-case endpoints exist by checking controller has `@Get(':caseId/persons')` and `@Post(':caseId/persons')` decorators
4. No changes to existing service logic — only new controller routes
</verification>

<success_criteria>

- CasesController has 3 new merge-related endpoints delegating to CaseMergeService
- PersonCaseAssociationController has 2+ endpoints delegating to PersonCaseAssociationService
- All endpoints are protected with JwtAuthGuard + TenantGuard
- Merge and write operations require COMPLIANCE_OFFICER or SYSTEM_ADMIN roles
- TypeScript compiles without errors
  </success_criteria>

<output>
After completion, create `.planning/phases/15-case-detail-page-overhaul/15-01-SUMMARY.md`
</output>
