---
phase: 13-hubspot-style-saved-views-system
plan: 08
type: execute
wave: 3
depends_on: ["13-02", "13-03"]
files_modified:
  - apps/frontend/src/components/views/AdvancedFiltersPanel.tsx
  - apps/frontend/src/components/views/FilterGroupCard.tsx
  - apps/frontend/src/components/views/FilterConditionRow.tsx
  - apps/frontend/src/components/views/index.ts
autonomous: true

must_haves:
  truths:
    - "Panel slides out from right side of screen"
    - "Filter groups are joined by OR logic (max 2 groups)"
    - "Conditions within a group are joined by AND logic (max 20 per group)"
    - "Each condition has property selector, operator dropdown, and value input"
    - "Operators vary by property type (text, number, date, enum)"
    - "Filters apply in real-time as conditions change"
  artifacts:
    - path: "apps/frontend/src/components/views/AdvancedFiltersPanel.tsx"
      provides: "Right slide-out panel for advanced filter configuration"
      contains: "FilterGroup"
    - path: "apps/frontend/src/components/views/FilterConditionRow.tsx"
      provides: "Single filter condition with property, operator, value"
      contains: "getOperatorsForType"
  key_links:
    - from: "AdvancedFiltersPanel"
      to: "SavedViewContext"
      via: "useSavedViewContext"
      pattern: "setFilters"
---

<objective>
Create the Advanced Filters Panel as a right slide-out with AND/OR filter groups.

Purpose: Advanced filters allow complex filtering with multiple conditions grouped by AND/OR logic. The panel provides a structured UI for building filter expressions that are more powerful than quick filters.

Output: AdvancedFiltersPanel slide-out with filter groups, condition rows, and real-time filter application.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/hubspot-view-system-spec.md
@apps/frontend/src/components/views/SavedViewProvider.tsx
@apps/frontend/src/lib/views/types.ts
@apps/frontend/src/lib/views/operators.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FilterConditionRow component</name>
  <files>apps/frontend/src/components/views/FilterConditionRow.tsx</files>
  <action>
Create a single filter condition row with property, operator, and value:

```typescript
'use client';

import React from 'react';
import { X } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Calendar } from '@/components/ui/calendar';
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from '@/components/ui/popover';
import { format } from 'date-fns';
import { Calendar as CalendarIcon } from 'lucide-react';
import {
  ColumnConfig,
  FilterCondition,
  FilterOperator,
  PropertyType,
} from '@/lib/views/types';
import { getOperatorsForType, OPERATOR_LABELS } from '@/lib/views/operators';
import { MultiSelectFilter, FilterOption } from './MultiSelectFilter';
import { cn } from '@/lib/utils';

interface FilterConditionRowProps {
  condition: FilterCondition;
  columns: ColumnConfig[];
  onChange: (condition: FilterCondition) => void;
  onRemove: () => void;
}

export function FilterConditionRow({
  condition,
  columns,
  onChange,
  onRemove,
}: FilterConditionRowProps) {
  const column = columns.find((c) => c.id === condition.propertyId);
  const operators = column ? getOperatorsForType(column.type) : [];

  const handlePropertyChange = (propertyId: string) => {
    const newColumn = columns.find((c) => c.id === propertyId);
    const newOperators = newColumn ? getOperatorsForType(newColumn.type) : [];
    onChange({
      ...condition,
      propertyId,
      operator: newOperators[0] || 'is',
      value: undefined,
      secondaryValue: undefined,
    });
  };

  const handleOperatorChange = (operator: FilterOperator) => {
    onChange({
      ...condition,
      operator,
      // Clear value when switching to is_known/is_unknown
      value: ['is_known', 'is_unknown'].includes(operator) ? undefined : condition.value,
      secondaryValue: operator === 'is_between' ? condition.secondaryValue : undefined,
    });
  };

  const handleValueChange = (value: unknown) => {
    onChange({ ...condition, value });
  };

  const handleSecondaryValueChange = (secondaryValue: unknown) => {
    onChange({ ...condition, secondaryValue });
  };

  const handleUnitChange = (unit: 'day' | 'week' | 'month') => {
    onChange({ ...condition, unit });
  };

  const renderValueInput = () => {
    if (!column) return null;

    // No value input for known/unknown operators
    if (['is_known', 'is_unknown'].includes(condition.operator)) {
      return null;
    }

    switch (column.type) {
      case 'text':
      case 'string':
        if (['is_any_of', 'is_none_of'].includes(condition.operator)) {
          return (
            <Input
              placeholder="Enter values (comma-separated)"
              value={Array.isArray(condition.value) ? condition.value.join(', ') : ''}
              onChange={(e) =>
                handleValueChange(e.target.value.split(',').map((s) => s.trim()))
              }
              className="flex-1"
            />
          );
        }
        return (
          <Input
            placeholder="Enter value"
            value={(condition.value as string) || ''}
            onChange={(e) => handleValueChange(e.target.value)}
            className="flex-1"
          />
        );

      case 'number':
        if (condition.operator === 'is_between') {
          return (
            <div className="flex items-center gap-2 flex-1">
              <Input
                type="number"
                placeholder="Min"
                value={(condition.value as number) ?? ''}
                onChange={(e) => handleValueChange(Number(e.target.value))}
                className="w-24"
              />
              <span className="text-muted-foreground">and</span>
              <Input
                type="number"
                placeholder="Max"
                value={(condition.secondaryValue as number) ?? ''}
                onChange={(e) => handleSecondaryValueChange(Number(e.target.value))}
                className="w-24"
              />
            </div>
          );
        }
        return (
          <Input
            type="number"
            placeholder="Enter number"
            value={(condition.value as number) ?? ''}
            onChange={(e) => handleValueChange(Number(e.target.value))}
            className="flex-1"
          />
        );

      case 'date':
      case 'datetime':
        // Relative date operators
        if (['is_less_than_n_ago', 'is_more_than_n_ago'].includes(condition.operator)) {
          return (
            <div className="flex items-center gap-2 flex-1">
              <Input
                type="number"
                min="1"
                placeholder="N"
                value={(condition.value as number) ?? ''}
                onChange={(e) => handleValueChange(Number(e.target.value))}
                className="w-20"
              />
              <Select
                value={condition.unit || 'day'}
                onValueChange={(v) => handleUnitChange(v as 'day' | 'week' | 'month')}
              >
                <SelectTrigger className="w-24">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="day">days ago</SelectItem>
                  <SelectItem value="week">weeks ago</SelectItem>
                  <SelectItem value="month">months ago</SelectItem>
                </SelectContent>
              </Select>
            </div>
          );
        }

        // Date range (is_between)
        if (condition.operator === 'is_between') {
          return (
            <div className="flex items-center gap-2 flex-1">
              <Popover>
                <PopoverTrigger asChild>
                  <Button variant="outline" className="w-[140px] justify-start">
                    <CalendarIcon className="mr-2 h-4 w-4" />
                    {condition.value
                      ? format(new Date(condition.value as string), 'MMM d, yyyy')
                      : 'Start date'}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0">
                  <Calendar
                    mode="single"
                    selected={condition.value ? new Date(condition.value as string) : undefined}
                    onSelect={(date) => handleValueChange(date?.toISOString())}
                  />
                </PopoverContent>
              </Popover>
              <span className="text-muted-foreground">to</span>
              <Popover>
                <PopoverTrigger asChild>
                  <Button variant="outline" className="w-[140px] justify-start">
                    <CalendarIcon className="mr-2 h-4 w-4" />
                    {condition.secondaryValue
                      ? format(new Date(condition.secondaryValue as string), 'MMM d, yyyy')
                      : 'End date'}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0">
                  <Calendar
                    mode="single"
                    selected={
                      condition.secondaryValue
                        ? new Date(condition.secondaryValue as string)
                        : undefined
                    }
                    onSelect={(date) => handleSecondaryValueChange(date?.toISOString())}
                  />
                </PopoverContent>
              </Popover>
            </div>
          );
        }

        // Single date
        return (
          <Popover>
            <PopoverTrigger asChild>
              <Button variant="outline" className="flex-1 justify-start">
                <CalendarIcon className="mr-2 h-4 w-4" />
                {condition.value
                  ? format(new Date(condition.value as string), 'MMM d, yyyy')
                  : 'Select date'}
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-auto p-0">
              <Calendar
                mode="single"
                selected={condition.value ? new Date(condition.value as string) : undefined}
                onSelect={(date) => handleValueChange(date?.toISOString())}
              />
            </PopoverContent>
          </Popover>
        );

      case 'select':
      case 'multiselect':
      case 'user':
        if (['is_any_of', 'is_none_of'].includes(condition.operator)) {
          const options: FilterOption[] = (column.options || []).map((opt) =>
            typeof opt === 'string'
              ? { value: opt, label: opt }
              : { value: opt.value, label: opt.label }
          );
          return (
            <Popover>
              <PopoverTrigger asChild>
                <Button variant="outline" className="flex-1 justify-start">
                  {Array.isArray(condition.value) && condition.value.length > 0
                    ? `${condition.value.length} selected`
                    : 'Select values'}
                </Button>
              </PopoverTrigger>
              <PopoverContent className="w-64 p-0" align="start">
                <MultiSelectFilter
                  options={options}
                  selectedValues={(condition.value as string[]) || []}
                  onChange={handleValueChange}
                />
              </PopoverContent>
            </Popover>
          );
        }
        return null;

      case 'boolean':
        return null; // Boolean uses is_true/is_false operators with no value

      default:
        return (
          <Input
            placeholder="Enter value"
            value={String(condition.value || '')}
            onChange={(e) => handleValueChange(e.target.value)}
            className="flex-1"
          />
        );
    }
  };

  return (
    <div className="flex items-start gap-2 p-3 bg-muted/30 rounded-lg">
      {/* Property selector */}
      <Select value={condition.propertyId} onValueChange={handlePropertyChange}>
        <SelectTrigger className="w-[180px]">
          <SelectValue placeholder="Select property" />
        </SelectTrigger>
        <SelectContent>
          {columns.map((col) => (
            <SelectItem key={col.id} value={col.id}>
              {col.header}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>

      {/* Operator selector */}
      <Select
        value={condition.operator}
        onValueChange={(v) => handleOperatorChange(v as FilterOperator)}
      >
        <SelectTrigger className="w-[180px]">
          <SelectValue />
        </SelectTrigger>
        <SelectContent>
          {operators.map((op) => (
            <SelectItem key={op} value={op}>
              {OPERATOR_LABELS[op]}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>

      {/* Value input */}
      {renderValueInput()}

      {/* Remove button */}
      <Button variant="ghost" size="icon" onClick={onRemove}>
        <X className="h-4 w-4" />
      </Button>
    </div>
  );
}
```

  </action>
  <verify>npm run typecheck passes</verify>
  <done>FilterConditionRow with property, operator, and type-specific value inputs</done>
</task>

<task type="auto">
  <name>Task 2: Create FilterGroupCard component</name>
  <files>apps/frontend/src/components/views/FilterGroupCard.tsx</files>
  <action>
Create a filter group card with conditions:

```typescript
'use client';

import React from 'react';
import { Copy, Trash2, Plus } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { FilterConditionRow } from './FilterConditionRow';
import { ColumnConfig, FilterGroup, FilterCondition } from '@/lib/views/types';
import { generateId } from '@/lib/utils';

interface FilterGroupCardProps {
  group: FilterGroup;
  groupIndex: number;
  columns: ColumnConfig[];
  canDelete: boolean;
  canDuplicate: boolean;
  onChange: (group: FilterGroup) => void;
  onDuplicate: () => void;
  onDelete: () => void;
}

const MAX_CONDITIONS_PER_GROUP = 20;

export function FilterGroupCard({
  group,
  groupIndex,
  columns,
  canDelete,
  canDuplicate,
  onChange,
  onDuplicate,
  onDelete,
}: FilterGroupCardProps) {
  const handleConditionChange = (index: number, condition: FilterCondition) => {
    const newConditions = [...group.conditions];
    newConditions[index] = condition;
    onChange({ ...group, conditions: newConditions });
  };

  const handleConditionRemove = (index: number) => {
    const newConditions = group.conditions.filter((_, i) => i !== index);
    onChange({ ...group, conditions: newConditions });
  };

  const handleAddCondition = () => {
    if (group.conditions.length >= MAX_CONDITIONS_PER_GROUP) return;

    const defaultColumn = columns[0];
    const newCondition: FilterCondition = {
      id: generateId(),
      propertyId: defaultColumn?.id || '',
      operator: 'is',
      value: undefined,
    };
    onChange({ ...group, conditions: [...group.conditions, newCondition] });
  };

  return (
    <Card className="border-2">
      <CardHeader className="pb-3">
        <div className="flex items-center justify-between">
          <CardTitle className="text-sm font-medium text-muted-foreground">
            Group {groupIndex + 1}
          </CardTitle>
          <div className="flex items-center gap-1">
            {canDuplicate && (
              <Button variant="ghost" size="icon" onClick={onDuplicate} title="Duplicate group">
                <Copy className="h-4 w-4" />
              </Button>
            )}
            {canDelete && (
              <Button variant="ghost" size="icon" onClick={onDelete} title="Delete group">
                <Trash2 className="h-4 w-4" />
              </Button>
            )}
          </div>
        </div>
      </CardHeader>
      <CardContent className="space-y-3">
        {group.conditions.map((condition, index) => (
          <React.Fragment key={condition.id}>
            {index > 0 && (
              <div className="flex items-center gap-2 py-1">
                <div className="h-px flex-1 bg-border" />
                <span className="text-xs text-muted-foreground font-medium px-2">
                  and
                </span>
                <div className="h-px flex-1 bg-border" />
              </div>
            )}
            <FilterConditionRow
              condition={condition}
              columns={columns}
              onChange={(c) => handleConditionChange(index, c)}
              onRemove={() => handleConditionRemove(index)}
            />
          </React.Fragment>
        ))}

        {/* Add filter button */}
        {group.conditions.length < MAX_CONDITIONS_PER_GROUP && (
          <Button
            variant="ghost"
            size="sm"
            className="w-full"
            onClick={handleAddCondition}
          >
            <Plus className="h-4 w-4 mr-2" />
            Add filter
          </Button>
        )}

        {group.conditions.length >= MAX_CONDITIONS_PER_GROUP && (
          <p className="text-xs text-muted-foreground text-center">
            Maximum {MAX_CONDITIONS_PER_GROUP} conditions per group
          </p>
        )}
      </CardContent>
    </Card>
  );
}
```

  </action>
  <verify>npm run typecheck passes</verify>
  <done>FilterGroupCard with AND-joined conditions and duplicate/delete actions</done>
</task>

<task type="auto">
  <name>Task 3: Create AdvancedFiltersPanel slide-out</name>
  <files>apps/frontend/src/components/views/AdvancedFiltersPanel.tsx</files>
  <action>
Create the main advanced filters slide-out panel:

```typescript
'use client';

import React from 'react';
import { X, Plus } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { ScrollArea } from '@/components/ui/scroll-area';
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
} from '@/components/ui/sheet';
import { useSavedViewContext } from '@/hooks/views/useSavedViewContext';
import { FilterGroupCard } from './FilterGroupCard';
import { FilterGroup } from '@/lib/views/types';
import { generateId } from '@/lib/utils';

interface AdvancedFiltersPanelProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

const MAX_FILTER_GROUPS = 2;

export function AdvancedFiltersPanel({ open, onOpenChange }: AdvancedFiltersPanelProps) {
  const { config, filters, setFilters, clearAdvancedFilters } = useSavedViewContext();

  const handleGroupChange = (index: number, group: FilterGroup) => {
    const newFilters = [...filters];
    newFilters[index] = group;
    setFilters(newFilters);
  };

  const handleGroupDuplicate = (index: number) => {
    if (filters.length >= MAX_FILTER_GROUPS) return;

    const groupToDuplicate = filters[index];
    const duplicatedGroup: FilterGroup = {
      id: generateId(),
      conditions: groupToDuplicate.conditions.map((c) => ({
        ...c,
        id: generateId(),
      })),
    };
    setFilters([...filters, duplicatedGroup]);
  };

  const handleGroupDelete = (index: number) => {
    const newFilters = filters.filter((_, i) => i !== index);
    setFilters(newFilters);
  };

  const handleAddGroup = () => {
    if (filters.length >= MAX_FILTER_GROUPS) return;

    const newGroup: FilterGroup = {
      id: generateId(),
      conditions: [
        {
          id: generateId(),
          propertyId: config.columns[0]?.id || '',
          operator: 'is',
          value: undefined,
        },
      ],
    };
    setFilters([...filters, newGroup]);
  };

  // Count total active conditions
  const totalConditions = filters.reduce((sum, g) => sum + g.conditions.length, 0);

  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      <SheetContent className="w-[500px] sm:max-w-[500px] flex flex-col">
        <SheetHeader className="flex-shrink-0">
          <div className="flex items-center justify-between">
            <SheetTitle>Advanced Filters</SheetTitle>
            {totalConditions > 0 && (
              <Button variant="ghost" size="sm" onClick={clearAdvancedFilters}>
                Clear all
              </Button>
            )}
          </div>
          <p className="text-sm text-muted-foreground">
            Records matching any group will be shown (OR logic between groups, AND within each group).
          </p>
        </SheetHeader>

        <ScrollArea className="flex-1 mt-6">
          <div className="space-y-4 pr-4">
            {filters.map((group, index) => (
              <React.Fragment key={group.id}>
                {index > 0 && (
                  <div className="flex items-center gap-2 py-2">
                    <div className="h-px flex-1 bg-border" />
                    <span className="px-3 py-1 rounded-full bg-amber-100 dark:bg-amber-900 text-amber-700 dark:text-amber-300 text-xs font-medium">
                      or
                    </span>
                    <div className="h-px flex-1 bg-border" />
                  </div>
                )}
                <FilterGroupCard
                  group={group}
                  groupIndex={index}
                  columns={config.columns.filter((c) => c.filterable !== false)}
                  canDelete={filters.length > 1 || group.conditions.length > 0}
                  canDuplicate={filters.length < MAX_FILTER_GROUPS}
                  onChange={(g) => handleGroupChange(index, g)}
                  onDuplicate={() => handleGroupDuplicate(index)}
                  onDelete={() => handleGroupDelete(index)}
                />
              </React.Fragment>
            ))}

            {/* Add group button */}
            {filters.length < MAX_FILTER_GROUPS && (
              <div className="flex items-center gap-2 pt-2">
                <div className="h-px flex-1 bg-border" />
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleAddGroup}
                  className="gap-2"
                >
                  <Plus className="h-4 w-4" />
                  Add filter group
                </Button>
                <div className="h-px flex-1 bg-border" />
              </div>
            )}

            {filters.length >= MAX_FILTER_GROUPS && (
              <p className="text-xs text-muted-foreground text-center pt-2">
                Maximum {MAX_FILTER_GROUPS} filter groups allowed
              </p>
            )}
          </div>
        </ScrollArea>

        {/* Footer with info */}
        <div className="flex-shrink-0 pt-4 border-t mt-4">
          <p className="text-xs text-muted-foreground">
            Filters are applied automatically as you make changes.
          </p>
        </div>
      </SheetContent>
    </Sheet>
  );
}
```

Update exports:

```typescript
// apps/frontend/src/components/views/index.ts
export { SavedViewProvider, SavedViewContext } from "./SavedViewProvider";
export type { SavedViewContextValue } from "./SavedViewProvider";
export { ViewTabsBar } from "./ViewTabsBar";
export { SortableViewTab } from "./SortableViewTab";
export { ViewTabContextMenu } from "./ViewTabContextMenu";
export { AddViewButton } from "./AddViewButton";
export { CreateViewDialog } from "./CreateViewDialog";
export { ViewToolbar } from "./ViewToolbar";
export { ViewModeToggle } from "./ViewModeToggle";
export { SaveButton } from "./SaveButton";
export { SortButton } from "./SortButton";
export { ExportButton } from "./ExportButton";
export { ColumnSelectionModal } from "./ColumnSelectionModal";
export { PropertyPicker } from "./PropertyPicker";
export { SelectedColumnsList } from "./SelectedColumnsList";
export { QuickFiltersRow } from "./QuickFiltersRow";
export { QuickFilterDropdown } from "./QuickFilterDropdown";
export { DateRangeFilter } from "./DateRangeFilter";
export { MultiSelectFilter } from "./MultiSelectFilter";
export { AdvancedFiltersPanel } from "./AdvancedFiltersPanel";
export { FilterGroupCard } from "./FilterGroupCard";
export { FilterConditionRow } from "./FilterConditionRow";
```

  </action>
  <verify>npm run typecheck passes; npm run lint passes</verify>
  <done>AdvancedFiltersPanel slide-out with filter groups and real-time application</done>
</task>

</tasks>

<verification>
```bash
cd apps/frontend
npm run typecheck
npm run lint
```
</verification>

<success_criteria>

- Panel slides in from right side using shadcn Sheet component
- Filter groups display with OR separator between them (max 2 groups)
- Conditions within group show AND separator (max 20 per group)
- Each condition has property dropdown, operator dropdown, and value input
- Operators change based on property type (text, number, date, select, etc.)
- Date conditions offer both specific dates and relative (N days ago)
- Multi-select conditions use searchable checkbox dropdown
- Filters apply immediately as conditions change
- Clear all button removes all advanced filters
- Duplicate group button copies entire group with new IDs
  </success_criteria>

<output>
After completion, create `.planning/phases/13-hubspot-style-saved-views-system/13-08-SUMMARY.md`
</output>
