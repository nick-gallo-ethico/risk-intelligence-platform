---
phase: 13-hubspot-style-saved-views-system
plan: 07
type: execute
wave: 2
depends_on: ["13-03"]
files_modified:
  - apps/frontend/src/components/views/QuickFiltersRow.tsx
  - apps/frontend/src/components/views/QuickFilterDropdown.tsx
  - apps/frontend/src/components/views/DateRangeFilter.tsx
  - apps/frontend/src/components/views/MultiSelectFilter.tsx
  - apps/frontend/src/components/views/index.ts
autonomous: true

must_haves:
  truths:
    - "Quick filters row shows dropdown buttons for common filterable properties"
    - "Date properties show preset ranges (Today, This week, This month, Custom)"
    - "Multi-select properties show searchable checkbox list"
    - "Advanced filters pill button opens slide-out panel"
    - "More button allows adding additional quick filter dropdowns"
  artifacts:
    - path: "apps/frontend/src/components/views/QuickFiltersRow.tsx"
      provides: "Horizontal row of quick filter dropdowns"
      contains: "QuickFiltersRow"
    - path: "apps/frontend/src/components/views/QuickFilterDropdown.tsx"
      provides: "Individual quick filter dropdown component"
      contains: "QuickFilterDropdown"
  key_links:
    - from: "QuickFiltersRow"
      to: "SavedViewContext"
      via: "useSavedViewContext"
      pattern: "addQuickFilter"
---

<objective>
Create the Quick Filters Row (Zone 3) with property-specific filter dropdowns.

Purpose: Quick filters provide fast access to common filtering operations without opening the advanced filters panel. Each dropdown adapts to the property type (date, user, status, text).

Output: QuickFiltersRow with type-aware filter dropdowns, date range picker, multi-select, and Advanced filters button.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/hubspot-view-system-spec.md
@apps/frontend/src/components/views/SavedViewProvider.tsx
@apps/frontend/src/lib/views/types.ts
@apps/frontend/src/lib/views/operators.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DateRangeFilter component</name>
  <files>apps/frontend/src/components/views/DateRangeFilter.tsx</files>
  <action>
Create a date range filter with presets:

```typescript
'use client';

import React from 'react';
import { Calendar } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Calendar as CalendarComponent } from '@/components/ui/calendar';
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from '@/components/ui/popover';
import { Separator } from '@/components/ui/separator';
import { cn } from '@/lib/utils';
import {
  startOfToday,
  endOfToday,
  startOfYesterday,
  endOfYesterday,
  startOfWeek,
  endOfWeek,
  startOfMonth,
  endOfMonth,
  startOfQuarter,
  endOfQuarter,
  subDays,
  format,
} from 'date-fns';

interface DateRange {
  from: Date | undefined;
  to: Date | undefined;
}

interface DateRangeFilterProps {
  value: DateRange | undefined;
  onChange: (range: DateRange | undefined) => void;
}

type DatePreset = {
  label: string;
  getValue: () => DateRange;
};

const DATE_PRESETS: DatePreset[] = [
  {
    label: 'Today',
    getValue: () => ({ from: startOfToday(), to: endOfToday() }),
  },
  {
    label: 'Yesterday',
    getValue: () => ({ from: startOfYesterday(), to: endOfYesterday() }),
  },
  {
    label: 'This week',
    getValue: () => ({ from: startOfWeek(new Date()), to: endOfWeek(new Date()) }),
  },
  {
    label: 'This month',
    getValue: () => ({ from: startOfMonth(new Date()), to: endOfMonth(new Date()) }),
  },
  {
    label: 'This quarter',
    getValue: () => ({ from: startOfQuarter(new Date()), to: endOfQuarter(new Date()) }),
  },
  {
    label: 'Last 30 days',
    getValue: () => ({ from: subDays(new Date(), 30), to: endOfToday() }),
  },
  {
    label: 'Last 90 days',
    getValue: () => ({ from: subDays(new Date(), 90), to: endOfToday() }),
  },
];

export function DateRangeFilter({ value, onChange }: DateRangeFilterProps) {
  const [isCustom, setIsCustom] = React.useState(false);

  const handlePresetClick = (preset: DatePreset) => {
    onChange(preset.getValue());
    setIsCustom(false);
  };

  const handleCustomRange = (range: DateRange | undefined) => {
    onChange(range);
    setIsCustom(true);
  };

  const handleClear = () => {
    onChange(undefined);
    setIsCustom(false);
  };

  const getDisplayLabel = () => {
    if (!value?.from) return 'Any time';

    // Check if matches a preset
    for (const preset of DATE_PRESETS) {
      const presetValue = preset.getValue();
      if (
        value.from.getTime() === presetValue.from?.getTime() &&
        value.to?.getTime() === presetValue.to?.getTime()
      ) {
        return preset.label;
      }
    }

    // Custom range
    if (value.to) {
      return `${format(value.from, 'MMM d')} - ${format(value.to, 'MMM d')}`;
    }
    return format(value.from, 'MMM d, yyyy');
  };

  return (
    <div className="space-y-2">
      {/* Presets */}
      <div className="space-y-1">
        {DATE_PRESETS.map((preset) => (
          <Button
            key={preset.label}
            variant="ghost"
            size="sm"
            className={cn(
              'w-full justify-start',
              !isCustom &&
                value?.from?.getTime() === preset.getValue().from?.getTime() &&
                'bg-accent'
            )}
            onClick={() => handlePresetClick(preset)}
          >
            {preset.label}
          </Button>
        ))}
      </div>

      <Separator />

      {/* Custom range */}
      <div className="p-2">
        <p className="text-sm font-medium mb-2">Custom range</p>
        <Popover>
          <PopoverTrigger asChild>
            <Button variant="outline" size="sm" className="w-full justify-start">
              <Calendar className="h-4 w-4 mr-2" />
              {isCustom && value?.from
                ? getDisplayLabel()
                : 'Select dates...'}
            </Button>
          </PopoverTrigger>
          <PopoverContent className="w-auto p-0" align="start">
            <CalendarComponent
              mode="range"
              selected={value}
              onSelect={handleCustomRange}
              numberOfMonths={2}
            />
          </PopoverContent>
        </Popover>
      </div>

      {value && (
        <>
          <Separator />
          <Button
            variant="ghost"
            size="sm"
            className="w-full"
            onClick={handleClear}
          >
            Clear filter
          </Button>
        </>
      )}
    </div>
  );
}
```

  </action>
  <verify>npm run typecheck passes</verify>
  <done>DateRangeFilter with presets and custom calendar picker</done>
</task>

<task type="auto">
  <name>Task 2: Create MultiSelectFilter component</name>
  <files>apps/frontend/src/components/views/MultiSelectFilter.tsx</files>
  <action>
Create a searchable multi-select filter:

```typescript
'use client';

import React, { useMemo, useState } from 'react';
import { Search, Check } from 'lucide-react';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Checkbox } from '@/components/ui/checkbox';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Separator } from '@/components/ui/separator';
import { Badge } from '@/components/ui/badge';
import { cn } from '@/lib/utils';

export interface FilterOption {
  value: string;
  label: string;
  description?: string;
  avatar?: string;
  color?: string; // For status badges
}

interface MultiSelectFilterProps {
  options: FilterOption[];
  selectedValues: string[];
  onChange: (values: string[]) => void;
  searchPlaceholder?: string;
  showSelectAll?: boolean;
}

export function MultiSelectFilter({
  options,
  selectedValues,
  onChange,
  searchPlaceholder = 'Search...',
  showSelectAll = true,
}: MultiSelectFilterProps) {
  const [search, setSearch] = useState('');

  const filteredOptions = useMemo(() => {
    if (!search.trim()) return options;
    const lower = search.toLowerCase();
    return options.filter(
      (opt) =>
        opt.label.toLowerCase().includes(lower) ||
        opt.description?.toLowerCase().includes(lower)
    );
  }, [options, search]);

  const handleToggle = (value: string) => {
    if (selectedValues.includes(value)) {
      onChange(selectedValues.filter((v) => v !== value));
    } else {
      onChange([...selectedValues, value]);
    }
  };

  const handleSelectAll = () => {
    if (selectedValues.length === options.length) {
      onChange([]);
    } else {
      onChange(options.map((o) => o.value));
    }
  };

  const handleClear = () => {
    onChange([]);
  };

  return (
    <div className="w-64">
      {/* Search */}
      <div className="relative p-2">
        <Search className="absolute left-4 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
        <Input
          placeholder={searchPlaceholder}
          value={search}
          onChange={(e) => setSearch(e.target.value)}
          className="pl-8"
        />
      </div>

      <Separator />

      {/* Select all option */}
      {showSelectAll && (
        <>
          <div
            className="flex items-center gap-3 px-4 py-2 cursor-pointer hover:bg-accent"
            onClick={handleSelectAll}
          >
            <Checkbox
              checked={selectedValues.length === options.length}
              indeterminate={
                selectedValues.length > 0 && selectedValues.length < options.length
              }
            />
            <span className="text-sm font-medium">Select all</span>
            <span className="ml-auto text-xs text-muted-foreground">
              {selectedValues.length} of {options.length}
            </span>
          </div>
          <Separator />
        </>
      )}

      {/* Options list */}
      <ScrollArea className="h-[240px]">
        <div className="py-1">
          {filteredOptions.map((option) => {
            const isSelected = selectedValues.includes(option.value);
            return (
              <div
                key={option.value}
                className={cn(
                  'flex items-center gap-3 px-4 py-2 cursor-pointer hover:bg-accent',
                  isSelected && 'bg-accent/50'
                )}
                onClick={() => handleToggle(option.value)}
              >
                <Checkbox checked={isSelected} />

                {/* Avatar if provided */}
                {option.avatar && (
                  <img
                    src={option.avatar}
                    alt=""
                    className="h-6 w-6 rounded-full"
                  />
                )}

                {/* Label with optional color badge */}
                <div className="flex-1 min-w-0">
                  {option.color ? (
                    <Badge
                      variant="secondary"
                      style={{ backgroundColor: option.color }}
                      className="text-white"
                    >
                      {option.label}
                    </Badge>
                  ) : (
                    <span className="text-sm truncate">{option.label}</span>
                  )}
                  {option.description && (
                    <p className="text-xs text-muted-foreground truncate">
                      {option.description}
                    </p>
                  )}
                </div>

                {isSelected && <Check className="h-4 w-4 text-primary" />}
              </div>
            );
          })}

          {filteredOptions.length === 0 && (
            <div className="px-4 py-8 text-center text-sm text-muted-foreground">
              No results found
            </div>
          )}
        </div>
      </ScrollArea>

      {/* Clear filter */}
      {selectedValues.length > 0 && (
        <>
          <Separator />
          <div className="p-2">
            <Button
              variant="ghost"
              size="sm"
              className="w-full"
              onClick={handleClear}
            >
              Clear filter
            </Button>
          </div>
        </>
      )}
    </div>
  );
}
```

  </action>
  <verify>npm run typecheck passes</verify>
  <done>MultiSelectFilter with search, select all, and checkbox options</done>
</task>

<task type="auto">
  <name>Task 3: Create QuickFilterDropdown component</name>
  <files>apps/frontend/src/components/views/QuickFilterDropdown.tsx</files>
  <action>
Create a type-aware quick filter dropdown:

```typescript
'use client';

import React from 'react';
import { ChevronDown, X } from 'lucide-react';
import { Button } from '@/components/ui/button';
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from '@/components/ui/popover';
import { Badge } from '@/components/ui/badge';
import { ColumnConfig, FilterCondition, PropertyType } from '@/lib/views/types';
import { DateRangeFilter } from './DateRangeFilter';
import { MultiSelectFilter, FilterOption } from './MultiSelectFilter';
import { cn } from '@/lib/utils';

interface QuickFilterDropdownProps {
  column: ColumnConfig;
  condition: FilterCondition | undefined;
  onConditionChange: (condition: FilterCondition | undefined) => void;
  onRemove?: () => void;
}

export function QuickFilterDropdown({
  column,
  condition,
  onConditionChange,
  onRemove,
}: QuickFilterDropdownProps) {
  const [open, setOpen] = React.useState(false);

  const isActive = condition !== undefined;

  const getDisplayValue = (): string => {
    if (!condition) return column.header;

    switch (column.type) {
      case 'date':
      case 'datetime':
        if (Array.isArray(condition.value)) {
          const [from, to] = condition.value;
          if (from && to) return `${column.header}: Custom range`;
        }
        return `${column.header}: ${condition.value}`;

      case 'select':
      case 'multiselect':
      case 'user':
        if (Array.isArray(condition.value)) {
          return `${column.header}: ${condition.value.length} selected`;
        }
        return column.header;

      default:
        return condition.value ? `${column.header}: ${condition.value}` : column.header;
    }
  };

  const renderFilterContent = () => {
    switch (column.type) {
      case 'date':
      case 'datetime':
        return (
          <DateRangeFilter
            value={
              condition?.value
                ? {
                    from: new Date(condition.value[0]),
                    to: condition.value[1] ? new Date(condition.value[1]) : undefined,
                  }
                : undefined
            }
            onChange={(range) => {
              if (!range?.from) {
                onConditionChange(undefined);
              } else {
                onConditionChange({
                  id: `quick-${column.id}`,
                  propertyId: column.id,
                  operator: 'is_between',
                  value: [range.from.toISOString(), range.to?.toISOString()],
                });
              }
              setOpen(false);
            }}
          />
        );

      case 'select':
      case 'multiselect':
        const options: FilterOption[] = (column.options || []).map((opt) =>
          typeof opt === 'string'
            ? { value: opt, label: opt }
            : { value: opt.value, label: opt.label, color: opt.color }
        );
        return (
          <MultiSelectFilter
            options={options}
            selectedValues={(condition?.value as string[]) || []}
            onChange={(values) => {
              if (values.length === 0) {
                onConditionChange(undefined);
              } else {
                onConditionChange({
                  id: `quick-${column.id}`,
                  propertyId: column.id,
                  operator: 'is_any_of',
                  value: values,
                });
              }
            }}
          />
        );

      case 'user':
        // User filter would use same MultiSelectFilter with user options
        const userOptions: FilterOption[] = (column.options || []).map((opt) =>
          typeof opt === 'string'
            ? { value: opt, label: opt }
            : { value: opt.value, label: opt.label, avatar: opt.avatar }
        );
        return (
          <MultiSelectFilter
            options={userOptions}
            selectedValues={(condition?.value as string[]) || []}
            searchPlaceholder="Search users..."
            onChange={(values) => {
              if (values.length === 0) {
                onConditionChange(undefined);
              } else {
                onConditionChange({
                  id: `quick-${column.id}`,
                  propertyId: column.id,
                  operator: 'is_any_of',
                  value: values,
                });
              }
            }}
          />
        );

      case 'boolean':
        return (
          <div className="p-2 space-y-1">
            <Button
              variant={condition?.value === true ? 'default' : 'ghost'}
              size="sm"
              className="w-full justify-start"
              onClick={() => {
                onConditionChange({
                  id: `quick-${column.id}`,
                  propertyId: column.id,
                  operator: 'is_true',
                  value: true,
                });
                setOpen(false);
              }}
            >
              Yes
            </Button>
            <Button
              variant={condition?.value === false ? 'default' : 'ghost'}
              size="sm"
              className="w-full justify-start"
              onClick={() => {
                onConditionChange({
                  id: `quick-${column.id}`,
                  propertyId: column.id,
                  operator: 'is_false',
                  value: false,
                });
                setOpen(false);
              }}
            >
              No
            </Button>
            {condition && (
              <Button
                variant="ghost"
                size="sm"
                className="w-full"
                onClick={() => {
                  onConditionChange(undefined);
                  setOpen(false);
                }}
              >
                Clear
              </Button>
            )}
          </div>
        );

      default:
        return (
          <div className="p-3 text-sm text-muted-foreground">
            Use Advanced Filters for this property type.
          </div>
        );
    }
  };

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          variant={isActive ? 'secondary' : 'outline'}
          size="sm"
          className={cn('gap-1', isActive && 'pr-1')}
        >
          {getDisplayValue()}
          {isActive ? (
            <Badge variant="secondary" className="ml-1 h-5 px-1">
              <X
                className="h-3 w-3 cursor-pointer"
                onClick={(e) => {
                  e.stopPropagation();
                  onConditionChange(undefined);
                }}
              />
            </Badge>
          ) : (
            <ChevronDown className="h-4 w-4" />
          )}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-auto p-0" align="start">
        {renderFilterContent()}
      </PopoverContent>
    </Popover>
  );
}
```

  </action>
  <verify>npm run typecheck passes</verify>
  <done>QuickFilterDropdown with type-aware content rendering</done>
</task>

<task type="auto">
  <name>Task 4: Create QuickFiltersRow component</name>
  <files>apps/frontend/src/components/views/QuickFiltersRow.tsx</files>
  <action>
Create the main quick filters row:

```typescript
'use client';

import React, { useState } from 'react';
import { Plus, SlidersHorizontal, X } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from '@/components/ui/popover';
import { ScrollArea } from '@/components/ui/scroll-area';
import { useSavedViewContext } from '@/hooks/views/useSavedViewContext';
import { QuickFilterDropdown } from './QuickFilterDropdown';
import { FilterCondition } from '@/lib/views/types';

interface QuickFiltersRowProps {
  onAdvancedFiltersClick: () => void;
  advancedFilterCount: number;
}

export function QuickFiltersRow({
  onAdvancedFiltersClick,
  advancedFilterCount,
}: QuickFiltersRowProps) {
  const {
    config,
    quickFilters,
    addQuickFilter,
    updateQuickFilter,
    removeQuickFilter,
    clearAllFilters,
  } = useSavedViewContext();

  const [addFilterOpen, setAddFilterOpen] = useState(false);

  // Get columns that are marked as quick filterable
  const quickFilterableColumns = config.columns.filter((c) => c.quickFilterable);

  // Get columns already in quick filters
  const activeQuickFilterIds = quickFilters.map((f) => f.propertyId);

  // Columns available to add
  const availableColumns = quickFilterableColumns.filter(
    (c) => !activeQuickFilterIds.includes(c.id)
  );

  const handleConditionChange = (
    columnId: string,
    condition: FilterCondition | undefined
  ) => {
    if (condition) {
      updateQuickFilter(columnId, condition);
    } else {
      removeQuickFilter(columnId);
    }
  };

  const handleAddQuickFilter = (columnId: string) => {
    addQuickFilter(columnId);
    setAddFilterOpen(false);
  };

  const totalActiveFilters = quickFilters.filter((f) => f.condition).length + advancedFilterCount;

  return (
    <div className="flex items-center gap-2 p-2 border-b bg-muted/30">
      {/* Quick filter dropdowns */}
      {quickFilters.map((qf) => {
        const column = config.columns.find((c) => c.id === qf.propertyId);
        if (!column) return null;

        return (
          <QuickFilterDropdown
            key={qf.propertyId}
            column={column}
            condition={qf.condition}
            onConditionChange={(condition) =>
              handleConditionChange(qf.propertyId, condition)
            }
            onRemove={() => removeQuickFilter(qf.propertyId)}
          />
        );
      })}

      {/* Add more quick filters */}
      {availableColumns.length > 0 && (
        <Popover open={addFilterOpen} onOpenChange={setAddFilterOpen}>
          <PopoverTrigger asChild>
            <Button variant="ghost" size="sm">
              <Plus className="h-4 w-4 mr-1" />
              More
            </Button>
          </PopoverTrigger>
          <PopoverContent className="w-56 p-0" align="start">
            <ScrollArea className="max-h-64">
              <div className="py-1">
                {availableColumns.map((column) => (
                  <button
                    key={column.id}
                    className="w-full px-3 py-2 text-sm text-left hover:bg-accent"
                    onClick={() => handleAddQuickFilter(column.id)}
                  >
                    {column.header}
                  </button>
                ))}
              </div>
            </ScrollArea>
          </PopoverContent>
        </Popover>
      )}

      <div className="flex-1" />

      {/* Clear all filters */}
      {totalActiveFilters > 0 && (
        <Button variant="ghost" size="sm" onClick={clearAllFilters}>
          <X className="h-4 w-4 mr-1" />
          Clear all ({totalActiveFilters})
        </Button>
      )}

      {/* Advanced filters button */}
      <Button
        variant={advancedFilterCount > 0 ? 'secondary' : 'outline'}
        size="sm"
        onClick={onAdvancedFiltersClick}
      >
        <SlidersHorizontal className="h-4 w-4 mr-2" />
        Advanced filters
        {advancedFilterCount > 0 && (
          <Badge variant="secondary" className="ml-1">
            {advancedFilterCount}
          </Badge>
        )}
      </Button>
    </div>
  );
}
```

Update exports:

```typescript
// apps/frontend/src/components/views/index.ts
export { SavedViewProvider, SavedViewContext } from "./SavedViewProvider";
export type { SavedViewContextValue } from "./SavedViewProvider";
export { ViewTabsBar } from "./ViewTabsBar";
export { SortableViewTab } from "./SortableViewTab";
export { ViewTabContextMenu } from "./ViewTabContextMenu";
export { AddViewButton } from "./AddViewButton";
export { CreateViewDialog } from "./CreateViewDialog";
export { ViewToolbar } from "./ViewToolbar";
export { ViewModeToggle } from "./ViewModeToggle";
export { SaveButton } from "./SaveButton";
export { SortButton } from "./SortButton";
export { ExportButton } from "./ExportButton";
export { ColumnSelectionModal } from "./ColumnSelectionModal";
export { PropertyPicker } from "./PropertyPicker";
export { SelectedColumnsList } from "./SelectedColumnsList";
export { QuickFiltersRow } from "./QuickFiltersRow";
export { QuickFilterDropdown } from "./QuickFilterDropdown";
export { DateRangeFilter } from "./DateRangeFilter";
export { MultiSelectFilter } from "./MultiSelectFilter";
```

  </action>
  <verify>npm run typecheck passes; npm run lint passes</verify>
  <done>QuickFiltersRow with dropdowns, add more, and advanced filters button</done>
</task>

</tasks>

<verification>
```bash
cd apps/frontend
npm run typecheck
npm run lint
```
</verification>

<success_criteria>

- QuickFiltersRow displays horizontal row of quick filter dropdowns
- Date properties show preset ranges (Today, This week, etc.) and custom picker
- Multi-select properties show searchable checkbox list with Select all
- Boolean properties show Yes/No toggle buttons
- More button adds additional quick filter dropdowns from available columns
- Active filters show clear (X) button on the dropdown
- Clear all button removes all quick and advanced filters
- Advanced filters button shows count badge when filters are active
  </success_criteria>

<output>
After completion, create `.planning/phases/13-hubspot-style-saved-views-system/13-07-SUMMARY.md`
</output>
