---
phase: 13-hubspot-style-saved-views-system
plan: 14
type: execute
wave: 5
depends_on: ["13-11", "13-12", "13-13"]
files_modified:
  - apps/frontend/src/hooks/views/useViewUrlState.ts
  - apps/frontend/src/components/views/SavedViewProvider.tsx
  - apps/frontend/src/components/views/BulkActionsBar.tsx
autonomous: true

must_haves:
  truths:
    - "View ID is reflected in URL query parameter"
    - "Filter state is reflected in URL for bookmarkable links"
    - "Shared links load the correct view with filters"
    - "URL changes when switching views or applying filters"
    - "Browser back/forward navigation works with view state"
  artifacts:
    - path: "apps/frontend/src/hooks/views/useViewUrlState.ts"
      provides: "Hook for URL state synchronization"
      contains: "useSearchParams"
    - path: "apps/frontend/src/components/views/SavedViewProvider.tsx"
      provides: "Updated provider with URL sync"
      contains: "useViewUrlState"
  key_links:
    - from: "SavedViewProvider"
      to: "useViewUrlState"
      via: "URL sync"
      pattern: "searchParams"
---

<objective>
Add URL state synchronization for bookmarkable view links and enhance bulk actions.

Purpose: Users should be able to bookmark a specific view with filters applied, share links with colleagues, and use browser back/forward to navigate view history.

Output: URL query parameters sync with view state, bulk action confirmations, and selection preservation.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/hubspot-view-system-spec.md
@apps/frontend/src/components/views/SavedViewProvider.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useViewUrlState hook</name>
  <files>apps/frontend/src/hooks/views/useViewUrlState.ts</files>
  <action>
Create a hook for bidirectional URL state synchronization:

```typescript
"use client";

import { useCallback, useEffect, useMemo } from "react";
import { useSearchParams, useRouter, usePathname } from "next/navigation";
import { FilterGroup, SortOrder } from "@/lib/views/types";

interface ViewUrlState {
  viewId: string | null;
  filters: string | null;
  sortBy: string | null;
  sortOrder: SortOrder | null;
  search: string | null;
  page: number;
  pageSize: number;
}

interface UseViewUrlStateReturn {
  urlState: ViewUrlState;
  setViewId: (viewId: string | null) => void;
  setFilters: (filters: FilterGroup[]) => void;
  setSort: (sortBy: string | null, sortOrder: SortOrder) => void;
  setSearch: (search: string) => void;
  setPage: (page: number) => void;
  setPageSize: (pageSize: number) => void;
  clearUrlState: () => void;
}

export function useViewUrlState(): UseViewUrlStateReturn {
  const searchParams = useSearchParams();
  const router = useRouter();
  const pathname = usePathname();

  // Parse current URL state
  const urlState = useMemo<ViewUrlState>(
    () => ({
      viewId: searchParams.get("view"),
      filters: searchParams.get("filters"),
      sortBy: searchParams.get("sortBy"),
      sortOrder: searchParams.get("sortOrder") as SortOrder | null,
      search: searchParams.get("q"),
      page: parseInt(searchParams.get("page") || "1", 10),
      pageSize: parseInt(searchParams.get("pageSize") || "25", 10),
    }),
    [searchParams],
  );

  // Helper to update URL params
  const updateUrl = useCallback(
    (updates: Partial<ViewUrlState>) => {
      const params = new URLSearchParams(searchParams.toString());

      Object.entries(updates).forEach(([key, value]) => {
        if (value === null || value === undefined || value === "") {
          params.delete(key === "search" ? "q" : key);
        } else if (key === "filters") {
          // Only set filters if there are actual conditions
          const parsed = typeof value === "string" ? JSON.parse(value) : value;
          if (Array.isArray(parsed) && parsed.length > 0) {
            params.set("filters", JSON.stringify(parsed));
          } else {
            params.delete("filters");
          }
        } else if (key === "search") {
          if (value) params.set("q", String(value));
          else params.delete("q");
        } else if (key === "page" && value === 1) {
          params.delete("page"); // Default page 1, no need in URL
        } else if (key === "pageSize" && value === 25) {
          params.delete("pageSize"); // Default pageSize, no need in URL
        } else {
          params.set(key === "viewId" ? "view" : key, String(value));
        }
      });

      const newUrl = params.toString()
        ? `${pathname}?${params.toString()}`
        : pathname;
      router.replace(newUrl, { scroll: false });
    },
    [searchParams, router, pathname],
  );

  const setViewId = useCallback(
    (viewId: string | null) => {
      // When switching views, clear filters and sort (they're part of the view)
      const params = new URLSearchParams();
      if (viewId) params.set("view", viewId);
      const newUrl = params.toString()
        ? `${pathname}?${params.toString()}`
        : pathname;
      router.push(newUrl, { scroll: false });
    },
    [router, pathname],
  );

  const setFilters = useCallback(
    (filters: FilterGroup[]) => {
      const hasConditions = filters.some((g) => g.conditions.length > 0);
      updateUrl({
        filters: hasConditions ? JSON.stringify(filters) : null,
        page: 1, // Reset to page 1 when filters change
      });
    },
    [updateUrl],
  );

  const setSort = useCallback(
    (sortBy: string | null, sortOrder: SortOrder) => {
      updateUrl({ sortBy, sortOrder });
    },
    [updateUrl],
  );

  const setSearch = useCallback(
    (search: string) => {
      updateUrl({
        search: search || null,
        page: 1, // Reset to page 1 when search changes
      });
    },
    [updateUrl],
  );

  const setPage = useCallback(
    (page: number) => {
      updateUrl({ page });
    },
    [updateUrl],
  );

  const setPageSize = useCallback(
    (pageSize: number) => {
      updateUrl({ pageSize, page: 1 });
    },
    [updateUrl],
  );

  const clearUrlState = useCallback(() => {
    router.replace(pathname, { scroll: false });
  }, [router, pathname]);

  return {
    urlState,
    setViewId,
    setFilters,
    setSort,
    setSearch,
    setPage,
    setPageSize,
    clearUrlState,
  };
}

// Helper to parse filters from URL
export function parseUrlFilters(filtersParam: string | null): FilterGroup[] {
  if (!filtersParam) return [];
  try {
    return JSON.parse(filtersParam);
  } catch {
    return [];
  }
}

// Helper to serialize filters for URL
export function serializeFiltersForUrl(filters: FilterGroup[]): string | null {
  const hasConditions = filters.some((g) => g.conditions.length > 0);
  if (!hasConditions) return null;
  return JSON.stringify(filters);
}
```

  </action>
  <verify>npm run typecheck passes</verify>
  <done>useViewUrlState hook with bidirectional URL sync</done>
</task>

<task type="auto">
  <name>Task 2: Update SavedViewProvider with URL state integration</name>
  <files>apps/frontend/src/components/views/SavedViewProvider.tsx</files>
  <action>
Update the SavedViewProvider to sync with URL state:

```typescript
// Add to the existing SavedViewProvider.tsx

// Import the hook at the top
import { useViewUrlState, parseUrlFilters } from '@/hooks/views/useViewUrlState';

// Inside the SavedViewProvider component, add URL state integration:

export function SavedViewProvider({
  moduleType,
  config,
  children,
}: SavedViewProviderProps) {
  const { urlState, setViewId: setUrlViewId, setFilters: setUrlFilters } = useViewUrlState();

  // ... existing state declarations ...

  // Initialize from URL on mount
  useEffect(() => {
    // Load view from URL if specified
    if (urlState.viewId && urlState.viewId !== activeView?.id) {
      const view = views.find(v => v.id === urlState.viewId);
      if (view) {
        setActiveView(view);
        // Apply view's settings
        setVisibleColumns(view.columns || config.defaultColumns);
        setFrozenColumnCount(view.frozenColumnCount || 0);
        setViewMode(view.viewMode || 'table');
        setBoardGroupBy(view.boardGroupBy);
      }
    }

    // Load filters from URL (these override view filters for shareable links)
    if (urlState.filters) {
      const parsedFilters = parseUrlFilters(urlState.filters);
      if (parsedFilters.length > 0) {
        setFilters(parsedFilters);
      }
    }

    // Load sort from URL
    if (urlState.sortBy) {
      setSortBy(urlState.sortBy);
      setSortOrder(urlState.sortOrder || 'asc');
    }

    // Load search from URL
    if (urlState.search) {
      setSearchQuery(urlState.search);
    }
  }, [urlState.viewId]); // Only run on initial load or view change

  // Sync filters to URL when they change (debounced)
  useEffect(() => {
    const timeout = setTimeout(() => {
      setUrlFilters(filters);
    }, 500);
    return () => clearTimeout(timeout);
  }, [filters, setUrlFilters]);

  // Update URL when active view changes
  const handleSetActiveView = useCallback((view: SavedView | null) => {
    setActiveView(view);
    setUrlViewId(view?.id || null);

    if (view) {
      // Apply view settings
      setVisibleColumns(view.columns || config.defaultColumns);
      setFilters(view.filters || []);
      setSortBy(view.sort?.column || null);
      setSortOrder(view.sort?.direction || 'asc');
      setFrozenColumnCount(view.frozenColumnCount || 0);
      setViewMode(view.viewMode || 'table');
      setBoardGroupBy(view.boardGroupBy);
    }

    setHasUnsavedChanges(false);
  }, [config.defaultColumns, setUrlViewId]);

  // ... rest of the provider implementation ...

  // Update the context value to include URL-related functions
  const value: SavedViewContextValue = useMemo(() => ({
    // ... existing values ...

    // URL state
    urlViewId: urlState.viewId,
    urlFilters: urlState.filters,

  }), [/* dependencies */]);

  return (
    <SavedViewContext.Provider value={value}>
      {children}
    </SavedViewContext.Provider>
  );
}
```

Note: This is a modification to the existing SavedViewProvider created in 13-03. The implementer should integrate these URL sync features into that component.
</action>
<verify>npm run typecheck passes</verify>
<done>SavedViewProvider updated with URL state integration</done>
</task>

<task type="auto">
  <name>Task 3: Enhance BulkActionsBar with confirmations and selection info</name>
  <files>apps/frontend/src/components/views/BulkActionsBar.tsx</files>
  <action>
Enhance the BulkActionsBar with better UX:

```typescript
'use client';

import React, { useState } from 'react';
import { X, Trash2, Download, UserPlus, Tag, CheckCircle, AlertTriangle } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { BulkAction } from '@/lib/views/types';

interface BulkActionsBarProps {
  selectedCount: number;
  totalCount: number;
  actions: BulkAction[];
  onClearSelection: () => void;
  onSelectAll: () => void;
  onAction: (actionId: string, selectedIds: string[]) => void;
  selectedIds: string[];
  entityName?: { singular: string; plural: string };
}

const ACTION_ICONS: Record<string, React.ReactNode> = {
  assign: <UserPlus className="h-4 w-4 mr-2" />,
  status: <CheckCircle className="h-4 w-4 mr-2" />,
  category: <Tag className="h-4 w-4 mr-2" />,
  export: <Download className="h-4 w-4 mr-2" />,
  delete: <Trash2 className="h-4 w-4 mr-2" />,
};

export function BulkActionsBar({
  selectedCount,
  totalCount,
  actions,
  onClearSelection,
  onSelectAll,
  onAction,
  selectedIds,
  entityName = { singular: 'record', plural: 'records' },
}: BulkActionsBarProps) {
  const [confirmAction, setConfirmAction] = useState<{
    actionId: string;
    label: string;
    destructive?: boolean;
  } | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);

  if (selectedCount === 0) return null;

  const allSelected = selectedCount === totalCount;
  const entityLabel = selectedCount === 1 ? entityName.singular : entityName.plural;

  const handleAction = async (actionId: string, destructive?: boolean, label?: string) => {
    if (destructive) {
      // Show confirmation dialog for destructive actions
      setConfirmAction({ actionId, label: label || 'this action', destructive: true });
      return;
    }

    setIsProcessing(true);
    try {
      await onAction(actionId, selectedIds);
    } finally {
      setIsProcessing(false);
    }
  };

  const handleConfirmedAction = async () => {
    if (!confirmAction) return;

    setIsProcessing(true);
    try {
      await onAction(confirmAction.actionId, selectedIds);
    } finally {
      setIsProcessing(false);
      setConfirmAction(null);
    }
  };

  return (
    <>
      <div className="flex items-center gap-3 px-4 py-2 bg-primary text-primary-foreground animate-in slide-in-from-top-2">
        {/* Selection info */}
        <div className="flex items-center gap-2">
          <Badge variant="secondary" className="bg-primary-foreground text-primary font-semibold">
            {selectedCount.toLocaleString()}
          </Badge>
          <span className="text-sm font-medium">{entityLabel} selected</span>
        </div>

        {/* Select all link */}
        {!allSelected && totalCount > selectedCount && (
          <Button
            variant="link"
            size="sm"
            className="text-primary-foreground underline p-0 h-auto"
            onClick={onSelectAll}
          >
            Select all {totalCount.toLocaleString()}
          </Button>
        )}

        <div className="h-4 w-px bg-primary-foreground/30" />

        {/* Bulk action buttons */}
        {actions.map((action) => {
          if (action.children && action.children.length > 0) {
            // Dropdown for actions with sub-options
            return (
              <DropdownMenu key={action.id}>
                <DropdownMenuTrigger asChild>
                  <Button
                    variant="secondary"
                    size="sm"
                    disabled={isProcessing}
                  >
                    {ACTION_ICONS[action.id] || null}
                    {action.label}
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent>
                  {action.children.map((child) => (
                    <DropdownMenuItem
                      key={child.id}
                      onClick={() => handleAction(child.id, child.destructive, child.label)}
                    >
                      {child.label}
                    </DropdownMenuItem>
                  ))}
                </DropdownMenuContent>
              </DropdownMenu>
            );
          }

          return (
            <Button
              key={action.id}
              variant={action.destructive ? 'destructive' : 'secondary'}
              size="sm"
              disabled={isProcessing}
              onClick={() => handleAction(action.id, action.destructive, action.label)}
            >
              {ACTION_ICONS[action.id] || null}
              {action.label}
            </Button>
          );
        })}

        {/* Spacer */}
        <div className="flex-1" />

        {/* Processing indicator */}
        {isProcessing && (
          <span className="text-sm animate-pulse">Processing...</span>
        )}

        {/* Clear selection */}
        <Button
          variant="ghost"
          size="sm"
          className="text-primary-foreground hover:text-primary-foreground hover:bg-primary-foreground/20"
          onClick={onClearSelection}
          disabled={isProcessing}
        >
          <X className="h-4 w-4 mr-1" />
          Clear
        </Button>
      </div>

      {/* Confirmation Dialog */}
      <AlertDialog open={!!confirmAction} onOpenChange={() => setConfirmAction(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle className="flex items-center gap-2">
              <AlertTriangle className="h-5 w-5 text-destructive" />
              Confirm {confirmAction?.label}
            </AlertDialogTitle>
            <AlertDialogDescription>
              You are about to {confirmAction?.label?.toLowerCase()} {selectedCount.toLocaleString()}{' '}
              {entityLabel}. This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isProcessing}>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleConfirmedAction}
              disabled={isProcessing}
              className="bg-destructive hover:bg-destructive/90"
            >
              {isProcessing ? 'Processing...' : `Yes, ${confirmAction?.label}`}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}
```

  </action>
  <verify>npm run typecheck passes; npm run lint passes</verify>
  <done>BulkActionsBar with confirmations and processing state</done>
</task>

</tasks>

<verification>
```bash
cd apps/frontend
npm run typecheck
npm run lint
```
</verification>

<success_criteria>

- View ID appears in URL as ?view=xxx when view is selected
- Filter state is encoded in URL as ?filters=xxx (JSON)
- Sort state appears as ?sortBy=xxx&sortOrder=asc
- Search appears as ?q=searchterm
- Pasting a URL with these params loads the correct state
- Browser back/forward navigates view history
- Switching views updates URL without full page reload
- Bulk actions show confirmation for destructive actions
- Processing state disables buttons during action
  </success_criteria>

<output>
After completion, create `.planning/phases/13-hubspot-style-saved-views-system/13-14-SUMMARY.md`
</output>
