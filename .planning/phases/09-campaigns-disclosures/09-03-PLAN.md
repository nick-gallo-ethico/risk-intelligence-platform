---
phase: 09-campaigns-disclosures
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/disclosures/threshold.service.ts
  - apps/backend/src/modules/disclosures/dto/threshold-rule.dto.ts
autonomous: true

must_haves:
  truths:
    - "Threshold rules can be configured with multiple conditions"
    - "Rolling window aggregates calculate correctly across time periods"
    - "Rules can trigger different actions: flag, create_case, require_approval"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "ThresholdRule model with conditions"
      contains: "model ThresholdRule"
    - path: "apps/backend/src/modules/disclosures/threshold.service.ts"
      provides: "Threshold evaluation engine"
      exports: ["ThresholdService"]
    - path: "apps/backend/src/modules/disclosures/dto/threshold-rule.dto.ts"
      provides: "Threshold rule DTOs"
      exports: ["CreateThresholdRuleDto", "ThresholdRuleResponseDto"]
  key_links:
    - from: "apps/backend/src/modules/disclosures/threshold.service.ts"
      to: "json-rules-engine"
      via: "npm dependency"
      pattern: "import.*json-rules-engine"
---

<objective>
Create the threshold configuration engine with rule builder for auto-case creation per RS.35-RS.38 - policy-driven automation with multi-dimensional rolling window aggregates.

Purpose: Enable compliance officers to define threshold rules that automatically trigger actions (flag for review, create case, require approval) when disclosure values exceed limits. This is the 09-A3 work item from the spec.

Output:
- Prisma schema for ThresholdRule model
- ThresholdService using json-rules-engine for rule evaluation
- DTOs for threshold rule configuration
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-campaigns-disclosures/09-CONTEXT.md
@.planning/phases/09-campaigns-disclosures/09-RESEARCH.md

# json-rules-engine patterns
@02-MODULES/09-CAMPAIGNS-DISCLOSURES-SPEC.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ThresholdRule model to Prisma schema</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
Add threshold rule model for configuring auto-case creation rules:

```prisma
// Threshold Rule Configuration (RS.35-RS.38)
model ThresholdRule {
  id              String    @id @default(uuid())
  organizationId  String
  organization    Organization @relation(fields: [organizationId], references: [id])

  name            String
  description     String?

  // Scope - which disclosure types this applies to
  disclosureTypes DisclosureFormType[]

  // Conditions - JSON array of rule conditions
  // Format: { field, operator, value, conjunction }[]
  conditions      Json

  // Aggregate configuration (RS.38 - multi-dimensional)
  aggregateConfig Json?     // { dimensions: [], timeWindow: {}, groupBy: [] }

  // Action to take when triggered
  action          ThresholdAction
  actionConfig    Json?     // Additional config for action (e.g., case template, notify list)

  // Retroactive behavior (RS.37)
  applyMode       ThresholdApplyMode @default(FORWARD_ONLY)

  // Priority for rule ordering (higher = evaluated first)
  priority        Int       @default(0)

  isActive        Boolean   @default(true)

  // Metadata
  createdById     String
  createdBy       User      @relation(fields: [createdById], references: [id])
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([organizationId, isActive])
  @@index([organizationId, disclosureTypes])
}

enum ThresholdAction {
  FLAG_REVIEW         // Flag for compliance review
  CREATE_CASE         // Auto-create case
  REQUIRE_APPROVAL    // Route through approval workflow
  NOTIFY              // Send notification only
}

enum ThresholdApplyMode {
  FORWARD_ONLY        // Apply to new disclosures only
  RETROACTIVE         // Re-evaluate all historical
  RETROACTIVE_DATE    // Re-evaluate from specific date
}

// Threshold trigger log - tracks when rules fire
model ThresholdTriggerLog {
  id              String    @id @default(uuid())
  organizationId  String

  ruleId          String
  rule            ThresholdRule @relation(fields: [ruleId], references: [id])

  // What triggered it
  disclosureId    String    // RIU ID for the disclosure
  personId        String

  // Evaluation details
  evaluatedValue  Decimal   @db.Decimal(12, 2)
  thresholdValue  Decimal   @db.Decimal(12, 2)
  aggregateBreakdown Json?  // Detail of aggregate calculation

  // Action taken
  actionTaken     ThresholdAction
  caseId          String?   // If case was created
  case            Case?     @relation(fields: [caseId], references: [id])

  triggeredAt     DateTime  @default(now())

  @@index([organizationId, ruleId])
  @@index([organizationId, personId])
  @@index([organizationId, triggeredAt])
}
```

Also add the relation to ThresholdRule:
```prisma
// Add to ThresholdRule model
triggers        ThresholdTriggerLog[]
```

Run: `cd apps/backend && npx prisma format`
  </action>
  <verify>
cd apps/backend && npx prisma validate
  </verify>
  <done>
Prisma schema validates with ThresholdRule and ThresholdTriggerLog models.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create threshold rule DTOs</name>
  <files>apps/backend/src/modules/disclosures/dto/threshold-rule.dto.ts</files>
  <action>
Create DTOs for threshold rule configuration:

```typescript
// apps/backend/src/modules/disclosures/dto/threshold-rule.dto.ts

import {
  IsString,
  IsOptional,
  IsArray,
  IsEnum,
  IsBoolean,
  IsInt,
  ValidateNested,
  Min,
  Max,
  MinLength,
  MaxLength,
} from 'class-validator';
import { Type } from 'class-transformer';
import { DisclosureFormTypeDto } from './form-template.dto';

// Threshold action types
export enum ThresholdActionDto {
  FLAG_REVIEW = 'FLAG_REVIEW',
  CREATE_CASE = 'CREATE_CASE',
  REQUIRE_APPROVAL = 'REQUIRE_APPROVAL',
  NOTIFY = 'NOTIFY',
}

export enum ThresholdApplyModeDto {
  FORWARD_ONLY = 'FORWARD_ONLY',
  RETROACTIVE = 'RETROACTIVE',
  RETROACTIVE_DATE = 'RETROACTIVE_DATE',
}

// Condition operator types
export enum ConditionOperator {
  EQUALS = 'eq',
  NOT_EQUALS = 'neq',
  GREATER_THAN = 'gt',
  GREATER_THAN_OR_EQUALS = 'gte',
  LESS_THAN = 'lt',
  LESS_THAN_OR_EQUALS = 'lte',
  CONTAINS = 'contains',
  NOT_CONTAINS = 'not_contains',
  IN = 'in',
  NOT_IN = 'not_in',
}

// Single condition
export class RuleConditionDto {
  @IsString()
  field: string;  // Field path: 'disclosureValue', 'relatedParty.type', etc.

  @IsEnum(ConditionOperator)
  operator: ConditionOperator;

  value: unknown;  // Can be number, string, array depending on operator

  @IsOptional()
  @IsEnum(['AND', 'OR'])
  conjunction?: 'AND' | 'OR';
}

// Aggregate configuration (RS.38)
export class AggregateConfigDto {
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  dimensions?: string[];  // 'person', 'entity', 'category', 'department'

  @IsOptional()
  timeWindow?: {
    type: 'rolling' | 'calendar';
    period: 'days' | 'months' | 'years';
    value: number;
  };

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  groupBy?: string[];  // Fields to group by for aggregate

  @IsOptional()
  @IsString()
  aggregateField?: string;  // Field to aggregate (default: disclosureValue)

  @IsOptional()
  @IsEnum(['SUM', 'COUNT', 'AVG', 'MAX'])
  aggregateFunction?: 'SUM' | 'COUNT' | 'AVG' | 'MAX';
}

// Action configuration
export class ActionConfigDto {
  @IsOptional()
  @IsString()
  caseTemplateId?: string;  // Template for auto-created case

  @IsOptional()
  @IsString()
  caseTitle?: string;  // Title template: "Gift threshold exceeded: {{personName}}"

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  notifyUsers?: string[];  // User IDs to notify

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  notifyRoles?: string[];  // Roles to notify (all users with role)

  @IsOptional()
  @IsString()
  workflowTemplateId?: string;  // Approval workflow template
}

// Create threshold rule DTO
export class CreateThresholdRuleDto {
  @IsString()
  @MinLength(3)
  @MaxLength(200)
  name: string;

  @IsOptional()
  @IsString()
  @MaxLength(2000)
  description?: string;

  @IsArray()
  @IsEnum(DisclosureFormTypeDto, { each: true })
  disclosureTypes: DisclosureFormTypeDto[];

  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => RuleConditionDto)
  conditions: RuleConditionDto[];

  @IsOptional()
  @ValidateNested()
  @Type(() => AggregateConfigDto)
  aggregateConfig?: AggregateConfigDto;

  @IsEnum(ThresholdActionDto)
  action: ThresholdActionDto;

  @IsOptional()
  @ValidateNested()
  @Type(() => ActionConfigDto)
  actionConfig?: ActionConfigDto;

  @IsOptional()
  @IsEnum(ThresholdApplyModeDto)
  applyMode?: ThresholdApplyModeDto;

  @IsOptional()
  @IsInt()
  @Min(0)
  @Max(100)
  priority?: number;
}

export class UpdateThresholdRuleDto {
  @IsOptional()
  @IsString()
  @MinLength(3)
  @MaxLength(200)
  name?: string;

  @IsOptional()
  @IsString()
  @MaxLength(2000)
  description?: string;

  @IsOptional()
  @IsArray()
  @IsEnum(DisclosureFormTypeDto, { each: true })
  disclosureTypes?: DisclosureFormTypeDto[];

  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => RuleConditionDto)
  conditions?: RuleConditionDto[];

  @IsOptional()
  @ValidateNested()
  @Type(() => AggregateConfigDto)
  aggregateConfig?: AggregateConfigDto;

  @IsOptional()
  @IsEnum(ThresholdActionDto)
  action?: ThresholdActionDto;

  @IsOptional()
  @ValidateNested()
  @Type(() => ActionConfigDto)
  actionConfig?: ActionConfigDto;

  @IsOptional()
  @IsBoolean()
  isActive?: boolean;

  @IsOptional()
  @IsInt()
  @Min(0)
  @Max(100)
  priority?: number;
}

// Response DTO
export class ThresholdRuleResponseDto {
  id: string;
  organizationId: string;
  name: string;
  description?: string;
  disclosureTypes: string[];
  conditions: RuleConditionDto[];
  aggregateConfig?: AggregateConfigDto;
  action: string;
  actionConfig?: ActionConfigDto;
  applyMode: string;
  priority: number;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;

  // Statistics
  triggerCount?: number;
  lastTriggeredAt?: Date;
}

// Evaluation result
export interface ThresholdEvaluationResult {
  triggered: boolean;
  triggeredRules: TriggeredRule[];
  recommendedAction: ThresholdActionDto | null;
}

export interface TriggeredRule {
  ruleId: string;
  ruleName: string;
  action: ThresholdActionDto;
  evaluatedValue: number;
  thresholdValue: number;
  aggregateBreakdown?: AggregateBreakdown;
}

export interface AggregateBreakdown {
  relatedDisclosures: {
    id: string;
    date: Date;
    value: number;
  }[];
  totalValue: number;
  windowStart: Date;
  windowEnd: Date;
}
```
  </action>
  <verify>
cd apps/backend && npx tsc --noEmit
  </verify>
  <done>
DTOs compile with full support for conditions, aggregate config, and action config. Includes evaluation result types for threshold checks.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ThresholdService with json-rules-engine</name>
  <files>apps/backend/src/modules/disclosures/threshold.service.ts</files>
  <action>
First install json-rules-engine:
```bash
cd apps/backend && npm install json-rules-engine
```

Then create the threshold service:

```typescript
// apps/backend/src/modules/disclosures/threshold.service.ts

import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../../common/prisma/prisma.service';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { AuditService } from '../../common/audit/audit.service';
import { Engine, Rule, RuleResult } from 'json-rules-engine';
import { Decimal } from '@prisma/client/runtime/library';
import {
  CreateThresholdRuleDto,
  UpdateThresholdRuleDto,
  ThresholdRuleResponseDto,
  ThresholdEvaluationResult,
  TriggeredRule,
  AggregateBreakdown,
  RuleConditionDto,
  ConditionOperator,
  ThresholdActionDto,
  AggregateConfigDto,
} from './dto/threshold-rule.dto';
import { ThresholdAction, Prisma } from '@prisma/client';

@Injectable()
export class ThresholdService {
  private readonly logger = new Logger(ThresholdService.name);

  constructor(
    private prisma: PrismaService,
    private eventEmitter: EventEmitter2,
    private auditService: AuditService,
  ) {}

  /**
   * Create a threshold rule
   */
  async create(
    dto: CreateThresholdRuleDto,
    organizationId: string,
    userId: string,
  ): Promise<ThresholdRuleResponseDto> {
    const rule = await this.prisma.thresholdRule.create({
      data: {
        organizationId,
        name: dto.name,
        description: dto.description,
        disclosureTypes: dto.disclosureTypes,
        conditions: dto.conditions as Prisma.JsonValue,
        aggregateConfig: dto.aggregateConfig as Prisma.JsonValue,
        action: dto.action as ThresholdAction,
        actionConfig: dto.actionConfig as Prisma.JsonValue,
        applyMode: dto.applyMode || 'FORWARD_ONLY',
        priority: dto.priority || 0,
        createdById: userId,
      },
    });

    await this.auditService.log({
      entityType: 'THRESHOLD_RULE',
      entityId: rule.id,
      action: 'created',
      actionDescription: `Created threshold rule "${rule.name}" with action ${rule.action}`,
      actorUserId: userId,
      organizationId,
    });

    return this.mapToResponse(rule);
  }

  /**
   * Update a threshold rule
   */
  async update(
    id: string,
    dto: UpdateThresholdRuleDto,
    organizationId: string,
    userId: string,
  ): Promise<ThresholdRuleResponseDto> {
    const existing = await this.findOneOrThrow(id, organizationId);

    const rule = await this.prisma.thresholdRule.update({
      where: { id },
      data: {
        name: dto.name,
        description: dto.description,
        disclosureTypes: dto.disclosureTypes,
        conditions: dto.conditions as Prisma.JsonValue,
        aggregateConfig: dto.aggregateConfig as Prisma.JsonValue,
        action: dto.action as ThresholdAction,
        actionConfig: dto.actionConfig as Prisma.JsonValue,
        isActive: dto.isActive,
        priority: dto.priority,
      },
    });

    await this.auditService.log({
      entityType: 'THRESHOLD_RULE',
      entityId: rule.id,
      action: 'updated',
      actionDescription: `Updated threshold rule "${rule.name}"`,
      actorUserId: userId,
      organizationId,
    });

    return this.mapToResponse(rule);
  }

  /**
   * Evaluate a disclosure against all applicable threshold rules
   */
  async evaluateDisclosure(
    disclosureId: string,
    organizationId: string,
    disclosureType: string,
    disclosureData: Record<string, unknown>,
    personId: string,
  ): Promise<ThresholdEvaluationResult> {
    // Get all active rules for this disclosure type
    const rules = await this.prisma.thresholdRule.findMany({
      where: {
        organizationId,
        isActive: true,
        disclosureTypes: { has: disclosureType },
      },
      orderBy: { priority: 'desc' },
    });

    if (rules.length === 0) {
      return { triggered: false, triggeredRules: [], recommendedAction: null };
    }

    const triggeredRules: TriggeredRule[] = [];
    let highestPriorityAction: ThresholdActionDto | null = null;

    for (const rule of rules) {
      const result = await this.evaluateRule(
        rule,
        disclosureData,
        personId,
        organizationId,
      );

      if (result.triggered) {
        triggeredRules.push({
          ruleId: rule.id,
          ruleName: rule.name,
          action: rule.action as ThresholdActionDto,
          evaluatedValue: result.evaluatedValue,
          thresholdValue: result.thresholdValue,
          aggregateBreakdown: result.aggregateBreakdown,
        });

        // Track highest priority action
        if (!highestPriorityAction) {
          highestPriorityAction = rule.action as ThresholdActionDto;
        } else {
          // CREATE_CASE > REQUIRE_APPROVAL > FLAG_REVIEW > NOTIFY
          const actionPriority = {
            CREATE_CASE: 4,
            REQUIRE_APPROVAL: 3,
            FLAG_REVIEW: 2,
            NOTIFY: 1,
          };
          if (actionPriority[rule.action] > actionPriority[highestPriorityAction]) {
            highestPriorityAction = rule.action as ThresholdActionDto;
          }
        }

        // Log trigger
        await this.logTrigger(rule, disclosureId, personId, result, organizationId);
      }
    }

    if (triggeredRules.length > 0) {
      this.eventEmitter.emit('threshold.triggered', {
        organizationId,
        disclosureId,
        personId,
        triggeredRules,
        recommendedAction: highestPriorityAction,
      });
    }

    return {
      triggered: triggeredRules.length > 0,
      triggeredRules,
      recommendedAction: highestPriorityAction,
    };
  }

  /**
   * Evaluate a single rule against disclosure data
   */
  private async evaluateRule(
    rule: any,
    disclosureData: Record<string, unknown>,
    personId: string,
    organizationId: string,
  ): Promise<{
    triggered: boolean;
    evaluatedValue: number;
    thresholdValue: number;
    aggregateBreakdown?: AggregateBreakdown;
  }> {
    const conditions = rule.conditions as RuleConditionDto[];
    const aggregateConfig = rule.aggregateConfig as AggregateConfigDto | null;

    // If aggregate config exists, calculate aggregate value first
    let evaluatedValue = 0;
    let aggregateBreakdown: AggregateBreakdown | undefined;

    if (aggregateConfig) {
      const aggregateResult = await this.calculateAggregate(
        personId,
        organizationId,
        aggregateConfig,
        disclosureData,
      );
      evaluatedValue = aggregateResult.totalValue;
      aggregateBreakdown = aggregateResult;
    } else {
      // Use the disclosure value directly
      evaluatedValue = this.extractNumericValue(disclosureData, 'disclosureValue');
    }

    // Create json-rules-engine for condition evaluation
    const engine = new Engine();

    // Convert our conditions to json-rules-engine format
    const engineConditions = this.buildEngineConditions(conditions);

    // Add the main rule
    engine.addRule(new Rule({
      conditions: engineConditions,
      event: { type: 'threshold-met' },
    }));

    // Build facts from disclosure data plus aggregate
    const facts = {
      ...this.flattenData(disclosureData),
      aggregateValue: evaluatedValue,
      disclosureValue: this.extractNumericValue(disclosureData, 'disclosureValue'),
    };

    const { events } = await engine.run(facts);

    // Find the threshold value from conditions
    const thresholdCondition = conditions.find(c =>
      ['gte', 'gt', 'lte', 'lt'].includes(c.operator)
    );
    const thresholdValue = thresholdCondition?.value as number || 0;

    return {
      triggered: events.length > 0,
      evaluatedValue,
      thresholdValue,
      aggregateBreakdown,
    };
  }

  /**
   * Calculate aggregate value across time window (RS.38)
   */
  private async calculateAggregate(
    personId: string,
    organizationId: string,
    config: AggregateConfigDto,
    currentDisclosure: Record<string, unknown>,
  ): Promise<AggregateBreakdown> {
    // Calculate time window
    const windowEnd = new Date();
    let windowStart = new Date();

    if (config.timeWindow) {
      const { period, value, type } = config.timeWindow;
      if (type === 'rolling') {
        switch (period) {
          case 'days':
            windowStart.setDate(windowStart.getDate() - value);
            break;
          case 'months':
            windowStart.setMonth(windowStart.getMonth() - value);
            break;
          case 'years':
            windowStart.setFullYear(windowStart.getFullYear() - value);
            break;
        }
      } else {
        // Calendar year/quarter
        windowStart = new Date(windowEnd.getFullYear(), 0, 1);
      }
    } else {
      // Default: rolling 12 months
      windowStart.setFullYear(windowStart.getFullYear() - 1);
    }

    // Build where clause for aggregate query
    const whereClause: Prisma.RiuDisclosureExtensionWhereInput = {
      organizationId,
      createdAt: {
        gte: windowStart,
        lte: windowEnd,
      },
    };

    // Add dimension filters
    if (config.dimensions?.includes('person')) {
      // Get the Person ID linked to this disclosure submitter
      whereClause.relatedPersonId = personId;
    }

    if (config.dimensions?.includes('entity') && currentDisclosure.relatedCompany) {
      whereClause.relatedCompany = {
        contains: currentDisclosure.relatedCompany as string,
        mode: 'insensitive',
      };
    }

    // Query related disclosures
    const relatedDisclosures = await this.prisma.riuDisclosureExtension.findMany({
      where: whereClause,
      select: {
        riuId: true,
        disclosureValue: true,
        createdAt: true,
      },
      orderBy: { createdAt: 'desc' },
    });

    // Calculate aggregate
    const field = config.aggregateField || 'disclosureValue';
    const func = config.aggregateFunction || 'SUM';

    let totalValue = 0;
    const values = relatedDisclosures
      .map(d => d.disclosureValue ? Number(d.disclosureValue) : 0)
      .filter(v => v > 0);

    // Add current disclosure value
    const currentValue = this.extractNumericValue(currentDisclosure, 'disclosureValue');
    values.push(currentValue);

    switch (func) {
      case 'SUM':
        totalValue = values.reduce((sum, v) => sum + v, 0);
        break;
      case 'COUNT':
        totalValue = values.length;
        break;
      case 'AVG':
        totalValue = values.length > 0 ? values.reduce((sum, v) => sum + v, 0) / values.length : 0;
        break;
      case 'MAX':
        totalValue = Math.max(...values, 0);
        break;
    }

    return {
      relatedDisclosures: relatedDisclosures.map(d => ({
        id: d.riuId,
        date: d.createdAt,
        value: d.disclosureValue ? Number(d.disclosureValue) : 0,
      })),
      totalValue,
      windowStart,
      windowEnd,
    };
  }

  /**
   * Build json-rules-engine conditions from our condition DTOs
   */
  private buildEngineConditions(conditions: RuleConditionDto[]): any {
    if (conditions.length === 0) {
      return { all: [] };
    }

    // Convert to json-rules-engine format
    const engineConditions = conditions.map(c => ({
      fact: c.field === 'disclosureValue' ? 'aggregateValue' : c.field,
      operator: this.mapOperator(c.operator),
      value: c.value,
    }));

    // Check for OR conjunction
    const hasOr = conditions.some(c => c.conjunction === 'OR');
    if (hasOr) {
      return { any: engineConditions };
    }

    return { all: engineConditions };
  }

  /**
   * Map our operator to json-rules-engine operator
   */
  private mapOperator(op: ConditionOperator): string {
    const mapping: Record<string, string> = {
      eq: 'equal',
      neq: 'notEqual',
      gt: 'greaterThan',
      gte: 'greaterThanInclusive',
      lt: 'lessThan',
      lte: 'lessThanInclusive',
      contains: 'contains',
      in: 'in',
      not_in: 'notIn',
    };
    return mapping[op] || 'equal';
  }

  /**
   * Extract numeric value from nested data path
   */
  private extractNumericValue(data: Record<string, unknown>, path: string): number {
    const parts = path.split('.');
    let value: unknown = data;
    for (const part of parts) {
      if (value && typeof value === 'object') {
        value = (value as Record<string, unknown>)[part];
      } else {
        return 0;
      }
    }
    return typeof value === 'number' ? value : parseFloat(String(value)) || 0;
  }

  /**
   * Flatten nested object for json-rules-engine facts
   */
  private flattenData(
    data: Record<string, unknown>,
    prefix = '',
  ): Record<string, unknown> {
    const result: Record<string, unknown> = {};
    for (const [key, value] of Object.entries(data)) {
      const newKey = prefix ? `${prefix}.${key}` : key;
      if (value && typeof value === 'object' && !Array.isArray(value)) {
        Object.assign(result, this.flattenData(value as Record<string, unknown>, newKey));
      } else {
        result[newKey] = value;
      }
    }
    return result;
  }

  /**
   * Log threshold trigger for audit
   */
  private async logTrigger(
    rule: any,
    disclosureId: string,
    personId: string,
    result: any,
    organizationId: string,
  ): Promise<void> {
    await this.prisma.thresholdTriggerLog.create({
      data: {
        organizationId,
        ruleId: rule.id,
        disclosureId,
        personId,
        evaluatedValue: new Decimal(result.evaluatedValue),
        thresholdValue: new Decimal(result.thresholdValue),
        aggregateBreakdown: result.aggregateBreakdown as Prisma.JsonValue,
        actionTaken: rule.action,
      },
    });
  }

  // CRUD helpers
  async findOne(id: string, organizationId: string): Promise<ThresholdRuleResponseDto | null> {
    const rule = await this.prisma.thresholdRule.findFirst({
      where: { id, organizationId },
    });
    return rule ? this.mapToResponse(rule) : null;
  }

  async findMany(organizationId: string): Promise<ThresholdRuleResponseDto[]> {
    const rules = await this.prisma.thresholdRule.findMany({
      where: { organizationId },
      orderBy: { priority: 'desc' },
    });
    return rules.map(r => this.mapToResponse(r));
  }

  async delete(id: string, organizationId: string, userId: string): Promise<void> {
    const rule = await this.findOneOrThrow(id, organizationId);
    await this.prisma.thresholdRule.delete({ where: { id } });
    await this.auditService.log({
      entityType: 'THRESHOLD_RULE',
      entityId: id,
      action: 'deleted',
      actionDescription: `Deleted threshold rule "${rule.name}"`,
      actorUserId: userId,
      organizationId,
    });
  }

  private async findOneOrThrow(id: string, organizationId: string) {
    const rule = await this.prisma.thresholdRule.findFirst({
      where: { id, organizationId },
    });
    if (!rule) throw new NotFoundException('Threshold rule not found');
    return rule;
  }

  private mapToResponse(rule: any): ThresholdRuleResponseDto {
    return {
      id: rule.id,
      organizationId: rule.organizationId,
      name: rule.name,
      description: rule.description,
      disclosureTypes: rule.disclosureTypes,
      conditions: rule.conditions as RuleConditionDto[],
      aggregateConfig: rule.aggregateConfig as AggregateConfigDto,
      action: rule.action,
      actionConfig: rule.actionConfig as any,
      applyMode: rule.applyMode,
      priority: rule.priority,
      isActive: rule.isActive,
      createdAt: rule.createdAt,
      updatedAt: rule.updatedAt,
    };
  }
}
```
  </action>
  <verify>
cd apps/backend && npx tsc --noEmit
  </verify>
  <done>
ThresholdService compiles with json-rules-engine integration. Supports rule CRUD, evaluation with rolling window aggregates, and trigger logging.
  </done>
</task>

</tasks>

<verification>
1. Run `cd apps/backend && npx prisma validate` - schema valid
2. Run `cd apps/backend && npx tsc --noEmit` - no TypeScript errors
3. Verify ThresholdRule model has:
   - Conditions JSON for rule configuration
   - AggregateConfig JSON for rolling window settings
   - Action enum for triggered behavior
   - ApplyMode for retroactive handling
4. Verify ThresholdService has:
   - evaluateDisclosure() method using json-rules-engine
   - calculateAggregate() for rolling window aggregates
   - Trigger logging to ThresholdTriggerLog
</verification>

<success_criteria>
1. Prisma schema validates with ThresholdRule and ThresholdTriggerLog
2. TypeScript compiles with no errors
3. json-rules-engine installed and imported
4. Rolling window calculation supports days/months/years periods
5. Aggregate functions: SUM, COUNT, AVG, MAX
6. Trigger events emitted for downstream processing
</success_criteria>

<output>
After completion, create `.planning/phases/09-campaigns-disclosures/09-03-SUMMARY.md`
</output>
