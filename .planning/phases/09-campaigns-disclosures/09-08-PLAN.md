---
phase: 09-campaigns-disclosures
plan: 08
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/campaigns/campaign-scheduling.service.ts
  - apps/backend/src/modules/campaigns/campaign-scheduling.processor.ts
autonomous: true

must_haves:
  truths:
    - "Campaigns can be scheduled for future launch"
    - "Wave-based staggered rollout distributes assignments over time"
    - "Blackout dates prevent sends during holidays"
  artifacts:
    - path: "apps/backend/src/modules/campaigns/campaign-scheduling.service.ts"
      provides: "Scheduled and staggered campaign launches"
      exports: ["CampaignSchedulingService"]
    - path: "apps/backend/src/modules/campaigns/campaign-scheduling.processor.ts"
      provides: "BullMQ processor for scheduled launches"
      exports: ["CampaignSchedulingProcessor"]
  key_links:
    - from: "apps/backend/src/modules/campaigns/campaign-scheduling.processor.ts"
      to: "apps/backend/src/modules/campaigns/campaigns.service.ts"
      via: "service injection"
      pattern: "constructor.*CampaignsService"
---

<objective>
Create the campaign scheduling service with scheduled launches, wave-based rollout, and blackout date enforcement per RS.53.

Purpose: Enable compliance officers to schedule campaigns for future dates, stagger delivery across waves to avoid overwhelming the system, and respect organization blackout periods. This is the 09-B2 work item from the spec.

Output:
- Campaign scheduling schema additions (waves, blackouts)
- CampaignSchedulingService for schedule management
- BullMQ processor for executing scheduled launches
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-campaigns-disclosures/09-CONTEXT.md
@.planning/phases/09-campaigns-disclosures/09-RESEARCH.md

# Existing campaign infrastructure
@apps/backend/src/modules/campaigns/campaigns.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add scheduling models to Prisma schema</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
Add models for campaign scheduling:

CampaignWave:
- id, organizationId, campaignId
- waveNumber: Int
- scheduledAt: DateTime
- audiencePercentage: Int (or explicit employee IDs)
- status: PENDING, LAUNCHED, CANCELLED
- launchedAt: DateTime?

OrgBlackoutDate:
- id, organizationId
- name: String (e.g., "Year-End Freeze")
- startDate: DateTime
- endDate: DateTime
- affectsLocations: String[] (or null for all)
- isRecurring: Boolean
- recurringPattern: String? (e.g., "YEARLY")
- createdById, createdAt

Add fields to Campaign model:
- scheduledLaunchAt: DateTime?
- rolloutStrategy: 'IMMEDIATE' | 'STAGGERED' | 'PILOT_FIRST'
- rolloutConfig: Json? (wave configuration)
  </action>
  <verify>cd apps/backend && npx prisma validate</verify>
  <done>Prisma schema validates with CampaignWave, OrgBlackoutDate, and Campaign scheduling fields.</done>
</task>

<task type="auto">
  <name>Task 2: Create CampaignSchedulingService</name>
  <files>apps/backend/src/modules/campaigns/campaign-scheduling.service.ts</files>
  <action>
Create scheduling service:

1. scheduleLaunch(campaignId, scheduledAt, rolloutConfig): Schedule campaign
   - Validate not during blackout
   - Create BullMQ delayed job
   - Update campaign status to SCHEDULED

2. createWaves(campaignId, config): Create wave records
   - config: { type: 'percentage' | 'daily_count', values: number[], startDate }
   - Example: [10%, 25%, 50%, 100%] on consecutive days
   - Assign employees to waves

3. checkBlackouts(date, organizationId): boolean
   - Check if date falls in any blackout period
   - Return true if blocked

4. getNextAvailableDate(fromDate, organizationId): DateTime
   - Find next date not in blackout

5. extendDeadlines(campaignId, blackoutId): Extend deadlines that fall in blackout
   - Auto-extend by blackout duration

6. manageBlackouts(organizationId): CRUD for blackout dates

Emit: campaign.scheduled, campaign.wave.launched events
  </action>
  <verify>cd apps/backend && npx tsc --noEmit</verify>
  <done>CampaignSchedulingService compiles with scheduling, waves, and blackout management.</done>
</task>

<task type="auto">
  <name>Task 3: Create BullMQ processor for scheduled launches</name>
  <files>apps/backend/src/modules/campaigns/campaign-scheduling.processor.ts</files>
  <action>
Create BullMQ processor using existing queue infrastructure:

@Processor('campaign-scheduling')
export class CampaignSchedulingProcessor {
  @Process('launch-campaign')
  async handleLaunch(job: Job<{ campaignId: string, waveNumber?: number }>)

  @Process('launch-wave')
  async handleWaveLaunch(job: Job<{ campaignId: string, waveNumber: number }>)
}

handleLaunch:
- Get campaign
- If STAGGERED, launch first wave only
- If IMMEDIATE, create all assignments
- Update campaign status to ACTIVE
- Emit campaign.launched event
- Queue next wave if applicable

handleWaveLaunch:
- Get wave record
- Create assignments for wave employees
- Update wave status to LAUNCHED
- Queue next wave if exists
- Emit campaign.wave.launched event
  </action>
  <verify>cd apps/backend && npx tsc --noEmit</verify>
  <done>CampaignSchedulingProcessor compiles with launch and wave handling.</done>
</task>

</tasks>

<verification>
1. Prisma schema validates
2. TypeScript compiles without errors
3. Scheduled campaign creates delayed job
4. Blackout check prevents scheduling during blocked dates
5. Wave launch creates assignments in batches
</verification>

<success_criteria>
1. Campaign can be scheduled for future date
2. Waves distribute assignments over multiple days
3. Blackout dates block scheduling
4. Deadlines auto-extend when in blackout
</success_criteria>

<output>
After completion, create `.planning/phases/09-campaigns-disclosures/09-08-SUMMARY.md`
</output>
