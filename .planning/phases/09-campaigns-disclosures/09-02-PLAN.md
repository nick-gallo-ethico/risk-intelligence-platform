---
phase: 09-campaigns-disclosures
plan: 02
type: execute
wave: 1
depends_on: ["09-01"]
files_modified:
  - apps/backend/src/modules/disclosures/disclosure-form.service.ts
  - apps/backend/src/modules/disclosures/disclosures.module.ts
  - apps/backend/src/modules/disclosures/disclosure-form.controller.ts
autonomous: true

must_haves:
  truths:
    - "Form templates can be created, updated, and published"
    - "Publishing creates immutable snapshot (version-on-publish)"
    - "Cloning supports translation child creation"
  artifacts:
    - path: "apps/backend/src/modules/disclosures/disclosure-form.service.ts"
      provides: "Form template CRUD with versioning"
      exports: ["DisclosureFormService"]
    - path: "apps/backend/src/modules/disclosures/disclosure-form.controller.ts"
      provides: "REST endpoints for form templates"
      exports: ["DisclosureFormController"]
    - path: "apps/backend/src/modules/disclosures/disclosures.module.ts"
      provides: "Disclosures module registration"
      exports: ["DisclosuresModule"]
  key_links:
    - from: "apps/backend/src/modules/disclosures/disclosure-form.controller.ts"
      to: "apps/backend/src/modules/disclosures/disclosure-form.service.ts"
      via: "DI injection"
      pattern: "constructor.*DisclosureFormService"
---

<objective>
Create the form template CRUD service with versioning support per RS.32 - version-on-publish pattern where published forms become immutable snapshots.

Purpose: Enable compliance officers to create, edit, and publish disclosure form templates. This is the 09-A2 work item from the spec.

Output:
- DisclosureFormService with create, update, publish, clone operations
- DisclosureFormController with REST endpoints
- DisclosuresModule registration
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-campaigns-disclosures/09-CONTEXT.md
@.planning/phases/09-campaigns-disclosures/09-01-SUMMARY.md

# Existing patterns to follow
@apps/backend/src/modules/forms/form-schema.service.ts
@apps/backend/src/modules/investigations/investigation-template.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DisclosureFormService with versioning</name>
  <files>apps/backend/src/modules/disclosures/disclosure-form.service.ts</files>
  <action>
Create the form template service implementing version-on-publish pattern:

```typescript
// apps/backend/src/modules/disclosures/disclosure-form.service.ts

import { Injectable, BadRequestException, NotFoundException, Logger } from '@nestjs/common';
import { PrismaService } from '../../common/prisma/prisma.service';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { AuditService } from '../../common/audit/audit.service';
import {
  CreateFormTemplateDto,
  UpdateFormTemplateDto,
  PublishFormTemplateDto,
  CloneFormTemplateDto,
  FormTemplateQueryDto,
  FormTemplateResponseDto,
} from './dto/form-template.dto';
import { FormTemplateStatus, Prisma } from '@prisma/client';

@Injectable()
export class DisclosureFormService {
  private readonly logger = new Logger(DisclosureFormService.name);

  constructor(
    private prisma: PrismaService,
    private eventEmitter: EventEmitter2,
    private auditService: AuditService,
  ) {}

  /**
   * Create a new form template (draft status)
   */
  async create(
    dto: CreateFormTemplateDto,
    organizationId: string,
    userId: string,
  ): Promise<FormTemplateResponseDto> {
    // Validate parent template exists if creating translation
    if (dto.parentTemplateId) {
      const parent = await this.prisma.disclosureFormTemplate.findUnique({
        where: { id: dto.parentTemplateId },
      });
      if (!parent) {
        throw new BadRequestException('Parent template not found');
      }
      if (parent.organizationId !== organizationId) {
        throw new BadRequestException('Parent template belongs to different organization');
      }
    }

    const template = await this.prisma.disclosureFormTemplate.create({
      data: {
        organizationId,
        name: dto.name,
        description: dto.description,
        disclosureType: dto.disclosureType,
        language: dto.language || 'en',
        parentTemplateId: dto.parentTemplateId,
        fields: dto.fields as Prisma.JsonValue,
        sections: dto.sections as Prisma.JsonValue,
        validationRules: dto.validationRules as Prisma.JsonValue,
        calculatedFields: dto.calculatedFields as Prisma.JsonValue,
        uiSchema: dto.uiSchema as Prisma.JsonValue,
        status: FormTemplateStatus.DRAFT,
        version: 1,
        createdById: userId,
      },
      include: {
        translations: { select: { id: true, language: true } },
      },
    });

    await this.auditService.log({
      entityType: 'DISCLOSURE_FORM_TEMPLATE',
      entityId: template.id,
      action: 'created',
      actionDescription: `Created disclosure form template "${template.name}" (${template.disclosureType})`,
      actorUserId: userId,
      organizationId,
    });

    this.eventEmitter.emit('disclosure-form.created', {
      organizationId,
      templateId: template.id,
      userId,
    });

    return this.mapToResponse(template);
  }

  /**
   * Update a draft template. Cannot update published templates.
   */
  async update(
    id: string,
    dto: UpdateFormTemplateDto,
    organizationId: string,
    userId: string,
  ): Promise<FormTemplateResponseDto> {
    const existing = await this.findOneOrThrow(id, organizationId);

    if (existing.status === FormTemplateStatus.PUBLISHED) {
      throw new BadRequestException(
        'Cannot update published template. Create a new version instead.'
      );
    }

    const template = await this.prisma.disclosureFormTemplate.update({
      where: { id },
      data: {
        name: dto.name,
        description: dto.description,
        fields: dto.fields as Prisma.JsonValue,
        sections: dto.sections as Prisma.JsonValue,
        validationRules: dto.validationRules as Prisma.JsonValue,
        calculatedFields: dto.calculatedFields as Prisma.JsonValue,
        uiSchema: dto.uiSchema as Prisma.JsonValue,
      },
      include: {
        translations: { select: { id: true, language: true } },
      },
    });

    await this.auditService.log({
      entityType: 'DISCLOSURE_FORM_TEMPLATE',
      entityId: template.id,
      action: 'updated',
      actionDescription: `Updated disclosure form template "${template.name}"`,
      actorUserId: userId,
      organizationId,
    });

    return this.mapToResponse(template);
  }

  /**
   * Publish a template - makes it immutable and available for use.
   * If already published and has submissions, creates new version instead.
   */
  async publish(
    id: string,
    dto: PublishFormTemplateDto,
    organizationId: string,
    userId: string,
  ): Promise<FormTemplateResponseDto> {
    const existing = await this.findOneOrThrow(id, organizationId);

    // Check if already published
    if (existing.status === FormTemplateStatus.PUBLISHED) {
      // Check for existing submissions
      const hasSubmissions = await this.prisma.riuDisclosureExtension.count({
        where: { formTemplateId: id },
      }) > 0;

      if (hasSubmissions || dto.createNewVersion) {
        // Create new version (RS.32 - version-on-publish)
        return this.createNewVersion(existing, userId, organizationId);
      }
      throw new BadRequestException('Template is already published');
    }

    // Validate template before publishing
    this.validateTemplateForPublish(existing);

    const template = await this.prisma.disclosureFormTemplate.update({
      where: { id },
      data: {
        status: FormTemplateStatus.PUBLISHED,
        publishedAt: new Date(),
        publishedBy: userId,
      },
      include: {
        translations: { select: { id: true, language: true } },
      },
    });

    await this.auditService.log({
      entityType: 'DISCLOSURE_FORM_TEMPLATE',
      entityId: template.id,
      action: 'published',
      actionDescription: `Published disclosure form template "${template.name}" v${template.version}`,
      actorUserId: userId,
      organizationId,
    });

    this.eventEmitter.emit('disclosure-form.published', {
      organizationId,
      templateId: template.id,
      version: template.version,
      userId,
    });

    return this.mapToResponse(template);
  }

  /**
   * Create a new version of an existing template (version-on-publish pattern)
   */
  private async createNewVersion(
    existing: any,
    userId: string,
    organizationId: string,
  ): Promise<FormTemplateResponseDto> {
    const newVersion = existing.version + 1;

    const template = await this.prisma.disclosureFormTemplate.create({
      data: {
        organizationId,
        name: existing.name,
        description: existing.description,
        disclosureType: existing.disclosureType,
        language: existing.language,
        parentTemplateId: existing.parentTemplateId,
        fields: existing.fields,
        sections: existing.sections,
        validationRules: existing.validationRules,
        calculatedFields: existing.calculatedFields,
        uiSchema: existing.uiSchema,
        status: FormTemplateStatus.DRAFT,
        version: newVersion,
        createdById: userId,
      },
      include: {
        translations: { select: { id: true, language: true } },
      },
    });

    // Archive the old version
    await this.prisma.disclosureFormTemplate.update({
      where: { id: existing.id },
      data: { status: FormTemplateStatus.ARCHIVED },
    });

    await this.auditService.log({
      entityType: 'DISCLOSURE_FORM_TEMPLATE',
      entityId: template.id,
      action: 'version_created',
      actionDescription: `Created new version v${newVersion} of "${template.name}"`,
      actorUserId: userId,
      organizationId,
    });

    return this.mapToResponse(template);
  }

  /**
   * Clone a template, optionally as a translation child
   */
  async clone(
    id: string,
    dto: CloneFormTemplateDto,
    organizationId: string,
    userId: string,
  ): Promise<FormTemplateResponseDto> {
    const source = await this.findOneOrThrow(id, organizationId);

    const template = await this.prisma.disclosureFormTemplate.create({
      data: {
        organizationId,
        name: dto.name,
        description: source.description,
        disclosureType: source.disclosureType,
        language: dto.language || source.language,
        parentTemplateId: dto.asTranslation ? id : null,
        fields: source.fields,
        sections: source.sections,
        validationRules: source.validationRules,
        calculatedFields: source.calculatedFields,
        uiSchema: source.uiSchema,
        status: FormTemplateStatus.DRAFT,
        version: 1,
        createdById: userId,
      },
      include: {
        translations: { select: { id: true, language: true } },
      },
    });

    await this.auditService.log({
      entityType: 'DISCLOSURE_FORM_TEMPLATE',
      entityId: template.id,
      action: 'cloned',
      actionDescription: `Cloned from "${source.name}" ${dto.asTranslation ? 'as translation' : ''}`,
      actorUserId: userId,
      organizationId,
    });

    return this.mapToResponse(template);
  }

  /**
   * Archive a template (soft delete)
   */
  async archive(
    id: string,
    organizationId: string,
    userId: string,
  ): Promise<void> {
    const existing = await this.findOneOrThrow(id, organizationId);

    // Check for active campaigns using this template
    const activeCampaigns = await this.prisma.campaign.count({
      where: {
        disclosureFormTemplateId: id,
        status: { in: ['ACTIVE', 'SCHEDULED'] },
      },
    });

    if (activeCampaigns > 0) {
      throw new BadRequestException(
        'Cannot archive template with active campaigns'
      );
    }

    await this.prisma.disclosureFormTemplate.update({
      where: { id },
      data: { status: FormTemplateStatus.ARCHIVED },
    });

    await this.auditService.log({
      entityType: 'DISCLOSURE_FORM_TEMPLATE',
      entityId: id,
      action: 'archived',
      actionDescription: `Archived disclosure form template "${existing.name}"`,
      actorUserId: userId,
      organizationId,
    });
  }

  /**
   * Find one template by ID
   */
  async findOne(
    id: string,
    organizationId: string,
  ): Promise<FormTemplateResponseDto | null> {
    const template = await this.prisma.disclosureFormTemplate.findFirst({
      where: { id, organizationId },
      include: {
        translations: { select: { id: true, language: true, version: true } },
        parentTemplate: { select: { id: true, version: true, name: true } },
      },
    });

    return template ? this.mapToResponse(template) : null;
  }

  /**
   * List templates with filtering
   */
  async findMany(
    query: FormTemplateQueryDto,
    organizationId: string,
  ): Promise<FormTemplateResponseDto[]> {
    const where: Prisma.DisclosureFormTemplateWhereInput = {
      organizationId,
    };

    if (query.disclosureType) {
      where.disclosureType = query.disclosureType;
    }
    if (query.status) {
      where.status = query.status as FormTemplateStatus;
    }
    if (query.language) {
      where.language = query.language;
    }
    if (query.search) {
      where.OR = [
        { name: { contains: query.search, mode: 'insensitive' } },
        { description: { contains: query.search, mode: 'insensitive' } },
      ];
    }
    if (!query.includeTranslations) {
      where.parentTemplateId = null; // Only root templates
    }

    const templates = await this.prisma.disclosureFormTemplate.findMany({
      where,
      include: {
        translations: { select: { id: true, language: true } },
      },
      orderBy: [{ name: 'asc' }, { version: 'desc' }],
    });

    return templates.map(t => this.mapToResponse(t));
  }

  /**
   * Get all versions of a template
   */
  async getVersions(
    name: string,
    organizationId: string,
  ): Promise<FormTemplateResponseDto[]> {
    const templates = await this.prisma.disclosureFormTemplate.findMany({
      where: { name, organizationId },
      orderBy: { version: 'desc' },
    });

    return templates.map(t => this.mapToResponse(t));
  }

  private async findOneOrThrow(id: string, organizationId: string) {
    const template = await this.prisma.disclosureFormTemplate.findFirst({
      where: { id, organizationId },
    });
    if (!template) {
      throw new NotFoundException('Form template not found');
    }
    return template;
  }

  private validateTemplateForPublish(template: any): void {
    const fields = template.fields as any[];
    if (!fields || fields.length === 0) {
      throw new BadRequestException('Template must have at least one field');
    }

    const sections = template.sections as any[];
    if (!sections || sections.length === 0) {
      throw new BadRequestException('Template must have at least one section');
    }

    // Validate all fields are assigned to sections
    const fieldIds = new Set(fields.map((f: any) => f.id));
    const assignedFieldIds = new Set(sections.flatMap((s: any) => s.fields || []));
    const unassigned = [...fieldIds].filter(id => !assignedFieldIds.has(id));
    if (unassigned.length > 0) {
      throw new BadRequestException(
        `Fields not assigned to any section: ${unassigned.join(', ')}`
      );
    }
  }

  private mapToResponse(template: any): FormTemplateResponseDto {
    return {
      id: template.id,
      organizationId: template.organizationId,
      name: template.name,
      description: template.description,
      disclosureType: template.disclosureType,
      version: template.version,
      status: template.status,
      publishedAt: template.publishedAt,
      language: template.language,
      parentTemplateId: template.parentTemplateId,
      fields: template.fields as any[],
      sections: template.sections as any[],
      validationRules: template.validationRules as any[],
      calculatedFields: template.calculatedFields as any[],
      uiSchema: template.uiSchema as any,
      isSystem: template.isSystem,
      createdAt: template.createdAt,
      updatedAt: template.updatedAt,
      translationCount: template.translations?.length || 0,
      isStale: template.parentTemplate
        ? template.version < template.parentTemplate.version
        : false,
      parentVersion: template.parentTemplate?.version,
    };
  }
}
```
  </action>
  <verify>
cd apps/backend && npx tsc --noEmit
  </verify>
  <done>
DisclosureFormService compiles with create, update, publish, clone, archive, findOne, findMany, and getVersions methods. Version-on-publish pattern implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DisclosureFormController with REST endpoints</name>
  <files>apps/backend/src/modules/disclosures/disclosure-form.controller.ts</files>
  <action>
Create REST controller for form template management:

```typescript
// apps/backend/src/modules/disclosures/disclosure-form.controller.ts

import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Param,
  Body,
  Query,
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { JwtAuthGuard } from '../../common/guards/jwt-auth.guard';
import { RolesGuard } from '../../common/guards/roles.guard';
import { Roles } from '../../common/decorators/roles.decorator';
import { CurrentUser } from '../../common/decorators/current-user.decorator';
import { TenantId } from '../../common/decorators/tenant-id.decorator';
import { UserRole } from '@prisma/client';
import { DisclosureFormService } from './disclosure-form.service';
import {
  CreateFormTemplateDto,
  UpdateFormTemplateDto,
  PublishFormTemplateDto,
  CloneFormTemplateDto,
  FormTemplateQueryDto,
} from './dto/form-template.dto';

@Controller('api/v1/disclosure-forms')
@UseGuards(JwtAuthGuard, RolesGuard)
export class DisclosureFormController {
  constructor(private readonly formService: DisclosureFormService) {}

  /**
   * Create a new form template
   */
  @Post()
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async create(
    @Body() dto: CreateFormTemplateDto,
    @CurrentUser('id') userId: string,
    @TenantId() organizationId: string,
  ) {
    return this.formService.create(dto, organizationId, userId);
  }

  /**
   * List form templates with optional filtering
   */
  @Get()
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async findMany(
    @Query() query: FormTemplateQueryDto,
    @TenantId() organizationId: string,
  ) {
    return this.formService.findMany(query, organizationId);
  }

  /**
   * Get a specific form template
   */
  @Get(':id')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER, UserRole.INVESTIGATOR)
  async findOne(
    @Param('id') id: string,
    @TenantId() organizationId: string,
  ) {
    return this.formService.findOne(id, organizationId);
  }

  /**
   * Get all versions of a form template by name
   */
  @Get('versions/:name')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async getVersions(
    @Param('name') name: string,
    @TenantId() organizationId: string,
  ) {
    return this.formService.getVersions(name, organizationId);
  }

  /**
   * Update a draft form template
   */
  @Put(':id')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async update(
    @Param('id') id: string,
    @Body() dto: UpdateFormTemplateDto,
    @CurrentUser('id') userId: string,
    @TenantId() organizationId: string,
  ) {
    return this.formService.update(id, dto, organizationId, userId);
  }

  /**
   * Publish a form template
   */
  @Post(':id/publish')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  @HttpCode(HttpStatus.OK)
  async publish(
    @Param('id') id: string,
    @Body() dto: PublishFormTemplateDto,
    @CurrentUser('id') userId: string,
    @TenantId() organizationId: string,
  ) {
    return this.formService.publish(id, dto, organizationId, userId);
  }

  /**
   * Clone a form template
   */
  @Post(':id/clone')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async clone(
    @Param('id') id: string,
    @Body() dto: CloneFormTemplateDto,
    @CurrentUser('id') userId: string,
    @TenantId() organizationId: string,
  ) {
    return this.formService.clone(id, dto, organizationId, userId);
  }

  /**
   * Create a translation of a form template
   */
  @Post(':id/translations')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  async createTranslation(
    @Param('id') id: string,
    @Body() dto: CloneFormTemplateDto,
    @CurrentUser('id') userId: string,
    @TenantId() organizationId: string,
  ) {
    return this.formService.clone(
      id,
      { ...dto, asTranslation: true },
      organizationId,
      userId,
    );
  }

  /**
   * Archive a form template
   */
  @Delete(':id')
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  @HttpCode(HttpStatus.NO_CONTENT)
  async archive(
    @Param('id') id: string,
    @CurrentUser('id') userId: string,
    @TenantId() organizationId: string,
  ) {
    await this.formService.archive(id, organizationId, userId);
  }
}
```
  </action>
  <verify>
cd apps/backend && npx tsc --noEmit
  </verify>
  <done>
DisclosureFormController compiles with all REST endpoints matching spec API: POST /api/forms, GET /api/forms, GET /api/forms/:id, PUT /api/forms/:id, POST /api/forms/:id/publish, POST /api/forms/:id/translations.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create DisclosuresModule and register providers</name>
  <files>apps/backend/src/modules/disclosures/disclosures.module.ts</files>
  <action>
Create the module and register all providers:

```typescript
// apps/backend/src/modules/disclosures/disclosures.module.ts

import { Module } from '@nestjs/common';
import { DisclosureFormService } from './disclosure-form.service';
import { DisclosureFormController } from './disclosure-form.controller';
// Future services will be added here:
// import { ThresholdService } from './threshold.service';
// import { ConflictDetectionService } from './conflict-detection.service';
// import { DisclosureSubmissionService } from './disclosure-submission.service';

@Module({
  imports: [],
  controllers: [
    DisclosureFormController,
  ],
  providers: [
    DisclosureFormService,
  ],
  exports: [
    DisclosureFormService,
  ],
})
export class DisclosuresModule {}
```

Also update the AppModule to include DisclosuresModule:

```typescript
// In apps/backend/src/app.module.ts, add:
import { DisclosuresModule } from './modules/disclosures/disclosures.module';

@Module({
  imports: [
    // ... existing imports
    DisclosuresModule,
  ],
})
export class AppModule {}
```
  </action>
  <verify>
cd apps/backend && npx tsc --noEmit
  </verify>
  <done>
DisclosuresModule registered with DisclosureFormService and DisclosureFormController. Module exported for use by other modules. AppModule updated to include DisclosuresModule.
  </done>
</task>

</tasks>

<verification>
1. Run `cd apps/backend && npx tsc --noEmit` - no TypeScript errors
2. Verify DisclosureFormService has:
   - create() - creates draft template
   - update() - updates draft (rejects published)
   - publish() - makes immutable, creates new version if has submissions
   - clone() - duplicates template, optionally as translation
   - archive() - soft deletes (checks for active campaigns)
3. Verify DisclosureFormController has all REST endpoints from spec
4. Verify DisclosuresModule exports DisclosureFormService
</verification>

<success_criteria>
1. TypeScript compiles with no errors
2. Form template CRUD operations work
3. Version-on-publish pattern: publishing template with submissions creates new version
4. Translation cloning links child to parent via parentTemplateId
5. Archive checks for active campaigns before allowing
</success_criteria>

<output>
After completion, create `.planning/phases/09-campaigns-disclosures/09-02-SUMMARY.md`
</output>
