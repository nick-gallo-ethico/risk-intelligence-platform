---
phase: 09-campaigns-disclosures
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/disclosures/dto/form-template.dto.ts
  - apps/backend/src/modules/disclosures/entities/form-field.types.ts
autonomous: true

must_haves:
  truths:
    - "Disclosure form templates can be created with compliance-specific field types"
    - "Form templates support versioning with published snapshots"
    - "Repeating sections with nested repeaters can be defined"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "DisclosureFormTemplate model with versioning"
      contains: "model DisclosureFormTemplate"
    - path: "apps/backend/src/modules/disclosures/entities/form-field.types.ts"
      provides: "Compliance field type definitions"
      exports: ["FormFieldType", "ComplianceFieldType", "FormSection", "RepeaterConfig"]
    - path: "apps/backend/src/modules/disclosures/dto/form-template.dto.ts"
      provides: "Form template DTOs"
      exports: ["CreateFormTemplateDto", "UpdateFormTemplateDto", "FormFieldDto"]
  key_links:
    - from: "apps/backend/src/modules/disclosures/dto/form-template.dto.ts"
      to: "apps/backend/src/modules/disclosures/entities/form-field.types.ts"
      via: "type imports"
      pattern: "import.*FormFieldType"
---

<objective>
Create the disclosure form schema engine with compliance-specific field types, nested repeaters, and versioning support per RS.22-RS.29 and RS.32.

Purpose: Forms are the foundation for all disclosure types (COI, gift, outside employment). This establishes the data model and type system before building the CRUD service.

Output:
- Prisma schema additions for DisclosureFormTemplate and related models
- TypeScript type definitions for all compliance field types
- DTOs for form template creation/update operations
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-campaigns-disclosures/09-CONTEXT.md
@.planning/phases/09-campaigns-disclosures/09-RESEARCH.md
@02-MODULES/09-CAMPAIGNS-DISCLOSURES-SPEC.md

# Existing Form engine to reference (do NOT duplicate - extend for disclosures)
@apps/backend/src/modules/forms/form-schema.service.ts
@apps/backend/src/modules/forms/types/form.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Disclosure Form Template models to Prisma schema</name>
  <files>apps/backend/prisma/schema.prisma</files>
  <action>
Add new models for disclosure-specific form management:

```prisma
// Disclosure Form Template - extends FormDefinition concept for disclosure-specific needs
model DisclosureFormTemplate {
  id              String    @id @default(uuid())
  organizationId  String
  organization    Organization @relation(fields: [organizationId], references: [id])

  name            String
  description     String?
  disclosureType  DisclosureFormType  // COI, GIFT, OUTSIDE_EMPLOYMENT, ATTESTATION, CUSTOM

  // Versioning (RS.32)
  version         Int       @default(1)
  status          FormTemplateStatus @default(DRAFT)
  publishedAt     DateTime?
  publishedBy     String?

  // Translation (RS.33) - parent-child model
  parentTemplateId String?
  parentTemplate   DisclosureFormTemplate? @relation("FormTranslations", fields: [parentTemplateId], references: [id])
  translations     DisclosureFormTemplate[] @relation("FormTranslations")
  language         String    @default("en")

  // Schema - JSON for field definitions, sections, validation rules
  fields          Json      // FormField[] - includes compliance field types
  sections        Json      // FormSection[] - supports nested repeaters
  validationRules Json?     // ValidationRule[] - cross-field validation
  calculatedFields Json?    // CalculatedField[] - expression engine (RS.28)
  uiSchema        Json?     // UI hints (field order, widths, etc.)

  // Metadata
  isSystem        Boolean   @default(false)  // System templates are org-agnostic
  createdById     String
  createdBy       User      @relation("FormTemplateCreator", fields: [createdById], references: [id])
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  disclosures     RiuDisclosureExtension[]
  campaigns       Campaign[] @relation("CampaignFormTemplate")

  @@unique([organizationId, name, version])
  @@index([organizationId, disclosureType])
  @@index([organizationId, status])
}

enum DisclosureFormType {
  COI
  GIFT
  OUTSIDE_EMPLOYMENT
  ATTESTATION
  POLITICAL
  CHARITABLE
  TRAVEL
  CUSTOM
}

enum FormTemplateStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}
```

Also add foreign key to RiuDisclosureExtension:
```prisma
// Add to existing RiuDisclosureExtension model
formTemplateId    String?
formTemplate      DisclosureFormTemplate? @relation(fields: [formTemplateId], references: [id])
formVersion       Int?  // Snapshot of version at submission time
```

And add relation to Campaign model:
```prisma
// Add to existing Campaign model
disclosureFormTemplateId String?
disclosureFormTemplate   DisclosureFormTemplate? @relation("CampaignFormTemplate", fields: [disclosureFormTemplateId], references: [id])
```

Run: `cd apps/backend && npx prisma format`
  </action>
  <verify>
cd apps/backend && npx prisma validate
  </verify>
  <done>
Prisma schema validates with DisclosureFormTemplate model, enums, and relations to RiuDisclosureExtension and Campaign.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create compliance field type definitions</name>
  <files>apps/backend/src/modules/disclosures/entities/form-field.types.ts</files>
  <action>
Create comprehensive type definitions for disclosure form fields per RS.23:

```typescript
// apps/backend/src/modules/disclosures/entities/form-field.types.ts

/**
 * Disclosure Form Field Types
 * Implements RS.23 - Full compliance field set
 */

// Basic field types
export enum BasicFieldType {
  TEXT = 'TEXT',
  TEXTAREA = 'TEXTAREA',
  NUMBER = 'NUMBER',
  DATE = 'DATE',
  DATETIME = 'DATETIME',
  DROPDOWN = 'DROPDOWN',
  MULTI_SELECT = 'MULTI_SELECT',
  CHECKBOX = 'CHECKBOX',
  RADIO = 'RADIO',
  FILE_UPLOAD = 'FILE_UPLOAD',
}

// Compliance-specific field types (RS.23)
export enum ComplianceFieldType {
  RELATIONSHIP_MAPPER = 'RELATIONSHIP_MAPPER',  // Entity -> person relationships
  DOLLAR_THRESHOLD = 'DOLLAR_THRESHOLD',        // Currency with threshold checking
  RECURRING_DATE = 'RECURRING_DATE',            // Annual, quarterly tracking
  ENTITY_LOOKUP = 'ENTITY_LOOKUP',              // Search vendor master, HRIS
  SIGNATURE_CAPTURE = 'SIGNATURE_CAPTURE',      // Digital signature
  ATTESTATION = 'ATTESTATION',                  // Required acknowledgment
  CURRENCY = 'CURRENCY',                        // Multi-currency support
  PERCENTAGE = 'PERCENTAGE',                    // 0-100 with validation
}

export type FormFieldType = BasicFieldType | ComplianceFieldType;

// Field definition structure
export interface FormField {
  id: string;
  type: FormFieldType;
  key: string;              // Unique identifier for field data
  label: string;
  description?: string;
  placeholder?: string;

  // Validation
  required?: boolean;
  validation?: FieldValidation;

  // Conditional logic (RS.27)
  conditionals?: FieldConditional[];

  // Type-specific configuration
  config?: FieldTypeConfig;

  // UI hints
  uiConfig?: FieldUiConfig;
}

export interface FieldValidation {
  minLength?: number;
  maxLength?: number;
  min?: number;
  max?: number;
  pattern?: string;        // Regex pattern
  patternMessage?: string; // Error message for pattern failure
  customValidator?: string; // Name of registered custom validator
}

export interface FieldConditional {
  if: {
    field: string;         // Field key to check
    operator: ConditionalOperator;
    value: unknown;
  };
  then: ConditionalAction;
}

export enum ConditionalOperator {
  EQUALS = 'eq',
  NOT_EQUALS = 'neq',
  GREATER_THAN = 'gt',
  LESS_THAN = 'lt',
  GREATER_THAN_OR_EQUALS = 'gte',
  LESS_THAN_OR_EQUALS = 'lte',
  CONTAINS = 'contains',
  NOT_CONTAINS = 'not_contains',
  IS_EMPTY = 'is_empty',
  IS_NOT_EMPTY = 'is_not_empty',
}

export interface ConditionalAction {
  show?: boolean;
  hide?: boolean;
  require?: boolean;
  unrequire?: boolean;
  setValue?: unknown;
}

// Type-specific configurations
export interface FieldTypeConfig {
  // Dropdown/Multi-select
  options?: FieldOption[];
  allowOther?: boolean;
  cascadeFrom?: string;     // Field key for cascading dropdown (RS.30)

  // Entity lookup
  entityType?: 'vendor' | 'employee' | 'person' | 'organization';
  searchFields?: string[];
  displayTemplate?: string;

  // Relationship mapper
  relationshipTypes?: string[];
  allowMultiple?: boolean;

  // Dollar threshold
  thresholdWarning?: number;  // Soft warning
  thresholdBlock?: number;    // Hard block
  currency?: string;

  // Recurring date
  recurrenceType?: 'annual' | 'quarterly' | 'monthly';

  // File upload
  allowedTypes?: string[];
  maxSizeBytes?: number;
  maxFiles?: number;

  // Calculated field reference (RS.28)
  expression?: string;
  expressionFields?: string[];  // Dependencies for recalculation
}

export interface FieldOption {
  value: string;
  label: string;
  parentValue?: string;     // For cascading dropdowns
  disabled?: boolean;
}

export interface FieldUiConfig {
  colSpan?: number;         // Grid column span (1-12)
  widget?: string;          // Custom widget name
  helpText?: string;
  tooltip?: string;
  hidden?: boolean;
}

// Section structure with nested repeaters (RS.29)
export interface FormSection {
  id: string;
  title: string;
  description?: string;
  fields: string[];         // Field IDs in this section

  // Repeater configuration
  repeater?: RepeaterConfig;

  // Conditional visibility
  conditional?: FieldConditional;

  // UI
  collapsible?: boolean;
  collapsed?: boolean;
}

export interface RepeaterConfig {
  enabled: boolean;
  minItems?: number;
  maxItems?: number;
  itemLabel?: string;       // Template: "Gift {{index}}"

  // Nested repeater (RS.29 - max 2 levels)
  nestedRepeaters?: {
    fieldId: string;
    config: RepeaterConfig;
  }[];

  // Aggregation
  aggregate?: AggregateConfig[];
}

export interface AggregateConfig {
  function: 'SUM' | 'COUNT' | 'AVG' | 'MIN' | 'MAX';
  sourceField: string;      // Field to aggregate
  targetField: string;      // Where to store result
}

// Calculated field expression (RS.28)
export interface CalculatedField {
  id: string;
  key: string;
  expression: string;       // e.g., "SUM(gifts.value)"
  dependencies: string[];   // Field keys this depends on
  format?: 'currency' | 'percentage' | 'number' | 'date';
}

// Validation rule for cross-field validation (RS.27)
export interface ValidationRule {
  id: string;
  name: string;
  condition: {
    left: string;           // Field key or expression
    operator: ConditionalOperator;
    right: string;          // Field key, expression, or literal
  };
  errorMessage: string;
  severity: 'error' | 'warning';
}

// Form template summary for listings
export interface FormTemplateSummary {
  id: string;
  name: string;
  disclosureType: string;
  version: number;
  status: string;
  language: string;
  hasTranslations: boolean;
  fieldCount: number;
  createdAt: Date;
  updatedAt: Date;
}
```
  </action>
  <verify>
cd apps/backend && npx tsc --noEmit apps/backend/src/modules/disclosures/entities/form-field.types.ts
  </verify>
  <done>
TypeScript compiles without errors. All compliance field types from RS.23 are defined, including relationship mapper, dollar threshold, recurring date, entity lookup, and signature capture.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create form template DTOs with validation</name>
  <files>apps/backend/src/modules/disclosures/dto/form-template.dto.ts</files>
  <action>
Create DTOs for form template CRUD operations:

```typescript
// apps/backend/src/modules/disclosures/dto/form-template.dto.ts

import {
  IsString,
  IsOptional,
  IsEnum,
  IsArray,
  ValidateNested,
  IsBoolean,
  IsObject,
  MinLength,
  MaxLength,
} from 'class-validator';
import { Type } from 'class-transformer';
import {
  FormField,
  FormSection,
  CalculatedField,
  ValidationRule,
} from '../entities/form-field.types';

// Disclosure form types matching Prisma enum
export enum DisclosureFormTypeDto {
  COI = 'COI',
  GIFT = 'GIFT',
  OUTSIDE_EMPLOYMENT = 'OUTSIDE_EMPLOYMENT',
  ATTESTATION = 'ATTESTATION',
  POLITICAL = 'POLITICAL',
  CHARITABLE = 'CHARITABLE',
  TRAVEL = 'TRAVEL',
  CUSTOM = 'CUSTOM',
}

export class CreateFormTemplateDto {
  @IsString()
  @MinLength(3)
  @MaxLength(200)
  name: string;

  @IsOptional()
  @IsString()
  @MaxLength(2000)
  description?: string;

  @IsEnum(DisclosureFormTypeDto)
  disclosureType: DisclosureFormTypeDto;

  @IsOptional()
  @IsString()
  language?: string = 'en';

  @IsOptional()
  @IsString()
  parentTemplateId?: string;

  @IsArray()
  @ValidateNested({ each: true })
  fields: FormField[];

  @IsArray()
  @ValidateNested({ each: true })
  sections: FormSection[];

  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  validationRules?: ValidationRule[];

  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  calculatedFields?: CalculatedField[];

  @IsOptional()
  @IsObject()
  uiSchema?: Record<string, unknown>;
}

export class UpdateFormTemplateDto {
  @IsOptional()
  @IsString()
  @MinLength(3)
  @MaxLength(200)
  name?: string;

  @IsOptional()
  @IsString()
  @MaxLength(2000)
  description?: string;

  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  fields?: FormField[];

  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  sections?: FormSection[];

  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  validationRules?: ValidationRule[];

  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  calculatedFields?: CalculatedField[];

  @IsOptional()
  @IsObject()
  uiSchema?: Record<string, unknown>;
}

export class PublishFormTemplateDto {
  @IsOptional()
  @IsBoolean()
  createNewVersion?: boolean;  // If true, creates new version instead of publishing current
}

export class CloneFormTemplateDto {
  @IsString()
  @MinLength(3)
  @MaxLength(200)
  name: string;

  @IsOptional()
  @IsString()
  language?: string;

  @IsOptional()
  @IsBoolean()
  asTranslation?: boolean;  // If true, links as child translation
}

export class FormTemplateQueryDto {
  @IsOptional()
  @IsEnum(DisclosureFormTypeDto)
  disclosureType?: DisclosureFormTypeDto;

  @IsOptional()
  @IsString()
  status?: 'DRAFT' | 'PUBLISHED' | 'ARCHIVED';

  @IsOptional()
  @IsString()
  language?: string;

  @IsOptional()
  @IsString()
  search?: string;

  @IsOptional()
  @IsBoolean()
  includeTranslations?: boolean;
}

// Response DTOs
export class FormTemplateResponseDto {
  id: string;
  organizationId: string;
  name: string;
  description?: string;
  disclosureType: string;
  version: number;
  status: string;
  publishedAt?: Date;
  language: string;
  parentTemplateId?: string;
  fields: FormField[];
  sections: FormSection[];
  validationRules?: ValidationRule[];
  calculatedFields?: CalculatedField[];
  uiSchema?: Record<string, unknown>;
  isSystem: boolean;
  createdAt: Date;
  updatedAt: Date;

  // Computed
  isStale?: boolean;        // True if parent has newer version
  parentVersion?: number;   // Parent version this was based on
  translationCount?: number;
}

export class FormTemplateListItemDto {
  id: string;
  name: string;
  disclosureType: string;
  version: number;
  status: string;
  language: string;
  hasTranslations: boolean;
  fieldCount: number;
  createdAt: Date;
  updatedAt: Date;
}
```
  </action>
  <verify>
cd apps/backend && npx tsc --noEmit
  </verify>
  <done>
TypeScript compiles without errors. DTOs include all necessary fields for form template CRUD operations with proper validation decorators.
  </done>
</task>

</tasks>

<verification>
1. Run `cd apps/backend && npx prisma validate` - schema is valid
2. Run `cd apps/backend && npx tsc --noEmit` - no TypeScript errors
3. Verify DisclosureFormTemplate model has:
   - Versioning fields (version, status, publishedAt)
   - Translation fields (parentTemplateId, language)
   - JSON fields for flexible schema (fields, sections, validationRules, calculatedFields)
4. Verify form-field.types.ts includes all RS.23 compliance field types
5. Verify DTOs have proper class-validator decorators
</verification>

<success_criteria>
1. Prisma schema validates with new models
2. TypeScript compiles with no errors
3. All 8 DisclosureFormType enum values defined
4. FormField type supports all compliance-specific field types from RS.23
5. RepeaterConfig supports 2 levels of nesting per RS.29
6. CalculatedField supports expression engine per RS.28
</success_criteria>

<output>
After completion, create `.planning/phases/09-campaigns-disclosures/09-01-SUMMARY.md`
</output>
