---
phase: 10-policy-management
plan: 05
type: execute
wave: 3
depends_on: [10-02]
files_modified:
  - apps/backend/src/modules/policies/translations/policy-translation.service.ts
  - apps/backend/src/modules/policies/translations/policy-translation.controller.ts
  - apps/backend/src/modules/policies/translations/dto/translation.dto.ts
  - apps/backend/src/modules/policies/listeners/translation-stale.listener.ts
  - apps/backend/src/modules/policies/policies.module.ts
autonomous: true

must_haves:
  truths:
    - "AI translation uses existing translate skill from Phase 5"
    - "Translations are linked to specific PolicyVersion"
    - "When source policy is updated, translations marked stale"
    - "Side-by-side editing preserves original while updating translation"
  artifacts:
    - path: "apps/backend/src/modules/policies/translations/policy-translation.service.ts"
      provides: "AI translation and translation management"
      exports: ["PolicyTranslationService"]
    - path: "apps/backend/src/modules/policies/listeners/translation-stale.listener.ts"
      provides: "Marks translations stale on new version publish"
      contains: "@OnEvent"
  key_links:
    - from: "PolicyTranslationService.translate"
      to: "SkillRegistry.executeSkill"
      via: "translate skill"
      pattern: "skillRegistry.executeSkill.*translate"
    - from: "TranslationStaleListener"
      to: "PolicyVersionTranslation.update"
      via: "isStale flag"
      pattern: "isStale.*true"
---

<objective>
Implement AI-powered policy translation using the existing translate skill - generate translations linked to specific versions, track staleness on updates, enable human review workflow.

Purpose: Multi-language policy distribution with maintained translations.
Output: PolicyTranslationService with AI translation, staleness tracking, and review workflow.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-policy-management/10-RESEARCH.md
@.planning/phases/05-ai-infrastructure/05-08-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create translation DTOs and PolicyTranslationService</name>
  <files>
apps/backend/src/modules/policies/translations/dto/translation.dto.ts
apps/backend/src/modules/policies/translations/policy-translation.service.ts
  </files>
  <action>
**Create dto/translation.dto.ts:**

CreateTranslationDto:
- policyVersionId: string (required)
- languageCode: string (required, ISO 639-1: en, es, fr, de, zh, ja, ko, pt, it, nl, ru, ar, hi)
- useAI: boolean (default true - use AI translation)
- content: string (optional - for manual translation, skip AI)

UpdateTranslationDto:
- title: string (optional)
- content: string (required)
- reviewNotes: string (optional)

ReviewTranslationDto:
- status: 'APPROVED' | 'NEEDS_REVISION' | 'PUBLISHED' (required)
- reviewNotes: string (optional)

TranslationQueryDto:
- policyVersionId: string (optional)
- languageCode: string (optional)
- reviewStatus: TranslationReviewStatus (optional)
- isStale: boolean (optional)
- page: number (default 1)
- limit: number (default 20)

Language constant map:
```typescript
export const LANGUAGE_NAMES: Record<string, string> = {
  en: 'English',
  es: 'Spanish',
  fr: 'French',
  de: 'German',
  zh: 'Chinese (Simplified)',
  ja: 'Japanese',
  ko: 'Korean',
  pt: 'Portuguese',
  it: 'Italian',
  nl: 'Dutch',
  ru: 'Russian',
  ar: 'Arabic',
  hi: 'Hindi',
};
```

**Create policy-translation.service.ts:**

@Injectable() PolicyTranslationService with:
- PrismaService
- SkillRegistry (from ai module)
- ActivityService
- EventEmitter2

Methods:

`translate(dto: CreateTranslationDto, userId: string, organizationId: string): Promise<PolicyVersionTranslation>`
- Get policyVersion with policy relation
- Verify version exists and belongs to org
- Check if translation already exists for this version+language
  - If exists and dto.useAI, throw ConflictException
- If dto.useAI:
  - Execute translate skill: skillRegistry.executeSkill('translate', { content: policyVersion.content, targetLanguage: dto.languageCode, preserveFormatting: true }, context)
  - Also translate title
  - Extract plainText from translated content
  - Create PolicyVersionTranslation with translatedBy: 'AI', aiModel: skill response model
- If manual (dto.content provided):
  - Create PolicyVersionTranslation with translatedBy: 'HUMAN'
- Set reviewStatus: 'PENDING_REVIEW'
- Log activity: "Translation created for {language}"
- Emit PolicyTranslationCreatedEvent
- Return translation

`updateTranslation(translationId: string, dto: UpdateTranslationDto, userId: string, organizationId: string): Promise<PolicyVersionTranslation>`
- Verify translation exists and belongs to org
- Update content, title, plainText
- If AI-generated, change translatedBy to 'HUMAN' (human edited)
- Reset isStale to false (human verified current)
- Log activity
- Return updated translation

`reviewTranslation(translationId: string, dto: ReviewTranslationDto, userId: string, organizationId: string): Promise<PolicyVersionTranslation>`
- Verify translation exists
- Update reviewStatus, reviewedAt, reviewedById, reviewNotes
- Log activity
- Emit PolicyTranslationReviewedEvent
- Return translation

`refreshStaleTranslation(translationId: string, userId: string, organizationId: string): Promise<PolicyVersionTranslation>`
- Get stale translation with policyVersion
- Re-translate using AI (same language)
- Create new content but preserve existing translation ID
- Mark as PENDING_REVIEW, isStale: false
- Log activity
- Return updated translation

`findByVersion(policyVersionId: string, organizationId: string): Promise<PolicyVersionTranslation[]>`
- Return all translations for a version
- Order by languageCode

`findStale(organizationId: string): Promise<PolicyVersionTranslation[]>`
- Return all translations where isStale: true
- Include policyVersion and policy for context

`getAvailableLanguages(): string[]`
- Return list of supported language codes

`private extractPlainText(html: string): string`
- Strip HTML, collapse whitespace
  </action>
  <verify>Service compiles. translate() uses SkillRegistry for AI translation.</verify>
  <done>PolicyTranslationService provides AI translation via existing skill and manual editing support.</done>
</task>

<task type="auto">
  <name>Task 2: Create translation staleness listener</name>
  <files>apps/backend/src/modules/policies/listeners/translation-stale.listener.ts</files>
  <action>
Create listeners/translation-stale.listener.ts:

@Injectable() TranslationStaleListener with:
- PrismaService
- EventEmitter2
- NotificationService (for alerting translators)

**Event Handlers:**

`@OnEvent('policy.published', { async: true })`
onPolicyPublished(event: PolicyPublishedEvent)
- Get the previous version's translations (version - 1)
- If no previous version, return (first publish, no stale)
- Mark all those translations as isStale: true
- Get translation assignments (users who created/reviewed translations)
- Queue notifications: "Policy updated - translations need review"
- Emit TranslationsMarkedStaleEvent with count

Implementation:
```typescript
async onPolicyPublished(event: PolicyPublishedEvent) {
  try {
    const { policyId, policyVersionId, organizationId } = event;

    // Get the new version number
    const newVersion = await this.prisma.policyVersion.findUnique({
      where: { id: policyVersionId },
      select: { version: true },
    });

    if (newVersion.version <= 1) {
      return; // First version, no previous translations
    }

    // Find previous version
    const previousVersion = await this.prisma.policyVersion.findFirst({
      where: {
        policyId,
        version: newVersion.version - 1,
      },
      select: { id: true },
    });

    if (!previousVersion) {
      return;
    }

    // Mark all translations for previous version as stale
    const result = await this.prisma.policyVersionTranslation.updateMany({
      where: {
        policyVersionId: previousVersion.id,
        isStale: false,
      },
      data: {
        isStale: true,
      },
    });

    if (result.count > 0) {
      this.eventEmitter.emit('translations.marked_stale', {
        policyId,
        previousVersionId: previousVersion.id,
        newVersionId: policyVersionId,
        translationCount: result.count,
        organizationId,
      });
    }
  } catch (error) {
    console.error('Failed to mark translations stale:', error);
    // Don't throw - publishing should succeed even if stale marking fails
  }
}
```

Wrap in try-catch per project pattern - failures logged, not thrown.
  </action>
  <verify>Listener compiles. Handler checks for previous version before marking stale.</verify>
  <done>TranslationStaleListener marks translations stale when source policy publishes new version.</done>
</task>

<task type="auto">
  <name>Task 3: Create translation controller and update module</name>
  <files>
apps/backend/src/modules/policies/translations/policy-translation.controller.ts
apps/backend/src/modules/policies/translations/index.ts
apps/backend/src/modules/policies/policies.module.ts
  </files>
  <action>
**Create policy-translation.controller.ts:**

@Controller('policies')
@UseGuards(AuthGuard, RolesGuard)
@ApiBearerAuth()
@ApiTags('policies')

Endpoints:

POST /versions/:versionId/translations - Create translation (AI or manual)
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER, Role.POLICY_AUTHOR)
- @Body() CreateTranslationDto
- Returns PolicyVersionTranslation

GET /versions/:versionId/translations - Get translations for version
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER, Role.POLICY_AUTHOR, Role.READ_ONLY)
- Returns PolicyVersionTranslation[]

PUT /translations/:id - Update translation content
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER, Role.POLICY_AUTHOR)
- @Body() UpdateTranslationDto
- Returns PolicyVersionTranslation

POST /translations/:id/review - Review translation
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER)
- @Body() ReviewTranslationDto
- Returns PolicyVersionTranslation

POST /translations/:id/refresh - Re-translate stale translation
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER, Role.POLICY_AUTHOR)
- Returns PolicyVersionTranslation

GET /translations/stale - Get all stale translations
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER)
- Returns PolicyVersionTranslation[]

GET /translations/languages - Get available languages
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER, Role.POLICY_AUTHOR)
- Returns { code: string, name: string }[]

**Create translations/index.ts:**
Export service, controller, DTOs

**Update policies.module.ts:**

Add to imports:
- AiModule (for SkillRegistry access)

Add to providers:
- PolicyTranslationService
- TranslationStaleListener

Add to controllers:
- PolicyTranslationController

Add to exports:
- PolicyTranslationService
  </action>
  <verify>Run `npm run build`. Controller compiles. Module imports AiModule.</verify>
  <done>Translation endpoints exposed, module imports AiModule for SkillRegistry.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` succeeds
2. translate() calls skillRegistry.executeSkill('translate', ...)
3. Manual translation creates record with translatedBy: 'HUMAN'
4. Policy publish marks previous version's translations as stale
5. refreshStaleTranslation() re-translates with AI
6. Review workflow updates reviewStatus, reviewedAt, reviewedById
7. Module imports AiModule for SkillRegistry access
</verification>

<success_criteria>
- AI translation uses existing translate skill (no custom LLM calls)
- Translations linked to specific PolicyVersion (not just Policy)
- Publishing new version marks old translations stale
- Side-by-side editing preserves original (read-only) while editing translation
- Review workflow with PENDING_REVIEW, APPROVED, NEEDS_REVISION, PUBLISHED states
</success_criteria>

<output>
After completion, create `.planning/phases/10-policy-management/10-05-SUMMARY.md`
</output>
