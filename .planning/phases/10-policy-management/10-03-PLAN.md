---
phase: 10-policy-management
plan: 03
type: execute
wave: 2
depends_on: [10-01]
files_modified:
  - apps/backend/src/modules/policies/approval/policy-approval.service.ts
  - apps/backend/src/modules/policies/approval/policy-approval.controller.ts
  - apps/backend/src/modules/policies/listeners/workflow.listener.ts
  - apps/backend/src/modules/policies/policies.module.ts
autonomous: true

must_haves:
  truths:
    - "Policies can be submitted for approval using existing WorkflowEngine"
    - "Workflow completion triggers policy status change to APPROVED"
    - "Workflow rejection returns policy to DRAFT status"
    - "Approval actions (approve/reject/request-changes) route through WorkflowEngine"
  artifacts:
    - path: "apps/backend/src/modules/policies/approval/policy-approval.service.ts"
      provides: "Policy approval workflow integration"
      exports: ["PolicyApprovalService"]
    - path: "apps/backend/src/modules/policies/listeners/workflow.listener.ts"
      provides: "Event listener for workflow state changes"
      contains: "@OnEvent"
  key_links:
    - from: "PolicyApprovalService.submitForApproval"
      to: "WorkflowEngineService.startWorkflow"
      via: "service injection"
      pattern: "workflowEngineService.startWorkflow"
    - from: "WorkflowListener"
      to: "PoliciesService"
      via: "event handling"
      pattern: "OnEvent.*workflow"
---

<objective>
Integrate policy approval with the existing WorkflowEngine - submit for approval, handle reviewer actions, and sync workflow state changes back to policy status.

Purpose: Enable approval workflows before policy publishing, leveraging existing Phase 1 workflow infrastructure.
Output: PolicyApprovalService and event listeners that connect policies to workflow engine.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-policy-management/10-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PolicyApprovalService for workflow integration</name>
  <files>apps/backend/src/modules/policies/approval/policy-approval.service.ts</files>
  <action>
Create approval/policy-approval.service.ts:

@Injectable() PolicyApprovalService with constructor injecting:
- PrismaService
- WorkflowEngineService (from modules/workflow)
- ActivityService
- EventEmitter2

**Methods:**

`submitForApproval(policyId: string, workflowTemplateId: string | null, submissionNotes: string, userId: string, organizationId: string): Promise<{ policy: Policy, workflowInstance: WorkflowInstance }>`
- Verify policy exists and is in DRAFT status
- Verify policy has draftContent (something to approve)
- Get workflow template (use workflowTemplateId or find default for POLICY entity type)
- If no workflow template found, throw BadRequestException("No approval workflow configured")
- Start workflow instance via workflowEngineService.startWorkflow():
  - templateId
  - entityType: 'POLICY'
  - entityId: policyId
  - startedById: userId
  - organizationId
  - context: { submissionNotes }
- Update policy status to PENDING_APPROVAL
- Log activity: "Policy submitted for approval"
- Emit PolicySubmittedForApprovalEvent
- Return { policy, workflowInstance }

`cancelApproval(policyId: string, reason: string, userId: string, organizationId: string): Promise<Policy>`
- Find active workflow instance for this policy
- Call workflowEngineService.cancel() with reason
- Update policy status back to DRAFT
- Log activity
- Return updated policy

`getApprovalStatus(policyId: string, organizationId: string): Promise<{ policy: Policy, workflowInstance: WorkflowInstance | null, currentStep: any, reviewers: any[] }>`
- Find policy
- Find active workflow instance for this policy (if any)
- Get current step and assignees from workflow instance
- Return status summary

`getDefaultWorkflowTemplate(organizationId: string): Promise<WorkflowTemplate | null>`
- Find workflow template where:
  - organizationId matches
  - isDefault: true
  - isArchived: false
  - entityType includes 'POLICY' (or is a general approval workflow)
- Return template or null

`getAvailableWorkflowTemplates(organizationId: string): Promise<WorkflowTemplate[]>`
- Find all active workflow templates for organization
- Filter to those suitable for policies (either general or policy-specific)
- Return sorted by name
  </action>
  <verify>Service compiles. Methods use WorkflowEngineService for all workflow operations.</verify>
  <done>PolicyApprovalService integrates with WorkflowEngine for policy approval workflows.</done>
</task>

<task type="auto">
  <name>Task 2: Create workflow event listener for policy status sync</name>
  <files>apps/backend/src/modules/policies/listeners/workflow.listener.ts</files>
  <action>
Create listeners/workflow.listener.ts:

**First, import or define workflow event types from the workflow module:**

```typescript
// Import from workflow module if exported, otherwise define locally
import {
  WorkflowCompletedEvent,
  WorkflowCancelledEvent,
  WorkflowRejectedEvent,
  WorkflowStepCompletedEvent,
} from '@/modules/workflow/events/workflow.events';

// If not exported from workflow module, check apps/backend/src/modules/workflow/events/
// and import from there. If types don't exist, define them:
//
// interface WorkflowCompletedEvent {
//   workflowInstanceId: string;
//   entityType: string;
//   entityId: string;
//   completedAt: Date;
// }
//
// interface WorkflowCancelledEvent {
//   workflowInstanceId: string;
//   entityType: string;
//   entityId: string;
//   reason: string;
//   cancelledAt: Date;
// }
//
// interface WorkflowRejectedEvent {
//   workflowInstanceId: string;
//   entityType: string;
//   entityId: string;
//   reason: string;
//   rejectedAt: Date;
// }
//
// interface WorkflowStepCompletedEvent {
//   workflowInstanceId: string;
//   entityType: string;
//   entityId: string;
//   stepId: string;
//   stepName: string;
//   completedById: string;
//   completedByName: string;
// }
```

@Injectable() PolicyWorkflowListener with constructor injecting:
- PrismaService
- EventEmitter2
- ActivityService

**Event Handlers:**

`@OnEvent('workflow.completed', { async: true })`
onWorkflowCompleted(event: WorkflowCompletedEvent)
- Check if event.entityType === 'POLICY'
- If not POLICY, return early (ignore)
- Update policy status to APPROVED
- Log activity: "Policy approved via workflow"
- Emit PolicyApprovedEvent

`@OnEvent('workflow.cancelled', { async: true })`
onWorkflowCancelled(event: WorkflowCancelledEvent)
- Check if event.entityType === 'POLICY'
- If not POLICY, return early
- Update policy status back to DRAFT
- Log activity: "Policy approval workflow cancelled"
- Emit PolicyApprovalCancelledEvent

`@OnEvent('workflow.rejected', { async: true })`
onWorkflowRejected(event: WorkflowRejectedEvent)
- Check if event.entityType === 'POLICY'
- If not POLICY, return early
- Update policy status back to DRAFT
- Log activity with rejection reason: "Policy rejected: {reason}"
- Emit PolicyRejectedEvent

`@OnEvent('workflow.step_completed', { async: true })`
onWorkflowStepCompleted(event: WorkflowStepCompletedEvent)
- Check if event.entityType === 'POLICY'
- If not POLICY, return early
- Log activity: "Approval step completed by {approverName}"
- Emit PolicyApprovalStepCompletedEvent (for notification)

All handlers wrapped in try-catch - failures logged, not thrown (per project pattern).
  </action>
  <verify>Listener compiles. Event handlers check entityType before processing. Event types are properly imported or defined.</verify>
  <done>PolicyWorkflowListener syncs workflow events to policy status changes.</done>
</task>

<task type="auto">
  <name>Task 3: Create approval controller and update module</name>
  <files>
apps/backend/src/modules/policies/approval/policy-approval.controller.ts
apps/backend/src/modules/policies/policies.module.ts
  </files>
  <action>
**Create approval/policy-approval.controller.ts:**

@Controller('policies')
@UseGuards(AuthGuard, RolesGuard)
@ApiBearerAuth()
@ApiTags('policies')

Endpoints:

POST /:id/submit-for-approval - Submit policy for approval
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER, Role.POLICY_AUTHOR)
- @Body() { workflowTemplateId?: string, submissionNotes?: string }
- Returns { policy, workflowInstance }

POST /:id/cancel-approval - Cancel approval workflow
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER)
- @Body() { reason: string }
- Returns updated Policy

GET /:id/approval-status - Get approval status
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER, Role.POLICY_AUTHOR, Role.POLICY_REVIEWER)
- Returns { policy, workflowInstance, currentStep, reviewers }

GET /workflow-templates - Get available workflow templates
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER, Role.POLICY_AUTHOR)
- Returns WorkflowTemplate[]

**Update policies.module.ts:**

Add to providers:
- PolicyApprovalService
- PolicyWorkflowListener

Add to imports:
- WorkflowModule (for WorkflowEngineService access)

Add to controllers:
- PolicyApprovalController

Add to exports:
- PolicyApprovalService
  </action>
  <verify>Run `npm run build`. Controller and module compile. Approval endpoints accessible.</verify>
  <done>Approval controller exposes submission and status endpoints, module imports WorkflowModule.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` succeeds
2. submitForApproval() calls WorkflowEngineService.startWorkflow()
3. Policy status changes to PENDING_APPROVAL on submit
4. Workflow.completed event updates policy to APPROVED
5. Workflow.rejected/cancelled events return policy to DRAFT
6. Controller endpoints have proper role guards
7. Module imports WorkflowModule
</verification>

<success_criteria>
- Policies integrate with existing WorkflowEngine (no custom approval system)
- Submit for approval starts workflow, changes status to PENDING_APPROVAL
- Workflow completion changes status to APPROVED (ready for publish)
- Workflow rejection/cancellation returns to DRAFT
- Approval status queryable with current step and reviewers
</success_criteria>

<output>
After completion, create `.planning/phases/10-policy-management/10-03-SUMMARY.md`
</output>
