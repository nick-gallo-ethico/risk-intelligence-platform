---
phase: 10-policy-management
plan: 08
type: execute
wave: 4
depends_on: [10-02, 10-03, 10-05]
files_modified:
  - apps/frontend/src/app/(authenticated)/policies/page.tsx
  - apps/frontend/src/app/(authenticated)/policies/new/page.tsx
  - apps/frontend/src/app/(authenticated)/policies/[id]/edit/page.tsx
  - apps/frontend/src/components/policies/policy-list.tsx
  - apps/frontend/src/components/policies/policy-editor.tsx
  - apps/frontend/src/components/policies/policy-filters.tsx
  - apps/frontend/src/services/policies.ts
  - apps/frontend/src/types/policy.ts
autonomous: true

must_haves:
  truths:
    - "Policy list shows all policies with status, type, owner, and version info"
    - "Policy editor uses Tiptap for rich text with autosave"
    - "Draft vs published state clearly indicated with banner"
    - "Submit for approval action available from editor"
  artifacts:
    - path: "apps/frontend/src/app/(authenticated)/policies/page.tsx"
      provides: "Policy list page"
      min_lines: 50
    - path: "apps/frontend/src/components/policies/policy-editor.tsx"
      provides: "Rich text policy editor with autosave"
      min_lines: 100
    - path: "apps/frontend/src/services/policies.ts"
      provides: "API client for policy operations"
      exports: ["policiesApi"]
  key_links:
    - from: "PolicyListPage"
      to: "policiesApi.list"
      via: "data fetching"
      pattern: "policiesApi.list"
    - from: "PolicyEditor"
      to: "RichTextEditor"
      via: "component composition"
      pattern: "RichTextEditor"
---

<objective>
Create the policy management UI - list page with filtering, new policy creation, and rich text editor with autosave and draft/published state management.

Purpose: Enable compliance officers to manage policies through a professional editing experience.
Output: Policy list page, creation page, editor page with Tiptap integration.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-policy-management/10-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create policy types and API client</name>
  <files>
apps/frontend/src/types/policy.ts
apps/frontend/src/services/policies.ts
  </files>
  <action>
**Create types/policy.ts:**

```typescript
export type PolicyStatus = 'DRAFT' | 'PENDING_APPROVAL' | 'APPROVED' | 'PUBLISHED' | 'RETIRED';

export type PolicyType =
  | 'CODE_OF_CONDUCT'
  | 'ANTI_HARASSMENT'
  | 'ANTI_BRIBERY'
  | 'DATA_PRIVACY'
  | 'INFORMATION_SECURITY'
  | 'GIFT_ENTERTAINMENT'
  | 'CONFLICTS_OF_INTEREST'
  | 'TRAVEL_EXPENSE'
  | 'WHISTLEBLOWER'
  | 'SOCIAL_MEDIA'
  | 'ACCEPTABLE_USE'
  | 'OTHER';

export interface Policy {
  id: string;
  title: string;
  slug: string;
  policyType: PolicyType;
  category?: string;
  status: PolicyStatus;
  currentVersion: number;
  draftContent?: string;
  draftUpdatedAt?: string;
  effectiveDate?: string;
  reviewDate?: string;
  ownerId: string;
  owner?: { id: string; name: string; email: string };
  createdAt: string;
  updatedAt: string;
}

export interface PolicyVersion {
  id: string;
  policyId: string;
  version: number;
  versionLabel?: string;
  content: string;
  summary?: string;
  changeNotes?: string;
  publishedAt: string;
  publishedBy?: { id: string; name: string };
  effectiveDate: string;
  isLatest: boolean;
}

export interface PolicyTranslation {
  id: string;
  languageCode: string;
  languageName: string;
  title: string;
  content: string;
  translatedBy: 'AI' | 'HUMAN' | 'IMPORT';
  reviewStatus: 'PENDING_REVIEW' | 'APPROVED' | 'NEEDS_REVISION' | 'PUBLISHED';
  isStale: boolean;
}

export interface CreatePolicyDto {
  title: string;
  policyType: PolicyType;
  category?: string;
  content?: string;
  ownerId?: string;
  effectiveDate?: string;
  reviewDate?: string;
}

export interface UpdatePolicyDto {
  title?: string;
  policyType?: PolicyType;
  category?: string;
  content?: string;
  effectiveDate?: string;
  reviewDate?: string;
}

export interface PublishPolicyDto {
  versionLabel?: string;
  summary?: string;
  changeNotes?: string;
  effectiveDate?: string;
}

export interface PolicyFilters {
  status?: PolicyStatus;
  policyType?: PolicyType;
  ownerId?: string;
  search?: string;
}
```

**Create services/policies.ts:**

```typescript
import { apiClient } from './api-client';
import type { Policy, PolicyVersion, CreatePolicyDto, UpdatePolicyDto, PublishPolicyDto, PolicyFilters, PolicyTranslation } from '@/types/policy';

export const policiesApi = {
  list: async (filters?: PolicyFilters, page = 1, limit = 20) => {
    const params = new URLSearchParams({ page: String(page), limit: String(limit) });
    if (filters?.status) params.set('status', filters.status);
    if (filters?.policyType) params.set('policyType', filters.policyType);
    if (filters?.ownerId) params.set('ownerId', filters.ownerId);
    if (filters?.search) params.set('search', filters.search);
    return apiClient.get<{ data: Policy[], total: number }>(`/policies?${params}`);
  },

  getById: async (id: string) => {
    return apiClient.get<Policy>(`/policies/${id}`);
  },

  create: async (dto: CreatePolicyDto) => {
    return apiClient.post<Policy>('/policies', dto);
  },

  updateDraft: async (id: string, dto: UpdatePolicyDto) => {
    return apiClient.put<Policy>(`/policies/${id}`, dto);
  },

  publish: async (id: string, dto: PublishPolicyDto) => {
    return apiClient.post<PolicyVersion>(`/policies/${id}/publish`, dto);
  },

  retire: async (id: string) => {
    return apiClient.post<Policy>(`/policies/${id}/retire`);
  },

  getVersions: async (id: string) => {
    return apiClient.get<PolicyVersion[]>(`/policies/${id}/versions`);
  },

  submitForApproval: async (id: string, workflowTemplateId?: string, submissionNotes?: string) => {
    return apiClient.post<{ policy: Policy }>(`/policies/${id}/submit-for-approval`, {
      workflowTemplateId,
      submissionNotes,
    });
  },

  cancelApproval: async (id: string, reason: string) => {
    return apiClient.post<Policy>(`/policies/${id}/cancel-approval`, { reason });
  },

  getApprovalStatus: async (id: string) => {
    return apiClient.get<{ policy: Policy; workflowInstance: any; currentStep: any }>(`/policies/${id}/approval-status`);
  },

  getWorkflowTemplates: async () => {
    return apiClient.get<any[]>('/policies/workflow-templates');
  },

  // Translations
  getTranslations: async (versionId: string) => {
    return apiClient.get<PolicyTranslation[]>(`/policies/versions/${versionId}/translations`);
  },

  createTranslation: async (versionId: string, languageCode: string) => {
    return apiClient.post<PolicyTranslation>(`/policies/versions/${versionId}/translations`, {
      policyVersionId: versionId,
      languageCode,
      useAI: true,
    });
  },
};
```
  </action>
  <verify>Types compile. API client methods match backend endpoints.</verify>
  <done>Policy types and API client created for all policy operations.</done>
</task>

<task type="auto">
  <name>Task 2: Create policy list page with filters</name>
  <files>
apps/frontend/src/app/(authenticated)/policies/page.tsx
apps/frontend/src/components/policies/policy-list.tsx
apps/frontend/src/components/policies/policy-filters.tsx
  </files>
  <action>
**Create components/policies/policy-filters.tsx:**

PolicyFilters component with:
- Status dropdown (All, Draft, Pending Approval, Published, Retired)
- Policy Type dropdown (all types)
- Owner filter (user search/select)
- Search input (debounced)
- "Clear Filters" button
- Uses shadcn/ui Select, Input components
- Calls onChange with updated filters

**Create components/policies/policy-list.tsx:**

PolicyList component accepting policies array:
- Table with columns: Title, Type, Status, Version, Owner, Last Updated, Actions
- Status badge with appropriate colors:
  - DRAFT: gray
  - PENDING_APPROVAL: yellow
  - APPROVED: blue
  - PUBLISHED: green
  - RETIRED: red
- Type displayed as formatted string (CODE_OF_CONDUCT -> "Code of Conduct")
- Version shows "v{currentVersion}" or "Draft" if 0
- Actions dropdown: Edit, View Details, Submit for Approval (if DRAFT), Retire (if PUBLISHED)
- Click row to navigate to /policies/[id]/edit
- Empty state: "No policies found. Create your first policy to get started."
- Uses shadcn/ui Table, Badge, DropdownMenu

**Create app/(authenticated)/policies/page.tsx:**

PoliciesPage:
- Breadcrumb: Dashboard > Policies
- Page header with "Policies" title and "New Policy" button
- PolicyFilters component
- PolicyList component with React Query data fetching
- Pagination controls
- Loading skeleton while fetching
- Error state with retry button

```tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { useState } from 'react';
import { Plus } from 'lucide-react';
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { PolicyList } from '@/components/policies/policy-list';
import { PolicyFilters } from '@/components/policies/policy-filters';
import { policiesApi } from '@/services/policies';
import type { PolicyFilters as Filters } from '@/types/policy';

export default function PoliciesPage() {
  const [filters, setFilters] = useState<Filters>({});
  const [page, setPage] = useState(1);

  const { data, isLoading, error } = useQuery({
    queryKey: ['policies', filters, page],
    queryFn: () => policiesApi.list(filters, page),
  });

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-semibold">Policies</h1>
          <p className="text-muted-foreground">Manage your organization's policies</p>
        </div>
        <Button asChild>
          <Link href="/policies/new">
            <Plus className="mr-2 h-4 w-4" />
            New Policy
          </Link>
        </Button>
      </div>

      <PolicyFilters filters={filters} onChange={setFilters} />

      {isLoading ? (
        <PolicyListSkeleton />
      ) : error ? (
        <ErrorState onRetry={() => {}} />
      ) : (
        <PolicyList
          policies={data?.data || []}
          total={data?.total || 0}
          page={page}
          onPageChange={setPage}
        />
      )}
    </div>
  );
}
```
  </action>
  <verify>Page compiles. PolicyList renders policies with status badges. Filters update query.</verify>
  <done>Policy list page with filtering, pagination, and action buttons.</done>
</task>

<task type="auto">
  <name>Task 3: Create policy editor with Tiptap and autosave</name>
  <files>
apps/frontend/src/app/(authenticated)/policies/new/page.tsx
apps/frontend/src/app/(authenticated)/policies/[id]/edit/page.tsx
apps/frontend/src/components/policies/policy-editor.tsx
  </files>
  <action>
**Create components/policies/policy-editor.tsx:**

PolicyEditor component:
- Props: policy (optional for new), onSave, onPublish, onSubmitForApproval
- Uses existing RichTextEditor (Tiptap) from components/rich-text/rich-text-editor.tsx
- Form fields:
  - Title (required)
  - Policy Type (select)
  - Category (optional text)
  - Effective Date (optional date picker)
  - Review Date (optional date picker)
- Editor toolbar: Bold, Italic, Headings, Lists, Links, Tables
- Draft status banner when status === 'DRAFT':
  - "DRAFT - Last saved X minutes ago" with subtle gray background
  - Per CONTEXT.md: calming design, not alarming
- Pending approval banner when status === 'PENDING_APPROVAL':
  - "In Approval Workflow - Editing disabled"
  - Show current step and reviewers
- Autosave with debounce (2-3 seconds after typing stops):
  - Use useEffect with setTimeout
  - Call onSave with content
  - Update "Last saved" timestamp
  - Show "Saving..." indicator during save
- Action buttons:
  - Save Draft (always, manual save)
  - Submit for Approval (if DRAFT and has content)
  - Publish (if APPROVED or DRAFT without workflow)
- Keyboard shortcuts: Mod+S for save

```tsx
'use client';

import { useEffect, useRef, useState, useCallback } from 'react';
import { useForm } from 'react-hook-form';
import { RichTextEditor } from '@/components/rich-text/rich-text-editor';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Select } from '@/components/ui/select';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { FileText, Send, Upload } from 'lucide-react';
import type { Policy, UpdatePolicyDto, PolicyType } from '@/types/policy';

interface PolicyEditorProps {
  policy?: Policy;
  onSave: (data: UpdatePolicyDto) => Promise<void>;
  onSubmitForApproval?: () => void;
  onPublish?: () => void;
  isSubmitting?: boolean;
}

const AUTOSAVE_DELAY = 2500; // 2.5 seconds

export function PolicyEditor({
  policy,
  onSave,
  onSubmitForApproval,
  onPublish,
  isSubmitting,
}: PolicyEditorProps) {
  const [content, setContent] = useState(policy?.draftContent || '');
  const [lastSaved, setLastSaved] = useState<Date | null>(null);
  const [isSaving, setIsSaving] = useState(false);
  const autosaveTimeoutRef = useRef<NodeJS.Timeout>();
  const { register, handleSubmit, watch, setValue } = useForm({
    defaultValues: {
      title: policy?.title || '',
      policyType: policy?.policyType || 'OTHER',
      category: policy?.category || '',
      effectiveDate: policy?.effectiveDate?.split('T')[0] || '',
      reviewDate: policy?.reviewDate?.split('T')[0] || '',
    },
  });

  // Autosave effect
  const triggerAutosave = useCallback(() => {
    if (autosaveTimeoutRef.current) {
      clearTimeout(autosaveTimeoutRef.current);
    }
    autosaveTimeoutRef.current = setTimeout(async () => {
      setIsSaving(true);
      await onSave({ content });
      setLastSaved(new Date());
      setIsSaving(false);
    }, AUTOSAVE_DELAY);
  }, [content, onSave]);

  useEffect(() => {
    if (policy?.status === 'PENDING_APPROVAL') return; // Don't autosave during approval
    triggerAutosave();
    return () => {
      if (autosaveTimeoutRef.current) {
        clearTimeout(autosaveTimeoutRef.current);
      }
    };
  }, [content, triggerAutosave, policy?.status]);

  // Keyboard shortcut: Mod+S to save
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 's') {
        e.preventDefault();
        onSave({ content });
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [content, onSave]);

  const isEditable = policy?.status !== 'PENDING_APPROVAL';

  return (
    <div className="space-y-6">
      {/* Draft/Approval Banner */}
      {policy?.status === 'DRAFT' && (
        <Alert className="bg-muted border-muted-foreground/20">
          <FileText className="h-4 w-4" />
          <AlertDescription>
            <span className="font-medium">DRAFT</span>
            {lastSaved && (
              <span className="ml-2 text-muted-foreground">
                Last saved {formatRelativeTime(lastSaved)}
              </span>
            )}
            {isSaving && <span className="ml-2 text-muted-foreground">Saving...</span>}
          </AlertDescription>
        </Alert>
      )}

      {policy?.status === 'PENDING_APPROVAL' && (
        <Alert className="bg-yellow-50 border-yellow-200">
          <AlertDescription>
            <span className="font-medium">In Approval Workflow</span>
            <span className="ml-2 text-muted-foreground">Editing disabled during review</span>
          </AlertDescription>
        </Alert>
      )}

      {/* Form Fields */}
      <div className="grid grid-cols-2 gap-4">
        <Input {...register('title')} placeholder="Policy Title" disabled={!isEditable} />
        {/* Policy Type Select, Category, Dates */}
      </div>

      {/* Rich Text Editor */}
      <div className="min-h-[500px] border rounded-lg">
        <RichTextEditor
          content={content}
          onChange={setContent}
          editable={isEditable}
          placeholder="Start writing your policy..."
        />
      </div>

      {/* Action Buttons */}
      <div className="flex justify-end gap-2">
        {policy?.status === 'DRAFT' && (
          <>
            <Button variant="outline" onClick={() => onSave({ content })} disabled={isSubmitting}>
              Save Draft
            </Button>
            {onSubmitForApproval && (
              <Button onClick={onSubmitForApproval} disabled={isSubmitting || !content}>
                <Send className="mr-2 h-4 w-4" />
                Submit for Approval
              </Button>
            )}
          </>
        )}
        {(policy?.status === 'APPROVED' || (policy?.status === 'DRAFT' && onPublish)) && (
          <Button onClick={onPublish} disabled={isSubmitting || !content}>
            <Upload className="mr-2 h-4 w-4" />
            Publish
          </Button>
        )}
      </div>
    </div>
  );
}
```

**Create app/(authenticated)/policies/new/page.tsx:**
- Form to create new policy
- Save creates policy, redirects to /policies/[id]/edit

**Create app/(authenticated)/policies/[id]/edit/page.tsx:**
- Load policy by ID
- Render PolicyEditor
- Handle save, submit for approval, publish actions
- Show loading state while fetching
  </action>
  <verify>Editor compiles. Autosave triggers after typing stops. Rich text renders. Status banners show correctly.</verify>
  <done>Policy editor with Tiptap, autosave, and draft/approval state management.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` succeeds in frontend
2. Policy list shows all policies with filters working
3. New policy page creates draft and redirects to editor
4. Editor autosaves after 2-3 seconds of inactivity
5. Draft banner shows "Last saved X minutes ago"
6. Pending approval shows "Editing disabled"
7. Submit for Approval button available for DRAFT policies
8. Keyboard shortcut Mod+S saves
</verification>

<success_criteria>
- Policy list with status, type, owner, version columns
- Filters by status, type, owner, search
- Rich text editor uses existing Tiptap (RichTextEditor)
- Autosave with debounce (2-3 seconds)
- Draft vs published clearly indicated
- Submit for approval action available
</success_criteria>

<output>
After completion, create `.planning/phases/10-policy-management/10-08-SUMMARY.md`
</output>
