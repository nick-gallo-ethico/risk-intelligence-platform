---
phase: 10-policy-management
plan: 02
type: execute
wave: 2
depends_on: [10-01]
files_modified:
  - apps/backend/src/modules/policies/policies.module.ts
  - apps/backend/src/modules/policies/policies.service.ts
  - apps/backend/src/modules/policies/policies.controller.ts
  - apps/backend/src/modules/policies/events/policy.events.ts
  - apps/backend/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "PoliciesService provides CRUD for policies with draft management"
    - "Publish operation creates immutable PolicyVersion and clears draft"
    - "Editing a published policy creates a new draft (does not modify published)"
    - "Events emitted for all policy mutations"
  artifacts:
    - path: "apps/backend/src/modules/policies/policies.service.ts"
      provides: "Policy CRUD with version-on-publish"
      exports: ["PoliciesService"]
    - path: "apps/backend/src/modules/policies/policies.controller.ts"
      provides: "REST endpoints for policy operations"
      exports: ["PoliciesController"]
    - path: "apps/backend/src/modules/policies/policies.module.ts"
      provides: "NestJS module exporting PoliciesService"
      exports: ["PoliciesModule"]
  key_links:
    - from: "PoliciesService.publish"
      to: "PolicyVersion create"
      via: "prisma.policyVersion.create"
      pattern: "policyVersion.create"
    - from: "PoliciesController"
      to: "PoliciesService"
      via: "dependency injection"
      pattern: "constructor.*PoliciesService"
---

<objective>
Create the Policy service with version-on-publish pattern - draft editing, publishing to immutable versions, and policy lifecycle management.

Purpose: Core business logic for policy management that all other policy features depend on.
Output: PoliciesModule with service and controller, ready for workflow and translation integration.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-policy-management/10-RESEARCH.md
@.planning/phases/10-policy-management/10-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Policy events and PoliciesService</name>
  <files>
apps/backend/src/modules/policies/events/policy.events.ts
apps/backend/src/modules/policies/policies.service.ts
  </files>
  <action>
**Create events/policy.events.ts:**

Event classes extending BaseEvent pattern:
- PolicyCreatedEvent { policyId, title, ownerId }
- PolicyUpdatedEvent { policyId, changes }
- PolicyPublishedEvent { policyId, policyVersionId, version }
- PolicyRetiredEvent { policyId }
- PolicyStatusChangedEvent { policyId, fromStatus, toStatus }

**Create policies.service.ts:**

@Injectable() PoliciesService with constructor injecting:
- PrismaService
- ActivityService (from common/activity)
- EventEmitter2

**Methods:**

`create(dto: CreatePolicyDto, userId: string, organizationId: string): Promise<Policy>`
- Generate slug from title (lowercase, hyphenated, unique within org)
- Create policy with status DRAFT
- Set draftContent, draftUpdatedAt, draftUpdatedById
- Emit PolicyCreatedEvent
- Log activity

`findById(id: string, organizationId: string): Promise<Policy>`
- Include latestVersion, owner relations
- Return null if not found or wrong org

`findAll(query: PolicyQueryDto, organizationId: string): Promise<{ data: Policy[], total: number }>`
- Apply filters: status, policyType, ownerId, search (title contains)
- Pagination with page/limit
- Include owner relation
- Sort by sortBy/sortOrder

`updateDraft(policyId: string, dto: UpdatePolicyDto, userId: string, organizationId: string): Promise<Policy>`
- Verify policy exists and belongs to org
- If status is PENDING_APPROVAL, throw BadRequestException
- If status is PUBLISHED and no draftContent, copy latest version content to draft
- Update draft fields, set draftUpdatedAt/draftUpdatedById
- Emit PolicyUpdatedEvent
- Log activity

`publish(policyId: string, dto: PublishPolicyDto, userId: string, organizationId: string): Promise<PolicyVersion>`
- Verify policy has draftContent
- Use transaction:
  - Mark previous isLatest versions as false
  - Create PolicyVersion with version = currentVersion + 1
  - Extract plainText from HTML content
  - Update policy: status PUBLISHED, increment currentVersion, clear draftContent
- Emit PolicyPublishedEvent
- Log activity
- Return created PolicyVersion

`retire(policyId: string, userId: string, organizationId: string): Promise<Policy>`
- Update status to RETIRED, set retiredAt
- Emit PolicyRetiredEvent
- Log activity

`getVersions(policyId: string, organizationId: string): Promise<PolicyVersion[]>`
- Return all versions ordered by version DESC
- Include publishedBy relation

`getVersion(policyVersionId: string, organizationId: string): Promise<PolicyVersion>`
- Return specific version with policy relation

**Helper methods:**

`private generateSlug(title: string, organizationId: string): Promise<string>`
- Convert to lowercase, replace non-alphanumeric with hyphens
- Check uniqueness, append number if exists

`private extractPlainText(html: string): string`
- Strip HTML tags, collapse whitespace
- Return clean text for search indexing
  </action>
  <verify>File compiles without errors. Service has create, findById, findAll, updateDraft, publish, retire, getVersions, getVersion methods.</verify>
  <done>PoliciesService implements CRUD with version-on-publish pattern, events emitted.</done>
</task>

<task type="auto">
  <name>Task 2: Create PoliciesController with REST endpoints</name>
  <files>apps/backend/src/modules/policies/policies.controller.ts</files>
  <action>
Create policies.controller.ts with:

@Controller('policies')
@UseGuards(AuthGuard, RolesGuard)
@ApiBearerAuth()
@ApiTags('policies')

**Endpoints:**

POST / - Create policy
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER, Role.POLICY_AUTHOR)
- @Body() CreatePolicyDto
- Returns created Policy

GET / - List policies
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER, Role.POLICY_AUTHOR, Role.READ_ONLY)
- @Query() PolicyQueryDto
- Returns { data: Policy[], total: number, page: number, limit: number }

GET /:id - Get single policy
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER, Role.POLICY_AUTHOR, Role.READ_ONLY)
- @Param('id') id
- Include latestVersion, check org ownership
- Returns Policy with versions

PUT /:id - Update draft
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER, Role.POLICY_AUTHOR)
- @Param('id') id
- @Body() UpdatePolicyDto
- Returns updated Policy

POST /:id/publish - Publish policy
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER)
- @Param('id') id
- @Body() PublishPolicyDto
- Returns created PolicyVersion

POST /:id/retire - Retire policy
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER)
- @Param('id') id
- Returns updated Policy

GET /:id/versions - Get all versions
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER, Role.POLICY_AUTHOR, Role.READ_ONLY)
- @Param('id') id
- Returns PolicyVersion[]

GET /versions/:versionId - Get specific version
- @Roles(Role.SYSTEM_ADMIN, Role.COMPLIANCE_OFFICER, Role.POLICY_AUTHOR, Role.READ_ONLY)
- @Param('versionId') versionId
- Returns PolicyVersion

Extract organizationId and userId from request context (req.user).
  </action>
  <verify>Controller compiles. All endpoints have proper decorators, guards, and call service methods.</verify>
  <done>PoliciesController exposes REST API for all policy operations with role-based access.</done>
</task>

<task type="auto">
  <name>Task 3: Create PoliciesModule and register in app</name>
  <files>
apps/backend/src/modules/policies/policies.module.ts
apps/backend/src/modules/policies/index.ts
apps/backend/src/app.module.ts
  </files>
  <action>
**Create policies.module.ts:**

@Module({
  imports: [PrismaModule, CommonModule],
  controllers: [PoliciesController],
  providers: [PoliciesService],
  exports: [PoliciesService],
})
export class PoliciesModule {}

**Create index.ts:**
Export PoliciesModule, PoliciesService, all DTOs, all events

**Update app.module.ts:**
Add PoliciesModule to imports array

Ensure folder structure:
```
apps/backend/src/modules/policies/
  ├── dto/
  │   ├── policy.dto.ts
  │   └── index.ts
  ├── events/
  │   └── policy.events.ts
  ├── policies.module.ts
  ├── policies.service.ts
  ├── policies.controller.ts
  └── index.ts
```
  </action>
  <verify>Run `npm run build` in apps/backend. Module compiles and is registered.</verify>
  <done>PoliciesModule registered in app, exports PoliciesService for other modules.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` succeeds
2. PoliciesService.create() generates slug, creates DRAFT policy
3. PoliciesService.updateDraft() prevents edit during PENDING_APPROVAL
4. PoliciesService.publish() creates PolicyVersion, increments currentVersion, clears draft
5. Controller endpoints have proper role guards
6. Events emitted on create, update, publish, retire
7. PoliciesModule exports PoliciesService
</verification>

<success_criteria>
- Policy CRUD operations work with draft management
- Publish creates immutable PolicyVersion with version number
- Editing published policy creates new draft (copy from latest version)
- REST endpoints with role-based access control
- Events emitted for audit trail
</success_criteria>

<output>
After completion, create `.planning/phases/10-policy-management/10-02-SUMMARY.md`
</output>
