---
phase: 05-ai-infrastructure
plan: 06
type: execute
wave: 2
depends_on: ["05-01", "05-05"]
files_modified:
  - apps/backend/src/modules/ai/services/context-loader.service.ts
  - apps/backend/src/modules/ai/dto/context.dto.ts
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/ai/ai.module.ts
autonomous: true

must_haves:
  truths:
    - "Context loads from multiple hierarchy levels (platform, org, team, user, entity)"
    - "Organization context files work like CLAUDE.md for brand voice"
    - "Entity context includes relevant data for the current entity"
    - "Context is cached for performance"
  artifacts:
    - path: "apps/backend/src/modules/ai/services/context-loader.service.ts"
      provides: "Hierarchical context assembly"
      exports: ["ContextLoaderService"]
      min_lines: 120
    - path: "apps/backend/prisma/schema.prisma"
      provides: "AiContextFile model for org/user context"
      contains: "model AiContextFile"
  key_links:
    - from: "apps/backend/src/modules/ai/services/context-loader.service.ts"
      to: "apps/backend/src/modules/ai/services/prompt.service.ts"
      via: "builds system prompt"
      pattern: "promptService|buildSystemPrompt"
---

<objective>
Create the context hierarchy loading system that assembles AI context from multiple levels (platform, organization, team, user, entity). This enables context-aware AI responses with organization-specific customization.

Purpose: Per CONTEXT.md, the AI should have CLAUDE.md-like context files at organization and user levels. Entity context provides data about the current case/investigation.

Output: ContextLoaderService that loads and assembles context for AI calls.
</objective>

<execution_context>
@C:\Users\cu0718\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\cu0718\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-ai-infrastructure/05-RESEARCH.md
@.planning/phases/05-ai-infrastructure/05-CONTEXT.md (context system decisions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AiContextFile model</name>
  <files>
    apps/backend/prisma/schema.prisma
  </files>
  <action>
Add the AiContextFile model to schema.prisma (after AiMessage):

```prisma
/// AiContextFile stores CLAUDE.md-like context files for organizations and users.
/// Platform context is stored in code; org/user context is stored in database.
model AiContextFile {
  id              String   @id @default(uuid())
  organizationId  String?  @map("organization_id") // null = platform level (but stored in code)
  userId          String?  @map("user_id") // null = org-level, set = user-level

  // Context file content
  name            String   // Display name
  content         String   @db.Text // Markdown content (like CLAUDE.md)
  description     String?

  // Scope
  scope           String   @default("org") // 'org', 'team', 'user'
  teamId          String?  @map("team_id") // For team-scoped context

  // Metadata
  isActive        Boolean  @default(true) @map("is_active")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@unique([organizationId, userId, name])
  @@index([organizationId, scope, isActive])
  @@index([userId, isActive])
  @@map("ai_context_files")
}
```

Run migration:
```bash
cd apps/backend && npx prisma migrate dev --name add_ai_context_file
```
  </action>
  <verify>
Migration succeeds.
`npx prisma generate` completes.
AiContextFile type appears in generated client.
  </verify>
  <done>
AiContextFile model created for org and user context storage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create context DTOs</name>
  <files>
    apps/backend/src/modules/ai/dto/context.dto.ts
  </files>
  <action>
Create `apps/backend/src/modules/ai/dto/context.dto.ts`:

```typescript
import { IsString, IsOptional, IsEnum } from 'class-validator';

export enum ContextScope {
  PLATFORM = 'platform',
  ORG = 'org',
  TEAM = 'team',
  USER = 'user',
  ENTITY = 'entity',
}

export interface PlatformContext {
  name: string;
  version: string;
  capabilities: string[];
  guidelines: string;
}

export interface OrganizationContext {
  id: string;
  name: string;
  contextFile?: string; // CLAUDE.md-like content
  terminology?: Record<string, string>; // Custom terms
  categories: Array<{ id: string; name: string; path?: string }>;
  settings?: {
    aiEnabled: boolean;
    formalityLevel: 'casual' | 'professional' | 'formal';
    noteCleanupStyle: 'light' | 'full';
    summaryDefaultLength: 'brief' | 'standard' | 'detailed';
  };
}

export interface TeamContext {
  id: string;
  name: string;
  contextFile?: string;
  focusArea?: string;
}

export interface UserContext {
  id: string;
  name: string;
  role: string;
  contextFile?: string;
  preferences?: {
    formalityLevel?: 'casual' | 'professional' | 'formal';
    responseLength?: 'brief' | 'standard' | 'detailed';
    language?: string;
  };
}

export interface EntityContext {
  type: string; // 'case', 'investigation', 'campaign', etc.
  id: string;
  referenceNumber?: string;
  status?: string;
  category?: string;
  priority?: string;
  summary?: string;
  createdAt?: Date;
  assignedTo?: string;
  // Additional entity-specific fields
  [key: string]: unknown;
}

export interface AIContext {
  platform: PlatformContext;
  organization: OrganizationContext;
  team?: TeamContext;
  user: UserContext;
  entity?: EntityContext;
  currentDateTime: string;
}

export class LoadContextDto {
  @IsString()
  organizationId: string;

  @IsString()
  userId: string;

  @IsString()
  @IsOptional()
  teamId?: string;

  @IsString()
  @IsOptional()
  entityType?: string;

  @IsString()
  @IsOptional()
  entityId?: string;
}

export class SaveContextFileDto {
  @IsString()
  organizationId: string;

  @IsString()
  @IsOptional()
  userId?: string;

  @IsString()
  @IsOptional()
  teamId?: string;

  @IsString()
  name: string;

  @IsString()
  content: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsEnum(['org', 'team', 'user'])
  @IsOptional()
  scope?: string;
}
```
  </action>
  <verify>
File created with all interface definitions.
`npm run build` succeeds.
  </verify>
  <done>
Context DTOs defined for all hierarchy levels.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ContextLoaderService</name>
  <files>
    apps/backend/src/modules/ai/services/context-loader.service.ts
    apps/backend/src/modules/ai/ai.module.ts
    apps/backend/src/modules/ai/dto/index.ts
    apps/backend/src/modules/ai/index.ts
  </files>
  <action>
1. Create `apps/backend/src/modules/ai/services/context-loader.service.ts`:

```typescript
import { Injectable, Logger, Inject, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Cache } from 'cache-manager';
import { PrismaService } from '../../prisma/prisma.service';
import { PromptService } from './prompt.service';
import {
  LoadContextDto,
  AIContext,
  PlatformContext,
  OrganizationContext,
  TeamContext,
  UserContext,
  EntityContext,
  SaveContextFileDto,
} from '../dto/context.dto';

@Injectable()
export class ContextLoaderService implements OnModuleInit {
  private readonly logger = new Logger(ContextLoaderService.name);

  // Cache TTLs in seconds
  private readonly platformCacheTtl = 3600; // 1 hour
  private readonly orgCacheTtl = 300; // 5 minutes
  private readonly userCacheTtl = 300; // 5 minutes
  private readonly entityCacheTtl = 60; // 1 minute (entities change more often)

  // Platform context (static, loaded once)
  private platformContext: PlatformContext;

  constructor(
    private readonly configService: ConfigService,
    private readonly prisma: PrismaService,
    private readonly promptService: PromptService,
    @Inject(CACHE_MANAGER) private readonly cacheManager: Cache,
  ) {}

  onModuleInit() {
    this.platformContext = this.loadPlatformContext();
  }

  /**
   * Load complete context hierarchy for an AI call.
   */
  async loadContext(params: LoadContextDto): Promise<AIContext> {
    const [orgContext, userContext, teamContext, entityContext] = await Promise.all([
      this.loadOrganizationContext(params.organizationId),
      this.loadUserContext(params.userId, params.organizationId),
      params.teamId ? this.loadTeamContext(params.teamId, params.organizationId) : null,
      params.entityType && params.entityId
        ? this.loadEntityContext(params.entityType, params.entityId, params.organizationId)
        : null,
    ]);

    return {
      platform: this.platformContext,
      organization: orgContext,
      team: teamContext || undefined,
      user: userContext,
      entity: entityContext || undefined,
      currentDateTime: new Date().toISOString(),
    };
  }

  /**
   * Build a complete system prompt from context and agent type.
   */
  async buildSystemPrompt(
    context: AIContext,
    agentType: string,
  ): Promise<string> {
    const templateName = `system/${agentType}`;

    try {
      return await this.promptService.render(
        templateName,
        {
          platform: context.platform,
          org: context.organization,
          team: context.team,
          user: context.user,
          entity: context.entity,
          currentDateTime: context.currentDateTime,
        },
        context.organization.id,
      );
    } catch (error) {
      // Fall back to base template if agent-specific doesn't exist
      this.logger.warn(`Template ${templateName} not found, using base`);
      return this.promptService.render(
        'system/base',
        {
          platform: context.platform,
          org: context.organization,
          team: context.team,
          user: context.user,
          entity: context.entity,
          currentDateTime: context.currentDateTime,
        },
        context.organization.id,
      );
    }
  }

  /**
   * Save a context file for organization, team, or user.
   */
  async saveContextFile(params: SaveContextFileDto): Promise<{ id: string }> {
    // Determine scope
    const scope = params.userId ? 'user' : params.teamId ? 'team' : 'org';

    // Upsert the context file
    const existing = await this.prisma.aiContextFile.findFirst({
      where: {
        organizationId: params.organizationId,
        userId: params.userId || null,
        name: params.name,
      },
    });

    let contextFile;
    if (existing) {
      contextFile = await this.prisma.aiContextFile.update({
        where: { id: existing.id },
        data: {
          content: params.content,
          description: params.description,
          scope,
          teamId: params.teamId,
        },
      });
    } else {
      contextFile = await this.prisma.aiContextFile.create({
        data: {
          organizationId: params.organizationId,
          userId: params.userId,
          name: params.name,
          content: params.content,
          description: params.description,
          scope,
          teamId: params.teamId,
        },
      });
    }

    // Invalidate cache
    const cacheKey = params.userId
      ? `ai:context:user:${params.userId}`
      : `ai:context:org:${params.organizationId}`;
    await this.cacheManager.del(cacheKey);

    return { id: contextFile.id };
  }

  /**
   * Get context file for editing.
   */
  async getContextFile(params: {
    organizationId: string;
    userId?: string;
    name: string;
  }): Promise<{ id: string; content: string; description?: string } | null> {
    const file = await this.prisma.aiContextFile.findFirst({
      where: {
        organizationId: params.organizationId,
        userId: params.userId || null,
        name: params.name,
        isActive: true,
      },
    });

    if (!file) return null;

    return {
      id: file.id,
      content: file.content,
      description: file.description || undefined,
    };
  }

  private loadPlatformContext(): PlatformContext {
    return {
      name: 'Ethico Risk Intelligence Platform',
      version: this.configService.get('APP_VERSION', '1.0.0'),
      capabilities: [
        'Case and Investigation Management',
        'Compliance Reporting',
        'Risk Assessment',
        'Policy Management',
        'Disclosure Campaigns',
        'Anonymous Reporting',
      ],
      guidelines: `
You are an AI assistant for compliance and ethics management. Your role is to:
- Help compliance officers investigate reports efficiently
- Maintain confidentiality of all case information
- Provide accurate, well-sourced information
- Flag sensitive content appropriately
- Never make final determinations - support human decision-making
- Follow professional compliance documentation standards
      `.trim(),
    };
  }

  private async loadOrganizationContext(orgId: string): Promise<OrganizationContext> {
    const cacheKey = `ai:context:org:${orgId}`;

    // Check cache
    const cached = await this.cacheManager.get<OrganizationContext>(cacheKey);
    if (cached) return cached;

    // Load from database
    const [org, contextFile, categories] = await Promise.all([
      this.prisma.organization.findUnique({
        where: { id: orgId },
        select: {
          id: true,
          name: true,
          settings: true,
        },
      }),
      this.prisma.aiContextFile.findFirst({
        where: {
          organizationId: orgId,
          userId: null,
          scope: 'org',
          isActive: true,
        },
      }),
      this.prisma.category.findMany({
        where: { organizationId: orgId, isActive: true },
        select: { id: true, name: true, path: true },
        take: 100,
      }),
    ]);

    if (!org) {
      throw new Error(`Organization not found: ${orgId}`);
    }

    const settings = org.settings as Record<string, unknown> | null;

    const context: OrganizationContext = {
      id: org.id,
      name: org.name,
      contextFile: contextFile?.content,
      terminology: (settings?.terminology as Record<string, string>) || undefined,
      categories,
      settings: {
        aiEnabled: (settings?.aiEnabled as boolean) ?? true,
        formalityLevel: (settings?.formalityLevel as 'casual' | 'professional' | 'formal') || 'professional',
        noteCleanupStyle: (settings?.noteCleanupStyle as 'light' | 'full') || 'light',
        summaryDefaultLength: (settings?.summaryDefaultLength as 'brief' | 'standard' | 'detailed') || 'standard',
      },
    };

    // Cache
    await this.cacheManager.set(cacheKey, context, this.orgCacheTtl * 1000);

    return context;
  }

  private async loadTeamContext(teamId: string, orgId: string): Promise<TeamContext> {
    const cacheKey = `ai:context:team:${teamId}`;

    const cached = await this.cacheManager.get<TeamContext>(cacheKey);
    if (cached) return cached;

    const [team, contextFile] = await Promise.all([
      this.prisma.team.findUnique({
        where: { id: teamId },
        select: { id: true, name: true },
      }),
      this.prisma.aiContextFile.findFirst({
        where: {
          organizationId: orgId,
          teamId,
          scope: 'team',
          isActive: true,
        },
      }),
    ]);

    if (!team) {
      throw new Error(`Team not found: ${teamId}`);
    }

    const context: TeamContext = {
      id: team.id,
      name: team.name,
      contextFile: contextFile?.content,
    };

    await this.cacheManager.set(cacheKey, context, this.orgCacheTtl * 1000);

    return context;
  }

  private async loadUserContext(userId: string, orgId: string): Promise<UserContext> {
    const cacheKey = `ai:context:user:${userId}`;

    const cached = await this.cacheManager.get<UserContext>(cacheKey);
    if (cached) return cached;

    const [user, contextFile] = await Promise.all([
      this.prisma.user.findUnique({
        where: { id: userId },
        select: {
          id: true,
          firstName: true,
          lastName: true,
          role: true,
        },
      }),
      this.prisma.aiContextFile.findFirst({
        where: {
          organizationId: orgId,
          userId,
          scope: 'user',
          isActive: true,
        },
      }),
    ]);

    if (!user) {
      throw new Error(`User not found: ${userId}`);
    }

    const context: UserContext = {
      id: user.id,
      name: `${user.firstName} ${user.lastName}`,
      role: user.role,
      contextFile: contextFile?.content,
    };

    await this.cacheManager.set(cacheKey, context, this.userCacheTtl * 1000);

    return context;
  }

  private async loadEntityContext(
    entityType: string,
    entityId: string,
    orgId: string,
  ): Promise<EntityContext> {
    const cacheKey = `ai:context:entity:${entityType}:${entityId}`;

    const cached = await this.cacheManager.get<EntityContext>(cacheKey);
    if (cached) return cached;

    let context: EntityContext;

    switch (entityType) {
      case 'case':
        context = await this.loadCaseContext(entityId, orgId);
        break;
      case 'investigation':
        context = await this.loadInvestigationContext(entityId, orgId);
        break;
      case 'campaign':
        context = await this.loadCampaignContext(entityId, orgId);
        break;
      default:
        context = { type: entityType, id: entityId };
    }

    await this.cacheManager.set(cacheKey, context, this.entityCacheTtl * 1000);

    return context;
  }

  private async loadCaseContext(caseId: string, orgId: string): Promise<EntityContext> {
    const caseData = await this.prisma.case.findFirst({
      where: { id: caseId, organizationId: orgId },
      select: {
        id: true,
        caseNumber: true,
        status: true,
        caseType: true,
        priority: true,
        summary: true,
        createdAt: true,
        category: { select: { name: true } },
      },
    });

    if (!caseData) {
      return { type: 'case', id: caseId };
    }

    return {
      type: 'case',
      id: caseData.id,
      referenceNumber: caseData.caseNumber,
      status: caseData.status,
      caseType: caseData.caseType,
      category: caseData.category?.name,
      priority: caseData.priority || undefined,
      summary: caseData.summary || undefined,
      createdAt: caseData.createdAt,
    };
  }

  private async loadInvestigationContext(investigationId: string, orgId: string): Promise<EntityContext> {
    const investigation = await this.prisma.investigation.findFirst({
      where: { id: investigationId, organizationId: orgId },
      select: {
        id: true,
        referenceNumber: true,
        status: true,
        priority: true,
        summary: true,
        createdAt: true,
        case: {
          select: {
            id: true,
            caseNumber: true,
            category: { select: { name: true } },
          },
        },
        primaryInvestigator: {
          select: { firstName: true, lastName: true },
        },
      },
    });

    if (!investigation) {
      return { type: 'investigation', id: investigationId };
    }

    return {
      type: 'investigation',
      id: investigation.id,
      referenceNumber: investigation.referenceNumber,
      status: investigation.status,
      priority: investigation.priority || undefined,
      summary: investigation.summary || undefined,
      createdAt: investigation.createdAt,
      category: investigation.case?.category?.name,
      caseId: investigation.case?.id,
      caseNumber: investigation.case?.caseNumber,
      assignedTo: investigation.primaryInvestigator
        ? `${investigation.primaryInvestigator.firstName} ${investigation.primaryInvestigator.lastName}`
        : undefined,
    };
  }

  private async loadCampaignContext(campaignId: string, orgId: string): Promise<EntityContext> {
    const campaign = await this.prisma.campaign.findFirst({
      where: { id: campaignId, organizationId: orgId },
      select: {
        id: true,
        name: true,
        type: true,
        status: true,
        createdAt: true,
        startDate: true,
        endDate: true,
        _count: { select: { assignments: true } },
      },
    });

    if (!campaign) {
      return { type: 'campaign', id: campaignId };
    }

    return {
      type: 'campaign',
      id: campaign.id,
      referenceNumber: campaign.name,
      status: campaign.status,
      campaignType: campaign.type,
      createdAt: campaign.createdAt,
      startDate: campaign.startDate,
      endDate: campaign.endDate,
      assignmentCount: campaign._count.assignments,
    };
  }
}
```

2. Update `apps/backend/src/modules/ai/dto/index.ts`:
```typescript
export * from './chat-message.dto';
export * from './rate-limit.dto';
export * from './conversation.dto';
export * from './context.dto';
```

3. Update `apps/backend/src/modules/ai/ai.module.ts`:
```typescript
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { CacheModule } from '@nestjs/cache-manager';
import { PrismaModule } from '../prisma/prisma.module';
import { AiClientService } from './services/ai-client.service';
import { ProviderRegistryService } from './services/provider-registry.service';
import { AiRateLimiterService } from './services/rate-limiter.service';
import { PromptService } from './services/prompt.service';
import { ConversationService } from './services/conversation.service';
import { ContextLoaderService } from './services/context-loader.service';
import { ClaudeProvider } from './providers/claude.provider';

@Module({
  imports: [
    ConfigModule,
    PrismaModule,
    CacheModule.register({
      ttl: 300000, // 5 minutes default
    }),
  ],
  providers: [
    ClaudeProvider,
    ProviderRegistryService,
    AiClientService,
    AiRateLimiterService,
    PromptService,
    ConversationService,
    ContextLoaderService,
  ],
  exports: [
    AiClientService,
    ProviderRegistryService,
    AiRateLimiterService,
    PromptService,
    ConversationService,
    ContextLoaderService,
    ClaudeProvider,
  ],
})
export class AiModule {}
```

4. Update `apps/backend/src/modules/ai/index.ts` to include ContextLoaderService export.
  </action>
  <verify>
`npm run build` succeeds.
ContextLoaderService has loadContext and buildSystemPrompt methods.
  </verify>
  <done>
Context hierarchy loading complete with caching and entity-specific context.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `npm run build` passes
2. `npx prisma migrate status` shows all migrations applied
3. AiContextFile model exists
4. ContextLoaderService loads platform, org, team, user, entity context
5. Context files support CRUD operations
6. Context is cached for performance
</verification>

<success_criteria>
- Context hierarchy: platform -> org -> team -> user -> entity
- Organization context files (CLAUDE.md-like) stored in database
- Entity context loads case/investigation/campaign details
- Context caching with appropriate TTLs
- System prompt built from context and agent type
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-infrastructure/05-06-SUMMARY.md`
</output>
