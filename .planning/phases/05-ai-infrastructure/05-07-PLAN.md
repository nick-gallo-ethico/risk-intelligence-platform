---
phase: 05-ai-infrastructure
plan: 07
type: execute
wave: 3
depends_on: ["05-02", "05-03", "05-04"]
files_modified:
  - apps/backend/src/modules/ai/skills/platform/note-cleanup.skill.ts
  - apps/backend/src/modules/ai/skills/platform/summarize.skill.ts
  - apps/backend/src/modules/ai/skills/skill.registry.ts
  - apps/backend/src/modules/ai/skills/skill.types.ts
  - apps/backend/src/modules/ai/skills/index.ts
  - apps/backend/src/modules/ai/ai.module.ts
autonomous: true

must_haves:
  truths:
    - "Note cleanup transforms bullet points into formal narrative"
    - "Summarize skill generates brief or comprehensive summaries"
    - "Skills are registered with required permissions"
    - "Skill execution respects rate limits"
  artifacts:
    - path: "apps/backend/src/modules/ai/skills/skill.registry.ts"
      provides: "Skill registration and lookup"
      exports: ["SkillRegistry"]
      min_lines: 80
    - path: "apps/backend/src/modules/ai/skills/platform/note-cleanup.skill.ts"
      provides: "Note cleanup skill implementation"
      exports: ["noteCleanupSkill"]
    - path: "apps/backend/src/modules/ai/skills/platform/summarize.skill.ts"
      provides: "Summarize skill implementation"
      exports: ["summarizeSkill"]
  key_links:
    - from: "apps/backend/src/modules/ai/skills/skill.registry.ts"
      to: "apps/backend/src/modules/ai/services/provider-registry.service.ts"
      via: "AI provider calls"
      pattern: "providerRegistry|getProvider"
---

<objective>
Create the skill registry and first two platform skills: note cleanup (AI-07) and summarization (AI-08). These are the most common AI operations used across the platform.

Purpose: Skills are reusable AI capabilities that can be invoked from the AI panel or programmatically. Note cleanup and summarization are foundational features per CONTEXT.md.

Output: SkillRegistry with note-cleanup and summarize skills registered and functional.
</objective>

<execution_context>
@C:\Users\cu0718\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\cu0718\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-ai-infrastructure/05-RESEARCH.md
@.planning/phases/05-ai-infrastructure/05-CONTEXT.md (note cleanup and summary style decisions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create skill types and registry</name>
  <files>
    apps/backend/src/modules/ai/skills/skill.types.ts
    apps/backend/src/modules/ai/skills/skill.registry.ts
    apps/backend/src/modules/ai/skills/index.ts
  </files>
  <action>
Create the skill infrastructure:

1. Create `apps/backend/src/modules/ai/skills/skill.types.ts`:
```typescript
import { z } from 'zod';

export enum SkillScope {
  PLATFORM = 'platform', // Available everywhere
  ORG = 'org',           // Organization-specific
  TEAM = 'team',         // Team-specific
  USER = 'user',         // User-defined
}

export interface SkillContext {
  organizationId: string;
  userId: string;
  entityType?: string;
  entityId?: string;
  permissions: string[];
}

export interface SkillResult<T = unknown> {
  success: boolean;
  data?: T;
  error?: string;
  metadata?: {
    inputTokens?: number;
    outputTokens?: number;
    durationMs?: number;
    model?: string;
  };
}

export interface SkillDefinition<TInput = unknown, TOutput = unknown> {
  id: string;
  name: string;
  description: string;
  scope: SkillScope;
  scopeId?: string; // Org/team/user ID if scoped
  entityTypes?: string[]; // Restrict to specific entity types
  requiredPermissions: string[];
  inputSchema: z.ZodType<TInput>;
  execute: (input: TInput, context: SkillContext) => Promise<SkillResult<TOutput>>;
}

// Zod to JSON Schema conversion helper
export function zodToJsonSchema(schema: z.ZodType): Record<string, unknown> {
  // Simplified conversion - in production use zod-to-json-schema library
  if (schema instanceof z.ZodObject) {
    const shape = schema._def.shape();
    const properties: Record<string, unknown> = {};
    const required: string[] = [];

    for (const [key, value] of Object.entries(shape)) {
      const zodType = value as z.ZodType;
      properties[key] = zodTypeToJsonSchema(zodType);

      if (!(zodType instanceof z.ZodOptional)) {
        required.push(key);
      }
    }

    return {
      type: 'object',
      properties,
      required: required.length > 0 ? required : undefined,
    };
  }

  return { type: 'object' };
}

function zodTypeToJsonSchema(zodType: z.ZodType): Record<string, unknown> {
  if (zodType instanceof z.ZodString) {
    return { type: 'string', description: zodType.description };
  }
  if (zodType instanceof z.ZodNumber) {
    return { type: 'number', description: zodType.description };
  }
  if (zodType instanceof z.ZodBoolean) {
    return { type: 'boolean', description: zodType.description };
  }
  if (zodType instanceof z.ZodEnum) {
    return { type: 'string', enum: zodType._def.values, description: zodType.description };
  }
  if (zodType instanceof z.ZodArray) {
    return { type: 'array', items: zodTypeToJsonSchema(zodType._def.type) };
  }
  if (zodType instanceof z.ZodOptional) {
    return zodTypeToJsonSchema(zodType._def.innerType);
  }
  if (zodType instanceof z.ZodDefault) {
    const inner = zodTypeToJsonSchema(zodType._def.innerType);
    return { ...inner, default: zodType._def.defaultValue() };
  }

  return { type: 'string' };
}
```

2. Create `apps/backend/src/modules/ai/skills/skill.registry.ts`:
```typescript
import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { SkillDefinition, SkillScope, SkillContext, SkillResult, zodToJsonSchema } from './skill.types';
import { ProviderRegistryService } from '../services/provider-registry.service';
import { AiRateLimiterService } from '../services/rate-limiter.service';
import { PromptService } from '../services/prompt.service';
import { AITool } from '../interfaces/ai-provider.interface';

// Import platform skills
import { noteCleanupSkill } from './platform/note-cleanup.skill';
import { summarizeSkill } from './platform/summarize.skill';

@Injectable()
export class SkillRegistry implements OnModuleInit {
  private readonly logger = new Logger(SkillRegistry.name);
  private readonly skills = new Map<string, SkillDefinition>();

  constructor(
    private readonly providerRegistry: ProviderRegistryService,
    private readonly rateLimiter: AiRateLimiterService,
    private readonly promptService: PromptService,
  ) {}

  onModuleInit() {
    // Register platform skills
    this.registerSkill(noteCleanupSkill(this.providerRegistry, this.rateLimiter, this.promptService));
    this.registerSkill(summarizeSkill(this.providerRegistry, this.rateLimiter, this.promptService));

    this.logger.log(`Registered ${this.skills.size} skills`);
  }

  /**
   * Register a skill.
   */
  registerSkill(skill: SkillDefinition): void {
    if (this.skills.has(skill.id)) {
      this.logger.warn(`Overwriting skill: ${skill.id}`);
    }
    this.skills.set(skill.id, skill);
    this.logger.debug(`Registered skill: ${skill.id}`);
  }

  /**
   * Get a skill by ID.
   */
  getSkill(id: string): SkillDefinition | undefined {
    return this.skills.get(id);
  }

  /**
   * Get skills available for the given context.
   */
  getAvailableSkills(params: {
    organizationId: string;
    userId: string;
    teamId?: string;
    entityType?: string;
    userPermissions: string[];
  }): SkillDefinition[] {
    return Array.from(this.skills.values()).filter(skill => {
      // Check scope
      if (skill.scope === SkillScope.ORG && skill.scopeId !== params.organizationId) {
        return false;
      }
      if (skill.scope === SkillScope.TEAM && skill.scopeId !== params.teamId) {
        return false;
      }
      if (skill.scope === SkillScope.USER && skill.scopeId !== params.userId) {
        return false;
      }

      // Check entity type restriction
      if (skill.entityTypes && params.entityType) {
        if (!skill.entityTypes.includes(params.entityType)) {
          return false;
        }
      }

      // Check permissions
      return skill.requiredPermissions.every(p => params.userPermissions.includes(p));
    });
  }

  /**
   * Execute a skill.
   */
  async executeSkill<T = unknown>(
    skillId: string,
    input: unknown,
    context: SkillContext,
  ): Promise<SkillResult<T>> {
    const skill = this.skills.get(skillId);
    if (!skill) {
      return { success: false, error: `Skill not found: ${skillId}` };
    }

    // Check permissions
    const hasPermission = skill.requiredPermissions.every(p => context.permissions.includes(p));
    if (!hasPermission) {
      return { success: false, error: 'Insufficient permissions for this skill' };
    }

    // Check entity type
    if (skill.entityTypes && context.entityType) {
      if (!skill.entityTypes.includes(context.entityType)) {
        return { success: false, error: `Skill not available for entity type: ${context.entityType}` };
      }
    }

    try {
      // Validate input
      const validatedInput = skill.inputSchema.parse(input);

      // Execute skill
      const result = await skill.execute(validatedInput, context);

      return result as SkillResult<T>;
    } catch (error) {
      if (error.name === 'ZodError') {
        return { success: false, error: `Invalid input: ${error.message}` };
      }
      this.logger.error(`Skill ${skillId} failed:`, error);
      return { success: false, error: error.message || 'Skill execution failed' };
    }
  }

  /**
   * Convert available skills to Claude tool format.
   */
  toClaudeTools(skills: SkillDefinition[]): AITool[] {
    return skills.map(skill => ({
      name: skill.id,
      description: skill.description,
      inputSchema: zodToJsonSchema(skill.inputSchema),
    }));
  }

  /**
   * List all registered skill IDs.
   */
  listSkills(): string[] {
    return Array.from(this.skills.keys());
  }
}
```

3. Create `apps/backend/src/modules/ai/skills/index.ts`:
```typescript
export * from './skill.types';
export * from './skill.registry';
export * from './platform/note-cleanup.skill';
export * from './platform/summarize.skill';
```
  </action>
  <verify>
Files created.
`npm run build` compiles without errors once skills are created.
  </verify>
  <done>
Skill registry infrastructure created with type definitions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create note cleanup skill</name>
  <files>
    apps/backend/src/modules/ai/skills/platform/note-cleanup.skill.ts
  </files>
  <action>
Create `apps/backend/src/modules/ai/skills/platform/note-cleanup.skill.ts`:

```typescript
import { z } from 'zod';
import { SkillDefinition, SkillScope, SkillContext, SkillResult } from '../skill.types';
import { ProviderRegistryService } from '../../services/provider-registry.service';
import { AiRateLimiterService } from '../../services/rate-limiter.service';
import { PromptService } from '../../services/prompt.service';

export const noteCleanupInputSchema = z.object({
  content: z.string().min(1).max(50000).describe('The raw note content to clean up'),
  style: z.enum(['light', 'full']).optional().default('light')
    .describe('Light preserves voice and makes minimal changes; full rewrites completely'),
  context: z.string().optional()
    .describe('Optional context about the note (e.g., interview notes, phone call summary)'),
});

export type NoteCleanupInput = z.infer<typeof noteCleanupInputSchema>;

export interface NoteCleanupOutput {
  cleanedContent: string;
  changes: Array<{
    type: 'grammar' | 'formatting' | 'clarity' | 'structure';
    count: number;
  }>;
  originalLength: number;
  cleanedLength: number;
}

export function noteCleanupSkill(
  providerRegistry: ProviderRegistryService,
  rateLimiter: AiRateLimiterService,
  promptService: PromptService,
): SkillDefinition<NoteCleanupInput, NoteCleanupOutput> {
  return {
    id: 'note-cleanup',
    name: 'Clean Up Notes',
    description: 'Transform bullet points and rough notes into formal narrative prose while preserving key information. Use "light" style to preserve original voice, "full" for complete rewrite.',
    scope: SkillScope.PLATFORM,
    requiredPermissions: ['ai:skills:note-cleanup'],

    inputSchema: noteCleanupInputSchema,

    async execute(input: NoteCleanupInput, context: SkillContext): Promise<SkillResult<NoteCleanupOutput>> {
      const startTime = Date.now();

      // Estimate tokens (rough: 4 chars per token, input + output)
      const estimatedTokens = Math.ceil(input.content.length / 4) * 2;

      // Check rate limit
      const rateLimitResult = await rateLimiter.checkAndConsume({
        organizationId: context.organizationId,
        estimatedTokens,
      });

      if (!rateLimitResult.allowed) {
        return {
          success: false,
          error: `Rate limit exceeded. Retry after ${Math.ceil((rateLimitResult.retryAfterMs || 0) / 1000)} seconds.`,
        };
      }

      try {
        // Get provider
        const provider = providerRegistry.getDefaultProvider();

        // Render prompt
        const prompt = await promptService.render(
          'skills/note-cleanup',
          { content: input.content, style: input.style, context: input.context },
          context.organizationId,
        );

        // Call AI
        const response = await provider.createMessage({
          maxTokens: 4096,
          messages: [{ role: 'user', content: prompt }],
        });

        const cleanedContent = response.content.trim();

        // Record usage
        await rateLimiter.recordUsage({
          organizationId: context.organizationId,
          userId: context.userId,
          inputTokens: response.usage.inputTokens,
          outputTokens: response.usage.outputTokens,
          model: provider.defaultModel,
          featureType: 'note-cleanup',
          entityType: context.entityType,
          entityId: context.entityId,
          durationMs: Date.now() - startTime,
        });

        // Analyze changes (simplified - real implementation would diff)
        const changes = analyzeChanges(input.content, cleanedContent);

        return {
          success: true,
          data: {
            cleanedContent,
            changes,
            originalLength: input.content.length,
            cleanedLength: cleanedContent.length,
          },
          metadata: {
            inputTokens: response.usage.inputTokens,
            outputTokens: response.usage.outputTokens,
            durationMs: Date.now() - startTime,
            model: provider.defaultModel,
          },
        };
      } catch (error) {
        return {
          success: false,
          error: error.message || 'Note cleanup failed',
        };
      }
    },
  };
}

function analyzeChanges(original: string, cleaned: string): Array<{ type: 'grammar' | 'formatting' | 'clarity' | 'structure'; count: number }> {
  const changes: Array<{ type: 'grammar' | 'formatting' | 'clarity' | 'structure'; count: number }> = [];

  // Count bullet points removed (formatting change)
  const originalBullets = (original.match(/^[\s]*[-*•]/gm) || []).length;
  const cleanedBullets = (cleaned.match(/^[\s]*[-*•]/gm) || []).length;
  if (originalBullets > cleanedBullets) {
    changes.push({ type: 'formatting', count: originalBullets - cleanedBullets });
  }

  // Estimate other changes based on length difference
  const lengthDiff = Math.abs(cleaned.length - original.length);
  if (lengthDiff > original.length * 0.1) {
    changes.push({ type: 'structure', count: 1 });
  }

  // Count sentence changes (rough estimate)
  const originalSentences = original.split(/[.!?]+/).length;
  const cleanedSentences = cleaned.split(/[.!?]+/).length;
  if (Math.abs(originalSentences - cleanedSentences) > 2) {
    changes.push({ type: 'clarity', count: Math.abs(originalSentences - cleanedSentences) });
  }

  if (changes.length === 0) {
    changes.push({ type: 'grammar', count: 1 }); // Assume at least minor grammar fixes
  }

  return changes;
}
```
  </action>
  <verify>
File created with note cleanup skill.
`npm run build` succeeds.
  </verify>
  <done>
Note cleanup skill implemented with light/full style options.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create summarize skill and wire up module</name>
  <files>
    apps/backend/src/modules/ai/skills/platform/summarize.skill.ts
    apps/backend/src/modules/ai/ai.module.ts
    apps/backend/src/modules/ai/index.ts
  </files>
  <action>
1. Create `apps/backend/src/modules/ai/skills/platform/summarize.skill.ts`:

```typescript
import { z } from 'zod';
import { SkillDefinition, SkillScope, SkillContext, SkillResult } from '../skill.types';
import { ProviderRegistryService } from '../../services/provider-registry.service';
import { AiRateLimiterService } from '../../services/rate-limiter.service';
import { PromptService } from '../../services/prompt.service';

export const summarizeInputSchema = z.object({
  content: z.string().min(1).max(100000).describe('The content to summarize'),
  style: z.enum(['brief', 'comprehensive']).optional().default('brief')
    .describe('Brief: 1-2 paragraphs. Comprehensive: full structured summary with sections.'),
  entityType: z.string().optional()
    .describe('Type of entity being summarized (case, investigation, campaign)'),
  additionalContext: z.string().optional()
    .describe('Additional context to inform the summary'),
});

export type SummarizeInput = z.infer<typeof summarizeInputSchema>;

export interface SummarizeOutput {
  summary: string;
  style: 'brief' | 'comprehensive';
  wordCount: number;
  keyPoints?: string[];
  confidence?: number; // 0-1, only shown if < 0.8
}

export function summarizeSkill(
  providerRegistry: ProviderRegistryService,
  rateLimiter: AiRateLimiterService,
  promptService: PromptService,
): SkillDefinition<SummarizeInput, SummarizeOutput> {
  return {
    id: 'summarize',
    name: 'Generate Summary',
    description: 'Generate a brief or comprehensive summary of content. Brief summaries are 1-2 paragraphs. Comprehensive summaries include structured sections.',
    scope: SkillScope.PLATFORM,
    requiredPermissions: ['ai:skills:summarize'],

    inputSchema: summarizeInputSchema,

    async execute(input: SummarizeInput, context: SkillContext): Promise<SkillResult<SummarizeOutput>> {
      const startTime = Date.now();

      // Estimate tokens
      const estimatedTokens = Math.ceil(input.content.length / 4) +
        (input.style === 'comprehensive' ? 1000 : 300);

      // Check rate limit
      const rateLimitResult = await rateLimiter.checkAndConsume({
        organizationId: context.organizationId,
        estimatedTokens,
      });

      if (!rateLimitResult.allowed) {
        return {
          success: false,
          error: `Rate limit exceeded. Retry after ${Math.ceil((rateLimitResult.retryAfterMs || 0) / 1000)} seconds.`,
        };
      }

      try {
        const provider = providerRegistry.getDefaultProvider();

        // Render prompt
        const prompt = await promptService.render(
          'skills/summarize',
          {
            content: input.content,
            style: input.style,
            entity: input.entityType ? { type: input.entityType } : undefined,
            additionalContext: input.additionalContext,
          },
          context.organizationId,
        );

        // Call AI
        const response = await provider.createMessage({
          maxTokens: input.style === 'comprehensive' ? 2048 : 512,
          messages: [{ role: 'user', content: prompt }],
        });

        const summary = response.content.trim();

        // Record usage
        await rateLimiter.recordUsage({
          organizationId: context.organizationId,
          userId: context.userId,
          inputTokens: response.usage.inputTokens,
          outputTokens: response.usage.outputTokens,
          model: provider.defaultModel,
          featureType: 'summarize',
          entityType: context.entityType,
          entityId: context.entityId,
          durationMs: Date.now() - startTime,
        });

        // Extract key points for comprehensive summaries
        const keyPoints = input.style === 'comprehensive'
          ? extractKeyPoints(summary)
          : undefined;

        // Calculate confidence (simplified - would be model-based in production)
        const confidence = calculateConfidence(input.content, summary);

        return {
          success: true,
          data: {
            summary,
            style: input.style || 'brief',
            wordCount: summary.split(/\s+/).length,
            keyPoints,
            confidence: confidence < 0.8 ? confidence : undefined, // Only show if low
          },
          metadata: {
            inputTokens: response.usage.inputTokens,
            outputTokens: response.usage.outputTokens,
            durationMs: Date.now() - startTime,
            model: provider.defaultModel,
          },
        };
      } catch (error) {
        return {
          success: false,
          error: error.message || 'Summarization failed',
        };
      }
    },
  };
}

function extractKeyPoints(summary: string): string[] {
  const points: string[] = [];

  // Look for bullet points
  const bulletMatches = summary.match(/^[\s]*[-*•]\s*(.+)$/gm);
  if (bulletMatches) {
    points.push(...bulletMatches.map(m => m.replace(/^[\s]*[-*•]\s*/, '').trim()));
  }

  // Look for numbered items
  const numberedMatches = summary.match(/^\d+\.\s*(.+)$/gm);
  if (numberedMatches) {
    points.push(...numberedMatches.map(m => m.replace(/^\d+\.\s*/, '').trim()));
  }

  // If no explicit points found, extract first sentence of each section
  if (points.length === 0) {
    const sections = summary.split(/##\s+/);
    for (const section of sections) {
      const firstSentence = section.match(/^[A-Z][^.!?]*[.!?]/);
      if (firstSentence) {
        points.push(firstSentence[0].trim());
      }
    }
  }

  return points.slice(0, 5); // Max 5 key points
}

function calculateConfidence(original: string, summary: string): number {
  // Simple heuristic based on compression ratio and content overlap
  const compressionRatio = summary.length / original.length;

  // Very short summaries of long content might miss important details
  if (compressionRatio < 0.05 && original.length > 5000) {
    return 0.6;
  }

  // Check if key terms from original appear in summary
  const originalWords = new Set(
    original.toLowerCase().match(/\b\w{4,}\b/g) || []
  );
  const summaryWords = new Set(
    summary.toLowerCase().match(/\b\w{4,}\b/g) || []
  );

  let overlap = 0;
  for (const word of summaryWords) {
    if (originalWords.has(word)) {
      overlap++;
    }
  }

  const overlapRatio = summaryWords.size > 0 ? overlap / summaryWords.size : 0;

  // Confidence based on overlap (0.7 base + 0.3 from overlap)
  return Math.min(0.7 + overlapRatio * 0.3, 1);
}
```

2. Update `apps/backend/src/modules/ai/ai.module.ts`:
```typescript
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { CacheModule } from '@nestjs/cache-manager';
import { PrismaModule } from '../prisma/prisma.module';
import { AiClientService } from './services/ai-client.service';
import { ProviderRegistryService } from './services/provider-registry.service';
import { AiRateLimiterService } from './services/rate-limiter.service';
import { PromptService } from './services/prompt.service';
import { ConversationService } from './services/conversation.service';
import { ContextLoaderService } from './services/context-loader.service';
import { SkillRegistry } from './skills/skill.registry';
import { ClaudeProvider } from './providers/claude.provider';

@Module({
  imports: [
    ConfigModule,
    PrismaModule,
    CacheModule.register({
      ttl: 300000,
    }),
  ],
  providers: [
    ClaudeProvider,
    ProviderRegistryService,
    AiClientService,
    AiRateLimiterService,
    PromptService,
    ConversationService,
    ContextLoaderService,
    SkillRegistry,
  ],
  exports: [
    AiClientService,
    ProviderRegistryService,
    AiRateLimiterService,
    PromptService,
    ConversationService,
    ContextLoaderService,
    SkillRegistry,
    ClaudeProvider,
  ],
})
export class AiModule {}
```

3. Update `apps/backend/src/modules/ai/index.ts`:
```typescript
export * from './ai.module';
export * from './services/ai-client.service';
export * from './services/provider-registry.service';
export * from './services/rate-limiter.service';
export * from './services/prompt.service';
export * from './services/conversation.service';
export * from './services/context-loader.service';
export * from './skills';
export * from './providers';
export * from './interfaces';
export * from './dto';
```
  </action>
  <verify>
`npm run build` succeeds.
SkillRegistry is exported from AiModule.
Both skills are registered on module init.
  </verify>
  <done>
Summarize skill created and skill registry wired into AI module.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `npm run build` passes
2. SkillRegistry has note-cleanup and summarize skills
3. Skills validate input with Zod
4. Skills respect rate limits
5. Skills record usage for analytics
</verification>

<success_criteria>
- Note cleanup transforms notes with light or full style
- Summarize generates brief or comprehensive summaries
- Skills check permissions before execution
- Rate limiting integrated with skill execution
- Usage tracked for billing and analytics
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-infrastructure/05-07-SUMMARY.md`
</output>
