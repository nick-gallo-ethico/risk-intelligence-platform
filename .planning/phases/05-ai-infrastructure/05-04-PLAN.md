---
phase: 05-ai-infrastructure
plan: 04
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/backend/src/modules/ai/services/prompt.service.ts
  - apps/backend/src/modules/ai/prompts/templates/system/base.hbs
  - apps/backend/src/modules/ai/prompts/templates/system/investigation-agent.hbs
  - apps/backend/src/modules/ai/prompts/templates/system/case-agent.hbs
  - apps/backend/src/modules/ai/prompts/templates/skills/summarize.hbs
  - apps/backend/src/modules/ai/prompts/templates/skills/note-cleanup.hbs
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/ai/ai.module.ts
autonomous: true

must_haves:
  truths:
    - "Prompts are rendered from versioned templates"
    - "Templates support variables via Handlebars syntax"
    - "Prompt versions are tracked for debugging and iteration"
    - "System prompts support organization context injection"
  artifacts:
    - path: "apps/backend/src/modules/ai/services/prompt.service.ts"
      provides: "Prompt template management"
      exports: ["PromptService"]
      min_lines: 80
    - path: "apps/backend/src/modules/ai/prompts/templates/system/base.hbs"
      provides: "Base system prompt template"
    - path: "apps/backend/prisma/schema.prisma"
      provides: "PromptTemplate model for versioning"
      contains: "model PromptTemplate"
  key_links:
    - from: "apps/backend/src/modules/ai/services/prompt.service.ts"
      to: "handlebars"
      via: "template compilation"
      pattern: "Handlebars\\.compile"
---

<objective>
Create versioned prompt template management using Handlebars for variable injection. This enables prompt iteration without code changes and supports organization-specific customization.

Purpose: Prompts are the core of AI behavior. Versioning allows A/B testing, rollback, and debugging. Templates with variables enable context-aware prompts.

Output: PromptService with template loading, rendering, and versioning capabilities.
</objective>

<execution_context>
@C:\Users\cu0718\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\cu0718\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-ai-infrastructure/05-RESEARCH.md
@.planning/phases/05-ai-infrastructure/05-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Handlebars and add PromptTemplate model</name>
  <files>
    apps/backend/package.json
    apps/backend/prisma/schema.prisma
  </files>
  <action>
1. Install Handlebars:
```bash
cd apps/backend && npm install handlebars
```

2. Add PromptTemplate model to schema.prisma (after AiRateLimit):
```prisma
/// PromptTemplate stores versioned prompt templates.
/// Allows A/B testing, rollback, and organization-specific overrides.
model PromptTemplate {
  id             String   @id @default(uuid())
  organizationId String?  @map("organization_id") // null = platform default
  name           String   // e.g., 'system.investigation-agent', 'skill.summarize'
  version        Int      @default(1)
  content        String   @db.Text // Handlebars template content
  description    String?
  isActive       Boolean  @default(true) @map("is_active")
  variables      Json?    // Schema for expected variables
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  @@unique([organizationId, name, version])
  @@index([organizationId, name, isActive])
  @@index([name, isActive])
  @@map("prompt_templates")
}
```

3. Run migration:
```bash
cd apps/backend && npx prisma migrate dev --name add_prompt_template
```
  </action>
  <verify>
Migration succeeds.
`npm run build` passes.
Handlebars appears in package.json.
  </verify>
  <done>
Handlebars installed and PromptTemplate model created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create prompt template files</name>
  <files>
    apps/backend/src/modules/ai/prompts/templates/system/base.hbs
    apps/backend/src/modules/ai/prompts/templates/system/investigation-agent.hbs
    apps/backend/src/modules/ai/prompts/templates/system/case-agent.hbs
    apps/backend/src/modules/ai/prompts/templates/skills/summarize.hbs
    apps/backend/src/modules/ai/prompts/templates/skills/note-cleanup.hbs
  </files>
  <action>
Create the default prompt templates:

1. Create `apps/backend/src/modules/ai/prompts/templates/system/base.hbs`:
```handlebars
You are an AI assistant for the Ethico Risk Intelligence Platform, a compliance and ethics management system.

{{#if org}}
## Organization Context
Organization: {{org.name}}
{{#if org.contextFile}}
{{{org.contextFile}}}
{{/if}}
{{/if}}

## Your Capabilities
- Summarize cases and investigations
- Clean up and format notes (light cleanup preserves voice, full rewrite transforms completely)
- Categorize reports based on content
- Generate risk assessments with contributing factors
- Answer compliance-related questions
- Draft communications (emails, memos)

## Guidelines
- Be professional, accurate, and thorough
- When dealing with sensitive information, maintain confidentiality
- Follow compliance documentation best practices
- Cite sources when referencing specific information
- Flag potentially sensitive content (PII, allegations) appropriately
- If uncertain, say so rather than guessing

Current date and time: {{currentDateTime}}
{{#if user}}
User: {{user.name}} ({{user.role}})
{{/if}}
```

2. Create `apps/backend/src/modules/ai/prompts/templates/system/investigation-agent.hbs`:
```handlebars
{{> system/base}}

## Investigation Agent Mode

You are currently assisting with Investigation #{{entity.referenceNumber}}.

{{#if entity}}
### Investigation Context
- Status: {{entity.status}}
- Category: {{entity.category}}
- Priority: {{entity.priority}}
{{#if entity.summary}}
- Summary: {{entity.summary}}
{{/if}}
{{#if entity.assignedTo}}
- Assigned to: {{entity.assignedTo}}
{{/if}}
{{/if}}

### Available Actions
You can help the investigator with:
- Summarizing the investigation (brief or comprehensive)
- Cleaning up interview notes and documentation
- Drafting questions for interviews
- Identifying patterns or related cases
- Generating risk assessments
- Drafting closure summaries

### Important
- All investigation details are confidential
- Do not make definitive conclusions - present findings for human judgment
- When suggesting actions, explain your reasoning
```

3. Create `apps/backend/src/modules/ai/prompts/templates/system/case-agent.hbs`:
```handlebars
{{> system/base}}

## Case Agent Mode

You are currently assisting with Case {{entity.caseNumber}}.

{{#if entity}}
### Case Context
- Status: {{entity.status}}
- Type: {{entity.caseType}}
- Category: {{entity.category}}
- Intake Date: {{entity.intakeDate}}
{{#if entity.reporterType}}
- Reporter: {{entity.reporterType}}
{{/if}}
{{#if entity.linkedRius}}
- Linked Reports: {{entity.linkedRius.length}}
{{/if}}
{{/if}}

### Available Actions
You can help with:
- Summarizing the case and linked reports
- Suggesting appropriate categorization
- Identifying similar cases for pattern detection
- Drafting response communications
- Generating risk scores with explanations
- Recommending next steps

### Important
- Case details may involve sensitive allegations
- Maintain presumption of innocence when discussing subjects
- Flag any information that requires immediate escalation
```

4. Create `apps/backend/src/modules/ai/prompts/templates/skills/summarize.hbs`:
```handlebars
Generate a {{style}} summary of the following content.

{{#if (eq style "brief")}}
Provide a 1-2 paragraph summary covering the key points. Focus on:
- Main issue or allegation
- Key parties involved
- Current status
- Recommended actions (if applicable)
{{else}}
Provide a comprehensive summary with the following sections:
## Background
Explain the context and how this came to our attention.

## Key Facts
List the relevant facts in chronological order.

## Parties Involved
Describe each party's role without judgment.

## Findings (if applicable)
Summarize any findings or conclusions reached.

## Status and Next Steps
Current status and recommended actions.
{{/if}}

{{#if entity.type}}
Entity Type: {{entity.type}}
{{/if}}

---
Content to summarize:

{{{content}}}

---

{{#if additionalContext}}
Additional Context:
{{{additionalContext}}}
{{/if}}

Provide the summary in clear, professional language. If any information seems incomplete or unclear, note it.
```

5. Create `apps/backend/src/modules/ai/prompts/templates/skills/note-cleanup.hbs`:
```handlebars
Clean up the following notes using {{style}} style.

{{#if (eq style "light")}}
## Light Cleanup Guidelines
- Fix grammar and spelling errors
- Improve sentence structure where awkward
- Preserve the original voice and tone
- Keep abbreviations if they're clear in context
- Maintain the same level of detail
- Do NOT add information not present in the original
{{else}}
## Full Rewrite Guidelines
- Transform into formal, professional prose
- Use complete sentences and proper paragraphs
- Expand abbreviations
- Add appropriate section headers if content is long
- Maintain all factual information
- Use third person and past tense for observations
- Present information chronologically where possible
{{/if}}

---
Original notes:

{{{content}}}

---

{{#if context}}
Context: {{context}}
{{/if}}

Return ONLY the cleaned up text, without explanations or meta-commentary.
```
  </action>
  <verify>
All .hbs files created in correct directories.
Templates contain proper Handlebars syntax.
  </verify>
  <done>
Base prompt templates created for system prompts and skills.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create PromptService</name>
  <files>
    apps/backend/src/modules/ai/services/prompt.service.ts
    apps/backend/src/modules/ai/ai.module.ts
    apps/backend/src/modules/ai/index.ts
  </files>
  <action>
1. Create `apps/backend/src/modules/ai/services/prompt.service.ts`:
```typescript
import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as Handlebars from 'handlebars';
import * as fs from 'fs';
import * as path from 'path';
import { PrismaService } from '../../prisma/prisma.service';

interface TemplateContext {
  org?: {
    name: string;
    contextFile?: string;
  };
  user?: {
    name: string;
    role: string;
  };
  entity?: Record<string, unknown>;
  currentDateTime: string;
  [key: string]: unknown;
}

@Injectable()
export class PromptService implements OnModuleInit {
  private readonly logger = new Logger(PromptService.name);
  private readonly compiledTemplates = new Map<string, HandlebarsTemplateDelegate>();
  private readonly templateDir: string;

  constructor(
    private readonly configService: ConfigService,
    private readonly prisma: PrismaService,
  ) {
    // Templates are in the prompts/templates directory relative to this file
    this.templateDir = path.join(__dirname, '..', 'prompts', 'templates');
  }

  async onModuleInit() {
    await this.loadFileTemplates();
    this.registerHelpers();
    this.logger.log(`Loaded ${this.compiledTemplates.size} prompt templates`);
  }

  /**
   * Render a prompt template with context.
   * Checks database for org-specific override, falls back to file template.
   */
  async render(
    templateName: string,
    context: TemplateContext,
    organizationId?: string,
  ): Promise<string> {
    // Add current datetime
    context.currentDateTime = new Date().toISOString();

    // Check for organization-specific override in database
    if (organizationId) {
      const dbTemplate = await this.prisma.promptTemplate.findFirst({
        where: {
          organizationId,
          name: templateName,
          isActive: true,
        },
        orderBy: { version: 'desc' },
      });

      if (dbTemplate) {
        const compiled = Handlebars.compile(dbTemplate.content);
        return compiled(context);
      }
    }

    // Use file template
    const compiled = this.compiledTemplates.get(templateName);
    if (!compiled) {
      throw new Error(`Prompt template not found: ${templateName}`);
    }

    return compiled(context);
  }

  /**
   * Get the raw template content (for display/editing).
   */
  async getTemplate(
    templateName: string,
    organizationId?: string,
  ): Promise<{ content: string; source: 'database' | 'file'; version?: number }> {
    if (organizationId) {
      const dbTemplate = await this.prisma.promptTemplate.findFirst({
        where: {
          organizationId,
          name: templateName,
          isActive: true,
        },
        orderBy: { version: 'desc' },
      });

      if (dbTemplate) {
        return {
          content: dbTemplate.content,
          source: 'database',
          version: dbTemplate.version,
        };
      }
    }

    const filePath = this.resolveTemplatePath(templateName);
    if (fs.existsSync(filePath)) {
      return {
        content: fs.readFileSync(filePath, 'utf-8'),
        source: 'file',
      };
    }

    throw new Error(`Template not found: ${templateName}`);
  }

  /**
   * Save a custom template version for an organization.
   */
  async saveTemplate(params: {
    organizationId: string;
    name: string;
    content: string;
    description?: string;
  }): Promise<{ id: string; version: number }> {
    // Get current version
    const current = await this.prisma.promptTemplate.findFirst({
      where: {
        organizationId: params.organizationId,
        name: params.name,
      },
      orderBy: { version: 'desc' },
    });

    const newVersion = (current?.version || 0) + 1;

    // Deactivate previous versions
    if (current) {
      await this.prisma.promptTemplate.updateMany({
        where: {
          organizationId: params.organizationId,
          name: params.name,
        },
        data: { isActive: false },
      });
    }

    // Create new version
    const template = await this.prisma.promptTemplate.create({
      data: {
        organizationId: params.organizationId,
        name: params.name,
        version: newVersion,
        content: params.content,
        description: params.description,
        isActive: true,
      },
    });

    return { id: template.id, version: template.version };
  }

  /**
   * List available template names.
   */
  listTemplates(): string[] {
    return Array.from(this.compiledTemplates.keys());
  }

  /**
   * Get template version history for an organization.
   */
  async getTemplateHistory(
    templateName: string,
    organizationId: string,
  ): Promise<Array<{ version: number; createdAt: Date; isActive: boolean }>> {
    const templates = await this.prisma.promptTemplate.findMany({
      where: {
        organizationId,
        name: templateName,
      },
      orderBy: { version: 'desc' },
      select: {
        version: true,
        createdAt: true,
        isActive: true,
      },
    });

    return templates;
  }

  /**
   * Revert to a previous template version.
   */
  async revertToVersion(
    templateName: string,
    organizationId: string,
    version: number,
  ): Promise<void> {
    const template = await this.prisma.promptTemplate.findFirst({
      where: {
        organizationId,
        name: templateName,
        version,
      },
    });

    if (!template) {
      throw new Error(`Template version not found: ${templateName} v${version}`);
    }

    // Deactivate all versions
    await this.prisma.promptTemplate.updateMany({
      where: {
        organizationId,
        name: templateName,
      },
      data: { isActive: false },
    });

    // Activate the target version
    await this.prisma.promptTemplate.update({
      where: { id: template.id },
      data: { isActive: true },
    });
  }

  private async loadFileTemplates(): Promise<void> {
    await this.loadTemplatesFromDir(this.templateDir, '');
  }

  private async loadTemplatesFromDir(dir: string, prefix: string): Promise<void> {
    if (!fs.existsSync(dir)) {
      this.logger.warn(`Template directory not found: ${dir}`);
      return;
    }

    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        const newPrefix = prefix ? `${prefix}/${entry.name}` : entry.name;
        await this.loadTemplatesFromDir(fullPath, newPrefix);
      } else if (entry.name.endsWith('.hbs')) {
        const templateName = prefix
          ? `${prefix}/${entry.name.replace('.hbs', '')}`
          : entry.name.replace('.hbs', '');

        const content = fs.readFileSync(fullPath, 'utf-8');
        const compiled = Handlebars.compile(content);
        this.compiledTemplates.set(templateName, compiled);

        // Also register as partial for nested templates
        Handlebars.registerPartial(templateName, content);

        this.logger.debug(`Loaded template: ${templateName}`);
      }
    }
  }

  private resolveTemplatePath(templateName: string): string {
    return path.join(this.templateDir, `${templateName}.hbs`);
  }

  private registerHelpers(): void {
    // Equality helper
    Handlebars.registerHelper('eq', (a, b) => a === b);

    // Not equal helper
    Handlebars.registerHelper('neq', (a, b) => a !== b);

    // Greater than helper
    Handlebars.registerHelper('gt', (a, b) => a > b);

    // Less than helper
    Handlebars.registerHelper('lt', (a, b) => a < b);

    // JSON stringify helper
    Handlebars.registerHelper('json', (obj) => JSON.stringify(obj, null, 2));

    // Date formatting helper
    Handlebars.registerHelper('formatDate', (date: Date | string) => {
      const d = typeof date === 'string' ? new Date(date) : date;
      return d.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      });
    });

    // Truncate helper
    Handlebars.registerHelper('truncate', (str: string, len: number) => {
      if (str.length <= len) return str;
      return str.slice(0, len) + '...';
    });

    // Uppercase helper
    Handlebars.registerHelper('upper', (str: string) => str?.toUpperCase());

    // Lowercase helper
    Handlebars.registerHelper('lower', (str: string) => str?.toLowerCase());
  }
}
```

2. Update `apps/backend/src/modules/ai/ai.module.ts`:
```typescript
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { PrismaModule } from '../prisma/prisma.module';
import { AiClientService } from './services/ai-client.service';
import { ProviderRegistryService } from './services/provider-registry.service';
import { AiRateLimiterService } from './services/rate-limiter.service';
import { PromptService } from './services/prompt.service';
import { ClaudeProvider } from './providers/claude.provider';

@Module({
  imports: [ConfigModule, PrismaModule],
  providers: [
    ClaudeProvider,
    ProviderRegistryService,
    AiClientService,
    AiRateLimiterService,
    PromptService,
  ],
  exports: [
    AiClientService,
    ProviderRegistryService,
    AiRateLimiterService,
    PromptService,
    ClaudeProvider,
  ],
})
export class AiModule {}
```

3. Update `apps/backend/src/modules/ai/index.ts` to include PromptService export.
  </action>
  <verify>
`npm run build` succeeds.
PromptService loads templates on module init.
  </verify>
  <done>
Prompt service created with template loading, rendering, versioning, and organization overrides.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `npm run build` passes
2. `npx prisma migrate status` shows all migrations applied
3. PromptTemplate model exists in schema
4. Template files exist in prompts/templates directory
5. PromptService loads templates on startup
6. Handlebars helpers are registered
</verification>

<success_criteria>
- Prompt templates stored as Handlebars .hbs files
- PromptService renders templates with context variables
- Organization-specific overrides supported via database
- Version history tracked for rollback capability
- Helper functions for common template operations
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-infrastructure/05-04-SUMMARY.md`
</output>
