---
phase: 05-ai-infrastructure
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/ai/services/conversation.service.ts
  - apps/backend/src/modules/ai/dto/conversation.dto.ts
  - apps/backend/src/modules/ai/ai.module.ts
autonomous: true

must_haves:
  truths:
    - "AI conversations are persisted to database"
    - "Conversation history is retrieved per entity context"
    - "Messages include role, content, and optional tool calls"
    - "Conversations can be paused, resumed, and archived"
  artifacts:
    - path: "apps/backend/prisma/schema.prisma"
      provides: "AiConversation and AiMessage models"
      contains: "model AiConversation"
    - path: "apps/backend/src/modules/ai/services/conversation.service.ts"
      provides: "Conversation CRUD and message management"
      exports: ["ConversationService"]
      min_lines: 100
  key_links:
    - from: "apps/backend/src/modules/ai/services/conversation.service.ts"
      to: "apps/backend/prisma/schema.prisma"
      via: "Prisma queries"
      pattern: "prisma\\.aiConversation|prisma\\.aiMessage"
---

<objective>
Create the AI conversation persistence layer with AiConversation and AiMessage models. This enables conversation history, context continuity across sessions, and audit logging of AI interactions.

Purpose: Per CONTEXT.md, conversations are persisted per entity with pause/resume support. Users can search archived conversations and export to PDF.

Output: ConversationService with CRUD operations for conversations and messages.
</objective>

<execution_context>
@C:\Users\cu0718\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\cu0718\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-ai-infrastructure/05-RESEARCH.md
@.planning/phases/05-ai-infrastructure/05-CONTEXT.md (conversation management decisions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AiConversation and AiMessage models</name>
  <files>
    apps/backend/prisma/schema.prisma
  </files>
  <action>
Add the conversation models to schema.prisma (after PromptTemplate model):

```prisma
// ===========================================
// AI Conversation Tracking
// ===========================================

/// Conversation status tracks the lifecycle
enum AiConversationStatus {
  ACTIVE
  PAUSED
  ARCHIVED

  @@map("ai_conversation_status")
}

/// AiConversation tracks a conversation session with the AI.
/// Conversations are scoped to organization, user, and optionally an entity.
model AiConversation {
  id              String               @id @default(uuid())
  organizationId  String               @map("organization_id")
  userId          String               @map("user_id")

  // Entity context (optional - can have org-wide conversations)
  entityType      String?              @map("entity_type") // 'case', 'investigation', 'campaign'
  entityId        String?              @map("entity_id")

  // Conversation metadata
  title           String?              // AI-generated or user-provided
  status          AiConversationStatus @default(ACTIVE)

  // Agent type used for this conversation
  agentType       String?              @map("agent_type") // 'investigation', 'case', 'compliance-manager'

  // Timestamps
  createdAt       DateTime             @default(now()) @map("created_at")
  updatedAt       DateTime             @updatedAt @map("updated_at")
  pausedAt        DateTime?            @map("paused_at")
  archivedAt      DateTime?            @map("archived_at")
  lastMessageAt   DateTime?            @map("last_message_at")

  // Token tracking for this conversation
  totalInputTokens  Int                @default(0) @map("total_input_tokens")
  totalOutputTokens Int                @default(0) @map("total_output_tokens")

  // Relations
  messages        AiMessage[]

  @@index([organizationId, userId, status])
  @@index([organizationId, entityType, entityId])
  @@index([userId, status])
  @@index([status, lastMessageAt])
  @@map("ai_conversations")
}

/// AiMessage represents a single message in a conversation.
/// Stores both user and assistant messages with optional tool use data.
model AiMessage {
  id              String         @id @default(uuid())
  conversationId  String         @map("conversation_id")

  // Message content
  role            String         // 'user', 'assistant'
  content         String         @db.Text

  // Tool use tracking (for assistant messages)
  toolCalls       Json?          @map("tool_calls") // Array of {id, name, input}
  toolResults     Json?          @map("tool_results") // Array of {toolUseId, result}

  // Token counts for this message
  inputTokens     Int?           @map("input_tokens")
  outputTokens    Int?           @map("output_tokens")

  // Metadata
  model           String?        // Model used for this response
  createdAt       DateTime       @default(now()) @map("created_at")

  // Relations
  conversation    AiConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([conversationId, createdAt])
  @@map("ai_messages")
}
```

Run migration:
```bash
cd apps/backend && npx prisma migrate dev --name add_ai_conversation
```
  </action>
  <verify>
Migration succeeds.
`npx prisma generate` completes.
AiConversation and AiMessage types appear in generated client.
  </verify>
  <done>
Conversation models created with proper indexes and relations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ConversationService</name>
  <files>
    apps/backend/src/modules/ai/services/conversation.service.ts
    apps/backend/src/modules/ai/dto/conversation.dto.ts
  </files>
  <action>
1. Create `apps/backend/src/modules/ai/dto/conversation.dto.ts`:
```typescript
import { IsString, IsOptional, IsEnum, IsArray, IsObject, MaxLength } from 'class-validator';

export enum ConversationStatus {
  ACTIVE = 'ACTIVE',
  PAUSED = 'PAUSED',
  ARCHIVED = 'ARCHIVED',
}

export class GetOrCreateConversationDto {
  @IsString()
  organizationId: string;

  @IsString()
  userId: string;

  @IsString()
  @IsOptional()
  entityType?: string;

  @IsString()
  @IsOptional()
  entityId?: string;

  @IsString()
  @IsOptional()
  agentType?: string;
}

export class AddMessageDto {
  @IsString()
  conversationId: string;

  @IsEnum(['user', 'assistant'])
  role: 'user' | 'assistant';

  @IsString()
  @MaxLength(500000) // ~125K tokens
  content: string;

  @IsArray()
  @IsOptional()
  toolCalls?: Array<{ id: string; name: string; input: unknown }>;

  @IsArray()
  @IsOptional()
  toolResults?: Array<{ toolUseId: string; result: unknown }>;

  @IsOptional()
  inputTokens?: number;

  @IsOptional()
  outputTokens?: number;

  @IsString()
  @IsOptional()
  model?: string;
}

export interface ConversationWithMessages {
  id: string;
  title: string | null;
  status: ConversationStatus;
  entityType: string | null;
  entityId: string | null;
  agentType: string | null;
  createdAt: Date;
  lastMessageAt: Date | null;
  messageCount: number;
  messages: Array<{
    id: string;
    role: string;
    content: string;
    createdAt: Date;
  }>;
}

export interface ConversationSummary {
  id: string;
  title: string | null;
  status: ConversationStatus;
  entityType: string | null;
  entityId: string | null;
  agentType: string | null;
  lastMessageAt: Date | null;
  messageCount: number;
  totalTokens: number;
}
```

2. Create `apps/backend/src/modules/ai/services/conversation.service.ts`:
```typescript
import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { AiConversation, AiMessage, Prisma } from '@prisma/client';
import {
  GetOrCreateConversationDto,
  AddMessageDto,
  ConversationWithMessages,
  ConversationSummary,
  ConversationStatus,
} from '../dto/conversation.dto';

@Injectable()
export class ConversationService {
  private readonly logger = new Logger(ConversationService.name);

  constructor(private readonly prisma: PrismaService) {}

  /**
   * Get or create an active conversation for the given context.
   * Returns existing active conversation if one exists.
   */
  async getOrCreate(params: GetOrCreateConversationDto): Promise<AiConversation> {
    // Find existing active conversation
    const existing = await this.prisma.aiConversation.findFirst({
      where: {
        organizationId: params.organizationId,
        userId: params.userId,
        entityType: params.entityType || null,
        entityId: params.entityId || null,
        status: 'ACTIVE',
      },
      orderBy: { lastMessageAt: 'desc' },
    });

    if (existing) {
      return existing;
    }

    // Create new conversation
    return this.prisma.aiConversation.create({
      data: {
        organizationId: params.organizationId,
        userId: params.userId,
        entityType: params.entityType,
        entityId: params.entityId,
        agentType: params.agentType,
        status: 'ACTIVE',
      },
    });
  }

  /**
   * Get a conversation by ID.
   */
  async get(id: string, organizationId: string): Promise<AiConversation | null> {
    return this.prisma.aiConversation.findFirst({
      where: { id, organizationId },
    });
  }

  /**
   * Get conversation with messages.
   */
  async getWithMessages(
    id: string,
    organizationId: string,
    messageLimit = 50,
  ): Promise<ConversationWithMessages | null> {
    const conversation = await this.prisma.aiConversation.findFirst({
      where: { id, organizationId },
      include: {
        messages: {
          orderBy: { createdAt: 'desc' },
          take: messageLimit,
        },
        _count: {
          select: { messages: true },
        },
      },
    });

    if (!conversation) return null;

    return {
      id: conversation.id,
      title: conversation.title,
      status: conversation.status as ConversationStatus,
      entityType: conversation.entityType,
      entityId: conversation.entityId,
      agentType: conversation.agentType,
      createdAt: conversation.createdAt,
      lastMessageAt: conversation.lastMessageAt,
      messageCount: conversation._count.messages,
      messages: conversation.messages.reverse().map(m => ({
        id: m.id,
        role: m.role,
        content: m.content,
        createdAt: m.createdAt,
      })),
    };
  }

  /**
   * Add a message to a conversation.
   */
  async addMessage(params: AddMessageDto): Promise<AiMessage> {
    const message = await this.prisma.aiMessage.create({
      data: {
        conversationId: params.conversationId,
        role: params.role,
        content: params.content,
        toolCalls: params.toolCalls as Prisma.JsonArray | undefined,
        toolResults: params.toolResults as Prisma.JsonArray | undefined,
        inputTokens: params.inputTokens,
        outputTokens: params.outputTokens,
        model: params.model,
      },
    });

    // Update conversation metadata
    const updateData: Prisma.AiConversationUpdateInput = {
      lastMessageAt: new Date(),
    };

    if (params.inputTokens) {
      updateData.totalInputTokens = { increment: params.inputTokens };
    }
    if (params.outputTokens) {
      updateData.totalOutputTokens = { increment: params.outputTokens };
    }

    await this.prisma.aiConversation.update({
      where: { id: params.conversationId },
      data: updateData,
    });

    return message;
  }

  /**
   * Get messages for a conversation.
   */
  async getMessages(
    conversationId: string,
    limit = 50,
    before?: Date,
  ): Promise<AiMessage[]> {
    return this.prisma.aiMessage.findMany({
      where: {
        conversationId,
        ...(before && { createdAt: { lt: before } }),
      },
      orderBy: { createdAt: 'desc' },
      take: limit,
    }).then(messages => messages.reverse());
  }

  /**
   * Pause a conversation (saves context for later resume).
   */
  async pause(id: string, organizationId: string): Promise<void> {
    const result = await this.prisma.aiConversation.updateMany({
      where: { id, organizationId, status: 'ACTIVE' },
      data: {
        status: 'PAUSED',
        pausedAt: new Date(),
      },
    });

    if (result.count === 0) {
      throw new NotFoundException('Conversation not found or not active');
    }
  }

  /**
   * Resume a paused conversation.
   */
  async resume(id: string, organizationId: string): Promise<void> {
    const result = await this.prisma.aiConversation.updateMany({
      where: { id, organizationId, status: 'PAUSED' },
      data: {
        status: 'ACTIVE',
        pausedAt: null,
      },
    });

    if (result.count === 0) {
      throw new NotFoundException('Conversation not found or not paused');
    }
  }

  /**
   * Archive a conversation (soft delete).
   */
  async archive(id: string, organizationId: string): Promise<void> {
    const result = await this.prisma.aiConversation.updateMany({
      where: { id, organizationId },
      data: {
        status: 'ARCHIVED',
        archivedAt: new Date(),
      },
    });

    if (result.count === 0) {
      throw new NotFoundException('Conversation not found');
    }
  }

  /**
   * List conversations for a user.
   */
  async list(params: {
    organizationId: string;
    userId: string;
    status?: ConversationStatus;
    entityType?: string;
    entityId?: string;
    limit?: number;
    offset?: number;
  }): Promise<{ conversations: ConversationSummary[]; total: number }> {
    const where: Prisma.AiConversationWhereInput = {
      organizationId: params.organizationId,
      userId: params.userId,
      ...(params.status && { status: params.status }),
      ...(params.entityType && { entityType: params.entityType }),
      ...(params.entityId && { entityId: params.entityId }),
    };

    const [conversations, total] = await Promise.all([
      this.prisma.aiConversation.findMany({
        where,
        orderBy: { lastMessageAt: 'desc' },
        take: params.limit || 20,
        skip: params.offset || 0,
        include: {
          _count: { select: { messages: true } },
        },
      }),
      this.prisma.aiConversation.count({ where }),
    ]);

    return {
      conversations: conversations.map(c => ({
        id: c.id,
        title: c.title,
        status: c.status as ConversationStatus,
        entityType: c.entityType,
        entityId: c.entityId,
        agentType: c.agentType,
        lastMessageAt: c.lastMessageAt,
        messageCount: c._count.messages,
        totalTokens: c.totalInputTokens + c.totalOutputTokens,
      })),
      total,
    };
  }

  /**
   * Search conversations by message content.
   */
  async search(params: {
    organizationId: string;
    userId: string;
    query: string;
    limit?: number;
  }): Promise<ConversationSummary[]> {
    // Search in messages
    const matchingMessages = await this.prisma.aiMessage.findMany({
      where: {
        content: { contains: params.query, mode: 'insensitive' },
        conversation: {
          organizationId: params.organizationId,
          userId: params.userId,
        },
      },
      select: { conversationId: true },
      distinct: ['conversationId'],
      take: params.limit || 20,
    });

    const conversationIds = matchingMessages.map(m => m.conversationId);

    const conversations = await this.prisma.aiConversation.findMany({
      where: { id: { in: conversationIds } },
      include: { _count: { select: { messages: true } } },
    });

    return conversations.map(c => ({
      id: c.id,
      title: c.title,
      status: c.status as ConversationStatus,
      entityType: c.entityType,
      entityId: c.entityId,
      agentType: c.agentType,
      lastMessageAt: c.lastMessageAt,
      messageCount: c._count.messages,
      totalTokens: c.totalInputTokens + c.totalOutputTokens,
    }));
  }

  /**
   * Generate a title for a conversation based on its messages.
   * Called after first few messages to provide meaningful title.
   */
  async generateTitle(conversationId: string): Promise<string> {
    const messages = await this.prisma.aiMessage.findMany({
      where: { conversationId },
      orderBy: { createdAt: 'asc' },
      take: 3,
      select: { content: true, role: true },
    });

    if (messages.length === 0) {
      return 'New Conversation';
    }

    // Use first user message as basis for title
    const firstUserMessage = messages.find(m => m.role === 'user');
    if (firstUserMessage) {
      // Truncate and clean up
      const title = firstUserMessage.content
        .slice(0, 60)
        .replace(/\n/g, ' ')
        .trim();
      return title.length < firstUserMessage.content.length ? `${title}...` : title;
    }

    return 'New Conversation';
  }

  /**
   * Update conversation title.
   */
  async updateTitle(
    id: string,
    organizationId: string,
    title: string,
  ): Promise<void> {
    await this.prisma.aiConversation.updateMany({
      where: { id, organizationId },
      data: { title },
    });
  }
}
```
  </action>
  <verify>
`npm run build` succeeds.
ConversationService has all required methods.
  </verify>
  <done>
ConversationService created with full CRUD operations.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire up ConversationService in AI module</name>
  <files>
    apps/backend/src/modules/ai/ai.module.ts
    apps/backend/src/modules/ai/dto/index.ts
    apps/backend/src/modules/ai/index.ts
  </files>
  <action>
1. Update `apps/backend/src/modules/ai/dto/index.ts`:
```typescript
export * from './chat-message.dto';
export * from './rate-limit.dto';
export * from './conversation.dto';
```

2. Update `apps/backend/src/modules/ai/ai.module.ts`:
```typescript
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { PrismaModule } from '../prisma/prisma.module';
import { AiClientService } from './services/ai-client.service';
import { ProviderRegistryService } from './services/provider-registry.service';
import { AiRateLimiterService } from './services/rate-limiter.service';
import { PromptService } from './services/prompt.service';
import { ConversationService } from './services/conversation.service';
import { ClaudeProvider } from './providers/claude.provider';

@Module({
  imports: [ConfigModule, PrismaModule],
  providers: [
    ClaudeProvider,
    ProviderRegistryService,
    AiClientService,
    AiRateLimiterService,
    PromptService,
    ConversationService,
  ],
  exports: [
    AiClientService,
    ProviderRegistryService,
    AiRateLimiterService,
    PromptService,
    ConversationService,
    ClaudeProvider,
  ],
})
export class AiModule {}
```

3. Update `apps/backend/src/modules/ai/index.ts`:
```typescript
export * from './ai.module';
export * from './services/ai-client.service';
export * from './services/provider-registry.service';
export * from './services/rate-limiter.service';
export * from './services/prompt.service';
export * from './services/conversation.service';
export * from './providers';
export * from './interfaces';
export * from './dto';
```
  </action>
  <verify>
`npm run build` succeeds.
ConversationService is exported from AiModule.
  </verify>
  <done>
ConversationService integrated into AI module.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `npm run build` passes
2. `npx prisma migrate status` shows all migrations applied
3. AiConversation and AiMessage models exist
4. ConversationService has getOrCreate, addMessage, pause, resume, archive methods
5. Message content supports tool calls and results
</verification>

<success_criteria>
- Conversations persisted per organization/user/entity context
- Messages include role, content, tool calls, and token counts
- Conversation lifecycle: ACTIVE -> PAUSED -> ARCHIVED
- Search across archived conversations
- Title generation from initial messages
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-infrastructure/05-05-SUMMARY.md`
</output>
