---
phase: 05-ai-infrastructure
plan: 11
type: execute
wave: 4
depends_on: ["05-09"]
files_modified:
  - apps/backend/src/modules/ai/ai.gateway.ts
  - apps/backend/src/modules/ai/ai.controller.ts
  - apps/backend/src/modules/ai/dto/websocket.dto.ts
  - apps/backend/src/modules/ai/ai.module.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket gateway streams AI responses in real-time"
    - "REST endpoints provide non-streaming skill execution"
    - "All endpoints enforce tenant isolation"
    - "Conversation management available via API"
  artifacts:
    - path: "apps/backend/src/modules/ai/ai.gateway.ts"
      provides: "WebSocket gateway for streaming chat"
      exports: ["AiGateway"]
      min_lines: 100
    - path: "apps/backend/src/modules/ai/ai.controller.ts"
      provides: "REST API for AI features"
      exports: ["AiController"]
      min_lines: 80
  key_links:
    - from: "apps/backend/src/modules/ai/ai.gateway.ts"
      to: "apps/backend/src/modules/ai/agents/agent.registry.ts"
      via: "gets agent for chat"
      pattern: "agentRegistry|getAgent"
    - from: "apps/backend/src/modules/ai/ai.controller.ts"
      to: "apps/backend/src/modules/ai/skills/skill.registry.ts"
      via: "executes skills"
      pattern: "skillRegistry|executeSkill"
---

<objective>
Create the API layer for AI features - WebSocket gateway for streaming chat and REST controller for skill execution. This exposes the AI infrastructure to the frontend.

Purpose: Per CONTEXT.md, the AI panel uses WebSocket for real-time streaming chat. REST endpoints support direct skill invocation and conversation management.

Output: AiGateway for WebSocket streaming and AiController for REST endpoints.
</objective>

<execution_context>
@C:\Users\cu0718\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\cu0718\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-ai-infrastructure/05-RESEARCH.md
@.planning/phases/05-ai-infrastructure/05-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebSocket DTOs</name>
  <files>
    apps/backend/src/modules/ai/dto/websocket.dto.ts
  </files>
  <action>
Create `apps/backend/src/modules/ai/dto/websocket.dto.ts`:

```typescript
import { IsString, IsOptional, IsEnum } from 'class-validator';

export class ChatPayload {
  @IsString()
  message: string;

  @IsString()
  @IsOptional()
  entityType?: string;

  @IsString()
  @IsOptional()
  entityId?: string;

  @IsString()
  @IsOptional()
  agentType?: string;
}

export class StopPayload {
  @IsString()
  conversationId: string;
}

export class ConversationActionPayload {
  @IsString()
  conversationId: string;
}

export class SkillExecutePayload {
  @IsString()
  skillId: string;

  input: Record<string, unknown>;

  @IsString()
  @IsOptional()
  entityType?: string;

  @IsString()
  @IsOptional()
  entityId?: string;
}

export class ActionExecutePayload {
  @IsString()
  actionId: string;

  input: Record<string, unknown>;

  @IsString()
  entityType: string;

  @IsString()
  entityId: string;

  @IsOptional()
  skipPreview?: boolean;
}

export interface SocketContext {
  organizationId: string;
  userId: string;
  userRole: string;
  permissions: string[];
}

// Outbound events
export interface TextDeltaEvent {
  type: 'text_delta';
  conversationId: string;
  text: string;
}

export interface ToolUseEvent {
  type: 'tool_use';
  conversationId: string;
  toolName: string;
  input: unknown;
}

export interface MessageStartEvent {
  type: 'message_start';
  conversationId: string;
}

export interface MessageCompleteEvent {
  type: 'message_complete';
  conversationId: string;
}

export interface ErrorEvent {
  type: 'error';
  conversationId: string;
  message: string;
}

export interface StoppedEvent {
  type: 'stopped';
  conversationId: string;
}
```
  </action>
  <verify>
File created with all DTOs.
  </verify>
  <done>
WebSocket DTOs created for chat communication.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AiGateway for WebSocket streaming</name>
  <files>
    apps/backend/src/modules/ai/ai.gateway.ts
  </files>
  <action>
Create `apps/backend/src/modules/ai/ai.gateway.ts`:

```typescript
import {
  WebSocketGateway,
  WebSocketServer,
  SubscribeMessage,
  OnGatewayConnection,
  OnGatewayDisconnect,
  ConnectedSocket,
  MessageBody,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Logger, UseGuards } from '@nestjs/common';
import { AgentRegistry } from './agents/agent.registry';
import { ConversationService } from './services/conversation.service';
import { SkillRegistry } from './skills/skill.registry';
import { ActionExecutorService } from './actions/action-executor.service';
import {
  ChatPayload,
  StopPayload,
  ConversationActionPayload,
  SkillExecutePayload,
  ActionExecutePayload,
  SocketContext,
} from './dto/websocket.dto';

@WebSocketGateway({
  namespace: '/ai',
  cors: {
    origin: '*', // Configure based on environment
    credentials: true,
  },
})
export class AiGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;

  private readonly logger = new Logger(AiGateway.name);
  private readonly activeStreams = new Map<string, boolean>();

  constructor(
    private readonly agentRegistry: AgentRegistry,
    private readonly conversationService: ConversationService,
    private readonly skillRegistry: SkillRegistry,
    private readonly actionExecutor: ActionExecutorService,
  ) {}

  async handleConnection(client: Socket) {
    try {
      // Extract auth context from handshake
      // In production, verify JWT and extract user info
      const context = this.extractContext(client);
      if (!context) {
        this.logger.warn(`Connection rejected: missing auth context`);
        client.disconnect(true);
        return;
      }

      client.data.context = context;
      this.logger.debug(`Client connected: ${client.id} (org: ${context.organizationId})`);
    } catch (error) {
      this.logger.error(`Connection error: ${error.message}`);
      client.disconnect(true);
    }
  }

  handleDisconnect(client: Socket) {
    this.logger.debug(`Client disconnected: ${client.id}`);
    // Clean up any active streams
    this.activeStreams.delete(client.id);
  }

  @SubscribeMessage('chat')
  async handleChat(
    @ConnectedSocket() client: Socket,
    @MessageBody() payload: ChatPayload,
  ): Promise<void> {
    const context: SocketContext = client.data.context;
    if (!context) {
      client.emit('error', { message: 'Not authenticated' });
      return;
    }

    const { message, entityType, entityId, agentType } = payload;

    // Determine agent type
    const resolvedAgentType = agentType ||
      this.agentRegistry.getAgentTypeForEntity(entityType || '') ||
      'compliance-manager';

    try {
      const agent = this.agentRegistry.getAgent(resolvedAgentType, {
        organizationId: context.organizationId,
        userId: context.userId,
        userRole: context.userRole,
        permissions: context.permissions,
        entityType,
        entityId,
      });

      // Initialize agent
      await agent.initialize({
        organizationId: context.organizationId,
        userId: context.userId,
        userRole: context.userRole,
        permissions: context.permissions,
        entityType,
        entityId,
      });

      // Get conversation ID for events
      const conversation = await this.conversationService.getOrCreate({
        organizationId: context.organizationId,
        userId: context.userId,
        entityType,
        entityId,
        agentType: resolvedAgentType,
      });

      const conversationId = conversation.id;

      // Mark stream as active
      this.activeStreams.set(client.id, true);

      // Emit start event
      client.emit('message_start', { conversationId });

      // Stream response
      const stream = agent.chat(message, {
        organizationId: context.organizationId,
        userId: context.userId,
        userRole: context.userRole,
        permissions: context.permissions,
        entityType,
        entityId,
      });

      for await (const event of stream) {
        // Check if stream was stopped
        if (!this.activeStreams.get(client.id)) {
          break;
        }

        if (event.type === 'text_delta' && event.text) {
          client.emit('text_delta', {
            conversationId,
            text: event.text,
          });
        } else if (event.type === 'tool_use' && event.toolCall) {
          client.emit('tool_use', {
            conversationId,
            toolName: event.toolCall.name,
            input: event.toolCall.input,
          });
        } else if (event.type === 'error') {
          client.emit('error', {
            conversationId,
            message: event.error,
          });
        }
      }

      // Emit complete event
      if (this.activeStreams.get(client.id)) {
        client.emit('message_complete', { conversationId });
      }
    } catch (error) {
      this.logger.error(`Chat error: ${error.message}`, error.stack);
      client.emit('error', {
        message: error.message || 'Chat failed',
      });
    } finally {
      this.activeStreams.delete(client.id);
    }
  }

  @SubscribeMessage('stop')
  async handleStop(
    @ConnectedSocket() client: Socket,
    @MessageBody() payload: StopPayload,
  ): Promise<void> {
    this.activeStreams.set(client.id, false);
    client.emit('stopped', { conversationId: payload.conversationId });
  }

  @SubscribeMessage('pause')
  async handlePause(
    @ConnectedSocket() client: Socket,
    @MessageBody() payload: ConversationActionPayload,
  ): Promise<void> {
    const context: SocketContext = client.data.context;

    try {
      await this.conversationService.pause(payload.conversationId, context.organizationId);
      client.emit('conversation_paused', { conversationId: payload.conversationId });
    } catch (error) {
      client.emit('error', { message: error.message });
    }
  }

  @SubscribeMessage('resume')
  async handleResume(
    @ConnectedSocket() client: Socket,
    @MessageBody() payload: ConversationActionPayload,
  ): Promise<void> {
    const context: SocketContext = client.data.context;

    try {
      await this.conversationService.resume(payload.conversationId, context.organizationId);
      client.emit('conversation_resumed', { conversationId: payload.conversationId });
    } catch (error) {
      client.emit('error', { message: error.message });
    }
  }

  @SubscribeMessage('skill_execute')
  async handleSkillExecute(
    @ConnectedSocket() client: Socket,
    @MessageBody() payload: SkillExecutePayload,
  ): Promise<void> {
    const context: SocketContext = client.data.context;

    try {
      const result = await this.skillRegistry.executeSkill(payload.skillId, payload.input, {
        organizationId: context.organizationId,
        userId: context.userId,
        entityType: payload.entityType,
        entityId: payload.entityId,
        permissions: context.permissions,
      });

      client.emit('skill_result', {
        skillId: payload.skillId,
        result,
      });
    } catch (error) {
      client.emit('error', { message: error.message });
    }
  }

  @SubscribeMessage('action_execute')
  async handleActionExecute(
    @ConnectedSocket() client: Socket,
    @MessageBody() payload: ActionExecutePayload,
  ): Promise<void> {
    const context: SocketContext = client.data.context;

    try {
      const result = await this.actionExecutor.execute(
        payload.actionId,
        payload.input,
        {
          organizationId: context.organizationId,
          userId: context.userId,
          userRole: context.userRole,
          permissions: context.permissions,
          entityType: payload.entityType,
          entityId: payload.entityId,
        },
        payload.skipPreview,
      );

      client.emit('action_result', {
        actionId: payload.actionId,
        result,
      });
    } catch (error) {
      client.emit('error', { message: error.message });
    }
  }

  private extractContext(client: Socket): SocketContext | null {
    // Extract from auth handshake
    // In production: verify JWT from client.handshake.auth.token
    const auth = client.handshake.auth;

    if (!auth.organizationId || !auth.userId) {
      return null;
    }

    return {
      organizationId: auth.organizationId,
      userId: auth.userId,
      userRole: auth.userRole || 'EMPLOYEE',
      permissions: auth.permissions || [],
    };
  }
}
```
  </action>
  <verify>
File created.
Gateway handles chat, stop, pause, resume, skill, action events.
  </verify>
  <done>
WebSocket gateway created for real-time AI streaming.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create AiController and wire up module</name>
  <files>
    apps/backend/src/modules/ai/ai.controller.ts
    apps/backend/src/modules/ai/dto/index.ts
    apps/backend/src/modules/ai/ai.module.ts
  </files>
  <action>
1. Create `apps/backend/src/modules/ai/ai.controller.ts`:

```typescript
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Query,
  UseGuards,
  Request,
} from '@nestjs/common';
import { SkillRegistry } from './skills/skill.registry';
import { ActionCatalog } from './actions/action.catalog';
import { ActionExecutorService } from './actions/action-executor.service';
import { ConversationService } from './services/conversation.service';
import { ContextLoaderService } from './services/context-loader.service';
import { AgentRegistry } from './agents/agent.registry';
import { AiRateLimiterService } from './services/rate-limiter.service';
import { ConversationStatus } from './dto/conversation.dto';

// Assume JwtAuthGuard exists from auth module
// import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@Controller('api/v1/ai')
// @UseGuards(JwtAuthGuard)
export class AiController {
  constructor(
    private readonly skillRegistry: SkillRegistry,
    private readonly actionCatalog: ActionCatalog,
    private readonly actionExecutor: ActionExecutorService,
    private readonly conversationService: ConversationService,
    private readonly contextLoader: ContextLoaderService,
    private readonly agentRegistry: AgentRegistry,
    private readonly rateLimiter: AiRateLimiterService,
  ) {}

  // ============ Skills ============

  @Get('skills')
  async listSkills(@Request() req: any) {
    const skills = this.skillRegistry.getAvailableSkills({
      organizationId: req.user?.organizationId || 'demo',
      userId: req.user?.id || 'demo',
      userPermissions: req.user?.permissions || [],
    });

    return skills.map(s => ({
      id: s.id,
      name: s.name,
      description: s.description,
      scope: s.scope,
    }));
  }

  @Post('skills/:skillId/execute')
  async executeSkill(
    @Param('skillId') skillId: string,
    @Body() body: { input: Record<string, unknown>; entityType?: string; entityId?: string },
    @Request() req: any,
  ) {
    const result = await this.skillRegistry.executeSkill(skillId, body.input, {
      organizationId: req.user?.organizationId || 'demo',
      userId: req.user?.id || 'demo',
      entityType: body.entityType,
      entityId: body.entityId,
      permissions: req.user?.permissions || [],
    });

    return result;
  }

  // ============ Actions ============

  @Get('actions')
  async listActions(
    @Query('entityType') entityType: string,
    @Request() req: any,
  ) {
    const actions = this.actionCatalog.getAvailableActions({
      entityType,
      userPermissions: req.user?.permissions || [],
    });

    return actions.map(a => ({
      id: a.id,
      name: a.name,
      description: a.description,
      category: a.category,
      requiresPreview: this.actionCatalog.requiresPreview(a.id),
    }));
  }

  @Post('actions/:actionId/preview')
  async previewAction(
    @Param('actionId') actionId: string,
    @Body() body: { input: Record<string, unknown>; entityType: string; entityId: string },
    @Request() req: any,
  ) {
    const preview = await this.actionExecutor.preview(actionId, body.input, {
      organizationId: req.user?.organizationId || 'demo',
      userId: req.user?.id || 'demo',
      userRole: req.user?.role || 'EMPLOYEE',
      permissions: req.user?.permissions || [],
      entityType: body.entityType,
      entityId: body.entityId,
    });

    return preview;
  }

  @Post('actions/:actionId/execute')
  async executeAction(
    @Param('actionId') actionId: string,
    @Body() body: { input: Record<string, unknown>; entityType: string; entityId: string; skipPreview?: boolean },
    @Request() req: any,
  ) {
    const result = await this.actionExecutor.execute(
      actionId,
      body.input,
      {
        organizationId: req.user?.organizationId || 'demo',
        userId: req.user?.id || 'demo',
        userRole: req.user?.role || 'EMPLOYEE',
        permissions: req.user?.permissions || [],
        entityType: body.entityType,
        entityId: body.entityId,
      },
      body.skipPreview,
    );

    return result;
  }

  @Post('actions/:actionId/undo')
  async undoAction(
    @Param('actionId') actionId: string,
    @Body() body: { entityType: string; entityId: string },
    @Request() req: any,
  ) {
    await this.actionExecutor.undo(actionId, {
      organizationId: req.user?.organizationId || 'demo',
      userId: req.user?.id || 'demo',
      userRole: req.user?.role || 'EMPLOYEE',
      permissions: req.user?.permissions || [],
      entityType: body.entityType,
      entityId: body.entityId,
    });

    return { success: true };
  }

  // ============ Conversations ============

  @Get('conversations')
  async listConversations(
    @Query('status') status: ConversationStatus,
    @Query('entityType') entityType: string,
    @Query('entityId') entityId: string,
    @Query('limit') limit: string,
    @Request() req: any,
  ) {
    return this.conversationService.list({
      organizationId: req.user?.organizationId || 'demo',
      userId: req.user?.id || 'demo',
      status,
      entityType,
      entityId,
      limit: limit ? parseInt(limit, 10) : undefined,
    });
  }

  @Get('conversations/:id')
  async getConversation(
    @Param('id') id: string,
    @Query('messageLimit') messageLimit: string,
    @Request() req: any,
  ) {
    return this.conversationService.getWithMessages(
      id,
      req.user?.organizationId || 'demo',
      messageLimit ? parseInt(messageLimit, 10) : undefined,
    );
  }

  @Get('conversations/search')
  async searchConversations(
    @Query('q') query: string,
    @Query('limit') limit: string,
    @Request() req: any,
  ) {
    return this.conversationService.search({
      organizationId: req.user?.organizationId || 'demo',
      userId: req.user?.id || 'demo',
      query,
      limit: limit ? parseInt(limit, 10) : undefined,
    });
  }

  @Post('conversations/:id/archive')
  async archiveConversation(
    @Param('id') id: string,
    @Request() req: any,
  ) {
    await this.conversationService.archive(id, req.user?.organizationId || 'demo');
    return { success: true };
  }

  // ============ Agents ============

  @Get('agents')
  async listAgents() {
    return this.agentRegistry.listAgentTypes().map(type => ({
      id: type,
      // Could add more metadata
    }));
  }

  @Get('agents/:type/suggestions')
  async getAgentSuggestions(
    @Param('type') type: string,
    @Query('entityType') entityType: string,
    @Query('entityId') entityId: string,
    @Request() req: any,
  ) {
    const agent = this.agentRegistry.getAgent(type, {
      organizationId: req.user?.organizationId || 'demo',
      userId: req.user?.id || 'demo',
      userRole: req.user?.role || 'EMPLOYEE',
      permissions: req.user?.permissions || [],
      entityType,
      entityId,
    });

    return {
      suggestions: agent.getSuggestedPrompts({
        organizationId: req.user?.organizationId || 'demo',
        userId: req.user?.id || 'demo',
        userRole: req.user?.role || 'EMPLOYEE',
        permissions: req.user?.permissions || [],
        entityType,
        entityId,
      }),
    };
  }

  // ============ Usage ============

  @Get('usage')
  async getUsage(
    @Query('period') period: 'day' | 'week' | 'month',
    @Request() req: any,
  ) {
    return this.rateLimiter.getUsageStats(
      req.user?.organizationId || 'demo',
      period || 'day',
    );
  }
}
```

2. Update `apps/backend/src/modules/ai/dto/index.ts`:
```typescript
export * from './chat-message.dto';
export * from './rate-limit.dto';
export * from './conversation.dto';
export * from './context.dto';
export * from './websocket.dto';
```

3. Update `apps/backend/src/modules/ai/ai.module.ts` to include controller and gateway:
```typescript
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { CacheModule } from '@nestjs/cache-manager';
import { PrismaModule } from '../prisma/prisma.module';
import { EventsModule } from '../events/events.module';
import { AiClientService } from './services/ai-client.service';
import { ProviderRegistryService } from './services/provider-registry.service';
import { AiRateLimiterService } from './services/rate-limiter.service';
import { PromptService } from './services/prompt.service';
import { ConversationService } from './services/conversation.service';
import { ContextLoaderService } from './services/context-loader.service';
import { SkillRegistry } from './skills/skill.registry';
import { AgentRegistry } from './agents/agent.registry';
import { ActionCatalog } from './actions/action.catalog';
import { ActionExecutorService } from './actions/action-executor.service';
import { ClaudeProvider } from './providers/claude.provider';
import { AiGateway } from './ai.gateway';
import { AiController } from './ai.controller';

@Module({
  imports: [
    ConfigModule,
    PrismaModule,
    EventsModule,
    CacheModule.register({
      ttl: 300000,
    }),
  ],
  controllers: [AiController],
  providers: [
    ClaudeProvider,
    ProviderRegistryService,
    AiClientService,
    AiRateLimiterService,
    PromptService,
    ConversationService,
    ContextLoaderService,
    SkillRegistry,
    AgentRegistry,
    ActionCatalog,
    ActionExecutorService,
    AiGateway,
  ],
  exports: [
    AiClientService,
    ProviderRegistryService,
    AiRateLimiterService,
    PromptService,
    ConversationService,
    ContextLoaderService,
    SkillRegistry,
    AgentRegistry,
    ActionCatalog,
    ActionExecutorService,
    ClaudeProvider,
  ],
})
export class AiModule {}
```
  </action>
  <verify>
`npm run build` succeeds.
AiController and AiGateway are registered in module.
  </verify>
  <done>
API layer created with WebSocket gateway and REST controller.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `npm run build` passes
2. AiGateway handles WebSocket events for streaming
3. AiController exposes REST endpoints for skills, actions, conversations
4. All endpoints enforce tenant isolation
5. Usage stats endpoint available
</verification>

<success_criteria>
- WebSocket gateway at /ai namespace for streaming chat
- REST endpoints for skill execution, action preview/execute/undo
- Conversation CRUD available via REST
- Agent suggestions available via REST
- Usage statistics available for billing dashboard
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-infrastructure/05-11-SUMMARY.md`
</output>
