---
phase: 05-ai-infrastructure
plan: 10
type: execute
wave: 4
depends_on: ["05-09"]
files_modified:
  - apps/backend/src/modules/ai/actions/action.types.ts
  - apps/backend/src/modules/ai/actions/action.catalog.ts
  - apps/backend/src/modules/ai/actions/action-executor.service.ts
  - apps/backend/src/modules/ai/actions/actions/add-note.action.ts
  - apps/backend/src/modules/ai/actions/actions/change-status.action.ts
  - apps/backend/src/modules/ai/actions/index.ts
  - apps/backend/prisma/schema.prisma
  - apps/backend/src/modules/ai/ai.module.ts
autonomous: true

must_haves:
  truths:
    - "Actions are mutations with permission validation"
    - "Actions that modify data are recorded for audit"
    - "Action catalog defines available actions per entity type"
    - "Quick actions have undo capability"
  artifacts:
    - path: "apps/backend/src/modules/ai/actions/action-executor.service.ts"
      provides: "Action execution with preview and undo"
      exports: ["ActionExecutorService"]
      min_lines: 100
    - path: "apps/backend/src/modules/ai/actions/action.catalog.ts"
      provides: "Action registration and lookup"
      exports: ["ActionCatalog"]
    - path: "apps/backend/prisma/schema.prisma"
      provides: "AiAction model for tracking"
      contains: "model AiAction"
  key_links:
    - from: "apps/backend/src/modules/ai/actions/action-executor.service.ts"
      to: "apps/backend/prisma/schema.prisma"
      via: "records actions"
      pattern: "prisma\\.aiAction"
---

<objective>
Create the action system (AI-15, AI-16) with permission validation, preview capability, and undo support. Actions are AI-initiated mutations that modify entities - distinct from skills which are read-only.

Purpose: Per CONTEXT.md, actions require preview for destructive operations and have configurable undo windows. This enables AI to take actions while maintaining user control.

Output: ActionCatalog, ActionExecutorService, and initial actions (add-note, change-status).
</objective>

<execution_context>
@C:\Users\cu0718\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\cu0718\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-ai-infrastructure/05-RESEARCH.md
@.planning/phases/05-ai-infrastructure/05-CONTEXT.md (action handling, undo system decisions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AiAction model and action types</name>
  <files>
    apps/backend/prisma/schema.prisma
    apps/backend/src/modules/ai/actions/action.types.ts
  </files>
  <action>
1. Add AiAction model to schema.prisma (after AiContextFile):
```prisma
/// AiAction status tracks the lifecycle of AI-initiated actions.
enum AiActionStatus {
  PENDING
  EXECUTING
  COMPLETED
  FAILED
  UNDONE

  @@map("ai_action_status")
}

/// AiAction records AI-initiated mutations for audit and undo capability.
model AiAction {
  id              String         @id @default(uuid())
  organizationId  String         @map("organization_id")
  conversationId  String?        @map("conversation_id") // Links to AI conversation
  userId          String         @map("user_id") // User who triggered the action

  // Action details
  actionType      String         @map("action_type") // e.g., 'add-note', 'change-status'
  entityType      String         @map("entity_type") // Target entity type
  entityId        String         @map("entity_id") // Target entity ID

  // Input and result
  input           Json           // Action input parameters
  result          Json?          // Action result (for undo)
  previousState   Json?          @map("previous_state") // State before action (for undo)

  // Status tracking
  status          AiActionStatus @default(PENDING)
  error           String?        // Error message if failed

  // Undo configuration
  undoWindowSeconds Int?         @map("undo_window_seconds") // 0 = non-undoable
  undoExpiresAt   DateTime?      @map("undo_expires_at")

  // Timestamps
  createdAt       DateTime       @default(now()) @map("created_at")
  executedAt      DateTime?      @map("executed_at")
  completedAt     DateTime?      @map("completed_at")
  undoneAt        DateTime?      @map("undone_at")
  undoneByUserId  String?        @map("undone_by_user_id")

  @@index([organizationId, entityType, entityId])
  @@index([organizationId, userId])
  @@index([conversationId])
  @@index([status, undoExpiresAt])
  @@map("ai_actions")
}
```

2. Run migration:
```bash
cd apps/backend && npx prisma migrate dev --name add_ai_action
```

3. Create `apps/backend/src/modules/ai/actions/action.types.ts`:
```typescript
import { z } from 'zod';

export enum ActionCategory {
  QUICK = 'quick',     // No preview needed, has undo (add note, change field)
  STANDARD = 'standard', // Preview recommended, has undo (change status, assign)
  CRITICAL = 'critical', // Preview required, limited undo (close, merge)
  EXTERNAL = 'external', // Preview required, no undo (send email, API call)
}

export interface ActionContext {
  organizationId: string;
  userId: string;
  userRole: string;
  permissions: string[];
  entityType: string;
  entityId: string;
  conversationId?: string;
}

export interface ActionPreview {
  description: string;
  changes: Array<{
    field: string;
    oldValue: unknown;
    newValue: unknown;
  }>;
  warnings?: string[];
  estimatedDuration?: string;
}

export interface ActionResult {
  success: boolean;
  message?: string;
  previousState?: Record<string, unknown>;
  newState?: Record<string, unknown>;
}

export interface ActionDefinition<TInput = unknown> {
  id: string;
  name: string;
  description: string;
  category: ActionCategory;
  entityTypes: string[];
  requiredPermissions: string[];
  undoWindowSeconds: number; // 0 = non-undoable
  inputSchema: z.ZodType<TInput>;

  // Validation
  canExecute?: (input: TInput, context: ActionContext) => Promise<{ allowed: boolean; reason?: string }>;

  // Preview generation (for standard and critical)
  generatePreview: (input: TInput, context: ActionContext) => Promise<ActionPreview>;

  // Execution
  execute: (input: TInput, context: ActionContext) => Promise<ActionResult>;

  // Undo (if undoWindowSeconds > 0)
  undo?: (actionId: string, previousState: Record<string, unknown>, context: ActionContext) => Promise<void>;
}

// Undo windows per CONTEXT.md
export const UNDO_WINDOWS = {
  QUICK: 30,      // 30 seconds for add note, update field
  STANDARD: 300,  // 5 minutes for change assignment, change status
  SIGNIFICANT: 1800, // 30 minutes for close case, close investigation
  EXTENDED: 86400,   // 24 hours for archive
  NONE: 0,        // Non-undoable for sent emails, external API calls
};
```
  </action>
  <verify>
Migration succeeds.
Types compile correctly.
  </verify>
  <done>
AiAction model and action types created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ActionCatalog and ActionExecutorService</name>
  <files>
    apps/backend/src/modules/ai/actions/action.catalog.ts
    apps/backend/src/modules/ai/actions/action-executor.service.ts
  </files>
  <action>
1. Create `apps/backend/src/modules/ai/actions/action.catalog.ts`:
```typescript
import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { ActionDefinition, ActionCategory, ActionContext } from './action.types';
import { addNoteAction } from './actions/add-note.action';
import { changeStatusAction } from './actions/change-status.action';

@Injectable()
export class ActionCatalog implements OnModuleInit {
  private readonly logger = new Logger(ActionCatalog.name);
  private readonly actions = new Map<string, ActionDefinition>();

  onModuleInit() {
    // Register built-in actions
    this.registerAction(addNoteAction);
    this.registerAction(changeStatusAction);

    this.logger.log(`Registered ${this.actions.size} actions`);
  }

  registerAction(action: ActionDefinition): void {
    if (this.actions.has(action.id)) {
      this.logger.warn(`Overwriting action: ${action.id}`);
    }
    this.actions.set(action.id, action);
    this.logger.debug(`Registered action: ${action.id}`);
  }

  getAction(id: string): ActionDefinition | undefined {
    return this.actions.get(id);
  }

  getAvailableActions(params: {
    entityType: string;
    userPermissions: string[];
    category?: ActionCategory;
  }): ActionDefinition[] {
    return Array.from(this.actions.values()).filter(action => {
      // Check entity type
      if (!action.entityTypes.includes(params.entityType)) {
        return false;
      }

      // Check category filter
      if (params.category && action.category !== params.category) {
        return false;
      }

      // Check permissions
      return action.requiredPermissions.every(p => params.userPermissions.includes(p));
    });
  }

  listActions(): string[] {
    return Array.from(this.actions.keys());
  }

  requiresPreview(actionId: string): boolean {
    const action = this.actions.get(actionId);
    if (!action) return true;
    return action.category === ActionCategory.STANDARD ||
           action.category === ActionCategory.CRITICAL ||
           action.category === ActionCategory.EXTERNAL;
  }
}
```

2. Create `apps/backend/src/modules/ai/actions/action-executor.service.ts`:
```typescript
import { Injectable, Logger, NotFoundException, ForbiddenException } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { PrismaService } from '../../prisma/prisma.service';
import { ActionCatalog } from './action.catalog';
import { ActionContext, ActionPreview, ActionResult, ActionCategory } from './action.types';
import { Prisma } from '@prisma/client';

export interface ExecutionResult {
  success: boolean;
  actionId: string;
  result?: ActionResult;
  error?: string;
  undoAvailable: boolean;
  undoExpiresAt?: Date;
}

@Injectable()
export class ActionExecutorService {
  private readonly logger = new Logger(ActionExecutorService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly actionCatalog: ActionCatalog,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  /**
   * Preview an action before execution.
   */
  async preview(
    actionId: string,
    input: unknown,
    context: ActionContext,
  ): Promise<ActionPreview> {
    const action = this.actionCatalog.getAction(actionId);
    if (!action) {
      throw new NotFoundException(`Action not found: ${actionId}`);
    }

    // Validate permissions
    this.validatePermissions(action.requiredPermissions, context.permissions);

    // Check entity type
    if (!action.entityTypes.includes(context.entityType)) {
      throw new ForbiddenException(`Action ${actionId} not available for ${context.entityType}`);
    }

    // Validate input
    const validatedInput = action.inputSchema.parse(input);

    // Check canExecute if defined
    if (action.canExecute) {
      const canExecuteResult = await action.canExecute(validatedInput, context);
      if (!canExecuteResult.allowed) {
        throw new ForbiddenException(canExecuteResult.reason || 'Action not allowed');
      }
    }

    // Generate preview
    return action.generatePreview(validatedInput, context);
  }

  /**
   * Execute an action.
   */
  async execute(
    actionId: string,
    input: unknown,
    context: ActionContext,
    skipPreview = false,
  ): Promise<ExecutionResult> {
    const action = this.actionCatalog.getAction(actionId);
    if (!action) {
      throw new NotFoundException(`Action not found: ${actionId}`);
    }

    // Validate permissions
    this.validatePermissions(action.requiredPermissions, context.permissions);

    // Check entity type
    if (!action.entityTypes.includes(context.entityType)) {
      throw new ForbiddenException(`Action ${actionId} not available for ${context.entityType}`);
    }

    // Validate input
    const validatedInput = action.inputSchema.parse(input);

    // Check if preview is required
    if (!skipPreview && this.actionCatalog.requiresPreview(actionId)) {
      // For standard+ actions, preview should be done first
      // This is just a safety check
      this.logger.debug(`Action ${actionId} normally requires preview`);
    }

    // Create action record
    const aiAction = await this.prisma.aiAction.create({
      data: {
        organizationId: context.organizationId,
        userId: context.userId,
        conversationId: context.conversationId,
        actionType: actionId,
        entityType: context.entityType,
        entityId: context.entityId,
        input: validatedInput as Prisma.JsonObject,
        status: 'EXECUTING',
        undoWindowSeconds: action.undoWindowSeconds,
        undoExpiresAt: action.undoWindowSeconds > 0
          ? new Date(Date.now() + action.undoWindowSeconds * 1000)
          : null,
        executedAt: new Date(),
      },
    });

    try {
      // Execute the action
      const result = await action.execute(validatedInput, context);

      if (result.success) {
        // Update action record with result
        await this.prisma.aiAction.update({
          where: { id: aiAction.id },
          data: {
            status: 'COMPLETED',
            result: result as Prisma.JsonObject,
            previousState: result.previousState as Prisma.JsonObject | undefined,
            completedAt: new Date(),
          },
        });

        // Emit event for activity feed
        this.eventEmitter.emit('ai.action.completed', {
          actionId: aiAction.id,
          organizationId: context.organizationId,
          userId: context.userId,
          entityType: context.entityType,
          entityId: context.entityId,
          actionType: actionId,
        });

        return {
          success: true,
          actionId: aiAction.id,
          result,
          undoAvailable: action.undoWindowSeconds > 0,
          undoExpiresAt: aiAction.undoExpiresAt || undefined,
        };
      } else {
        await this.prisma.aiAction.update({
          where: { id: aiAction.id },
          data: {
            status: 'FAILED',
            error: result.message || 'Action failed',
          },
        });

        return {
          success: false,
          actionId: aiAction.id,
          error: result.message || 'Action failed',
          undoAvailable: false,
        };
      }
    } catch (error) {
      await this.prisma.aiAction.update({
        where: { id: aiAction.id },
        data: {
          status: 'FAILED',
          error: error.message,
        },
      });

      this.logger.error(`Action ${actionId} failed:`, error);

      return {
        success: false,
        actionId: aiAction.id,
        error: error.message,
        undoAvailable: false,
      };
    }
  }

  /**
   * Undo a previously executed action.
   */
  async undo(actionId: string, context: ActionContext): Promise<void> {
    const aiAction = await this.prisma.aiAction.findFirst({
      where: {
        id: actionId,
        organizationId: context.organizationId,
        status: 'COMPLETED',
      },
    });

    if (!aiAction) {
      throw new NotFoundException('Action not found or not completed');
    }

    // Check undo window
    if (!aiAction.undoExpiresAt || aiAction.undoExpiresAt < new Date()) {
      throw new ForbiddenException('Undo window has expired');
    }

    const action = this.actionCatalog.getAction(aiAction.actionType);
    if (!action || !action.undo) {
      throw new ForbiddenException('Action is not undoable');
    }

    // Execute undo
    await action.undo(
      actionId,
      aiAction.previousState as Record<string, unknown> || {},
      context,
    );

    // Update action record
    await this.prisma.aiAction.update({
      where: { id: actionId },
      data: {
        status: 'UNDONE',
        undoneAt: new Date(),
        undoneByUserId: context.userId,
      },
    });

    // Emit event
    this.eventEmitter.emit('ai.action.undone', {
      actionId,
      organizationId: context.organizationId,
      userId: context.userId,
      entityType: aiAction.entityType,
      entityId: aiAction.entityId,
      actionType: aiAction.actionType,
    });
  }

  /**
   * Get action history for an entity.
   */
  async getActionHistory(params: {
    organizationId: string;
    entityType?: string;
    entityId?: string;
    limit?: number;
  }): Promise<Array<{
    id: string;
    actionType: string;
    status: string;
    createdAt: Date;
    undoAvailable: boolean;
  }>> {
    const actions = await this.prisma.aiAction.findMany({
      where: {
        organizationId: params.organizationId,
        ...(params.entityType && { entityType: params.entityType }),
        ...(params.entityId && { entityId: params.entityId }),
      },
      orderBy: { createdAt: 'desc' },
      take: params.limit || 50,
    });

    return actions.map(a => ({
      id: a.id,
      actionType: a.actionType,
      status: a.status,
      createdAt: a.createdAt,
      undoAvailable: a.status === 'COMPLETED' &&
        a.undoExpiresAt !== null &&
        a.undoExpiresAt > new Date(),
    }));
  }

  private validatePermissions(required: string[], userPermissions: string[]): void {
    const missing = required.filter(p => !userPermissions.includes(p));
    if (missing.length > 0) {
      throw new ForbiddenException(`Missing permissions: ${missing.join(', ')}`);
    }
  }
}
```
  </action>
  <verify>
Files created.
Service compiles without errors.
  </verify>
  <done>
ActionCatalog and ActionExecutorService created with preview and undo support.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create initial actions and wire up module</name>
  <files>
    apps/backend/src/modules/ai/actions/actions/add-note.action.ts
    apps/backend/src/modules/ai/actions/actions/change-status.action.ts
    apps/backend/src/modules/ai/actions/index.ts
    apps/backend/src/modules/ai/ai.module.ts
  </files>
  <action>
1. Create `apps/backend/src/modules/ai/actions/actions/add-note.action.ts`:
```typescript
import { z } from 'zod';
import { ActionDefinition, ActionCategory, ActionContext, UNDO_WINDOWS } from '../action.types';
import { PrismaService } from '../../../prisma/prisma.service';

export const addNoteInputSchema = z.object({
  content: z.string().min(1).max(50000),
  noteType: z.enum(['general', 'interview', 'observation', 'analysis']).optional().default('general'),
});

export type AddNoteInput = z.infer<typeof addNoteInputSchema>;

// Note: This needs PrismaService injected - in production, use a factory pattern
// For now, we define the action structure
export const addNoteAction: ActionDefinition<AddNoteInput> = {
  id: 'add-note',
  name: 'Add Note',
  description: 'Add a note to the current entity (case or investigation)',
  category: ActionCategory.QUICK,
  entityTypes: ['case', 'investigation'],
  requiredPermissions: ['notes:create'],
  undoWindowSeconds: UNDO_WINDOWS.QUICK,
  inputSchema: addNoteInputSchema,

  async generatePreview(input: AddNoteInput, context: ActionContext) {
    return {
      description: `Add a ${input.noteType} note to ${context.entityType} ${context.entityId}`,
      changes: [
        {
          field: 'notes',
          oldValue: null,
          newValue: input.content.slice(0, 100) + (input.content.length > 100 ? '...' : ''),
        },
      ],
    };
  },

  async execute(input: AddNoteInput, context: ActionContext) {
    // Note: In production, inject PrismaService via factory
    // This is a simplified version for the action structure
    return {
      success: true,
      message: `Note added to ${context.entityType}`,
      previousState: { noteId: null },
      newState: { noteContent: input.content },
    };
  },

  async undo(actionId: string, previousState: Record<string, unknown>, context: ActionContext) {
    // Delete the note using the stored noteId from previousState
    // In production: await prisma.note.delete({ where: { id: previousState.noteId } })
  },
};
```

2. Create `apps/backend/src/modules/ai/actions/actions/change-status.action.ts`:
```typescript
import { z } from 'zod';
import { ActionDefinition, ActionCategory, ActionContext, UNDO_WINDOWS } from '../action.types';

export const changeStatusInputSchema = z.object({
  newStatus: z.string(),
  reason: z.string().optional(),
});

export type ChangeStatusInput = z.infer<typeof changeStatusInputSchema>;

export const changeStatusAction: ActionDefinition<ChangeStatusInput> = {
  id: 'change-status',
  name: 'Change Status',
  description: 'Change the status of a case or investigation',
  category: ActionCategory.STANDARD,
  entityTypes: ['case', 'investigation'],
  requiredPermissions: ['cases:update:status', 'investigations:update:status'],
  undoWindowSeconds: UNDO_WINDOWS.STANDARD,
  inputSchema: changeStatusInputSchema,

  async canExecute(input: ChangeStatusInput, context: ActionContext) {
    // Validate status transition is allowed
    const validTransitions: Record<string, string[]> = {
      'NEW': ['OPEN', 'CLOSED'],
      'OPEN': ['CLOSED'],
      'CLOSED': ['OPEN'],
    };

    // In production, fetch current status and validate
    return { allowed: true };
  },

  async generatePreview(input: ChangeStatusInput, context: ActionContext) {
    // In production, fetch current status
    const currentStatus = 'OPEN'; // Placeholder

    return {
      description: `Change ${context.entityType} status from ${currentStatus} to ${input.newStatus}`,
      changes: [
        {
          field: 'status',
          oldValue: currentStatus,
          newValue: input.newStatus,
        },
      ],
      warnings: input.newStatus === 'CLOSED'
        ? ['Closing will send notifications to assigned users']
        : undefined,
    };
  },

  async execute(input: ChangeStatusInput, context: ActionContext) {
    // In production, update via Prisma
    const previousStatus = 'OPEN'; // Would be fetched first

    return {
      success: true,
      message: `Status changed to ${input.newStatus}`,
      previousState: { status: previousStatus },
      newState: { status: input.newStatus },
    };
  },

  async undo(actionId: string, previousState: Record<string, unknown>, context: ActionContext) {
    // Restore previous status
    // await prisma[context.entityType].update({ where: { id: context.entityId }, data: { status: previousState.status } })
  },
};
```

3. Create `apps/backend/src/modules/ai/actions/index.ts`:
```typescript
export * from './action.types';
export * from './action.catalog';
export * from './action-executor.service';
export * from './actions/add-note.action';
export * from './actions/change-status.action';
```

4. Update `apps/backend/src/modules/ai/ai.module.ts`:
```typescript
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { CacheModule } from '@nestjs/cache-manager';
import { PrismaModule } from '../prisma/prisma.module';
import { EventsModule } from '../events/events.module';
import { AiClientService } from './services/ai-client.service';
import { ProviderRegistryService } from './services/provider-registry.service';
import { AiRateLimiterService } from './services/rate-limiter.service';
import { PromptService } from './services/prompt.service';
import { ConversationService } from './services/conversation.service';
import { ContextLoaderService } from './services/context-loader.service';
import { SkillRegistry } from './skills/skill.registry';
import { AgentRegistry } from './agents/agent.registry';
import { ActionCatalog } from './actions/action.catalog';
import { ActionExecutorService } from './actions/action-executor.service';
import { ClaudeProvider } from './providers/claude.provider';

@Module({
  imports: [
    ConfigModule,
    PrismaModule,
    EventsModule,
    CacheModule.register({
      ttl: 300000,
    }),
  ],
  providers: [
    ClaudeProvider,
    ProviderRegistryService,
    AiClientService,
    AiRateLimiterService,
    PromptService,
    ConversationService,
    ContextLoaderService,
    SkillRegistry,
    AgentRegistry,
    ActionCatalog,
    ActionExecutorService,
  ],
  exports: [
    AiClientService,
    ProviderRegistryService,
    AiRateLimiterService,
    PromptService,
    ConversationService,
    ContextLoaderService,
    SkillRegistry,
    AgentRegistry,
    ActionCatalog,
    ActionExecutorService,
    ClaudeProvider,
  ],
})
export class AiModule {}
```

5. Update `apps/backend/src/modules/ai/index.ts` to include actions exports.
  </action>
  <verify>
`npm run build` succeeds.
ActionCatalog has 2 actions registered.
ActionExecutorService has preview, execute, undo methods.
  </verify>
  <done>
Action system created with add-note and change-status actions.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `npm run build` passes
2. `npx prisma migrate status` shows all migrations applied
3. AiAction model exists
4. ActionCatalog has add-note and change-status registered
5. ActionExecutorService supports preview, execute, undo
6. Actions emit events for activity feed
</verification>

<success_criteria>
- Actions are mutations with permission validation
- Quick actions have short undo windows (30s)
- Standard actions have longer undo windows (5min)
- Action history tracked in database
- Events emitted for audit and activity feed
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-infrastructure/05-10-SUMMARY.md`
</output>
