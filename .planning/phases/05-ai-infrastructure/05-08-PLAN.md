---
phase: 05-ai-infrastructure
plan: 08
type: execute
wave: 3
depends_on: ["05-07"]
files_modified:
  - apps/backend/src/modules/ai/skills/platform/category-suggest.skill.ts
  - apps/backend/src/modules/ai/skills/platform/risk-score.skill.ts
  - apps/backend/src/modules/ai/skills/platform/translate.skill.ts
  - apps/backend/src/modules/ai/skills/skill.registry.ts
  - apps/backend/src/modules/ai/skills/index.ts
  - apps/backend/src/modules/ai/prompts/templates/skills/category-suggest.hbs
  - apps/backend/src/modules/ai/prompts/templates/skills/risk-score.hbs
  - apps/backend/src/modules/ai/prompts/templates/skills/translate.hbs
autonomous: true

must_haves:
  truths:
    - "Category suggestion returns ranked categories with confidence scores"
    - "Risk score includes breakdown of contributing factors"
    - "Translation preserves original content alongside translation"
    - "All skills integrate with rate limiting and usage tracking"
  artifacts:
    - path: "apps/backend/src/modules/ai/skills/platform/category-suggest.skill.ts"
      provides: "Real-time category suggestion"
      exports: ["categorySuggestSkill"]
    - path: "apps/backend/src/modules/ai/skills/platform/risk-score.skill.ts"
      provides: "Risk scoring with factor breakdown"
      exports: ["riskScoreSkill"]
    - path: "apps/backend/src/modules/ai/skills/platform/translate.skill.ts"
      provides: "Translation with original preserved"
      exports: ["translateSkill"]
  key_links:
    - from: "apps/backend/src/modules/ai/skills/skill.registry.ts"
      to: "apps/backend/src/modules/ai/skills/platform/*.skill.ts"
      via: "skill registration"
      pattern: "registerSkill"
---

<objective>
Create three additional platform skills: category suggestion (AI-09), risk scoring (AI-10), and translation (AI-11). These complete the core AI feature set.

Purpose: Category suggestion enables real-time categorization during intake. Risk scoring provides quantified risk assessment. Translation supports multi-language compliance operations.

Output: Three additional skills registered in SkillRegistry.
</objective>

<execution_context>
@C:\Users\cu0718\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\cu0718\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-ai-infrastructure/05-RESEARCH.md
@.planning/phases/05-ai-infrastructure/05-CONTEXT.md (categorization, risk scoring decisions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create category suggestion skill</name>
  <files>
    apps/backend/src/modules/ai/skills/platform/category-suggest.skill.ts
    apps/backend/src/modules/ai/prompts/templates/skills/category-suggest.hbs
  </files>
  <action>
1. Create `apps/backend/src/modules/ai/prompts/templates/skills/category-suggest.hbs`:
```handlebars
Analyze the following content and suggest the most appropriate compliance category.

{{#if categories}}
## Available Categories
{{#each categories}}
- {{this.name}}{{#if this.description}}: {{this.description}}{{/if}}
{{/each}}
{{/if}}

## Content to Categorize
{{{content}}}

## Instructions
1. Analyze the content for key indicators of compliance issues
2. Match to the most appropriate category from the available list
3. Provide a confidence score (0.0 to 1.0)
4. Explain your reasoning briefly

Respond in the following JSON format:
{
  "suggestions": [
    {
      "categoryId": "category-id",
      "categoryName": "Category Name",
      "confidence": 0.85,
      "reasoning": "Brief explanation of why this category fits"
    }
  ],
  "indicators": ["key", "indicator", "phrases", "found"]
}

Return up to 3 suggestions, ranked by confidence.
```

2. Create `apps/backend/src/modules/ai/skills/platform/category-suggest.skill.ts`:
```typescript
import { z } from 'zod';
import { SkillDefinition, SkillScope, SkillContext, SkillResult } from '../skill.types';
import { ProviderRegistryService } from '../../services/provider-registry.service';
import { AiRateLimiterService } from '../../services/rate-limiter.service';
import { PromptService } from '../../services/prompt.service';

export const categorySuggestInputSchema = z.object({
  content: z.string().min(10).max(50000).describe('Content to categorize (report text, intake notes, etc.)'),
  categories: z.array(z.object({
    id: z.string(),
    name: z.string(),
    description: z.string().optional(),
  })).optional().describe('Available categories. If not provided, uses organization defaults.'),
});

export type CategorySuggestInput = z.infer<typeof categorySuggestInputSchema>;

export interface CategorySuggestion {
  categoryId: string;
  categoryName: string;
  confidence: number;
  reasoning: string;
}

export interface CategorySuggestOutput {
  suggestions: CategorySuggestion[];
  indicators: string[];
  topSuggestion?: CategorySuggestion;
}

export function categorySuggestSkill(
  providerRegistry: ProviderRegistryService,
  rateLimiter: AiRateLimiterService,
  promptService: PromptService,
): SkillDefinition<CategorySuggestInput, CategorySuggestOutput> {
  return {
    id: 'category-suggest',
    name: 'Suggest Category',
    description: 'Analyze content and suggest appropriate compliance categories with confidence scores and reasoning.',
    scope: SkillScope.PLATFORM,
    requiredPermissions: ['ai:skills:category-suggest'],

    inputSchema: categorySuggestInputSchema,

    async execute(input: CategorySuggestInput, context: SkillContext): Promise<SkillResult<CategorySuggestOutput>> {
      const startTime = Date.now();
      const estimatedTokens = Math.ceil(input.content.length / 4) + 500;

      const rateLimitResult = await rateLimiter.checkAndConsume({
        organizationId: context.organizationId,
        estimatedTokens,
      });

      if (!rateLimitResult.allowed) {
        return {
          success: false,
          error: `Rate limit exceeded. Retry after ${Math.ceil((rateLimitResult.retryAfterMs || 0) / 1000)} seconds.`,
        };
      }

      try {
        const provider = providerRegistry.getDefaultProvider();

        const prompt = await promptService.render(
          'skills/category-suggest',
          { content: input.content, categories: input.categories },
          context.organizationId,
        );

        const response = await provider.createMessage({
          maxTokens: 1024,
          messages: [{ role: 'user', content: prompt }],
        });

        // Parse JSON response
        const jsonMatch = response.content.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          throw new Error('Invalid response format from AI');
        }

        const parsed = JSON.parse(jsonMatch[0]);

        await rateLimiter.recordUsage({
          organizationId: context.organizationId,
          userId: context.userId,
          inputTokens: response.usage.inputTokens,
          outputTokens: response.usage.outputTokens,
          model: provider.defaultModel,
          featureType: 'category-suggest',
          entityType: context.entityType,
          entityId: context.entityId,
          durationMs: Date.now() - startTime,
        });

        const suggestions = parsed.suggestions || [];
        const topSuggestion = suggestions.length > 0 ? suggestions[0] : undefined;

        return {
          success: true,
          data: {
            suggestions,
            indicators: parsed.indicators || [],
            topSuggestion,
          },
          metadata: {
            inputTokens: response.usage.inputTokens,
            outputTokens: response.usage.outputTokens,
            durationMs: Date.now() - startTime,
            model: provider.defaultModel,
          },
        };
      } catch (error) {
        return {
          success: false,
          error: error.message || 'Category suggestion failed',
        };
      }
    },
  };
}
```
  </action>
  <verify>
Files created.
Skill returns ranked suggestions with confidence.
  </verify>
  <done>
Category suggestion skill created with JSON response parsing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create risk scoring skill</name>
  <files>
    apps/backend/src/modules/ai/skills/platform/risk-score.skill.ts
    apps/backend/src/modules/ai/prompts/templates/skills/risk-score.hbs
  </files>
  <action>
1. Create `apps/backend/src/modules/ai/prompts/templates/skills/risk-score.hbs`:
```handlebars
Assess the risk level of the following compliance matter.

## Content
{{{content}}}

{{#if entity}}
## Entity Context
Type: {{entity.type}}
{{#if entity.category}}Category: {{entity.category}}{{/if}}
{{#if entity.status}}Status: {{entity.status}}{{/if}}
{{/if}}

## Risk Assessment Framework
Consider these factors:
1. **Severity**: How serious is the alleged behavior?
2. **Scope**: How many people/departments are affected?
3. **Legal Exposure**: Potential regulatory or legal consequences
4. **Reputation Risk**: Impact on organization's reputation
5. **Recurrence**: Is this a pattern or isolated incident?
6. **Evidence**: Quality and clarity of evidence
7. **Urgency**: Time sensitivity of response needed

## Instructions
Analyze the content against each factor and provide:
1. An overall risk score (1-10, where 10 is highest risk)
2. Breakdown scores for each factor
3. Key concerns driving the risk assessment
4. Recommended priority level

Respond in JSON format:
{
  "overallScore": 7,
  "factors": {
    "severity": { "score": 8, "notes": "explanation" },
    "scope": { "score": 5, "notes": "explanation" },
    "legalExposure": { "score": 7, "notes": "explanation" },
    "reputationRisk": { "score": 6, "notes": "explanation" },
    "recurrence": { "score": 4, "notes": "explanation" },
    "evidence": { "score": 7, "notes": "explanation" },
    "urgency": { "score": 8, "notes": "explanation" }
  },
  "keyConcerns": ["concern 1", "concern 2"],
  "priority": "HIGH",
  "summary": "Brief risk assessment summary"
}
```

2. Create `apps/backend/src/modules/ai/skills/platform/risk-score.skill.ts`:
```typescript
import { z } from 'zod';
import { SkillDefinition, SkillScope, SkillContext, SkillResult } from '../skill.types';
import { ProviderRegistryService } from '../../services/provider-registry.service';
import { AiRateLimiterService } from '../../services/rate-limiter.service';
import { PromptService } from '../../services/prompt.service';

export const riskScoreInputSchema = z.object({
  content: z.string().min(10).max(100000).describe('Content to assess for risk'),
  entityType: z.string().optional().describe('Type of entity (case, investigation)'),
  category: z.string().optional().describe('Category of the matter'),
  additionalContext: z.string().optional().describe('Additional context for assessment'),
});

export type RiskScoreInput = z.infer<typeof riskScoreInputSchema>;

export interface RiskFactor {
  score: number;
  notes: string;
}

export interface RiskScoreOutput {
  overallScore: number;
  factors: {
    severity: RiskFactor;
    scope: RiskFactor;
    legalExposure: RiskFactor;
    reputationRisk: RiskFactor;
    recurrence: RiskFactor;
    evidence: RiskFactor;
    urgency: RiskFactor;
  };
  keyConcerns: string[];
  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  summary: string;
  confidence?: number;
}

export function riskScoreSkill(
  providerRegistry: ProviderRegistryService,
  rateLimiter: AiRateLimiterService,
  promptService: PromptService,
): SkillDefinition<RiskScoreInput, RiskScoreOutput> {
  return {
    id: 'risk-score',
    name: 'Assess Risk',
    description: 'Generate a comprehensive risk assessment with factor breakdown and priority recommendation.',
    scope: SkillScope.PLATFORM,
    requiredPermissions: ['ai:skills:risk-score'],
    entityTypes: ['case', 'investigation', 'riu'],

    inputSchema: riskScoreInputSchema,

    async execute(input: RiskScoreInput, context: SkillContext): Promise<SkillResult<RiskScoreOutput>> {
      const startTime = Date.now();
      const estimatedTokens = Math.ceil(input.content.length / 4) + 800;

      const rateLimitResult = await rateLimiter.checkAndConsume({
        organizationId: context.organizationId,
        estimatedTokens,
      });

      if (!rateLimitResult.allowed) {
        return {
          success: false,
          error: `Rate limit exceeded. Retry after ${Math.ceil((rateLimitResult.retryAfterMs || 0) / 1000)} seconds.`,
        };
      }

      try {
        const provider = providerRegistry.getDefaultProvider();

        const prompt = await promptService.render(
          'skills/risk-score',
          {
            content: input.content,
            entity: {
              type: input.entityType,
              category: input.category,
            },
          },
          context.organizationId,
        );

        const response = await provider.createMessage({
          maxTokens: 1500,
          messages: [{ role: 'user', content: prompt }],
        });

        // Parse JSON response
        const jsonMatch = response.content.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          throw new Error('Invalid response format from AI');
        }

        const parsed = JSON.parse(jsonMatch[0]);

        await rateLimiter.recordUsage({
          organizationId: context.organizationId,
          userId: context.userId,
          inputTokens: response.usage.inputTokens,
          outputTokens: response.usage.outputTokens,
          model: provider.defaultModel,
          featureType: 'risk-score',
          entityType: context.entityType,
          entityId: context.entityId,
          durationMs: Date.now() - startTime,
        });

        // Calculate confidence based on evidence score
        const evidenceScore = parsed.factors?.evidence?.score || 5;
        const confidence = evidenceScore >= 7 ? undefined : evidenceScore / 10;

        return {
          success: true,
          data: {
            overallScore: parsed.overallScore,
            factors: parsed.factors,
            keyConcerns: parsed.keyConcerns || [],
            priority: parsed.priority,
            summary: parsed.summary,
            confidence,
          },
          metadata: {
            inputTokens: response.usage.inputTokens,
            outputTokens: response.usage.outputTokens,
            durationMs: Date.now() - startTime,
            model: provider.defaultModel,
          },
        };
      } catch (error) {
        return {
          success: false,
          error: error.message || 'Risk assessment failed',
        };
      }
    },
  };
}
```
  </action>
  <verify>
Files created.
Risk score returns factor breakdown.
  </verify>
  <done>
Risk scoring skill created with comprehensive factor analysis.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create translation skill and update registry</name>
  <files>
    apps/backend/src/modules/ai/skills/platform/translate.skill.ts
    apps/backend/src/modules/ai/prompts/templates/skills/translate.hbs
    apps/backend/src/modules/ai/skills/skill.registry.ts
    apps/backend/src/modules/ai/skills/index.ts
  </files>
  <action>
1. Create `apps/backend/src/modules/ai/prompts/templates/skills/translate.hbs`:
```handlebars
Translate the following content from {{sourceLanguage}} to {{targetLanguage}}.

## Original Content ({{sourceLanguage}})
{{{content}}}

## Translation Guidelines
1. Preserve the meaning and tone of the original
2. Maintain any technical or legal terminology appropriately
3. Keep proper nouns unchanged
4. Preserve formatting (paragraphs, bullet points)
5. Flag any culturally-specific references that may need adaptation

Provide the translation ONLY, without explanations or meta-commentary.
{{#if preserveFormatting}}
Preserve all original formatting including headers, lists, and paragraph breaks.
{{/if}}
```

2. Create `apps/backend/src/modules/ai/skills/platform/translate.skill.ts`:
```typescript
import { z } from 'zod';
import { SkillDefinition, SkillScope, SkillContext, SkillResult } from '../skill.types';
import { ProviderRegistryService } from '../../services/provider-registry.service';
import { AiRateLimiterService } from '../../services/rate-limiter.service';
import { PromptService } from '../../services/prompt.service';

export const translateInputSchema = z.object({
  content: z.string().min(1).max(50000).describe('Content to translate'),
  sourceLanguage: z.string().default('auto').describe('Source language (or "auto" to detect)'),
  targetLanguage: z.string().describe('Target language for translation'),
  preserveFormatting: z.boolean().optional().default(true).describe('Preserve original formatting'),
});

export type TranslateInput = z.infer<typeof translateInputSchema>;

export interface TranslateOutput {
  original: string;
  translated: string;
  sourceLanguage: string;
  targetLanguage: string;
  detectedLanguage?: string;
  confidence?: number;
}

export function translateSkill(
  providerRegistry: ProviderRegistryService,
  rateLimiter: AiRateLimiterService,
  promptService: PromptService,
): SkillDefinition<TranslateInput, TranslateOutput> {
  return {
    id: 'translate',
    name: 'Translate Content',
    description: 'Translate content between languages while preserving the original. Supports auto-detection of source language.',
    scope: SkillScope.PLATFORM,
    requiredPermissions: ['ai:skills:translate'],

    inputSchema: translateInputSchema,

    async execute(input: TranslateInput, context: SkillContext): Promise<SkillResult<TranslateOutput>> {
      const startTime = Date.now();
      // Translation typically outputs similar length
      const estimatedTokens = Math.ceil(input.content.length / 4) * 2;

      const rateLimitResult = await rateLimiter.checkAndConsume({
        organizationId: context.organizationId,
        estimatedTokens,
      });

      if (!rateLimitResult.allowed) {
        return {
          success: false,
          error: `Rate limit exceeded. Retry after ${Math.ceil((rateLimitResult.retryAfterMs || 0) / 1000)} seconds.`,
        };
      }

      try {
        const provider = providerRegistry.getDefaultProvider();

        // Detect language if set to auto
        let sourceLanguage = input.sourceLanguage;
        let detectedLanguage: string | undefined;

        if (sourceLanguage === 'auto') {
          const detectionResult = await detectLanguage(provider, input.content);
          sourceLanguage = detectionResult.language;
          detectedLanguage = detectionResult.language;
        }

        const prompt = await promptService.render(
          'skills/translate',
          {
            content: input.content,
            sourceLanguage,
            targetLanguage: input.targetLanguage,
            preserveFormatting: input.preserveFormatting,
          },
          context.organizationId,
        );

        const response = await provider.createMessage({
          maxTokens: 4096,
          messages: [{ role: 'user', content: prompt }],
        });

        const translated = response.content.trim();

        await rateLimiter.recordUsage({
          organizationId: context.organizationId,
          userId: context.userId,
          inputTokens: response.usage.inputTokens,
          outputTokens: response.usage.outputTokens,
          model: provider.defaultModel,
          featureType: 'translate',
          entityType: context.entityType,
          entityId: context.entityId,
          durationMs: Date.now() - startTime,
        });

        return {
          success: true,
          data: {
            original: input.content,
            translated,
            sourceLanguage,
            targetLanguage: input.targetLanguage,
            detectedLanguage,
          },
          metadata: {
            inputTokens: response.usage.inputTokens,
            outputTokens: response.usage.outputTokens,
            durationMs: Date.now() - startTime,
            model: provider.defaultModel,
          },
        };
      } catch (error) {
        return {
          success: false,
          error: error.message || 'Translation failed',
        };
      }
    },
  };
}

async function detectLanguage(
  provider: ReturnType<ProviderRegistryService['getDefaultProvider']>,
  text: string,
): Promise<{ language: string; confidence: number }> {
  const sample = text.slice(0, 500); // Use first 500 chars for detection

  const response = await provider.createMessage({
    maxTokens: 50,
    messages: [{
      role: 'user',
      content: `What language is the following text? Reply with just the language name in English (e.g., "English", "Spanish", "German").\n\nText: ${sample}`,
    }],
  });

  const language = response.content.trim().replace(/[."']/g, '');

  return {
    language: language || 'English',
    confidence: 0.9,
  };
}
```

3. Update `apps/backend/src/modules/ai/skills/skill.registry.ts` to register the new skills:
```typescript
// Add imports at top
import { categorySuggestSkill } from './platform/category-suggest.skill';
import { riskScoreSkill } from './platform/risk-score.skill';
import { translateSkill } from './platform/translate.skill';

// In onModuleInit, add:
this.registerSkill(categorySuggestSkill(this.providerRegistry, this.rateLimiter, this.promptService));
this.registerSkill(riskScoreSkill(this.providerRegistry, this.rateLimiter, this.promptService));
this.registerSkill(translateSkill(this.providerRegistry, this.rateLimiter, this.promptService));
```

4. Update `apps/backend/src/modules/ai/skills/index.ts`:
```typescript
export * from './skill.types';
export * from './skill.registry';
export * from './platform/note-cleanup.skill';
export * from './platform/summarize.skill';
export * from './platform/category-suggest.skill';
export * from './platform/risk-score.skill';
export * from './platform/translate.skill';
```
  </action>
  <verify>
`npm run build` succeeds.
All 5 skills are registered in SkillRegistry.
  </verify>
  <done>
Translation skill created and all skills registered in registry.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `npm run build` passes
2. SkillRegistry has 5 skills: note-cleanup, summarize, category-suggest, risk-score, translate
3. All skills validate input with Zod
4. All skills respect rate limits
5. Prompt templates exist for all skills
</verification>

<success_criteria>
- Category suggestion returns ranked suggestions with reasoning
- Risk scoring provides factor breakdown and priority
- Translation preserves original alongside translation
- All skills integrate with rate limiting
- All skills track usage for analytics
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-infrastructure/05-08-SUMMARY.md`
</output>
