---
phase: 05-ai-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/backend/src/modules/ai/interfaces/ai-provider.interface.ts
  - apps/backend/src/modules/ai/providers/claude.provider.ts
  - apps/backend/src/modules/ai/providers/index.ts
  - apps/backend/src/modules/ai/services/provider-registry.service.ts
  - apps/backend/src/modules/ai/ai.module.ts
autonomous: true

must_haves:
  truths:
    - "AI calls go through provider abstraction, not directly to SDK"
    - "Claude provider implements AIProvider interface"
    - "Provider registry resolves correct provider by name"
    - "System can switch providers without changing calling code"
  artifacts:
    - path: "apps/backend/src/modules/ai/interfaces/ai-provider.interface.ts"
      provides: "AIProvider interface definition"
      exports: ["AIProvider", "AIMessage", "AITool"]
    - path: "apps/backend/src/modules/ai/providers/claude.provider.ts"
      provides: "Claude implementation of AIProvider"
      exports: ["ClaudeProvider"]
    - path: "apps/backend/src/modules/ai/services/provider-registry.service.ts"
      provides: "Registry for managing AI providers"
      exports: ["ProviderRegistryService"]
  key_links:
    - from: "apps/backend/src/modules/ai/providers/claude.provider.ts"
      to: "apps/backend/src/modules/ai/interfaces/ai-provider.interface.ts"
      via: "implements AIProvider"
      pattern: "implements AIProvider"
    - from: "apps/backend/src/modules/ai/services/provider-registry.service.ts"
      to: "apps/backend/src/modules/ai/providers/claude.provider.ts"
      via: "registers provider"
      pattern: "registerProvider|ClaudeProvider"
---

<objective>
Create the AIProvider abstraction layer that allows swapping LLM providers while maintaining a consistent API. This supports future multi-LLM scenarios (self-hosted models, other providers) without changing calling code.

Purpose: Decouple AI features from Claude-specific implementation so the platform can support self-hosted LLMs for customers who can't use cloud AI.

Output: AIProvider interface, ClaudeProvider implementation, and ProviderRegistryService.
</objective>

<execution_context>
@C:\Users\cu0718\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\cu0718\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-ai-infrastructure/05-RESEARCH.md

# Prior plan context
@.planning/phases/05-ai-infrastructure/05-01-PLAN.md (AI client service)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define AIProvider interface and types</name>
  <files>
    apps/backend/src/modules/ai/interfaces/ai-provider.interface.ts
    apps/backend/src/modules/ai/interfaces/index.ts
  </files>
  <action>
Create the provider abstraction interfaces:

1. Create `apps/backend/src/modules/ai/interfaces/ai-provider.interface.ts`:
```typescript
/**
 * Standard message format for AI provider communication.
 * Matches Anthropic's format but is provider-agnostic.
 */
export interface AIMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

/**
 * Tool definition for AI function calling.
 */
export interface AITool {
  name: string;
  description: string;
  inputSchema: Record<string, unknown>;
}

/**
 * Tool call made by the AI.
 */
export interface AIToolCall {
  id: string;
  name: string;
  input: Record<string, unknown>;
}

/**
 * Stream event types emitted during streaming responses.
 */
export interface AIStreamEvent {
  type: 'text_delta' | 'tool_use' | 'message_complete' | 'usage' | 'error';
  text?: string;
  toolCall?: AIToolCall;
  usage?: AIUsage;
  error?: string;
}

/**
 * Token usage metrics for billing and rate limiting.
 */
export interface AIUsage {
  inputTokens: number;
  outputTokens: number;
  cacheReadTokens?: number;
  cacheWriteTokens?: number;
}

/**
 * Parameters for creating a message.
 */
export interface CreateMessageParams {
  model?: string;
  maxTokens?: number;
  system?: string;
  messages: AIMessage[];
  tools?: AITool[];
  temperature?: number;
}

/**
 * Response from a non-streaming message creation.
 */
export interface AIMessageResponse {
  content: string;
  toolCalls?: AIToolCall[];
  usage: AIUsage;
  stopReason: 'end_turn' | 'tool_use' | 'max_tokens' | 'stop_sequence';
}

/**
 * Provider capability flags.
 */
export interface AIProviderCapabilities {
  streaming: boolean;
  tools: boolean;
  vision: boolean;
  promptCaching: boolean;
}

/**
 * Abstract interface for AI providers.
 * Implementations must handle provider-specific details while
 * exposing a consistent API for the application.
 */
export interface AIProvider {
  /** Provider identifier (e.g., 'claude', 'openai', 'local') */
  readonly name: string;

  /** Provider capabilities */
  readonly capabilities: AIProviderCapabilities;

  /** Available models for this provider */
  readonly availableModels: string[];

  /** Default model to use */
  readonly defaultModel: string;

  /**
   * Create a message (non-streaming).
   */
  createMessage(params: CreateMessageParams): Promise<AIMessageResponse>;

  /**
   * Stream a message response.
   * Returns an async iterator of stream events.
   */
  streamMessage(
    params: CreateMessageParams,
    abortSignal?: AbortSignal,
  ): AsyncIterable<AIStreamEvent>;

  /**
   * Estimate token count for text.
   * Provider-specific implementation for accuracy.
   */
  estimateTokens(text: string): number;

  /**
   * Check if the provider is properly configured and ready.
   */
  isReady(): boolean;
}
```

2. Create `apps/backend/src/modules/ai/interfaces/index.ts`:
```typescript
export * from './ai-provider.interface';
```
  </action>
  <verify>
`npm run build` succeeds.
Interface file exports all types without errors.
  </verify>
  <done>
AIProvider interface defined with all required methods and types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ClaudeProvider</name>
  <files>
    apps/backend/src/modules/ai/providers/claude.provider.ts
    apps/backend/src/modules/ai/providers/index.ts
  </files>
  <action>
Create the Claude implementation of AIProvider:

1. Create `apps/backend/src/modules/ai/providers/claude.provider.ts`:
```typescript
import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import Anthropic from '@anthropic-ai/sdk';
import {
  AIProvider,
  AIProviderCapabilities,
  CreateMessageParams,
  AIMessageResponse,
  AIStreamEvent,
  AIMessage,
  AITool,
} from '../interfaces/ai-provider.interface';

@Injectable()
export class ClaudeProvider implements AIProvider, OnModuleInit {
  private readonly logger = new Logger(ClaudeProvider.name);
  private client: Anthropic | null = null;

  readonly name = 'claude';

  readonly capabilities: AIProviderCapabilities = {
    streaming: true,
    tools: true,
    vision: true,
    promptCaching: true,
  };

  readonly availableModels = [
    'claude-sonnet-4-5',
    'claude-opus-4',
    'claude-3-5-haiku-latest',
  ];

  readonly defaultModel = 'claude-sonnet-4-5';

  constructor(private readonly configService: ConfigService) {}

  onModuleInit() {
    const apiKey = this.configService.get<string>('ANTHROPIC_API_KEY');
    if (!apiKey) {
      this.logger.warn('ANTHROPIC_API_KEY not set - Claude provider disabled');
      return;
    }

    this.client = new Anthropic({ apiKey });
    this.logger.log('Claude provider initialized');
  }

  isReady(): boolean {
    return this.client !== null;
  }

  async createMessage(params: CreateMessageParams): Promise<AIMessageResponse> {
    this.ensureReady();

    const { system, userMessages } = this.separateSystemMessage(params.messages);
    const claudeTools = params.tools ? this.convertTools(params.tools) : undefined;

    const response = await this.client!.messages.create({
      model: params.model || this.defaultModel,
      max_tokens: params.maxTokens || 4096,
      system: params.system || system || undefined,
      messages: userMessages,
      tools: claudeTools,
      temperature: params.temperature,
    });

    return this.convertResponse(response);
  }

  async *streamMessage(
    params: CreateMessageParams,
    abortSignal?: AbortSignal,
  ): AsyncIterable<AIStreamEvent> {
    this.ensureReady();

    const { system, userMessages } = this.separateSystemMessage(params.messages);
    const claudeTools = params.tools ? this.convertTools(params.tools) : undefined;

    const stream = this.client!.messages.stream(
      {
        model: params.model || this.defaultModel,
        max_tokens: params.maxTokens || 4096,
        system: params.system || system || undefined,
        messages: userMessages,
        tools: claudeTools,
        temperature: params.temperature,
      },
      { signal: abortSignal },
    );

    let currentToolId: string | undefined;
    let currentToolName: string | undefined;
    let toolInputJson = '';

    try {
      for await (const event of stream) {
        if (event.type === 'content_block_start') {
          const block = event.content_block as { type: string; id?: string; name?: string };
          if (block.type === 'tool_use') {
            currentToolId = block.id;
            currentToolName = block.name;
            toolInputJson = '';
          }
        } else if (event.type === 'content_block_delta') {
          const delta = event.delta as { type: string; text?: string; partial_json?: string };

          if (delta.type === 'text_delta' && delta.text) {
            yield { type: 'text_delta', text: delta.text };
          } else if (delta.type === 'input_json_delta' && delta.partial_json) {
            toolInputJson += delta.partial_json;
          }
        } else if (event.type === 'content_block_stop') {
          if (currentToolId && currentToolName) {
            try {
              const input = JSON.parse(toolInputJson);
              yield {
                type: 'tool_use',
                toolCall: {
                  id: currentToolId,
                  name: currentToolName,
                  input,
                },
              };
            } catch {
              this.logger.warn('Failed to parse tool input JSON');
            }
            currentToolId = undefined;
            currentToolName = undefined;
            toolInputJson = '';
          }
        } else if (event.type === 'message_delta') {
          const usage = (event as { usage?: { input_tokens: number; output_tokens: number } }).usage;
          if (usage) {
            yield {
              type: 'usage',
              usage: {
                inputTokens: usage.input_tokens,
                outputTokens: usage.output_tokens,
              },
            };
          }
        } else if (event.type === 'message_stop') {
          yield { type: 'message_complete' };
        }
      }
    } catch (error: unknown) {
      const err = error as { name?: string; message?: string };
      if (err.name === 'AbortError') {
        return;
      }
      yield { type: 'error', error: err.message || 'Unknown error' };
    }
  }

  estimateTokens(text: string): number {
    // Claude uses ~4 characters per token on average for English
    // This is a rough estimate; for accurate counts use the tokenizer
    return Math.ceil(text.length / 4);
  }

  private ensureReady(): void {
    if (!this.client) {
      throw new Error('Claude provider not initialized - ANTHROPIC_API_KEY not set');
    }
  }

  private separateSystemMessage(messages: AIMessage[]): {
    system: string | undefined;
    userMessages: Array<{ role: 'user' | 'assistant'; content: string }>;
  } {
    const systemMessages = messages.filter(m => m.role === 'system');
    const userMessages = messages
      .filter(m => m.role !== 'system')
      .map(m => ({
        role: m.role as 'user' | 'assistant',
        content: m.content,
      }));

    return {
      system: systemMessages.map(m => m.content).join('\n\n') || undefined,
      userMessages,
    };
  }

  private convertTools(tools: AITool[]): Anthropic.Tool[] {
    return tools.map(tool => ({
      name: tool.name,
      description: tool.description,
      input_schema: tool.inputSchema as Anthropic.Tool.InputSchema,
    }));
  }

  private convertResponse(response: Anthropic.Message): AIMessageResponse {
    const textContent = response.content
      .filter(block => block.type === 'text')
      .map(block => (block as Anthropic.TextBlock).text)
      .join('');

    const toolCalls = response.content
      .filter(block => block.type === 'tool_use')
      .map(block => {
        const toolBlock = block as Anthropic.ToolUseBlock;
        return {
          id: toolBlock.id,
          name: toolBlock.name,
          input: toolBlock.input as Record<string, unknown>,
        };
      });

    return {
      content: textContent,
      toolCalls: toolCalls.length > 0 ? toolCalls : undefined,
      usage: {
        inputTokens: response.usage.input_tokens,
        outputTokens: response.usage.output_tokens,
      },
      stopReason: response.stop_reason as AIMessageResponse['stopReason'],
    };
  }
}
```

2. Create `apps/backend/src/modules/ai/providers/index.ts`:
```typescript
export * from './claude.provider';
```
  </action>
  <verify>
`npm run build` succeeds.
ClaudeProvider implements all AIProvider methods.
  </verify>
  <done>
ClaudeProvider fully implements AIProvider interface with streaming and tool support.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ProviderRegistryService and update module</name>
  <files>
    apps/backend/src/modules/ai/services/provider-registry.service.ts
    apps/backend/src/modules/ai/ai.module.ts
    apps/backend/src/modules/ai/index.ts
  </files>
  <action>
Create the provider registry that manages available providers:

1. Create `apps/backend/src/modules/ai/services/provider-registry.service.ts`:
```typescript
import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { AIProvider } from '../interfaces/ai-provider.interface';
import { ClaudeProvider } from '../providers/claude.provider';

/**
 * Registry for AI providers.
 * Manages provider registration and selection.
 */
@Injectable()
export class ProviderRegistryService implements OnModuleInit {
  private readonly logger = new Logger(ProviderRegistryService.name);
  private readonly providers = new Map<string, AIProvider>();
  private defaultProviderName: string;

  constructor(
    private readonly configService: ConfigService,
    private readonly claudeProvider: ClaudeProvider,
  ) {
    this.defaultProviderName = this.configService.get<string>('AI_DEFAULT_PROVIDER', 'claude');
  }

  onModuleInit() {
    // Register built-in providers
    this.registerProvider(this.claudeProvider);

    this.logger.log(`Registered ${this.providers.size} AI provider(s)`);

    // Verify default provider is available
    const defaultProvider = this.providers.get(this.defaultProviderName);
    if (!defaultProvider?.isReady()) {
      this.logger.warn(`Default AI provider '${this.defaultProviderName}' is not ready`);
    }
  }

  /**
   * Register an AI provider.
   */
  registerProvider(provider: AIProvider): void {
    if (this.providers.has(provider.name)) {
      this.logger.warn(`Overwriting existing provider: ${provider.name}`);
    }
    this.providers.set(provider.name, provider);
    this.logger.debug(`Registered provider: ${provider.name}`);
  }

  /**
   * Get a provider by name.
   * Falls back to default if name not specified.
   */
  getProvider(name?: string): AIProvider {
    const providerName = name || this.defaultProviderName;
    const provider = this.providers.get(providerName);

    if (!provider) {
      throw new Error(`AI provider '${providerName}' not found. Available: ${this.listProviders().join(', ')}`);
    }

    if (!provider.isReady()) {
      throw new Error(`AI provider '${providerName}' is not ready (check configuration)`);
    }

    return provider;
  }

  /**
   * Get the default provider.
   */
  getDefaultProvider(): AIProvider {
    return this.getProvider(this.defaultProviderName);
  }

  /**
   * List all registered provider names.
   */
  listProviders(): string[] {
    return Array.from(this.providers.keys());
  }

  /**
   * List ready (configured) providers.
   */
  listReadyProviders(): string[] {
    return Array.from(this.providers.entries())
      .filter(([_, provider]) => provider.isReady())
      .map(([name]) => name);
  }

  /**
   * Check if any provider is available.
   */
  hasAvailableProvider(): boolean {
    return this.listReadyProviders().length > 0;
  }
}
```

2. Update `apps/backend/src/modules/ai/ai.module.ts`:
```typescript
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { AiClientService } from './services/ai-client.service';
import { ProviderRegistryService } from './services/provider-registry.service';
import { ClaudeProvider } from './providers/claude.provider';

@Module({
  imports: [ConfigModule],
  providers: [
    ClaudeProvider,
    ProviderRegistryService,
    AiClientService,
  ],
  exports: [
    AiClientService,
    ProviderRegistryService,
    ClaudeProvider,
  ],
})
export class AiModule {}
```

3. Update `apps/backend/src/modules/ai/index.ts`:
```typescript
export * from './ai.module';
export * from './services/ai-client.service';
export * from './services/provider-registry.service';
export * from './providers';
export * from './interfaces';
export * from './dto';
```

4. Add to `.env.example`:
```
AI_DEFAULT_PROVIDER=claude
```
  </action>
  <verify>
`npm run build` succeeds.
ProviderRegistryService registers ClaudeProvider on module init.
  </verify>
  <done>
Provider abstraction complete. AI features can call getProvider() to get any configured provider.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `npm run build` passes
2. `npm run lint` passes
3. AIProvider interface is exported from the module
4. ClaudeProvider implements AIProvider
5. ProviderRegistryService can resolve providers by name
6. Default provider is configurable via environment
</verification>

<success_criteria>
- AIProvider interface defines consistent API for all providers
- ClaudeProvider wraps @anthropic-ai/sdk and implements AIProvider
- ProviderRegistryService manages provider registration and lookup
- System falls back gracefully when provider not configured
- Easy to add new providers by implementing AIProvider interface
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-infrastructure/05-02-SUMMARY.md`
</output>
