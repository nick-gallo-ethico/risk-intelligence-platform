---
phase: 03-authentication-sso
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - apps/backend/src/modules/auth/domain/domain.service.ts
  - apps/backend/src/modules/auth/domain/domain.controller.ts
  - apps/backend/src/modules/auth/domain/domain-verification.service.ts
  - apps/backend/src/modules/auth/domain/dto/domain.dto.ts
  - apps/backend/src/modules/auth/domain/domain.module.ts
  - apps/backend/src/modules/auth/auth.module.ts
autonomous: true

must_haves:
  truths:
    - "Organization admins can add email domains for SSO tenant routing"
    - "Domains are verified via DNS TXT record before enabling"
    - "Verified domains map user emails to organizations during SSO"
    - "Domain verification events are logged to audit trail"
  artifacts:
    - path: "apps/backend/src/modules/auth/domain/domain.service.ts"
      provides: "Domain CRUD and tenant lookup by email"
      exports: ["DomainService"]
    - path: "apps/backend/src/modules/auth/domain/domain-verification.service.ts"
      provides: "DNS TXT record verification logic"
      exports: ["DomainVerificationService"]
    - path: "apps/backend/src/modules/auth/domain/domain.controller.ts"
      provides: "REST endpoints for domain management"
      exports: ["DomainController"]
  key_links:
    - from: "domain.service.ts"
      to: "prisma.tenantDomain"
      via: "Prisma queries"
      pattern: "prisma\\.tenantDomain"
    - from: "domain.service.ts"
      to: "auditService"
      via: "Audit logging"
      pattern: "auditService\\.log"
    - from: "domain-verification.service.ts"
      to: "dns"
      via: "DNS TXT lookup"
      pattern: "dns\\.promises\\.resolveTxt"
---

<objective>
Implement domain verification workflow for SSO tenant routing.

Purpose: Enable organizations to claim email domains (e.g., "acme.com") and verify ownership via DNS TXT records. Verified domains allow automatic tenant routing during SSO - users with @acme.com emails are routed to Acme's organization. This is critical security: without verification, anyone could claim a domain and intercept users.

Output: DomainService for CRUD operations and tenant lookup, DomainVerificationService for DNS verification, REST endpoints for domain management.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-authentication-sso/03-RESEARCH.md
@.planning/phases/03-authentication-sso/03-01-SUMMARY.md
@apps/backend/src/modules/auth/auth.module.ts
@apps/backend/src/modules/audit/audit.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DomainVerificationService for DNS TXT verification</name>
  <files>apps/backend/src/modules/auth/domain/domain-verification.service.ts</files>
  <action>
Create `domain/domain-verification.service.ts`:

```typescript
import { Injectable, Logger } from '@nestjs/common';
import * as dns from 'dns';
import * as crypto from 'crypto';

/**
 * Service for verifying domain ownership via DNS TXT records.
 *
 * Domain verification is CRITICAL for SSO security:
 * - Without verification, anyone could claim a domain
 * - Attackers could intercept users via JIT provisioning
 * - Verification proves the requester controls the domain's DNS
 */
@Injectable()
export class DomainVerificationService {
  private readonly logger = new Logger(DomainVerificationService.name);

  /**
   * DNS TXT record prefix for verification
   * Format: _ethico-verify.domain.com TXT "ethico-verify=TOKEN"
   */
  private readonly DNS_PREFIX = '_ethico-verify';
  private readonly TXT_PREFIX = 'ethico-verify=';

  /**
   * Generate a cryptographically secure verification token.
   * Token is 32 bytes (64 hex characters) for sufficient entropy.
   */
  generateVerificationToken(): string {
    return crypto.randomBytes(32).toString('hex');
  }

  /**
   * Get the DNS TXT record name for a domain.
   * @param domain - The domain to verify (e.g., "acme.com")
   * @returns The full TXT record name (e.g., "_ethico-verify.acme.com")
   */
  getTxtRecordName(domain: string): string {
    return `${this.DNS_PREFIX}.${domain}`;
  }

  /**
   * Get the expected TXT record value for a token.
   * @param token - The verification token
   * @returns The expected TXT value (e.g., "ethico-verify=abc123...")
   */
  getExpectedTxtValue(token: string): string {
    return `${this.TXT_PREFIX}${token}`;
  }

  /**
   * Verify domain ownership via DNS TXT record lookup.
   *
   * @param domain - The domain to verify
   * @param expectedToken - The verification token to look for
   * @returns true if valid TXT record found, false otherwise
   */
  async verifyDnsTxtRecord(domain: string, expectedToken: string): Promise<boolean> {
    const recordName = this.getTxtRecordName(domain);
    const expectedValue = this.getExpectedTxtValue(expectedToken);

    try {
      // Set timeout for DNS lookup (5 seconds)
      const resolver = new dns.Resolver();
      resolver.setServers(['8.8.8.8', '8.8.4.4', '1.1.1.1']); // Use public DNS

      const records = await dns.promises.resolveTxt(recordName);

      // DNS TXT records are arrays of strings (can be chunked)
      // Flatten and check each record
      for (const record of records) {
        const value = record.join(''); // Join chunked values
        if (value === expectedValue) {
          this.logger.log(`Domain ${domain} verified successfully`);
          return true;
        }
      }

      this.logger.warn(`Domain ${domain} verification failed: token not found in TXT records`);
      return false;
    } catch (error) {
      if (error.code === 'ENOTFOUND' || error.code === 'ENODATA') {
        this.logger.warn(`Domain ${domain} verification failed: TXT record not found`);
        return false;
      }

      this.logger.error(`Domain ${domain} verification error: ${error.message}`);
      return false;
    }
  }

  /**
   * Get instructions for domain verification.
   * Returns user-friendly instructions for adding the DNS TXT record.
   */
  getVerificationInstructions(domain: string, token: string): {
    recordType: string;
    recordName: string;
    recordValue: string;
    instructions: string;
  } {
    return {
      recordType: 'TXT',
      recordName: this.getTxtRecordName(domain),
      recordValue: this.getExpectedTxtValue(token),
      instructions: `Add a TXT record to your DNS configuration:\n\n` +
        `Host/Name: ${this.DNS_PREFIX}\n` +
        `Type: TXT\n` +
        `Value: ${this.getExpectedTxtValue(token)}\n\n` +
        `Note: DNS changes can take up to 24-48 hours to propagate.`,
    };
  }
}
```
  </action>
  <verify>
Run: `cd apps/backend && npx tsc --noEmit`
Should compile without errors.
  </verify>
  <done>
DomainVerificationService exists with generateVerificationToken(), verifyDnsTxtRecord(), and getVerificationInstructions() methods. Uses crypto for secure token generation and dns module for TXT lookups.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DomainService for domain CRUD and tenant routing</name>
  <files>
apps/backend/src/modules/auth/domain/domain.service.ts
apps/backend/src/modules/auth/domain/dto/domain.dto.ts
  </files>
  <action>
1. Create `domain/dto/domain.dto.ts`:

```typescript
import { IsString, IsNotEmpty, Matches, IsOptional, IsBoolean } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class AddDomainDto {
  @ApiProperty({ example: 'acme.com', description: 'Email domain to claim' })
  @IsString()
  @IsNotEmpty()
  @Matches(/^[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,}$/i, {
    message: 'Invalid domain format',
  })
  domain: string;

  @ApiPropertyOptional({ description: 'Set as primary domain for organization' })
  @IsOptional()
  @IsBoolean()
  isPrimary?: boolean;
}

export class DomainResponseDto {
  @ApiProperty()
  id: string;

  @ApiProperty()
  domain: string;

  @ApiProperty()
  verified: boolean;

  @ApiProperty({ nullable: true })
  verifiedAt: Date | null;

  @ApiProperty()
  isPrimary: boolean;

  @ApiProperty()
  verificationInstructions?: {
    recordType: string;
    recordName: string;
    recordValue: string;
    instructions: string;
  };
}

export class VerifyDomainResponseDto {
  @ApiProperty()
  verified: boolean;

  @ApiProperty({ nullable: true })
  message: string;
}
```

2. Create `domain/domain.service.ts`:

```typescript
import {
  Injectable,
  NotFoundException,
  ConflictException,
  BadRequestException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { AuditService } from '../../audit/audit.service';
import { DomainVerificationService } from './domain-verification.service';
import { AddDomainDto, DomainResponseDto, VerifyDomainResponseDto } from './dto/domain.dto';
import { AuditActionCategory } from '@prisma/client';

@Injectable()
export class DomainService {
  constructor(
    private prisma: PrismaService,
    private auditService: AuditService,
    private verificationService: DomainVerificationService,
  ) {}

  /**
   * Find organization by verified email domain.
   * Used during SSO to route users to correct tenant.
   *
   * @param email - User's email address
   * @returns Organization if domain is verified, null otherwise
   */
  async findOrganizationByEmailDomain(email: string) {
    const domain = email.split('@')[1]?.toLowerCase();
    if (!domain) return null;

    const tenantDomain = await this.prisma.tenantDomain.findFirst({
      where: {
        domain,
        verified: true,
      },
      include: {
        organization: true,
      },
    });

    return tenantDomain?.organization ?? null;
  }

  /**
   * Get all domains for an organization.
   */
  async getDomainsForOrganization(organizationId: string): Promise<DomainResponseDto[]> {
    const domains = await this.prisma.tenantDomain.findMany({
      where: { organizationId },
      orderBy: [{ isPrimary: 'desc' }, { createdAt: 'asc' }],
    });

    return domains.map((d) => ({
      id: d.id,
      domain: d.domain,
      verified: d.verified,
      verifiedAt: d.verifiedAt,
      isPrimary: d.isPrimary,
      verificationInstructions: d.verified
        ? undefined
        : this.verificationService.getVerificationInstructions(d.domain, d.verificationToken),
    }));
  }

  /**
   * Add a new domain to an organization.
   * Domain starts unverified - must complete DNS verification.
   */
  async addDomain(
    organizationId: string,
    dto: AddDomainDto,
    userId: string,
  ): Promise<DomainResponseDto> {
    const normalizedDomain = dto.domain.toLowerCase();

    // Check if domain already claimed by any organization
    const existingDomain = await this.prisma.tenantDomain.findUnique({
      where: { domain: normalizedDomain },
    });

    if (existingDomain) {
      if (existingDomain.organizationId === organizationId) {
        throw new ConflictException('Domain already added to your organization');
      }
      throw new ConflictException('Domain is already claimed by another organization');
    }

    // If setting as primary, ensure only one primary per org
    if (dto.isPrimary) {
      await this.prisma.tenantDomain.updateMany({
        where: { organizationId, isPrimary: true },
        data: { isPrimary: false },
      });
    }

    // Generate verification token
    const verificationToken = this.verificationService.generateVerificationToken();

    // Create domain record
    const domain = await this.prisma.tenantDomain.create({
      data: {
        organizationId,
        domain: normalizedDomain,
        verificationToken,
        verificationMethod: 'DNS_TXT',
        isPrimary: dto.isPrimary ?? false,
      },
    });

    // Audit log
    await this.auditService.log({
      entityType: 'ORGANIZATION',
      entityId: organizationId,
      organizationId,
      action: 'DOMAIN_ADDED',
      actionDescription: `Domain ${normalizedDomain} added for verification`,
      actionCategory: AuditActionCategory.SECURITY,
      actorUserId: userId,
    });

    return {
      id: domain.id,
      domain: domain.domain,
      verified: domain.verified,
      verifiedAt: domain.verifiedAt,
      isPrimary: domain.isPrimary,
      verificationInstructions: this.verificationService.getVerificationInstructions(
        domain.domain,
        domain.verificationToken,
      ),
    };
  }

  /**
   * Verify domain ownership via DNS TXT record.
   */
  async verifyDomain(
    organizationId: string,
    domainId: string,
    userId: string,
  ): Promise<VerifyDomainResponseDto> {
    const domain = await this.prisma.tenantDomain.findFirst({
      where: { id: domainId, organizationId },
    });

    if (!domain) {
      throw new NotFoundException('Domain not found');
    }

    if (domain.verified) {
      return { verified: true, message: 'Domain is already verified' };
    }

    // Perform DNS verification
    const verified = await this.verificationService.verifyDnsTxtRecord(
      domain.domain,
      domain.verificationToken,
    );

    if (verified) {
      await this.prisma.tenantDomain.update({
        where: { id: domainId },
        data: {
          verified: true,
          verifiedAt: new Date(),
        },
      });

      await this.auditService.log({
        entityType: 'ORGANIZATION',
        entityId: organizationId,
        organizationId,
        action: 'DOMAIN_VERIFIED',
        actionDescription: `Domain ${domain.domain} verified successfully`,
        actionCategory: AuditActionCategory.SECURITY,
        actorUserId: userId,
      });

      return { verified: true, message: 'Domain verified successfully' };
    }

    return {
      verified: false,
      message: 'DNS TXT record not found. Ensure the record is properly configured and DNS has propagated.',
    };
  }

  /**
   * Remove a domain from an organization.
   */
  async removeDomain(organizationId: string, domainId: string, userId: string): Promise<void> {
    const domain = await this.prisma.tenantDomain.findFirst({
      where: { id: domainId, organizationId },
    });

    if (!domain) {
      throw new NotFoundException('Domain not found');
    }

    await this.prisma.tenantDomain.delete({
      where: { id: domainId },
    });

    await this.auditService.log({
      entityType: 'ORGANIZATION',
      entityId: organizationId,
      organizationId,
      action: 'DOMAIN_REMOVED',
      actionDescription: `Domain ${domain.domain} removed`,
      actionCategory: AuditActionCategory.SECURITY,
      actorUserId: userId,
    });
  }

  /**
   * Set a domain as primary for the organization.
   */
  async setPrimaryDomain(organizationId: string, domainId: string, userId: string): Promise<void> {
    const domain = await this.prisma.tenantDomain.findFirst({
      where: { id: domainId, organizationId, verified: true },
    });

    if (!domain) {
      throw new NotFoundException('Domain not found or not verified');
    }

    // Unset current primary
    await this.prisma.tenantDomain.updateMany({
      where: { organizationId, isPrimary: true },
      data: { isPrimary: false },
    });

    // Set new primary
    await this.prisma.tenantDomain.update({
      where: { id: domainId },
      data: { isPrimary: true },
    });

    await this.auditService.log({
      entityType: 'ORGANIZATION',
      entityId: organizationId,
      organizationId,
      action: 'PRIMARY_DOMAIN_SET',
      actionDescription: `${domain.domain} set as primary domain`,
      actionCategory: AuditActionCategory.SECURITY,
      actorUserId: userId,
    });
  }
}
```
  </action>
  <verify>
Run: `cd apps/backend && npx tsc --noEmit`
Should compile without errors.
  </verify>
  <done>
DomainService exists with findOrganizationByEmailDomain(), addDomain(), verifyDomain(), removeDomain(), setPrimaryDomain() methods. DTOs provide validation and API documentation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create DomainController and DomainModule</name>
  <files>
apps/backend/src/modules/auth/domain/domain.controller.ts
apps/backend/src/modules/auth/domain/domain.module.ts
apps/backend/src/modules/auth/auth.module.ts
  </files>
  <action>
1. Create `domain/domain.controller.ts`:

```typescript
import {
  Controller,
  Get,
  Post,
  Delete,
  Patch,
  Body,
  Param,
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth } from '@nestjs/swagger';
import { Throttle } from '@nestjs/throttler';
import { JwtAuthGuard } from '../guards/jwt-auth.guard';
import { RolesGuard } from '../../common/guards/roles.guard';
import { Roles } from '../../common/decorators/roles.decorator';
import { CurrentUser } from '../../common/decorators/current-user.decorator';
import { UserRole } from '@prisma/client';
import { DomainService } from './domain.service';
import { AddDomainDto, DomainResponseDto, VerifyDomainResponseDto } from './dto/domain.dto';

@ApiTags('domains')
@ApiBearerAuth()
@Controller('api/v1/domains')
@UseGuards(JwtAuthGuard, RolesGuard)
export class DomainController {
  constructor(private readonly domainService: DomainService) {}

  @Get()
  @Roles(UserRole.SYSTEM_ADMIN, UserRole.COMPLIANCE_OFFICER)
  @ApiOperation({ summary: 'Get all domains for organization' })
  @ApiResponse({ status: 200, type: [DomainResponseDto] })
  async getDomains(@CurrentUser() user: { organizationId: string }): Promise<DomainResponseDto[]> {
    return this.domainService.getDomainsForOrganization(user.organizationId);
  }

  @Post()
  @Roles(UserRole.SYSTEM_ADMIN)
  @Throttle({ default: { limit: 10, ttl: 3600000 } }) // 10 per hour
  @ApiOperation({ summary: 'Add a new domain for verification' })
  @ApiResponse({ status: 201, type: DomainResponseDto })
  async addDomain(
    @Body() dto: AddDomainDto,
    @CurrentUser() user: { sub: string; organizationId: string },
  ): Promise<DomainResponseDto> {
    return this.domainService.addDomain(user.organizationId, dto, user.sub);
  }

  @Post(':id/verify')
  @Roles(UserRole.SYSTEM_ADMIN)
  @Throttle({ default: { limit: 20, ttl: 3600000 } }) // 20 per hour
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Verify domain ownership via DNS TXT record' })
  @ApiResponse({ status: 200, type: VerifyDomainResponseDto })
  async verifyDomain(
    @Param('id') domainId: string,
    @CurrentUser() user: { sub: string; organizationId: string },
  ): Promise<VerifyDomainResponseDto> {
    return this.domainService.verifyDomain(user.organizationId, domainId, user.sub);
  }

  @Patch(':id/primary')
  @Roles(UserRole.SYSTEM_ADMIN)
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Set domain as primary for organization' })
  @ApiResponse({ status: 204 })
  async setPrimaryDomain(
    @Param('id') domainId: string,
    @CurrentUser() user: { sub: string; organizationId: string },
  ): Promise<void> {
    return this.domainService.setPrimaryDomain(user.organizationId, domainId, user.sub);
  }

  @Delete(':id')
  @Roles(UserRole.SYSTEM_ADMIN)
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Remove a domain from organization' })
  @ApiResponse({ status: 204 })
  async removeDomain(
    @Param('id') domainId: string,
    @CurrentUser() user: { sub: string; organizationId: string },
  ): Promise<void> {
    return this.domainService.removeDomain(user.organizationId, domainId, user.sub);
  }
}
```

2. Create `domain/domain.module.ts`:

```typescript
import { Module } from '@nestjs/common';
import { DomainController } from './domain.controller';
import { DomainService } from './domain.service';
import { DomainVerificationService } from './domain-verification.service';

@Module({
  controllers: [DomainController],
  providers: [DomainService, DomainVerificationService],
  exports: [DomainService, DomainVerificationService],
})
export class DomainModule {}
```

3. Create `domain/index.ts` for exports:

```typescript
export * from './domain.module';
export * from './domain.service';
export * from './domain-verification.service';
export * from './dto/domain.dto';
```

4. Update `auth.module.ts` to import DomainModule:

Add to imports array:
```typescript
import { DomainModule } from './domain';

@Module({
  imports: [
    // ... existing imports
    DomainModule,
  ],
  // ...
})
```

And re-export DomainService for use by SSO services:
```typescript
exports: [AuthService, JwtModule, DomainModule],
```
  </action>
  <verify>
Run: `cd apps/backend && npx tsc --noEmit && npm test`
TypeScript compiles and tests pass.
  </verify>
  <done>
DomainController provides REST endpoints for domain management (GET, POST, POST /verify, PATCH /primary, DELETE). DomainModule exports services for use by SSO. AuthModule imports and re-exports DomainModule.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd apps/backend && npx tsc --noEmit`
2. Tests pass: `cd apps/backend && npm test`
3. Endpoints documented: Start server and check Swagger at /api/docs for domains endpoints
4. Audit logging: Check that domain actions log to audit_logs table
</verification>

<success_criteria>
- DomainVerificationService generates tokens and verifies DNS TXT records
- DomainService provides findOrganizationByEmailDomain() for SSO tenant routing
- Domain CRUD operations (add, verify, remove, set primary) work correctly
- All domain changes are logged to audit trail
- REST endpoints require SYSTEM_ADMIN role
- Verification endpoint rate-limited to prevent DNS abuse
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication-sso/03-03-SUMMARY.md`
</output>
