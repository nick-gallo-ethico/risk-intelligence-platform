---
phase: 03-authentication-sso
plan: 04
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - apps/backend/src/modules/auth/sso/sso.service.ts
  - apps/backend/src/modules/auth/sso/sso-config.service.ts
  - apps/backend/src/modules/auth/sso/sso.module.ts
  - apps/backend/src/modules/auth/sso/dto/sso.dto.ts
  - apps/backend/src/modules/auth/auth.module.ts
autonomous: true

must_haves:
  truths:
    - "SSO users are found by provider+ssoId or created via JIT provisioning"
    - "JIT provisioning routes users to correct tenant via verified domain"
    - "Existing users can link SSO provider to their account"
    - "SSO configuration can be enabled/disabled per tenant"
    - "All SSO events are logged to audit trail"
  artifacts:
    - path: "apps/backend/src/modules/auth/sso/sso.service.ts"
      provides: "Core SSO orchestration with JIT provisioning"
      exports: ["SsoService"]
    - path: "apps/backend/src/modules/auth/sso/sso-config.service.ts"
      provides: "Per-tenant SSO configuration management"
      exports: ["SsoConfigService"]
  key_links:
    - from: "sso.service.ts"
      to: "domain.service.ts"
      via: "findOrganizationByEmailDomain"
      pattern: "domainService\\.findOrganizationByEmailDomain"
    - from: "sso.service.ts"
      to: "prisma.user"
      via: "User find/create"
      pattern: "prisma\\.user\\.(findFirst|create)"
    - from: "sso.service.ts"
      to: "auditService"
      via: "Audit logging"
      pattern: "auditService\\.log"
---

<objective>
Create core SSO service with Just-In-Time user provisioning.

Purpose: Implement the central SSO orchestration that all SSO strategies (Azure AD, Google, SAML) will use. The SsoService handles finding existing users, creating new users via JIT provisioning, and linking SSO accounts. SsoConfigService manages per-tenant SSO configuration.

Output: SsoService with findOrCreateSsoUser() for JIT provisioning, SsoConfigService for tenant SSO settings, DTOs for SSO configuration.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-authentication-sso/03-RESEARCH.md
@.planning/phases/03-authentication-sso/03-01-SUMMARY.md
@apps/backend/src/modules/auth/auth.service.ts
@apps/backend/src/modules/auth/domain/domain.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SsoConfigService for per-tenant SSO configuration</name>
  <files>
apps/backend/src/modules/auth/sso/sso-config.service.ts
apps/backend/src/modules/auth/sso/dto/sso.dto.ts
  </files>
  <action>
1. Create `sso/dto/sso.dto.ts`:

```typescript
import {
  IsString,
  IsBoolean,
  IsOptional,
  IsEnum,
  ValidateIf,
} from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { UserRole } from '@prisma/client';

export type SsoProviderType = 'azure-ad' | 'google' | 'saml' | null;

export class UpdateSsoConfigDto {
  @ApiPropertyOptional({ enum: ['azure-ad', 'google', 'saml'] })
  @IsOptional()
  @IsString()
  ssoProvider?: SsoProviderType;

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  ssoEnabled?: boolean;

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  jitProvisioningEnabled?: boolean;

  @ApiPropertyOptional({ enum: UserRole })
  @IsOptional()
  @IsEnum(UserRole)
  defaultRole?: UserRole;

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  mfaRequired?: boolean;

  // Azure AD specific
  @ApiPropertyOptional({ description: 'Azure AD tenant ID (for Azure AD SSO)' })
  @ValidateIf((o) => o.ssoProvider === 'azure-ad')
  @IsString()
  azureTenantId?: string;

  // SAML specific
  @ApiPropertyOptional({ description: 'SAML IdP Entity ID' })
  @ValidateIf((o) => o.ssoProvider === 'saml')
  @IsString()
  samlIdpEntityId?: string;

  @ApiPropertyOptional({ description: 'SAML IdP SSO URL' })
  @ValidateIf((o) => o.ssoProvider === 'saml')
  @IsString()
  samlIdpEntryPoint?: string;

  @ApiPropertyOptional({ description: 'SAML IdP Certificate (PEM format)' })
  @ValidateIf((o) => o.ssoProvider === 'saml')
  @IsString()
  samlIdpCertificate?: string;

  @ApiPropertyOptional({ description: 'SAML SP Entity ID' })
  @ValidateIf((o) => o.ssoProvider === 'saml')
  @IsString()
  samlSpEntityId?: string;
}

export class SsoConfigResponseDto {
  @ApiProperty()
  id: string;

  @ApiProperty()
  organizationId: string;

  @ApiProperty({ nullable: true })
  ssoProvider: string | null;

  @ApiProperty()
  ssoEnabled: boolean;

  @ApiProperty()
  jitProvisioningEnabled: boolean;

  @ApiProperty({ enum: UserRole })
  defaultRole: UserRole;

  @ApiProperty()
  mfaRequired: boolean;

  @ApiProperty({ nullable: true })
  azureTenantId: string | null;

  // SAML fields (sensitive parts redacted in response)
  @ApiProperty({ nullable: true })
  samlIdpEntityId: string | null;

  @ApiProperty({ nullable: true })
  samlIdpEntryPoint: string | null;

  @ApiProperty({ description: 'Whether SAML certificate is configured' })
  samlCertificateConfigured: boolean;

  @ApiProperty({ nullable: true })
  samlSpEntityId: string | null;
}
```

2. Create `sso/sso-config.service.ts`:

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { AuditService } from '../../audit/audit.service';
import { UpdateSsoConfigDto, SsoConfigResponseDto } from './dto/sso.dto';
import { SamlConfig } from '../interfaces';
import { AuditActionCategory, UserRole } from '@prisma/client';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class SsoConfigService {
  constructor(
    private prisma: PrismaService,
    private auditService: AuditService,
    private configService: ConfigService,
  ) {}

  /**
   * Get SSO configuration for an organization.
   * Creates default config if none exists.
   */
  async getConfig(organizationId: string): Promise<SsoConfigResponseDto> {
    let config = await this.prisma.tenantSsoConfig.findUnique({
      where: { organizationId },
    });

    // Create default config if none exists
    if (!config) {
      config = await this.prisma.tenantSsoConfig.create({
        data: {
          organizationId,
          ssoProvider: null,
          ssoEnabled: false,
          jitProvisioningEnabled: true,
          defaultRole: UserRole.EMPLOYEE,
          mfaRequired: false,
        },
      });
    }

    return this.toResponseDto(config);
  }

  /**
   * Update SSO configuration for an organization.
   */
  async updateConfig(
    organizationId: string,
    dto: UpdateSsoConfigDto,
    userId: string,
  ): Promise<SsoConfigResponseDto> {
    // Ensure config exists
    await this.getConfig(organizationId);

    const config = await this.prisma.tenantSsoConfig.update({
      where: { organizationId },
      data: {
        ssoProvider: dto.ssoProvider,
        ssoEnabled: dto.ssoEnabled,
        jitProvisioningEnabled: dto.jitProvisioningEnabled,
        defaultRole: dto.defaultRole,
        mfaRequired: dto.mfaRequired,
        azureTenantId: dto.azureTenantId,
        samlIdpEntityId: dto.samlIdpEntityId,
        samlIdpEntryPoint: dto.samlIdpEntryPoint,
        samlIdpCertificate: dto.samlIdpCertificate,
        samlSpEntityId: dto.samlSpEntityId,
      },
    });

    await this.auditService.log({
      entityType: 'ORGANIZATION',
      entityId: organizationId,
      organizationId,
      action: 'SSO_CONFIG_UPDATED',
      actionDescription: `SSO configuration updated: provider=${dto.ssoProvider}, enabled=${dto.ssoEnabled}`,
      actionCategory: AuditActionCategory.SECURITY,
      actorUserId: userId,
      changes: {
        ssoProvider: dto.ssoProvider,
        ssoEnabled: dto.ssoEnabled,
        jitProvisioningEnabled: dto.jitProvisioningEnabled,
      },
    });

    return this.toResponseDto(config);
  }

  /**
   * Check if SSO is enabled for an organization.
   */
  async isSsoEnabled(organizationId: string): Promise<boolean> {
    const config = await this.prisma.tenantSsoConfig.findUnique({
      where: { organizationId },
      select: { ssoEnabled: true },
    });
    return config?.ssoEnabled ?? false;
  }

  /**
   * Get SAML configuration for a tenant slug.
   * Used by SAML strategy for per-tenant IdP settings.
   */
  async getSamlConfig(organizationSlug: string): Promise<SamlConfig> {
    const org = await this.prisma.organization.findUnique({
      where: { slug: organizationSlug },
      include: { tenantSsoConfig: true },
    });

    if (!org || !org.tenantSsoConfig) {
      throw new NotFoundException('Organization or SSO config not found');
    }

    const config = org.tenantSsoConfig;
    if (config.ssoProvider !== 'saml' || !config.ssoEnabled) {
      throw new NotFoundException('SAML SSO not configured for this organization');
    }

    if (!config.samlIdpEntryPoint || !config.samlIdpCertificate) {
      throw new NotFoundException('SAML configuration incomplete');
    }

    const apiUrl = this.configService.get<string>('API_URL', 'http://localhost:3000');

    return {
      callbackUrl: `${apiUrl}/api/v1/auth/saml/${organizationSlug}/callback`,
      entryPoint: config.samlIdpEntryPoint,
      issuer: config.samlSpEntityId || `${apiUrl}/saml/${organizationSlug}`,
      cert: config.samlIdpCertificate,
      wantAssertionsSigned: true,
      wantAuthnResponseSigned: true,
      signatureAlgorithm: 'sha256',
    };
  }

  private toResponseDto(config: any): SsoConfigResponseDto {
    return {
      id: config.id,
      organizationId: config.organizationId,
      ssoProvider: config.ssoProvider,
      ssoEnabled: config.ssoEnabled,
      jitProvisioningEnabled: config.jitProvisioningEnabled,
      defaultRole: config.defaultRole,
      mfaRequired: config.mfaRequired,
      azureTenantId: config.azureTenantId,
      samlIdpEntityId: config.samlIdpEntityId,
      samlIdpEntryPoint: config.samlIdpEntryPoint,
      samlCertificateConfigured: !!config.samlIdpCertificate,
      samlSpEntityId: config.samlSpEntityId,
    };
  }
}
```
  </action>
  <verify>
Run: `cd apps/backend && npx tsc --noEmit`
Should compile without errors.
  </verify>
  <done>
SsoConfigService provides getConfig(), updateConfig(), isSsoEnabled(), getSamlConfig() methods. DTOs validate SSO configuration updates with conditional validation for provider-specific fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SsoService with JIT user provisioning</name>
  <files>apps/backend/src/modules/auth/sso/sso.service.ts</files>
  <action>
Create `sso/sso.service.ts`:

```typescript
import {
  Injectable,
  UnauthorizedException,
  Logger,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { AuditService } from '../../audit/audit.service';
import { DomainService } from '../domain/domain.service';
import { SsoConfigService } from './sso-config.service';
import { SsoUserData } from '../interfaces';
import { AuditActionCategory, User } from '@prisma/client';

/**
 * Core SSO service that handles user lookup and JIT provisioning.
 * Used by all SSO strategies (Azure AD, Google, SAML).
 *
 * JIT Provisioning Flow:
 * 1. Try to find user by SSO provider + SSO ID
 * 2. If not found, try to find by email (link existing account)
 * 3. If not found, JIT provision new user based on verified domain
 *
 * Security: JIT provisioning ONLY works for verified domains.
 */
@Injectable()
export class SsoService {
  private readonly logger = new Logger(SsoService.name);

  constructor(
    private prisma: PrismaService,
    private auditService: AuditService,
    private domainService: DomainService,
    private ssoConfigService: SsoConfigService,
  ) {}

  /**
   * Find or create a user during SSO callback.
   * This is the main entry point for all SSO strategies.
   *
   * @param ssoUser - User data from SSO provider
   * @returns User entity with organization included
   * @throws UnauthorizedException if user cannot be found/created
   */
  async findOrCreateSsoUser(ssoUser: SsoUserData): Promise<User & { organization: any }> {
    const email = ssoUser.email.toLowerCase();

    this.logger.log(`SSO login attempt: ${email} via ${ssoUser.provider}`);

    // 1. Try to find user by SSO ID (same provider)
    let user = await this.prisma.user.findFirst({
      where: {
        ssoProvider: ssoUser.provider,
        ssoId: ssoUser.ssoId,
      },
      include: { organization: true },
    });

    if (user) {
      await this.updateLastLogin(user);
      await this.logSsoLogin(user, ssoUser.provider, 'SSO_ID_MATCH');
      return user as User & { organization: any };
    }

    // 2. Try to find user by email (link SSO to existing account)
    user = await this.prisma.user.findFirst({
      where: { email },
      include: { organization: true },
    });

    if (user) {
      return this.linkSsoToExistingUser(user, ssoUser);
    }

    // 3. JIT Provisioning - find tenant by verified domain
    return this.jitProvisionUser(ssoUser);
  }

  /**
   * Link SSO credentials to an existing user account.
   */
  private async linkSsoToExistingUser(
    existingUser: User & { organization: any },
    ssoUser: SsoUserData,
  ): Promise<User & { organization: any }> {
    // Check if user already has different SSO linked
    if (existingUser.ssoProvider && existingUser.ssoProvider !== ssoUser.provider) {
      this.logger.warn(
        `User ${existingUser.email} already has ${existingUser.ssoProvider} linked, attempted ${ssoUser.provider}`,
      );
      throw new UnauthorizedException(
        `Account already linked to ${existingUser.ssoProvider}. Please sign in using that provider.`,
      );
    }

    const user = await this.prisma.user.update({
      where: { id: existingUser.id },
      data: {
        ssoProvider: ssoUser.provider,
        ssoId: ssoUser.ssoId,
        lastLoginAt: new Date(),
        // Update name if empty
        firstName: existingUser.firstName || ssoUser.firstName,
        lastName: existingUser.lastName || ssoUser.lastName,
      },
      include: { organization: true },
    });

    await this.auditService.log({
      entityType: 'USER',
      entityId: user.id,
      organizationId: user.organizationId,
      action: 'SSO_LINKED',
      actionDescription: `User ${user.email} linked ${ssoUser.provider} SSO to existing account`,
      actionCategory: AuditActionCategory.SECURITY,
      actorUserId: user.id,
    });

    this.logger.log(`Linked ${ssoUser.provider} SSO to existing user ${user.email}`);
    return user as User & { organization: any };
  }

  /**
   * JIT provision a new user based on verified email domain.
   */
  private async jitProvisionUser(
    ssoUser: SsoUserData,
  ): Promise<User & { organization: any }> {
    const email = ssoUser.email.toLowerCase();

    // Find organization by verified domain
    const organization = await this.domainService.findOrganizationByEmailDomain(email);

    if (!organization) {
      this.logger.warn(`JIT provisioning failed for ${email}: no verified domain found`);
      throw new UnauthorizedException(
        'Your organization is not registered. Please contact your administrator.',
      );
    }

    // Check if JIT provisioning is enabled
    const ssoConfig = await this.prisma.tenantSsoConfig.findUnique({
      where: { organizationId: organization.id },
    });

    if (!ssoConfig?.jitProvisioningEnabled) {
      this.logger.warn(`JIT provisioning disabled for org ${organization.slug}`);
      throw new UnauthorizedException(
        'Just-in-time provisioning is disabled for your organization. Please contact your administrator.',
      );
    }

    // Check if SSO is enabled
    if (!ssoConfig.ssoEnabled) {
      this.logger.warn(`SSO not enabled for org ${organization.slug}`);
      throw new UnauthorizedException(
        'SSO is not enabled for your organization. Please contact your administrator.',
      );
    }

    // Create new user
    const user = await this.prisma.user.create({
      data: {
        email,
        firstName: ssoUser.firstName || 'Unknown',
        lastName: ssoUser.lastName || 'User',
        ssoProvider: ssoUser.provider,
        ssoId: ssoUser.ssoId,
        organizationId: organization.id,
        role: ssoConfig.defaultRole,
        isActive: true,
        emailVerifiedAt: new Date(), // SSO = verified email
        lastLoginAt: new Date(),
      },
      include: { organization: true },
    });

    await this.auditService.log({
      entityType: 'USER',
      entityId: user.id,
      organizationId: organization.id,
      action: 'USER_JIT_PROVISIONED',
      actionDescription: `User ${email} provisioned via ${ssoUser.provider} SSO (JIT)`,
      actionCategory: AuditActionCategory.SECURITY,
      actorUserId: user.id,
    });

    this.logger.log(`JIT provisioned user ${email} to org ${organization.slug}`);
    return user as User & { organization: any };
  }

  /**
   * Update last login timestamp for user.
   */
  private async updateLastLogin(user: User): Promise<void> {
    await this.prisma.user.update({
      where: { id: user.id },
      data: { lastLoginAt: new Date() },
    });
  }

  /**
   * Log SSO login event.
   */
  private async logSsoLogin(
    user: User,
    provider: string,
    matchType: string,
  ): Promise<void> {
    await this.auditService.log({
      entityType: 'USER',
      entityId: user.id,
      organizationId: user.organizationId,
      action: 'SSO_LOGIN',
      actionDescription: `User ${user.email} logged in via ${provider} (${matchType})`,
      actionCategory: AuditActionCategory.SECURITY,
      actorUserId: user.id,
    });
  }
}
```
  </action>
  <verify>
Run: `cd apps/backend && npx tsc --noEmit`
Should compile without errors.
  </verify>
  <done>
SsoService provides findOrCreateSsoUser() with three-step logic: 1) find by SSO ID, 2) link to existing user by email, 3) JIT provision based on verified domain. All SSO events logged to audit.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create SsoModule and integrate with AuthModule</name>
  <files>
apps/backend/src/modules/auth/sso/sso.module.ts
apps/backend/src/modules/auth/sso/index.ts
apps/backend/src/modules/auth/auth.module.ts
  </files>
  <action>
1. Create `sso/sso.module.ts`:

```typescript
import { Module, forwardRef } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { SsoService } from './sso.service';
import { SsoConfigService } from './sso-config.service';
import { DomainModule } from '../domain';
import { AuditModule } from '../../audit/audit.module';

@Module({
  imports: [
    ConfigModule,
    forwardRef(() => DomainModule),
    AuditModule,
  ],
  providers: [SsoService, SsoConfigService],
  exports: [SsoService, SsoConfigService],
})
export class SsoModule {}
```

2. Create `sso/index.ts`:

```typescript
export * from './sso.module';
export * from './sso.service';
export * from './sso-config.service';
export * from './dto/sso.dto';
```

3. Update `auth.module.ts`:

Add SsoModule to imports and exports:

```typescript
import { Module, forwardRef } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './strategies/jwt.strategy';
import { DomainModule } from './domain';
import { SsoModule } from './sso';

@Module({
  imports: [
    PassportModule.register({ defaultStrategy: 'jwt' }),
    JwtModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        secret: configService.get<string>('jwt.secret'),
        signOptions: {
          expiresIn: configService.get<string>('jwt.accessTokenExpiry', '15m'),
        },
      }),
    }),
    DomainModule,
    SsoModule,
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy],
  exports: [AuthService, JwtModule, DomainModule, SsoModule],
})
export class AuthModule {}
```

4. Create directory for SSO config endpoint (optional - can be in separate plan):

Add a simple SSO config endpoint to AuthController or create separate controller:

```typescript
// Add to auth.controller.ts

import { SsoConfigService, UpdateSsoConfigDto, SsoConfigResponseDto } from './sso';

// In controller class:
constructor(
  private authService: AuthService,
  private ssoConfigService: SsoConfigService, // Add this
) {}

@Get('sso/config')
@Roles(UserRole.SYSTEM_ADMIN)
@ApiOperation({ summary: 'Get SSO configuration' })
async getSsoConfig(@CurrentUser() user: { organizationId: string }): Promise<SsoConfigResponseDto> {
  return this.ssoConfigService.getConfig(user.organizationId);
}

@Patch('sso/config')
@Roles(UserRole.SYSTEM_ADMIN)
@ApiOperation({ summary: 'Update SSO configuration' })
async updateSsoConfig(
  @Body() dto: UpdateSsoConfigDto,
  @CurrentUser() user: { sub: string; organizationId: string },
): Promise<SsoConfigResponseDto> {
  return this.ssoConfigService.updateConfig(user.organizationId, dto, user.sub);
}
```
  </action>
  <verify>
Run: `cd apps/backend && npx tsc --noEmit && npm test`
TypeScript compiles and tests pass.
  </verify>
  <done>
SsoModule exports SsoService and SsoConfigService. AuthModule imports and re-exports SsoModule. SSO config endpoints available for SYSTEM_ADMIN.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd apps/backend && npx tsc --noEmit`
2. Tests pass: `cd apps/backend && npm test`
3. Module structure correct: Check SsoService injects DomainService successfully
4. Audit logging: Verify SSO events would log to audit_logs
</verification>

<success_criteria>
- SsoService.findOrCreateSsoUser() implements three-step lookup/create logic
- JIT provisioning only works for verified domains (security critical)
- Existing users can link SSO providers to their accounts
- SsoConfigService manages per-tenant SSO settings
- All SSO events (login, link, provision) are logged to audit
- SSO config endpoints require SYSTEM_ADMIN role
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication-sso/03-04-SUMMARY.md`
</output>
