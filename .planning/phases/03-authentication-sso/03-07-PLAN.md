---
phase: 03-authentication-sso
plan: 07
type: execute
wave: 3
depends_on: ["03-03", "03-04"]
files_modified:
  - apps/backend/src/modules/auth/strategies/saml.strategy.ts
  - apps/backend/src/modules/auth/auth.controller.ts
  - apps/backend/src/modules/auth/auth.module.ts
  - apps/backend/package.json
autonomous: true

must_haves:
  truths:
    - "Enterprise customers can configure SAML 2.0 with their IdP"
    - "SAML assertions are properly validated with signature verification"
    - "Per-tenant SAML configuration supports different IdPs"
    - "User is JIT provisioned based on verified domain"
  artifacts:
    - path: "apps/backend/src/modules/auth/strategies/saml.strategy.ts"
      provides: "Multi-tenant SAML 2.0 Passport strategy"
      exports: ["SamlStrategy"]
    - path: "apps/backend/src/modules/auth/auth.controller.ts"
      provides: "SAML login and callback endpoints with tenant routing"
      contains: "AuthGuard('saml')"
  key_links:
    - from: "saml.strategy.ts"
      to: "sso-config.service.ts"
      via: "getSamlConfig"
      pattern: "ssoConfigService\\.getSamlConfig"
    - from: "saml.strategy.ts"
      to: "sso.service.ts"
      via: "findOrCreateSsoUser"
      pattern: "ssoService\\.findOrCreateSsoUser"
---

<objective>
Implement SAML 2.0 SSO strategy with @node-saml/passport-saml.

Purpose: Enable enterprise customers to configure SAML SSO with their own Identity Providers (Okta, Ping Identity, OneLogin, etc.). SAML is required for many large enterprises. Uses per-tenant configuration so each customer can have their own IdP settings.

Output: SamlStrategy with per-tenant configuration, login/callback endpoints with tenant routing, proper signature validation for security.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-authentication-sso/03-RESEARCH.md
@.planning/phases/03-authentication-sso/03-04-SUMMARY.md
@apps/backend/src/modules/auth/sso/sso-config.service.ts
@apps/backend/src/modules/auth/strategies/google.strategy.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @node-saml/passport-saml package</name>
  <files>apps/backend/package.json</files>
  <action>
Install the SAML passport strategy:

```bash
cd apps/backend && npm install @node-saml/passport-saml
```

IMPORTANT: Use @node-saml/passport-saml (v5+), NOT the deprecated passport-saml package.
The @node-saml fork is actively maintained and includes critical security fixes including CVE-2022-39299.

Note: Types are included in the package, no separate @types package needed.
  </action>
  <verify>
Run: `cd apps/backend && npm ls @node-saml/passport-saml`
Should show @node-saml/passport-saml@5.x.x installed.
  </verify>
  <done>
@node-saml/passport-saml package installed (v5+).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create multi-tenant SamlStrategy</name>
  <files>apps/backend/src/modules/auth/strategies/saml.strategy.ts</files>
  <action>
Create `strategies/saml.strategy.ts`:

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import {
  Strategy,
  Profile,
  SamlConfig as PassportSamlConfig,
  VerifiedCallback,
} from '@node-saml/passport-saml';
import { Request } from 'express';
import { SsoService } from '../sso/sso.service';
import { SsoConfigService } from '../sso/sso-config.service';
import { SsoUserData } from '../interfaces';

/**
 * SAML 2.0 Strategy with multi-tenant support.
 *
 * Each organization can configure their own IdP (Okta, Ping, OneLogin, etc.).
 * Configuration is loaded dynamically per-request based on tenant slug.
 *
 * SECURITY CRITICAL:
 * - Always validate assertion signatures (wantAssertionsSigned: true)
 * - Always validate response signatures (wantAuthnResponseSigned: true)
 * - Use SHA-256 or higher for signatures
 * - CVE-2022-39299: Ensure using @node-saml/passport-saml v5+
 */
@Injectable()
export class SamlStrategy extends PassportStrategy(Strategy, 'saml') {
  private readonly logger = new Logger(SamlStrategy.name);

  constructor(
    private ssoConfigService: SsoConfigService,
    private ssoService: SsoService,
  ) {
    // Multi-tenant SAML uses getSamlOptions callback for per-request configuration
    super({
      passReqToCallback: true,
      getSamlOptions: async (
        req: Request,
        done: (err: Error | null, options: PassportSamlConfig | null) => void,
      ) => {
        try {
          // Extract tenant from URL path: /api/v1/auth/saml/:tenant/callback
          const tenant = req.params.tenant;

          if (!tenant) {
            return done(new Error('Tenant identifier required for SAML SSO'), null);
          }

          // Load tenant-specific SAML configuration
          const config = await this.ssoConfigService.getSamlConfig(tenant);

          this.logger.log(`Loading SAML config for tenant: ${tenant}`);

          done(null, {
            callbackUrl: config.callbackUrl,
            entryPoint: config.entryPoint,
            issuer: config.issuer,
            cert: config.cert,
            wantAssertionsSigned: config.wantAssertionsSigned,
            wantAuthnResponseSigned: config.wantAuthnResponseSigned,
            signatureAlgorithm: config.signatureAlgorithm,
            // Additional security settings
            acceptedClockSkewMs: 60000, // 1 minute clock skew tolerance
            disableRequestedAuthnContext: true, // Better IdP compatibility
          });
        } catch (error) {
          this.logger.error(`SAML config error for tenant: ${error.message}`);
          done(error, null);
        }
      },
    });
  }

  /**
   * Validate SAML assertion from IdP.
   * Called after successful SAML authentication.
   *
   * @param req - Express request (contains tenant info)
   * @param profile - User profile from SAML assertion
   * @param done - Passport callback
   */
  async validate(
    req: Request,
    profile: Profile,
    done: VerifiedCallback,
  ): Promise<void> {
    try {
      const email = this.extractEmail(profile);
      const tenant = req.params.tenant;

      this.logger.log(`SAML callback for user: ${email} (tenant: ${tenant})`);

      if (!email) {
        this.logger.error('SAML assertion missing email');
        return done(new Error('Email not provided in SAML assertion'), null, null);
      }

      // Extract user data from SAML profile
      const ssoUser: SsoUserData = {
        email: email.toLowerCase(),
        firstName: this.extractFirstName(profile),
        lastName: this.extractLastName(profile),
        provider: 'saml',
        ssoId: profile.nameID || email, // Use nameID as stable identifier
        rawProfile: profile as unknown as Record<string, unknown>,
      };

      // Use SsoService for user lookup/creation
      const user = await this.ssoService.findOrCreateSsoUser(ssoUser);

      done(null, user);
    } catch (error) {
      this.logger.error(`SAML validation error: ${error.message}`);
      done(error, null, null);
    }
  }

  /**
   * Extract email from SAML profile.
   * SAML assertions can have email in various attributes.
   */
  private extractEmail(profile: Profile): string {
    return (
      profile.nameID ||
      profile.email ||
      (profile as any)['http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress'] ||
      (profile as any)['http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn'] ||
      ''
    );
  }

  /**
   * Extract first name from SAML profile.
   */
  private extractFirstName(profile: Profile): string {
    return (
      profile.firstName ||
      (profile as any).givenName ||
      (profile as any)['http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname'] ||
      ''
    );
  }

  /**
   * Extract last name from SAML profile.
   */
  private extractLastName(profile: Profile): string {
    return (
      profile.lastName ||
      (profile as any).surname ||
      (profile as any)['http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname'] ||
      ''
    );
  }
}
```
  </action>
  <verify>
Run: `cd apps/backend && npx tsc --noEmit`
Should compile without errors.
  </verify>
  <done>
SamlStrategy uses getSamlOptions for multi-tenant configuration, loads config per-request via SsoConfigService, validates SAML assertions with signature verification.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add SAML endpoints to AuthController and register strategy</name>
  <files>
apps/backend/src/modules/auth/auth.controller.ts
apps/backend/src/modules/auth/auth.module.ts
apps/backend/src/modules/auth/strategies/index.ts
  </files>
  <action>
1. Update `strategies/index.ts` to export SamlStrategy:

```typescript
export * from './jwt.strategy';
export * from './azure-ad.strategy';
export * from './google.strategy';
export * from './saml.strategy';
```

2. Update `auth.module.ts` to include SamlStrategy:

Add SamlStrategy to providers array:

```typescript
import { JwtStrategy, AzureAdStrategy, GoogleStrategy, SamlStrategy } from './strategies';

// In @Module providers:
providers: [AuthService, JwtStrategy, AzureAdStrategy, GoogleStrategy, SamlStrategy],
```

3. Add SAML endpoints to `auth.controller.ts`:

Add after Google endpoints. Note: SAML endpoints include :tenant parameter for multi-tenant routing.

```typescript
/**
 * Initiate SAML SSO login for a specific tenant.
 * Redirects user to their organization's IdP.
 *
 * @param tenant - Organization slug (e.g., "acme")
 */
@Get('saml/:tenant')
@UseGuards(AuthGuard('saml'))
@Throttle({ default: { limit: 10, ttl: 60000 } })
@Public()
@ApiOperation({ summary: 'Initiate SAML SSO login for tenant' })
@ApiParam({ name: 'tenant', description: 'Organization slug' })
@ApiResponse({ status: 302, description: 'Redirects to IdP login' })
samlLogin(@Param('tenant') tenant: string): void {
  // Passport handles the redirect to IdP
  // Tenant is used by SamlStrategy to load correct configuration
}

/**
 * Handle SAML SSO callback (Assertion Consumer Service).
 * Validates the SAML assertion and issues JWT tokens.
 *
 * @param tenant - Organization slug
 */
@Post('saml/:tenant/callback')
@UseGuards(AuthGuard('saml'))
@Throttle({ default: { limit: 20, ttl: 60000 } })
@Public()
@HttpCode(HttpStatus.OK)
@ApiOperation({ summary: 'SAML SSO callback (ACS)' })
@ApiParam({ name: 'tenant', description: 'Organization slug' })
@ApiResponse({ status: 200, type: AuthResponseDto })
async samlCallback(
  @Param('tenant') tenant: string,
  @Req() req: Request,
  @Res({ passthrough: true }) res: Response,
): Promise<AuthResponseDto> {
  // User is already validated by SamlStrategy
  const user = req.user as any;

  // Verify user belongs to the correct tenant
  const organization = await this.authService.getOrganizationBySlug(tenant);
  if (!organization || user.organizationId !== organization.id) {
    throw new UnauthorizedException('User does not belong to this organization');
  }

  // Create session and generate JWT tokens
  const session = await this.authService.createSsoSession(
    user.id,
    user.organizationId,
    req.headers['user-agent'],
    req.ip,
  );

  const tokens = await this.authService.generateTokensForUser(user, session.id);

  return {
    ...tokens,
    user: {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      role: user.role,
      organizationId: user.organizationId,
    },
  };
}

/**
 * Get SAML metadata for a tenant (SP metadata).
 * IdP administrators use this to configure the Service Provider.
 */
@Get('saml/:tenant/metadata')
@Public()
@ApiOperation({ summary: 'Get SAML SP metadata for tenant' })
@ApiParam({ name: 'tenant', description: 'Organization slug' })
@Produces('application/xml')
async getSamlMetadata(
  @Param('tenant') tenant: string,
  @Res() res: Response,
): Promise<void> {
  // This would generate SAML SP metadata XML
  // For now, return basic placeholder
  const apiUrl = this.configService.get<string>('API_URL', 'http://localhost:3000');
  const metadata = `<?xml version="1.0"?>
<EntityDescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
                  entityID="${apiUrl}/saml/${tenant}">
  <SPSSODescriptor AuthnRequestsSigned="false"
                   WantAssertionsSigned="true"
                   protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol">
    <AssertionConsumerService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
                              Location="${apiUrl}/api/v1/auth/saml/${tenant}/callback"
                              index="0" isDefault="true"/>
  </SPSSODescriptor>
</EntityDescriptor>`;

  res.set('Content-Type', 'application/xml');
  res.send(metadata);
}
```

4. Add helper method to `auth.service.ts`:

```typescript
/**
 * Get organization by slug.
 * Used for SAML tenant verification.
 */
async getOrganizationBySlug(slug: string) {
  return this.prisma.withBypassRLS(async () => {
    return this.prisma.organization.findUnique({
      where: { slug },
    });
  });
}
```

Note: Add `ConfigService` to AuthController constructor if not already present for metadata generation.
  </action>
  <verify>
Run: `cd apps/backend && npx tsc --noEmit && npm test`
TypeScript compiles and tests pass.
  </verify>
  <done>
SamlStrategy registered in AuthModule. AuthController has /saml/:tenant (GET) for initiating login, /saml/:tenant/callback (POST) for ACS, and /saml/:tenant/metadata (GET) for SP metadata. All endpoints include tenant parameter for multi-tenant routing.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd apps/backend && npx tsc --noEmit`
2. Tests pass: `cd apps/backend && npm test`
3. Strategy registered: Check that SamlStrategy is in AuthModule providers
4. Multi-tenant: Verify endpoints include :tenant parameter
5. Security: Verify wantAssertionsSigned and wantAuthnResponseSigned are true in config
</verification>

<success_criteria>
- @node-saml/passport-saml package installed (v5+ for security)
- SamlStrategy loads per-tenant configuration via getSamlOptions
- GET /api/v1/auth/saml/:tenant redirects to tenant's IdP
- POST /api/v1/auth/saml/:tenant/callback handles SAML assertion
- GET /api/v1/auth/saml/:tenant/metadata returns SP metadata XML
- Assertion signatures are validated (wantAssertionsSigned: true)
- JIT provisioning works for users with verified domains
- Tenant verification prevents cross-tenant assertion replay
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication-sso/03-07-SUMMARY.md`
</output>
