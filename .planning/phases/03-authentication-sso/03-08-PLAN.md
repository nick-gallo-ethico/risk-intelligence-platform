---
phase: 03-authentication-sso
plan: 08
type: execute
wave: 4
depends_on: ["03-01", "03-02"]
files_modified:
  - apps/backend/src/modules/auth/mfa/mfa.service.ts
  - apps/backend/src/modules/auth/mfa/mfa.controller.ts
  - apps/backend/src/modules/auth/mfa/recovery-codes.service.ts
  - apps/backend/src/modules/auth/mfa/dto/mfa.dto.ts
  - apps/backend/src/modules/auth/mfa/mfa.module.ts
  - apps/backend/src/modules/auth/guards/mfa.guard.ts
  - apps/backend/src/modules/auth/auth.module.ts
  - apps/backend/package.json
autonomous: true

must_haves:
  truths:
    - "Users can enable TOTP-based MFA on their accounts"
    - "MFA setup generates QR code for authenticator apps"
    - "Recovery codes are generated and can be used for MFA bypass"
    - "MFA verification is required after initial login when enabled"
    - "All MFA events are logged to audit trail"
  artifacts:
    - path: "apps/backend/src/modules/auth/mfa/mfa.service.ts"
      provides: "TOTP generation, verification, and MFA lifecycle"
      exports: ["MfaService"]
    - path: "apps/backend/src/modules/auth/mfa/recovery-codes.service.ts"
      provides: "Recovery code generation and validation"
      exports: ["RecoveryCodesService"]
    - path: "apps/backend/src/modules/auth/mfa/mfa.controller.ts"
      provides: "MFA setup, verify, and disable endpoints"
      exports: ["MfaController"]
  key_links:
    - from: "mfa.service.ts"
      to: "prisma.user"
      via: "User MFA fields update"
      pattern: "prisma\\.user\\.update"
    - from: "mfa.service.ts"
      to: "auditService"
      via: "Audit logging"
      pattern: "auditService\\.log"
    - from: "mfa.controller.ts"
      to: "mfa.service.ts"
      via: "Service methods"
      pattern: "mfaService\\."
---

<objective>
Implement TOTP-based multi-factor authentication with recovery codes.

Purpose: Add an additional security layer for user accounts. Users can enable TOTP-based MFA using authenticator apps (Google Authenticator, Authy, 1Password, etc.). Recovery codes provide a backup method when the authenticator is unavailable. Organizations can require MFA for all users via policy.

Output: MfaService for TOTP operations, RecoveryCodesService for backup codes, MfaController for endpoints, MfaGuard for protecting sensitive operations.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-authentication-sso/03-RESEARCH.md
@.planning/phases/03-authentication-sso/03-01-SUMMARY.md
@apps/backend/src/modules/auth/auth.service.ts
@apps/backend/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install MFA dependencies</name>
  <files>apps/backend/package.json</files>
  <action>
Install TOTP and QR code generation packages:

```bash
cd apps/backend && npm install otplib qrcode @types/qrcode
```

- otplib: Modern TOTP/HOTP library (RFC 6238 compliant)
- qrcode: QR code generation for authenticator app setup

Note: Do NOT use speakeasy - it's unmaintained for 7+ years. otplib is the recommended replacement.
  </action>
  <verify>
Run: `cd apps/backend && npm ls otplib qrcode`
Should show both packages installed.
  </verify>
  <done>
otplib, qrcode, and @types/qrcode packages installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RecoveryCodesService and MfaService</name>
  <files>
apps/backend/src/modules/auth/mfa/recovery-codes.service.ts
apps/backend/src/modules/auth/mfa/mfa.service.ts
apps/backend/src/modules/auth/mfa/dto/mfa.dto.ts
  </files>
  <action>
1. Create `mfa/dto/mfa.dto.ts`:

```typescript
import { IsString, Length, Matches } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class InitiateMfaSetupDto {}

export class MfaSetupResponseDto {
  @ApiProperty({ description: 'TOTP secret (show to user for manual entry)' })
  secret: string;

  @ApiProperty({ description: 'QR code as data URL for authenticator apps' })
  qrCode: string;

  @ApiProperty({ description: 'otpauth:// URL for manual entry' })
  otpAuthUrl: string;
}

export class VerifyMfaSetupDto {
  @ApiProperty({ description: '6-digit TOTP code from authenticator app', example: '123456' })
  @IsString()
  @Length(6, 6)
  @Matches(/^\d{6}$/, { message: 'Code must be 6 digits' })
  code: string;
}

export class MfaEnabledResponseDto {
  @ApiProperty({ description: 'Recovery codes (show once, user must save)' })
  recoveryCodes: string[];

  @ApiProperty()
  message: string;
}

export class VerifyMfaDto {
  @ApiProperty({ description: '6-digit TOTP code or recovery code', example: '123456' })
  @IsString()
  @Length(6, 8) // TOTP is 6 digits, recovery codes are 8 hex chars
  code: string;
}

export class MfaVerifyResponseDto {
  @ApiProperty()
  verified: boolean;

  @ApiProperty({ description: 'Number of remaining recovery codes (if recovery code used)' })
  remainingRecoveryCodes?: number;
}

export class DisableMfaDto {
  @ApiProperty({ description: '6-digit TOTP code to confirm disable' })
  @IsString()
  @Length(6, 6)
  @Matches(/^\d{6}$/, { message: 'Code must be 6 digits' })
  code: string;
}

export class RegenerateRecoveryCodesDto {
  @ApiProperty({ description: '6-digit TOTP code to confirm regeneration' })
  @IsString()
  @Length(6, 6)
  @Matches(/^\d{6}$/, { message: 'Code must be 6 digits' })
  code: string;
}

export class MfaStatusResponseDto {
  @ApiProperty()
  enabled: boolean;

  @ApiProperty({ nullable: true })
  enabledAt: Date | null;

  @ApiProperty({ description: 'Number of remaining recovery codes' })
  remainingRecoveryCodes: number;
}
```

2. Create `mfa/recovery-codes.service.ts`:

```typescript
import { Injectable } from '@nestjs/common';
import * as crypto from 'crypto';

/**
 * Service for generating and validating MFA recovery codes.
 * Recovery codes provide backup access when authenticator app is unavailable.
 */
@Injectable()
export class RecoveryCodesService {
  private readonly CODE_COUNT = 10;
  private readonly CODE_LENGTH = 4; // 4 bytes = 8 hex chars

  /**
   * Generate a set of cryptographically secure recovery codes.
   * @returns Array of plain-text codes (to show to user once)
   */
  generateRecoveryCodes(): string[] {
    const codes: string[] = [];
    for (let i = 0; i < this.CODE_COUNT; i++) {
      // Generate 8-character uppercase hex code
      codes.push(crypto.randomBytes(this.CODE_LENGTH).toString('hex').toUpperCase());
    }
    return codes;
  }

  /**
   * Hash recovery codes for storage.
   * Never store plain-text recovery codes in the database.
   * @param codes - Plain-text recovery codes
   * @returns Array of SHA-256 hashes
   */
  hashRecoveryCodes(codes: string[]): string[] {
    return codes.map((code) =>
      crypto.createHash('sha256').update(code.toUpperCase()).digest('hex'),
    );
  }

  /**
   * Verify a recovery code against stored hashes.
   * @param inputCode - Code entered by user
   * @param hashedCodes - Stored hashed codes
   * @returns Index of matched code, or -1 if not found
   */
  verifyRecoveryCode(inputCode: string, hashedCodes: string[]): number {
    const hashedInput = crypto
      .createHash('sha256')
      .update(inputCode.toUpperCase())
      .digest('hex');

    return hashedCodes.indexOf(hashedInput);
  }
}
```

3. Create `mfa/mfa.service.ts`:

```typescript
import {
  Injectable,
  BadRequestException,
  UnauthorizedException,
  Logger,
} from '@nestjs/common';
import { authenticator } from 'otplib';
import * as QRCode from 'qrcode';
import { PrismaService } from '../../prisma/prisma.service';
import { AuditService } from '../../audit/audit.service';
import { RecoveryCodesService } from './recovery-codes.service';
import {
  MfaSetupResponseDto,
  MfaEnabledResponseDto,
  MfaVerifyResponseDto,
  MfaStatusResponseDto,
} from './dto/mfa.dto';
import { AuditActionCategory } from '@prisma/client';

/**
 * Service for TOTP-based multi-factor authentication.
 *
 * TOTP (Time-based One-Time Password) uses RFC 6238.
 * Compatible with Google Authenticator, Authy, 1Password, etc.
 */
@Injectable()
export class MfaService {
  private readonly logger = new Logger(MfaService.name);
  private readonly APP_NAME = 'Ethico Platform';

  constructor(
    private prisma: PrismaService,
    private auditService: AuditService,
    private recoveryCodesService: RecoveryCodesService,
  ) {
    // Configure TOTP settings
    authenticator.options = {
      digits: 6,
      step: 30, // 30-second window
      window: 1, // Allow 1 step before/after for clock drift
    };
  }

  /**
   * Initiate MFA setup for a user.
   * Generates a new TOTP secret and QR code.
   * MFA is not enabled until verifyAndEnableMfa() is called.
   */
  async initiateMfaSetup(userId: string): Promise<MfaSetupResponseDto> {
    const user = await this.prisma.user.findUniqueOrThrow({
      where: { id: userId },
    });

    if (user.mfaEnabled) {
      throw new BadRequestException('MFA is already enabled. Disable it first to set up again.');
    }

    // Generate new TOTP secret
    const secret = authenticator.generateSecret();

    // Store secret temporarily (not enabled until verified)
    await this.prisma.user.update({
      where: { id: userId },
      data: {
        mfaSecret: secret,
        mfaEnabled: false,
      },
    });

    // Generate QR code for authenticator app
    const otpAuthUrl = authenticator.keyuri(user.email, this.APP_NAME, secret);
    const qrCode = await QRCode.toDataURL(otpAuthUrl);

    this.logger.log(`MFA setup initiated for user ${user.email}`);

    return {
      secret, // Show to user for manual entry
      qrCode,
      otpAuthUrl,
    };
  }

  /**
   * Verify TOTP code and enable MFA for user.
   * Called after user scans QR code and enters verification code.
   */
  async verifyAndEnableMfa(userId: string, code: string): Promise<MfaEnabledResponseDto> {
    const user = await this.prisma.user.findUniqueOrThrow({
      where: { id: userId },
    });

    if (user.mfaEnabled) {
      throw new BadRequestException('MFA is already enabled');
    }

    if (!user.mfaSecret) {
      throw new BadRequestException('MFA setup not initiated. Call setup endpoint first.');
    }

    // Verify the TOTP code
    const isValid = authenticator.verify({
      token: code,
      secret: user.mfaSecret,
    });

    if (!isValid) {
      throw new UnauthorizedException('Invalid verification code');
    }

    // Generate recovery codes
    const recoveryCodes = this.recoveryCodesService.generateRecoveryCodes();
    const hashedCodes = this.recoveryCodesService.hashRecoveryCodes(recoveryCodes);

    // Enable MFA and store hashed recovery codes
    await this.prisma.user.update({
      where: { id: userId },
      data: {
        mfaEnabled: true,
        mfaVerifiedAt: new Date(),
        mfaRecoveryCodes: hashedCodes,
      },
    });

    await this.auditService.log({
      entityType: 'USER',
      entityId: userId,
      organizationId: user.organizationId,
      action: 'MFA_ENABLED',
      actionDescription: `User ${user.email} enabled two-factor authentication`,
      actionCategory: AuditActionCategory.SECURITY,
      actorUserId: userId,
    });

    this.logger.log(`MFA enabled for user ${user.email}`);

    // Return plain recovery codes (only time user sees them)
    return {
      recoveryCodes,
      message: 'MFA enabled successfully. Save your recovery codes in a safe place.',
    };
  }

  /**
   * Verify MFA code during login.
   * Accepts either TOTP code or recovery code.
   */
  async verifyMfa(userId: string, code: string): Promise<MfaVerifyResponseDto> {
    const user = await this.prisma.user.findUniqueOrThrow({
      where: { id: userId },
    });

    if (!user.mfaEnabled || !user.mfaSecret) {
      throw new BadRequestException('MFA is not enabled for this user');
    }

    // Try TOTP verification first
    const isValidTotp = authenticator.verify({
      token: code,
      secret: user.mfaSecret,
    });

    if (isValidTotp) {
      return { verified: true };
    }

    // Try recovery code
    const codeIndex = this.recoveryCodesService.verifyRecoveryCode(
      code,
      user.mfaRecoveryCodes,
    );

    if (codeIndex === -1) {
      throw new UnauthorizedException('Invalid MFA code');
    }

    // Remove used recovery code
    const updatedCodes = [...user.mfaRecoveryCodes];
    updatedCodes.splice(codeIndex, 1);

    await this.prisma.user.update({
      where: { id: userId },
      data: { mfaRecoveryCodes: updatedCodes },
    });

    await this.auditService.log({
      entityType: 'USER',
      entityId: userId,
      organizationId: user.organizationId,
      action: 'MFA_RECOVERY_CODE_USED',
      actionDescription: `User ${user.email} used MFA recovery code (${updatedCodes.length} remaining)`,
      actionCategory: AuditActionCategory.SECURITY,
      actorUserId: userId,
    });

    this.logger.warn(`Recovery code used by ${user.email}, ${updatedCodes.length} remaining`);

    return {
      verified: true,
      remainingRecoveryCodes: updatedCodes.length,
    };
  }

  /**
   * Disable MFA for a user.
   * Requires TOTP verification to prevent unauthorized disable.
   */
  async disableMfa(userId: string, code: string): Promise<void> {
    const user = await this.prisma.user.findUniqueOrThrow({
      where: { id: userId },
    });

    if (!user.mfaEnabled || !user.mfaSecret) {
      throw new BadRequestException('MFA is not enabled');
    }

    // Verify TOTP code before disabling
    const isValid = authenticator.verify({
      token: code,
      secret: user.mfaSecret,
    });

    if (!isValid) {
      throw new UnauthorizedException('Invalid verification code');
    }

    await this.prisma.user.update({
      where: { id: userId },
      data: {
        mfaEnabled: false,
        mfaSecret: null,
        mfaVerifiedAt: null,
        mfaRecoveryCodes: [],
      },
    });

    await this.auditService.log({
      entityType: 'USER',
      entityId: userId,
      organizationId: user.organizationId,
      action: 'MFA_DISABLED',
      actionDescription: `User ${user.email} disabled two-factor authentication`,
      actionCategory: AuditActionCategory.SECURITY,
      actorUserId: userId,
    });

    this.logger.log(`MFA disabled for user ${user.email}`);
  }

  /**
   * Regenerate recovery codes.
   * Requires TOTP verification.
   */
  async regenerateRecoveryCodes(userId: string, code: string): Promise<string[]> {
    const user = await this.prisma.user.findUniqueOrThrow({
      where: { id: userId },
    });

    if (!user.mfaEnabled || !user.mfaSecret) {
      throw new BadRequestException('MFA is not enabled');
    }

    // Verify TOTP code
    const isValid = authenticator.verify({
      token: code,
      secret: user.mfaSecret,
    });

    if (!isValid) {
      throw new UnauthorizedException('Invalid verification code');
    }

    // Generate new recovery codes
    const recoveryCodes = this.recoveryCodesService.generateRecoveryCodes();
    const hashedCodes = this.recoveryCodesService.hashRecoveryCodes(recoveryCodes);

    await this.prisma.user.update({
      where: { id: userId },
      data: { mfaRecoveryCodes: hashedCodes },
    });

    await this.auditService.log({
      entityType: 'USER',
      entityId: userId,
      organizationId: user.organizationId,
      action: 'MFA_RECOVERY_CODES_REGENERATED',
      actionDescription: `User ${user.email} regenerated MFA recovery codes`,
      actionCategory: AuditActionCategory.SECURITY,
      actorUserId: userId,
    });

    this.logger.log(`Recovery codes regenerated for user ${user.email}`);

    return recoveryCodes;
  }

  /**
   * Get MFA status for a user.
   */
  async getMfaStatus(userId: string): Promise<MfaStatusResponseDto> {
    const user = await this.prisma.user.findUniqueOrThrow({
      where: { id: userId },
      select: {
        mfaEnabled: true,
        mfaVerifiedAt: true,
        mfaRecoveryCodes: true,
      },
    });

    return {
      enabled: user.mfaEnabled,
      enabledAt: user.mfaVerifiedAt,
      remainingRecoveryCodes: user.mfaRecoveryCodes?.length ?? 0,
    };
  }

  /**
   * Check if user has MFA enabled.
   * Used by auth flow to determine if MFA verification is needed.
   */
  async isMfaEnabled(userId: string): Promise<boolean> {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      select: { mfaEnabled: true },
    });
    return user?.mfaEnabled ?? false;
  }
}
```
  </action>
  <verify>
Run: `cd apps/backend && npx tsc --noEmit`
Should compile without errors.
  </verify>
  <done>
MfaService provides initiateMfaSetup(), verifyAndEnableMfa(), verifyMfa(), disableMfa(), regenerateRecoveryCodes(), getMfaStatus(). RecoveryCodesService handles secure code generation and verification. All MFA events logged to audit.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create MfaController, MfaGuard, and MfaModule</name>
  <files>
apps/backend/src/modules/auth/mfa/mfa.controller.ts
apps/backend/src/modules/auth/guards/mfa.guard.ts
apps/backend/src/modules/auth/mfa/mfa.module.ts
apps/backend/src/modules/auth/mfa/index.ts
apps/backend/src/modules/auth/auth.module.ts
  </files>
  <action>
1. Create `mfa/mfa.controller.ts`:

```typescript
import {
  Controller,
  Get,
  Post,
  Delete,
  Body,
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth } from '@nestjs/swagger';
import { Throttle } from '@nestjs/throttler';
import { JwtAuthGuard } from '../guards/jwt-auth.guard';
import { CurrentUser } from '../../common/decorators/current-user.decorator';
import { MfaService } from './mfa.service';
import {
  MfaSetupResponseDto,
  VerifyMfaSetupDto,
  MfaEnabledResponseDto,
  VerifyMfaDto,
  MfaVerifyResponseDto,
  DisableMfaDto,
  RegenerateRecoveryCodesDto,
  MfaStatusResponseDto,
} from './dto/mfa.dto';

@ApiTags('mfa')
@ApiBearerAuth()
@Controller('api/v1/auth/mfa')
@UseGuards(JwtAuthGuard)
export class MfaController {
  constructor(private readonly mfaService: MfaService) {}

  @Get('status')
  @ApiOperation({ summary: 'Get MFA status for current user' })
  @ApiResponse({ status: 200, type: MfaStatusResponseDto })
  async getMfaStatus(@CurrentUser() user: { sub: string }): Promise<MfaStatusResponseDto> {
    return this.mfaService.getMfaStatus(user.sub);
  }

  @Post('setup')
  @Throttle({ default: { limit: 5, ttl: 3600000 } }) // 5 per hour
  @ApiOperation({ summary: 'Initiate MFA setup (generates QR code)' })
  @ApiResponse({ status: 201, type: MfaSetupResponseDto })
  async initiateMfaSetup(@CurrentUser() user: { sub: string }): Promise<MfaSetupResponseDto> {
    return this.mfaService.initiateMfaSetup(user.sub);
  }

  @Post('setup/verify')
  @Throttle({ default: { limit: 10, ttl: 3600000 } }) // 10 per hour
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Verify setup code and enable MFA' })
  @ApiResponse({ status: 200, type: MfaEnabledResponseDto })
  async verifyAndEnableMfa(
    @Body() dto: VerifyMfaSetupDto,
    @CurrentUser() user: { sub: string },
  ): Promise<MfaEnabledResponseDto> {
    return this.mfaService.verifyAndEnableMfa(user.sub, dto.code);
  }

  @Post('verify')
  @Throttle({ default: { limit: 3, ttl: 60000 } }) // 3 per minute (strict)
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Verify MFA code during login' })
  @ApiResponse({ status: 200, type: MfaVerifyResponseDto })
  async verifyMfa(
    @Body() dto: VerifyMfaDto,
    @CurrentUser() user: { sub: string },
  ): Promise<MfaVerifyResponseDto> {
    return this.mfaService.verifyMfa(user.sub, dto.code);
  }

  @Delete()
  @Throttle({ default: { limit: 3, ttl: 3600000 } }) // 3 per hour
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Disable MFA (requires code verification)' })
  @ApiResponse({ status: 204 })
  async disableMfa(
    @Body() dto: DisableMfaDto,
    @CurrentUser() user: { sub: string },
  ): Promise<void> {
    return this.mfaService.disableMfa(user.sub, dto.code);
  }

  @Post('recovery-codes/regenerate')
  @Throttle({ default: { limit: 3, ttl: 3600000 } }) // 3 per hour
  @ApiOperation({ summary: 'Regenerate recovery codes (requires code verification)' })
  @ApiResponse({ status: 200, type: [String] })
  async regenerateRecoveryCodes(
    @Body() dto: RegenerateRecoveryCodesDto,
    @CurrentUser() user: { sub: string },
  ): Promise<{ recoveryCodes: string[] }> {
    const codes = await this.mfaService.regenerateRecoveryCodes(user.sub, dto.code);
    return { recoveryCodes: codes };
  }
}
```

2. Create `guards/mfa.guard.ts`:

```typescript
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  UnauthorizedException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { MfaService } from '../mfa/mfa.service';

/**
 * Guard that requires MFA verification for protected operations.
 * Use with @RequiresMfa() decorator on sensitive endpoints.
 */
@Injectable()
export class MfaGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private mfaService: MfaService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const user = request.user;

    if (!user) {
      throw new UnauthorizedException('Authentication required');
    }

    // Check if user has MFA enabled
    const mfaEnabled = await this.mfaService.isMfaEnabled(user.sub);

    if (!mfaEnabled) {
      // MFA not enabled, allow access
      return true;
    }

    // Check if this session has MFA verified
    // The JWT should contain mfaVerified: true after MFA verification
    if (!user.mfaVerified) {
      throw new UnauthorizedException('MFA verification required');
    }

    return true;
  }
}
```

3. Create `mfa/mfa.module.ts`:

```typescript
import { Module } from '@nestjs/common';
import { MfaController } from './mfa.controller';
import { MfaService } from './mfa.service';
import { RecoveryCodesService } from './recovery-codes.service';
import { AuditModule } from '../../audit/audit.module';

@Module({
  imports: [AuditModule],
  controllers: [MfaController],
  providers: [MfaService, RecoveryCodesService],
  exports: [MfaService],
})
export class MfaModule {}
```

4. Create `mfa/index.ts`:

```typescript
export * from './mfa.module';
export * from './mfa.service';
export * from './recovery-codes.service';
export * from './dto/mfa.dto';
```

5. Update `auth.module.ts` to import MfaModule:

```typescript
import { MfaModule } from './mfa';

@Module({
  imports: [
    // ... existing imports
    MfaModule,
  ],
  // ...
  exports: [AuthService, JwtModule, DomainModule, SsoModule, MfaModule],
})
export class AuthModule {}
```

6. Update `guards/index.ts` to export MfaGuard:

```typescript
export * from './jwt-auth.guard';
export * from './mfa.guard';
export * from './throttle-behind-proxy.guard';
```
  </action>
  <verify>
Run: `cd apps/backend && npx tsc --noEmit && npm test`
TypeScript compiles and tests pass.
  </verify>
  <done>
MfaController provides endpoints for MFA setup, verification, disable, and recovery code regeneration. MfaGuard protects sensitive operations requiring MFA. MfaModule exports MfaService for use by auth flow. All MFA endpoints have appropriate rate limits.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd apps/backend && npx tsc --noEmit`
2. Tests pass: `cd apps/backend && npm test`
3. TOTP works: Test QR code generation and verification with authenticator app
4. Recovery codes: Verify codes are generated, hashed, and can be used
5. Audit logging: Check MFA events appear in audit_logs
</verification>

<success_criteria>
- otplib and qrcode packages installed
- MfaService handles TOTP generation, verification, enable/disable
- RecoveryCodesService generates secure recovery codes (hashed storage)
- MFA setup generates QR code scannable by authenticator apps
- Recovery codes can be used when authenticator unavailable
- All MFA operations require authentication
- Sensitive operations (disable, regenerate) require code verification
- All MFA events logged to audit trail
- MFA endpoints rate-limited (3/min for verify, strict limits on setup)
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication-sso/03-08-SUMMARY.md`
</output>
