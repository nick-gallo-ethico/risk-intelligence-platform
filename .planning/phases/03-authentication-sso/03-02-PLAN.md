---
phase: 03-authentication-sso
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/src/app.module.ts
  - apps/backend/src/modules/auth/auth.controller.ts
  - apps/backend/src/modules/auth/guards/throttle-behind-proxy.guard.ts
  - apps/backend/package.json
autonomous: true

must_haves:
  truths:
    - "Rate limiting is enforced globally with configurable defaults"
    - "Auth endpoints have stricter rate limits than other endpoints"
    - "Rate limiting uses Redis storage for multi-instance deployments"
    - "Real client IP is extracted correctly behind proxies"
  artifacts:
    - path: "apps/backend/src/app.module.ts"
      provides: "ThrottlerModule configuration with Redis storage"
      contains: "ThrottlerModule"
    - path: "apps/backend/src/modules/auth/auth.controller.ts"
      provides: "Auth endpoints with @Throttle decorators"
      contains: "@Throttle"
    - path: "apps/backend/src/modules/auth/guards/throttle-behind-proxy.guard.ts"
      provides: "Custom throttle guard for proxy IP extraction"
      exports: ["ThrottleBehindProxyGuard"]
  key_links:
    - from: "app.module.ts"
      to: "Redis"
      via: "ThrottlerStorageRedisService"
      pattern: "ThrottlerStorageRedisService"
    - from: "auth.controller.ts"
      to: "ThrottlerGuard"
      via: "@Throttle decorator"
      pattern: "@Throttle.*limit.*ttl"
---

<objective>
Add rate limiting infrastructure to protect authentication endpoints from brute-force attacks.

Purpose: Prevent credential stuffing and brute-force attacks by implementing tiered rate limiting - strict limits on sensitive endpoints (login, MFA verify) and moderate limits on less sensitive endpoints. Uses Redis for distributed rate limiting across multiple application instances.

Output: Global throttler module configuration, custom guard for proxy IP extraction, auth controller with appropriate rate limits per endpoint.
</objective>

<execution_context>
@C:\Users\cu0718\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cu0718\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-authentication-sso/03-RESEARCH.md
@apps/backend/src/app.module.ts
@apps/backend/src/modules/auth/auth.controller.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install rate limiting dependencies</name>
  <files>apps/backend/package.json</files>
  <action>
Install the required rate limiting packages:

```bash
cd apps/backend && npm install @nestjs/throttler @nest-lab/throttler-storage-redis
```

These packages provide:
- @nestjs/throttler: Official NestJS rate limiting module
- @nest-lab/throttler-storage-redis: Redis storage adapter for distributed rate limiting

Note: ioredis is already installed (used by BullMQ), so no additional Redis client needed.
  </action>
  <verify>
Run: `cd apps/backend && npm ls @nestjs/throttler @nest-lab/throttler-storage-redis`
Should show both packages installed without errors.
  </verify>
  <done>
@nestjs/throttler and @nest-lab/throttler-storage-redis packages are installed in apps/backend/package.json.
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure ThrottlerModule with Redis storage in app.module.ts</name>
  <files>apps/backend/src/app.module.ts</files>
  <action>
1. Add imports at the top of app.module.ts:
```typescript
import { ThrottlerModule, ThrottlerGuard } from '@nestjs/throttler';
import { ThrottlerStorageRedisService } from '@nest-lab/throttler-storage-redis';
import { APP_GUARD } from '@nestjs/core';
```

2. Add ThrottlerModule to the imports array:
```typescript
ThrottlerModule.forRootAsync({
  imports: [ConfigModule],
  inject: [ConfigService],
  useFactory: (configService: ConfigService) => ({
    throttlers: [
      {
        name: 'default',
        ttl: 60000, // 1 minute window
        limit: 100, // 100 requests per minute globally
      },
    ],
    storage: new ThrottlerStorageRedisService(
      configService.get<string>('REDIS_URL', 'redis://localhost:6379'),
    ),
  }),
}),
```

3. Add the global throttler guard to providers:
```typescript
{
  provide: APP_GUARD,
  useClass: ThrottlerGuard,
},
```

4. Add configuration environment variable documentation in a comment:
```typescript
// Rate limiting configuration:
// THROTTLE_TTL: Window duration in milliseconds (default: 60000)
// THROTTLE_LIMIT: Max requests per window (default: 100)
// Uses REDIS_URL for distributed rate limiting across instances
```
  </action>
  <verify>
Run: `cd apps/backend && npx tsc --noEmit`
Should compile without errors.
  </verify>
  <done>
ThrottlerModule is configured in app.module.ts with Redis storage and global guard is registered. Default rate limit is 100 requests per minute per IP.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create custom throttle guard for proxy IP extraction and apply to auth endpoints</name>
  <files>
apps/backend/src/modules/auth/guards/throttle-behind-proxy.guard.ts
apps/backend/src/modules/auth/auth.controller.ts
  </files>
  <action>
1. Create `guards/throttle-behind-proxy.guard.ts`:
```typescript
import { Injectable, ExecutionContext } from '@nestjs/common';
import { ThrottlerGuard } from '@nestjs/throttler';
import { Request } from 'express';

/**
 * Custom throttler guard that correctly extracts client IP behind proxies.
 * Uses X-Forwarded-For header when available, falling back to direct IP.
 * Also implements per-target throttling for authentication endpoints.
 */
@Injectable()
export class ThrottleBehindProxyGuard extends ThrottlerGuard {
  /**
   * Extract the real client IP from behind proxies.
   * Priority: X-Forwarded-For first value > X-Real-IP > socket remote address
   */
  protected async getTracker(req: Request): Promise<string> {
    // X-Forwarded-For can be comma-separated list; first is original client
    const forwardedFor = req.headers['x-forwarded-for'];
    if (forwardedFor) {
      const ips = Array.isArray(forwardedFor)
        ? forwardedFor[0]
        : forwardedFor.split(',')[0];
      return ips.trim();
    }

    // X-Real-IP is set by some proxies (nginx)
    const realIp = req.headers['x-real-ip'];
    if (realIp) {
      return Array.isArray(realIp) ? realIp[0] : realIp;
    }

    // Fall back to direct connection IP
    return req.ip || req.socket.remoteAddress || 'unknown';
  }

  /**
   * Generate a unique key for rate limiting.
   * For auth endpoints, include the target (email) to prevent
   * distributed attacks against a single account.
   */
  protected generateKey(
    context: ExecutionContext,
    tracker: string,
    throttlerName: string,
  ): string {
    const req = context.switchToHttp().getRequest<Request>();
    const baseKey = `${throttlerName}:${tracker}`;

    // For login endpoint, also track by target email
    if (req.path.includes('/auth/login') && req.body?.email) {
      return `${baseKey}:${req.body.email.toLowerCase()}`;
    }

    // For MFA endpoints, track by user if available
    if (req.path.includes('/auth/mfa') && req.user?.sub) {
      return `${baseKey}:${req.user.sub}`;
    }

    return baseKey;
  }
}
```

2. Update `auth.controller.ts` with rate limit decorators:

Add imports at the top:
```typescript
import { Throttle, SkipThrottle } from '@nestjs/throttler';
```

Apply decorators to endpoints:

For login endpoint - strict limit (5 per minute):
```typescript
@Throttle({ default: { limit: 5, ttl: 60000 } })
@Post('login')
```

For token refresh - moderate limit (30 per minute):
```typescript
@Throttle({ default: { limit: 30, ttl: 60000 } })
@Post('refresh')
```

Add logout endpoint if not exists with moderate limit:
```typescript
@Throttle({ default: { limit: 10, ttl: 60000 } })
@Post('logout')
```

3. Create guards/index.ts to export the new guard:
```typescript
export * from './throttle-behind-proxy.guard';
```

4. Add comment documentation explaining rate limits:
```typescript
// Rate limit tiers for auth endpoints:
// - Login: 5/min (strict - protects against brute force)
// - MFA verify: 3/min (strict - protects MFA bypass attempts)
// - Password reset: 3/hour (strict - prevents abuse)
// - Refresh: 30/min (moderate - normal app usage)
// - Logout: 10/min (moderate - batch logout scenarios)
// - SSO initiate: 10/min (moderate - redirect-based, less abuse risk)
```
  </action>
  <verify>
Run: `cd apps/backend && npx tsc --noEmit && npm test -- --testPathPattern="auth"'`
TypeScript compiles and auth tests pass.
  </verify>
  <done>
ThrottleBehindProxyGuard extracts real IP from X-Forwarded-For/X-Real-IP headers. Auth endpoints have @Throttle decorators with appropriate limits: login 5/min, refresh 30/min.
  </done>
</task>

</tasks>

<verification>
1. Dependencies installed: `cd apps/backend && npm ls @nestjs/throttler`
2. TypeScript compiles: `cd apps/backend && npx tsc --noEmit`
3. Tests pass: `cd apps/backend && npm test`
4. Manual verification (optional): Start server, make 6 rapid login requests, verify 429 response on 6th
</verification>

<success_criteria>
- @nestjs/throttler and @nest-lab/throttler-storage-redis packages installed
- ThrottlerModule configured with Redis storage in app.module.ts
- Global ThrottlerGuard registered
- ThrottleBehindProxyGuard correctly extracts IP from proxy headers
- Login endpoint limited to 5 requests per minute
- Refresh endpoint limited to 30 requests per minute
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication-sso/03-02-SUMMARY.md`
</output>
